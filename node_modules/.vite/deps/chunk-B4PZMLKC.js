import {
  n
} from "./chunk-325NUS3B.js";
import {
  co,
  io,
  oo,
  ro,
  so
} from "./chunk-ULVX53PV.js";
import {
  M
} from "./chunk-5UWODSHZ.js";
import {
  g,
  y as y2
} from "./chunk-ODKV7UAD.js";
import {
  R,
  y
} from "./chunk-PM2IHWHB.js";
import {
  j
} from "./chunk-HUVX2E5O.js";
import {
  h
} from "./chunk-MVM2C7P2.js";
import {
  _,
  x
} from "./chunk-7EER3O2F.js";
import {
  mo
} from "./chunk-R7QRGPF3.js";
import {
  ae
} from "./chunk-NMWROSO4.js";
import {
  require_react
} from "./chunk-4373DSHM.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/dgz-ui/dist/tooltip-C35SqwxH.js
var s = __toESM(require_react(), 1);
var [_2, Ie] = j("Tooltip", [
  oo
]);
var D = oo();
var H = "TooltipProvider";
var ne = 700;
var A = "tooltip.open";
var [se, j2] = _2(H);
var S = (t) => {
  const {
    __scopeTooltip: o,
    delayDuration: e = ne,
    skipDelayDuration: r = 300,
    disableHoverableContent: n2 = false,
    children: l
  } = t, i = s.useRef(true), v = s.useRef(false), a = s.useRef(0);
  return s.useEffect(() => {
    const p = a.current;
    return () => window.clearTimeout(p);
  }, []), ae.jsx(
    se,
    {
      scope: o,
      isOpenDelayedRef: i,
      delayDuration: e,
      onOpen: s.useCallback(() => {
        window.clearTimeout(a.current), i.current = false;
      }, []),
      onClose: s.useCallback(() => {
        window.clearTimeout(a.current), a.current = window.setTimeout(
          () => i.current = true,
          r
        );
      }, [r]),
      isPointerInTransitRef: v,
      onPointerInTransitChange: s.useCallback((p) => {
        v.current = p;
      }, []),
      disableHoverableContent: n2,
      children: l
    }
  );
};
S.displayName = H;
var R2 = "Tooltip";
var [ae2, O] = _2(R2);
var G = (t) => {
  const {
    __scopeTooltip: o,
    children: e,
    open: r,
    defaultOpen: n2,
    onOpenChange: l,
    disableHoverableContent: i,
    delayDuration: v
  } = t, a = j2(R2, t.__scopeTooltip), p = D(o), [c, d] = s.useState(null), m = g(), u = s.useRef(0), h2 = i ?? a.disableHoverableContent, T = v ?? a.delayDuration, x2 = s.useRef(false), [C, y3] = y2({
    prop: r,
    defaultProp: n2 ?? false,
    onChange: (I) => {
      I ? (a.onOpen(), document.dispatchEvent(new CustomEvent(A))) : a.onClose(), l == null || l(I);
    },
    caller: R2
  }), w = s.useMemo(() => C ? x2.current ? "delayed-open" : "instant-open" : "closed", [C]), P = s.useCallback(() => {
    window.clearTimeout(u.current), u.current = 0, x2.current = false, y3(true);
  }, [y3]), E = s.useCallback(() => {
    window.clearTimeout(u.current), u.current = 0, y3(false);
  }, [y3]), k = s.useCallback(() => {
    window.clearTimeout(u.current), u.current = window.setTimeout(() => {
      x2.current = true, y3(true), u.current = 0;
    }, T);
  }, [T, y3]);
  return s.useEffect(() => () => {
    u.current && (window.clearTimeout(u.current), u.current = 0);
  }, []), ae.jsx(io, { ...p, children: ae.jsx(
    ae2,
    {
      scope: o,
      contentId: m,
      open: C,
      stateAttribute: w,
      trigger: c,
      onTriggerChange: d,
      onTriggerEnter: s.useCallback(() => {
        a.isOpenDelayedRef.current ? k() : P();
      }, [a.isOpenDelayedRef, k, P]),
      onTriggerLeave: s.useCallback(() => {
        h2 ? E() : (window.clearTimeout(u.current), u.current = 0);
      }, [E, h2]),
      onOpen: P,
      onClose: E,
      disableHoverableContent: h2,
      children: e
    }
  ) });
};
G.displayName = R2;
var L = "TooltipTrigger";
var F = s.forwardRef(
  (t, o) => {
    const { __scopeTooltip: e, ...r } = t, n2 = O(L, e), l = j2(L, e), i = D(e), v = s.useRef(null), a = x(o, v, n2.onTriggerChange), p = s.useRef(false), c = s.useRef(false), d = s.useCallback(() => p.current = false, []);
    return s.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), ae.jsx(ro, { asChild: true, ...i, children: ae.jsx(
      h.button,
      {
        "aria-describedby": n2.open ? n2.contentId : void 0,
        "data-state": n2.stateAttribute,
        ...r,
        ref: a,
        onPointerMove: y(t.onPointerMove, (m) => {
          m.pointerType !== "touch" && !c.current && !l.isPointerInTransitRef.current && (n2.onTriggerEnter(), c.current = true);
        }),
        onPointerLeave: y(t.onPointerLeave, () => {
          n2.onTriggerLeave(), c.current = false;
        }),
        onPointerDown: y(t.onPointerDown, () => {
          n2.open && n2.onClose(), p.current = true, document.addEventListener("pointerup", d, { once: true });
        }),
        onFocus: y(t.onFocus, () => {
          p.current || n2.onOpen();
        }),
        onBlur: y(t.onBlur, n2.onClose),
        onClick: y(t.onClick, n2.onClose)
      }
    ) });
  }
);
F.displayName = L;
var ie = "TooltipPortal";
var [Me, le] = _2(ie, {
  forceMount: void 0
});
var b = "TooltipContent";
var B = s.forwardRef(
  (t, o) => {
    const e = le(b, t.__scopeTooltip), { forceMount: r = e.forceMount, side: n2 = "top", ...l } = t, i = O(b, t.__scopeTooltip);
    return ae.jsx(R, { present: r || i.open, children: i.disableHoverableContent ? ae.jsx($, { side: n2, ...l, ref: o }) : ae.jsx(ce, { side: n2, ...l, ref: o }) });
  }
);
var ce = s.forwardRef((t, o) => {
  const e = O(b, t.__scopeTooltip), r = j2(b, t.__scopeTooltip), n2 = s.useRef(null), l = x(o, n2), [i, v] = s.useState(null), { trigger: a, onClose: p } = e, c = n2.current, { onPointerInTransitChange: d } = r, m = s.useCallback(() => {
    v(null), d(false);
  }, [d]), u = s.useCallback(
    (h2, T) => {
      const x2 = h2.currentTarget, C = { x: h2.clientX, y: h2.clientY }, y3 = ve(C, x2.getBoundingClientRect()), w = me(C, y3), P = he(T.getBoundingClientRect()), E = Te([...w, ...P]);
      v(E), d(true);
    },
    [d]
  );
  return s.useEffect(() => () => m(), [m]), s.useEffect(() => {
    if (a && c) {
      const h2 = (x2) => u(x2, c), T = (x2) => u(x2, a);
      return a.addEventListener("pointerleave", h2), c.addEventListener("pointerleave", T), () => {
        a.removeEventListener("pointerleave", h2), c.removeEventListener("pointerleave", T);
      };
    }
  }, [a, c, u, m]), s.useEffect(() => {
    if (i) {
      const h2 = (T) => {
        const x2 = T.target, C = { x: T.clientX, y: T.clientY }, y3 = (a == null ? void 0 : a.contains(x2)) || (c == null ? void 0 : c.contains(x2)), w = !xe(C, i);
        y3 ? m() : w && (m(), p());
      };
      return document.addEventListener("pointermove", h2), () => document.removeEventListener("pointermove", h2);
    }
  }, [a, c, i, p, m]), ae.jsx($, { ...t, ref: l });
});
var [ue, pe] = _2(R2, { isInside: false });
var de = _("TooltipContent");
var $ = s.forwardRef(
  (t, o) => {
    const {
      __scopeTooltip: e,
      children: r,
      "aria-label": n2,
      onEscapeKeyDown: l,
      onPointerDownOutside: i,
      ...v
    } = t, a = O(b, e), p = D(e), { onClose: c } = a;
    return s.useEffect(() => (document.addEventListener(A, c), () => document.removeEventListener(A, c)), [c]), s.useEffect(() => {
      if (a.trigger) {
        const d = (m) => {
          const u = m.target;
          u != null && u.contains(a.trigger) && c();
        };
        return window.addEventListener("scroll", d, { capture: true }), () => window.removeEventListener("scroll", d, { capture: true });
      }
    }, [a.trigger, c]), ae.jsx(
      M,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown: l,
        onPointerDownOutside: i,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: c,
        children: ae.jsxs(
          so,
          {
            "data-state": a.stateAttribute,
            ...p,
            ...v,
            ref: o,
            style: {
              ...v.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              ae.jsx(de, { children: r }),
              ae.jsx(ue, { scope: e, isInside: true, children: ae.jsx(n, { id: a.contentId, role: "tooltip", children: n2 || r }) })
            ]
          }
        )
      }
    );
  }
);
B.displayName = b;
var z = "TooltipArrow";
var fe = s.forwardRef(
  (t, o) => {
    const { __scopeTooltip: e, ...r } = t, n2 = D(e);
    return pe(
      z,
      e
    ).isInside ? null : ae.jsx(co, { ...n2, ...r, ref: o });
  }
);
fe.displayName = z;
function ve(t, o) {
  const e = Math.abs(o.top - t.y), r = Math.abs(o.bottom - t.y), n2 = Math.abs(o.right - t.x), l = Math.abs(o.left - t.x);
  switch (Math.min(e, r, n2, l)) {
    case l:
      return "left";
    case n2:
      return "right";
    case e:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function me(t, o, e = 5) {
  const r = [];
  switch (o) {
    case "top":
      r.push(
        { x: t.x - e, y: t.y + e },
        { x: t.x + e, y: t.y + e }
      );
      break;
    case "bottom":
      r.push(
        { x: t.x - e, y: t.y - e },
        { x: t.x + e, y: t.y - e }
      );
      break;
    case "left":
      r.push(
        { x: t.x + e, y: t.y - e },
        { x: t.x + e, y: t.y + e }
      );
      break;
    case "right":
      r.push(
        { x: t.x - e, y: t.y - e },
        { x: t.x - e, y: t.y + e }
      );
      break;
  }
  return r;
}
function he(t) {
  const { top: o, right: e, bottom: r, left: n2 } = t;
  return [
    { x: n2, y: o },
    { x: e, y: o },
    { x: e, y: r },
    { x: n2, y: r }
  ];
}
function xe(t, o) {
  const { x: e, y: r } = t;
  let n2 = false;
  for (let l = 0, i = o.length - 1; l < o.length; i = l++) {
    const v = o[l], a = o[i], p = v.x, c = v.y, d = a.x, m = a.y;
    c > r != m > r && e < (d - p) * (r - c) / (m - c) + p && (n2 = !n2);
  }
  return n2;
}
function Te(t) {
  const o = t.slice();
  return o.sort((e, r) => e.x < r.x ? -1 : e.x > r.x ? 1 : e.y < r.y ? -1 : e.y > r.y ? 1 : 0), ye(o);
}
function ye(t) {
  if (t.length <= 1) return t.slice();
  const o = [];
  for (let r = 0; r < t.length; r++) {
    const n2 = t[r];
    for (; o.length >= 2; ) {
      const l = o[o.length - 1], i = o[o.length - 2];
      if ((l.x - i.x) * (n2.y - i.y) >= (l.y - i.y) * (n2.x - i.x)) o.pop();
      else break;
    }
    o.push(n2);
  }
  o.pop();
  const e = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const n2 = t[r];
    for (; e.length >= 2; ) {
      const l = e[e.length - 1], i = e[e.length - 2];
      if ((l.x - i.x) * (n2.y - i.y) >= (l.y - i.y) * (n2.x - i.x)) e.pop();
      else break;
    }
    e.push(n2);
  }
  return e.pop(), o.length === 1 && e.length === 1 && o[0].x === e[0].x && o[0].y === e[0].y ? o : o.concat(e);
}
var Ce = S;
var ge = G;
var be = F;
var U = B;
var Ne = Ce;
var He = ge;
var Se = be;
var we = s.forwardRef(({ className: t, sideOffset: o = 4, ...e }, r) => ae.jsx(
  U,
  {
    ref: r,
    sideOffset: o,
    className: mo(
      "bg-popover text-popover-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 overflow-hidden rounded-md border px-3 py-1.5 text-sm shadow-md",
      t
    ),
    ...e
  }
));
we.displayName = U.displayName;

export {
  Ne,
  He,
  Se,
  we
};
//# sourceMappingURL=chunk-B4PZMLKC.js.map
