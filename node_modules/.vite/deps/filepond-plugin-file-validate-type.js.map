{
  "version": 3,
  "sources": ["../../filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js"],
  "sourcesContent": ["/*!\r\n * FilePondPluginFileValidateType 1.2.9\r\n * Licensed under MIT, https://opensource.org/licenses/MIT/\r\n * Please visit https://pqina.nl/filepond/ for details.\r\n */\r\n\r\n/* eslint-disable */\r\n\r\nconst plugin = ({ addFilter, utils }) => {\r\n    // get quick reference to Type utils\r\n    const {\r\n        Type,\r\n        isString,\r\n        replaceInString,\r\n        guesstimateMimeType,\r\n        getExtensionFromFilename,\r\n        getFilenameFromURL,\r\n    } = utils;\r\n\r\n    const mimeTypeMatchesWildCard = (mimeType, wildcard) => {\r\n        const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\r\n        const wildcardGroup = wildcard.slice(0, -2); // image/* -> image\r\n        return mimeTypeGroup === wildcardGroup;\r\n    };\r\n\r\n    const isValidMimeType = (acceptedTypes, userInputType) =>\r\n        acceptedTypes.some(acceptedType => {\r\n            // accepted is wildcard mime type\r\n            if (/\\*$/.test(acceptedType)) {\r\n                return mimeTypeMatchesWildCard(userInputType, acceptedType);\r\n            }\r\n\r\n            // is normal mime type\r\n            return acceptedType === userInputType;\r\n        });\r\n\r\n    const getItemType = item => {\r\n        // if the item is a url we guess the mime type by the extension\r\n        let type = '';\r\n        if (isString(item)) {\r\n            const filename = getFilenameFromURL(item);\r\n            const extension = getExtensionFromFilename(filename);\r\n            if (extension) {\r\n                type = guesstimateMimeType(extension);\r\n            }\r\n        } else {\r\n            type = item.type;\r\n        }\r\n\r\n        return type;\r\n    };\r\n\r\n    const validateFile = (item, acceptedFileTypes, typeDetector) => {\r\n        // no types defined, everything is allowed \\o/\r\n        if (acceptedFileTypes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        // gets the item type\r\n        const type = getItemType(item);\r\n\r\n        // no type detector, test now\r\n        if (!typeDetector) {\r\n            return isValidMimeType(acceptedFileTypes, type);\r\n        }\r\n\r\n        // use type detector\r\n        return new Promise((resolve, reject) => {\r\n            typeDetector(item, type)\r\n                .then(detectedType => {\r\n                    if (isValidMimeType(acceptedFileTypes, detectedType)) {\r\n                        resolve();\r\n                    } else {\r\n                        reject();\r\n                    }\r\n                })\r\n                .catch(reject);\r\n        });\r\n    };\r\n\r\n    const applyMimeTypeMap = map => acceptedFileType =>\r\n        map[acceptedFileType] === null ? false : map[acceptedFileType] || acceptedFileType;\r\n\r\n    // setup attribute mapping for accept\r\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', map =>\r\n        Object.assign(map, {\r\n            accept: 'acceptedFileTypes',\r\n        })\r\n    );\r\n\r\n    // filtering if an item is allowed in hopper\r\n    addFilter('ALLOW_HOPPER_ITEM', (file, { query }) => {\r\n        // if we are not doing file type validation exit\r\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\r\n            return true;\r\n        }\r\n\r\n        // we validate the file against the accepted file types\r\n        return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\r\n    });\r\n\r\n    // called for each file that is loaded\r\n    // right before it is set to the item state\r\n    // should return a promise\r\n    addFilter(\r\n        'LOAD_FILE',\r\n        (file, { query }) =>\r\n            new Promise((resolve, reject) => {\r\n                if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\r\n                    resolve(file);\r\n                    return;\r\n                }\r\n\r\n                const acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\r\n\r\n                // custom type detector method\r\n                const typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\r\n\r\n                // if invalid, exit here\r\n                const validationResult = validateFile(file, acceptedFileTypes, typeDetector);\r\n\r\n                const handleRejection = () => {\r\n                    const acceptedFileTypesMapped = acceptedFileTypes\r\n                        .map(\r\n                            applyMimeTypeMap(\r\n                                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\r\n                            )\r\n                        )\r\n                        .filter(label => label !== false);\r\n\r\n                    const acceptedFileTypesMappedUnique = acceptedFileTypesMapped.filter(\r\n                        (item, index) => acceptedFileTypesMapped.indexOf(item) === index\r\n                    );\r\n\r\n                    reject({\r\n                        status: {\r\n                            main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\r\n                            sub: replaceInString(\r\n                                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\r\n                                {\r\n                                    allTypes: acceptedFileTypesMappedUnique.join(', '),\r\n                                    allButLastType: acceptedFileTypesMappedUnique\r\n                                        .slice(0, -1)\r\n                                        .join(', '),\r\n                                    lastType:\r\n                                        acceptedFileTypesMappedUnique[\r\n                                            acceptedFileTypesMappedUnique.length - 1\r\n                                        ],\r\n                                }\r\n                            ),\r\n                        },\r\n                    });\r\n                };\r\n\r\n                // has returned new filename immidiately\r\n                if (typeof validationResult === 'boolean') {\r\n                    if (!validationResult) {\r\n                        return handleRejection();\r\n                    }\r\n                    return resolve(file);\r\n                }\r\n\r\n                // is promise\r\n                validationResult\r\n                    .then(() => {\r\n                        resolve(file);\r\n                    })\r\n                    .catch(handleRejection);\r\n            })\r\n    );\r\n\r\n    // expose plugin\r\n    return {\r\n        // default options\r\n        options: {\r\n            // Enable or disable file type validation\r\n            allowFileTypeValidation: [true, Type.BOOLEAN],\r\n\r\n            // What file types to accept\r\n            acceptedFileTypes: [[], Type.ARRAY],\r\n            // - must be comma separated\r\n            // - mime types: image/png, image/jpeg, image/gif\r\n            // - extensions: .png, .jpg, .jpeg ( not enabled yet )\r\n            // - wildcards: image/*\r\n\r\n            // label to show when a type is not allowed\r\n            labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\r\n\r\n            // nicer label\r\n            fileValidateTypeLabelExpectedTypes: [\r\n                'Expects {allButLastType} or {lastType}',\r\n                Type.STRING,\r\n            ],\r\n\r\n            // map mime types to extensions\r\n            fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\r\n\r\n            // Custom function to detect type of file\r\n            fileValidateTypeDetectType: [null, Type.FUNCTION],\r\n        },\r\n    };\r\n};\r\n\r\n// fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\r\nconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\r\nif (isBrowser) {\r\n    document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', { detail: plugin }));\r\n}\r\n\r\nexport default plugin;\r\n"],
  "mappings": ";;;AAQA,IAAM,SAAS,CAAC,EAAE,WAAW,MAAM,MAAM;AAErC,QAAM;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,IAAI;AAEJ,QAAM,0BAA0B,CAAC,UAAU,aAAa;AACpD,UAAM,iBAAiB,SAAS,KAAK,QAAQ,KAAK,CAAC,GAAG,IAAI;AAC1D,UAAM,gBAAgB,SAAS,MAAM,GAAG,EAAE;AAC1C,WAAO,kBAAkB;AAAA,EAC7B;AAEA,QAAM,kBAAkB,CAAC,eAAe,kBACpC,cAAc,KAAK,kBAAgB;AAE/B,QAAI,MAAM,KAAK,YAAY,GAAG;AAC1B,aAAO,wBAAwB,eAAe,YAAY;AAAA,IAC9D;AAGA,WAAO,iBAAiB;AAAA,EAC5B,CAAC;AAEL,QAAM,cAAc,UAAQ;AAExB,QAAI,OAAO;AACX,QAAI,SAAS,IAAI,GAAG;AAChB,YAAM,WAAW,mBAAmB,IAAI;AACxC,YAAM,YAAY,yBAAyB,QAAQ;AACnD,UAAI,WAAW;AACX,eAAO,oBAAoB,SAAS;AAAA,MACxC;AAAA,IACJ,OAAO;AACH,aAAO,KAAK;AAAA,IAChB;AAEA,WAAO;AAAA,EACX;AAEA,QAAM,eAAe,CAAC,MAAM,mBAAmB,iBAAiB;AAE5D,QAAI,kBAAkB,WAAW,GAAG;AAChC,aAAO;AAAA,IACX;AAGA,UAAM,OAAO,YAAY,IAAI;AAG7B,QAAI,CAAC,cAAc;AACf,aAAO,gBAAgB,mBAAmB,IAAI;AAAA,IAClD;AAGA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,mBAAa,MAAM,IAAI,EAClB,KAAK,kBAAgB;AAClB,YAAI,gBAAgB,mBAAmB,YAAY,GAAG;AAClD,kBAAQ;AAAA,QACZ,OAAO;AACH,iBAAO;AAAA,QACX;AAAA,MACJ,CAAC,EACA,MAAM,MAAM;AAAA,IACrB,CAAC;AAAA,EACL;AAEA,QAAM,mBAAmB,SAAO,sBAC5B,IAAI,gBAAgB,MAAM,OAAO,QAAQ,IAAI,gBAAgB,KAAK;AAGtE;AAAA,IAAU;AAAA,IAA+B,SACrC,OAAO,OAAO,KAAK;AAAA,MACf,QAAQ;AAAA,IACZ,CAAC;AAAA,EACL;AAGA,YAAU,qBAAqB,CAAC,MAAM,EAAE,MAAM,MAAM;AAEhD,QAAI,CAAC,MAAM,gCAAgC,GAAG;AAC1C,aAAO;AAAA,IACX;AAGA,WAAO,aAAa,MAAM,MAAM,yBAAyB,CAAC;AAAA,EAC9D,CAAC;AAKD;AAAA,IACI;AAAA,IACA,CAAC,MAAM,EAAE,MAAM,MACX,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC7B,UAAI,CAAC,MAAM,gCAAgC,GAAG;AAC1C,gBAAQ,IAAI;AACZ;AAAA,MACJ;AAEA,YAAM,oBAAoB,MAAM,yBAAyB;AAGzD,YAAM,eAAe,MAAM,oCAAoC;AAG/D,YAAM,mBAAmB,aAAa,MAAM,mBAAmB,YAAY;AAE3E,YAAM,kBAAkB,MAAM;AAC1B,cAAM,0BAA0B,kBAC3B;AAAA,UACG;AAAA,YACI,MAAM,iDAAiD;AAAA,UAC3D;AAAA,QACJ,EACC,OAAO,WAAS,UAAU,KAAK;AAEpC,cAAM,gCAAgC,wBAAwB;AAAA,UAC1D,CAAC,MAAM,UAAU,wBAAwB,QAAQ,IAAI,MAAM;AAAA,QAC/D;AAEA,eAAO;AAAA,UACH,QAAQ;AAAA,YACJ,MAAM,MAAM,iCAAiC;AAAA,YAC7C,KAAK;AAAA,cACD,MAAM,6CAA6C;AAAA,cACnD;AAAA,gBACI,UAAU,8BAA8B,KAAK,IAAI;AAAA,gBACjD,gBAAgB,8BACX,MAAM,GAAG,EAAE,EACX,KAAK,IAAI;AAAA,gBACd,UACI,8BACI,8BAA8B,SAAS,CAC3C;AAAA,cACR;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAGA,UAAI,OAAO,qBAAqB,WAAW;AACvC,YAAI,CAAC,kBAAkB;AACnB,iBAAO,gBAAgB;AAAA,QAC3B;AACA,eAAO,QAAQ,IAAI;AAAA,MACvB;AAGA,uBACK,KAAK,MAAM;AACR,gBAAQ,IAAI;AAAA,MAChB,CAAC,EACA,MAAM,eAAe;AAAA,IAC9B,CAAC;AAAA,EACT;AAGA,SAAO;AAAA;AAAA,IAEH,SAAS;AAAA;AAAA,MAEL,yBAAyB,CAAC,MAAM,KAAK,OAAO;AAAA;AAAA,MAG5C,mBAAmB,CAAC,CAAC,GAAG,KAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOlC,yBAAyB,CAAC,2BAA2B,KAAK,MAAM;AAAA;AAAA,MAGhE,oCAAoC;AAAA,QAChC;AAAA,QACA,KAAK;AAAA,MACT;AAAA;AAAA,MAGA,uCAAuC,CAAC,CAAC,GAAG,KAAK,MAAM;AAAA;AAAA,MAGvD,4BAA4B,CAAC,MAAM,KAAK,QAAQ;AAAA,IACpD;AAAA,EACJ;AACJ;AAGA,IAAM,YAAY,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa;AAC9E,IAAI,WAAW;AACX,WAAS,cAAc,IAAI,YAAY,yBAAyB,EAAE,QAAQ,OAAO,CAAC,CAAC;AACvF;AAEA,IAAO,iDAAQ;",
  "names": []
}
