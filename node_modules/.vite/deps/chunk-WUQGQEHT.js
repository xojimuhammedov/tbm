import {
  St,
  m,
  pt,
  y
} from "./chunk-4ONM6MHH.js";
import {
  zo
} from "./chunk-COGQTHYJ.js";
import {
  aw
} from "./chunk-LPOMZQTJ.js";
import {
  Ge,
  H,
  He,
  J,
  Mt,
  Oe,
  Pe,
  Qe,
  S,
  Tt,
  V,
  Ye,
  Ze,
  ce,
  de,
  ht,
  ke,
  mo,
  ne,
  ze
} from "./chunk-SPRZPVMT.js";
import {
  ae
} from "./chunk-HBZT6TY3.js";
import {
  require_react
} from "./chunk-HPJJ3TUJ.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/dgz-ui-shared/dist/unstyled-DA_k1WVz.js
var P2 = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/dgz-ui-shared/dist/index-sde7W6lA-CGLFJGTK.js
var l = __toESM(require_react(), 1);
var D = "Dialog";
var [b, ce2] = He(D);
var [J2, u] = b(D);
var I = (e) => {
  const {
    __scopeDialog: n,
    children: t,
    open: a,
    defaultOpen: r,
    onOpenChange: o,
    modal: i = true
  } = e, c2 = l.useRef(null), f = l.useRef(null), [v2, h2] = Qe({
    prop: a,
    defaultProp: r ?? false,
    onChange: o,
    caller: D
  });
  return S.jsx(
    J2,
    {
      scope: n,
      triggerRef: c2,
      contentRef: f,
      contentId: Ze(),
      titleId: Ze(),
      descriptionId: Ze(),
      open: v2,
      onOpenChange: h2,
      onOpenToggle: l.useCallback(() => h2((q2) => !q2), [h2]),
      modal: i,
      children: t
    }
  );
};
I.displayName = D;
var w = "DialogTrigger";
var O = l.forwardRef(
  (e, n) => {
    const { __scopeDialog: t, ...a } = e, r = u(w, t), o = H(n, r.triggerRef);
    return S.jsx(
      de.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": r.open,
        "aria-controls": r.contentId,
        "data-state": C(r.open),
        ...a,
        ref: o,
        onClick: J(e.onClick, r.onOpenToggle)
      }
    );
  }
);
O.displayName = w;
var _ = "DialogPortal";
var [Y, F] = b(_, {
  forceMount: void 0
});
var $ = (e) => {
  const { __scopeDialog: n, forceMount: t, children: a, container: r } = e, o = u(_, n);
  return S.jsx(Y, { scope: n, forceMount: t, children: l.Children.map(a, (i) => S.jsx(Pe, { present: t || o.open, children: S.jsx(Oe, { asChild: true, container: r, children: i }) })) });
};
$.displayName = _;
var m2 = "DialogOverlay";
var N = l.forwardRef(
  (e, n) => {
    const t = F(m2, e.__scopeDialog), { forceMount: a = t.forceMount, ...r } = e, o = u(m2, e.__scopeDialog);
    return o.modal ? S.jsx(Pe, { present: a || o.open, children: S.jsx(oe, { ...r, ref: n }) }) : null;
  }
);
N.displayName = m2;
var ee = ce("DialogOverlay.RemoveScroll");
var oe = l.forwardRef(
  (e, n) => {
    const { __scopeDialog: t, ...a } = e, r = u(m2, t);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      S.jsx(ht, { as: ee, allowPinchZoom: true, shards: [r.contentRef], children: S.jsx(
        de.div,
        {
          "data-state": C(r.open),
          ...a,
          ref: n,
          style: { pointerEvents: "auto", ...a.style }
        }
      ) })
    );
  }
);
var d = "DialogContent";
var E = l.forwardRef(
  (e, n) => {
    const t = F(d, e.__scopeDialog), { forceMount: a = t.forceMount, ...r } = e, o = u(d, e.__scopeDialog);
    return S.jsx(Pe, { present: a || o.open, children: o.modal ? S.jsx(ne2, { ...r, ref: n }) : S.jsx(te, { ...r, ref: n }) });
  }
);
E.displayName = d;
var ne2 = l.forwardRef(
  (e, n) => {
    const t = u(d, e.__scopeDialog), a = l.useRef(null), r = H(n, t.contentRef, a);
    return l.useEffect(() => {
      const o = a.current;
      if (o) return Tt(o);
    }, []), S.jsx(
      M,
      {
        ...e,
        ref: r,
        trapFocus: t.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: J(e.onCloseAutoFocus, (o) => {
          var i;
          o.preventDefault(), (i = t.triggerRef.current) == null || i.focus();
        }),
        onPointerDownOutside: J(e.onPointerDownOutside, (o) => {
          const i = o.detail.originalEvent, c2 = i.button === 0 && i.ctrlKey === true;
          (i.button === 2 || c2) && o.preventDefault();
        }),
        onFocusOutside: J(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
);
var te = l.forwardRef(
  (e, n) => {
    const t = u(d, e.__scopeDialog), a = l.useRef(false), r = l.useRef(false);
    return S.jsx(
      M,
      {
        ...e,
        ref: n,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (o) => {
          var i, c2;
          (i = e.onCloseAutoFocus) == null || i.call(e, o), o.defaultPrevented || (a.current || (c2 = t.triggerRef.current) == null || c2.focus(), o.preventDefault()), a.current = false, r.current = false;
        },
        onInteractOutside: (o) => {
          var i, c2;
          (i = e.onInteractOutside) == null || i.call(e, o), o.defaultPrevented || (a.current = true, o.detail.originalEvent.type === "pointerdown" && (r.current = true));
          const f = o.target;
          (c2 = t.triggerRef.current) != null && c2.contains(f) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && r.current && o.preventDefault();
        }
      }
    );
  }
);
var M = l.forwardRef(
  (e, n) => {
    const { __scopeDialog: t, trapFocus: a, onOpenAutoFocus: r, onCloseAutoFocus: o, ...i } = e, c2 = u(d, t), f = l.useRef(null), v2 = H(n, f);
    return Mt(), S.jsxs(S.Fragment, { children: [
      S.jsx(
        ke,
        {
          asChild: true,
          loop: true,
          trapped: a,
          onMountAutoFocus: r,
          onUnmountAutoFocus: o,
          children: S.jsx(
            ze,
            {
              role: "dialog",
              id: c2.contentId,
              "aria-describedby": c2.descriptionId,
              "aria-labelledby": c2.titleId,
              "data-state": C(c2.open),
              ...i,
              ref: v2,
              onDismiss: () => c2.onOpenChange(false)
            }
          )
        }
      ),
      S.jsxs(S.Fragment, { children: [
        S.jsx(re, { titleId: c2.titleId }),
        S.jsx(se, { contentRef: f, descriptionId: c2.descriptionId })
      ] })
    ] });
  }
);
var j = "DialogTitle";
var P = l.forwardRef(
  (e, n) => {
    const { __scopeDialog: t, ...a } = e, r = u(j, t);
    return S.jsx(de.h2, { id: r.titleId, ...a, ref: n });
  }
);
P.displayName = j;
var A = "DialogDescription";
var k = l.forwardRef(
  (e, n) => {
    const { __scopeDialog: t, ...a } = e, r = u(A, t);
    return S.jsx(de.p, { id: r.descriptionId, ...a, ref: n });
  }
);
k.displayName = A;
var S2 = "DialogClose";
var T = l.forwardRef(
  (e, n) => {
    const { __scopeDialog: t, ...a } = e, r = u(S2, t);
    return S.jsx(
      de.button,
      {
        type: "button",
        ...a,
        ref: n,
        onClick: J(e.onClick, () => r.onOpenChange(false))
      }
    );
  }
);
T.displayName = S2;
function C(e) {
  return e ? "open" : "closed";
}
var W = "DialogTitleWarning";
var [ue, B] = Ye(W, {
  contentName: d,
  titleName: j,
  docsSlug: "dialog"
});
var re = ({ titleId: e }) => {
  const n = B(W), t = `\`${n.contentName}\` requires a \`${n.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${n.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${n.docsSlug}`;
  return l.useEffect(() => {
    e && (document.getElementById(e) || console.error(t));
  }, [t, e]), null;
};
var ae2 = "DialogDescriptionWarning";
var se = ({ contentRef: e, descriptionId: n }) => {
  const t = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${B(ae2).contentName}}.`;
  return l.useEffect(() => {
    var a;
    const r = (a = e.current) == null ? void 0 : a.getAttribute("aria-describedby");
    n && r && (document.getElementById(n) || console.warn(t));
  }, [t, e, n]), null;
};
var de2 = I;
var fe = O;
var pe = $;
var ge = N;
var me = E;
var De = P;
var ve = k;
var he = T;

// node_modules/dgz-ui-shared/dist/unstyled-DA_k1WVz.js
var Et = "AlertDialog";
var [Cs, ia] = He(Et, [
  ce2
]);
var X = ce2();
var At = (t) => {
  const { __scopeAlertDialog: e, ...s } = t, r = X(e);
  return S.jsx(de2, { ...r, ...s, modal: true });
};
At.displayName = Et;
var Ns = "AlertDialogTrigger";
var It = P2.forwardRef(
  (t, e) => {
    const { __scopeAlertDialog: s, ...r } = t, a = X(s);
    return S.jsx(fe, { ...a, ...r, ref: e });
  }
);
It.displayName = Ns;
var Es = "AlertDialogPortal";
var jt = (t) => {
  const { __scopeAlertDialog: e, ...s } = t, r = X(e);
  return S.jsx(pe, { ...r, ...s });
};
jt.displayName = Es;
var As = "AlertDialogOverlay";
var Ot = P2.forwardRef(
  (t, e) => {
    const { __scopeAlertDialog: s, ...r } = t, a = X(s);
    return S.jsx(ge, { ...a, ...r, ref: e });
  }
);
Ot.displayName = As;
var oe2 = "AlertDialogContent";
var [Is, js] = Cs(oe2);
var Os = Ge("AlertDialogContent");
var Rt = P2.forwardRef(
  (t, e) => {
    const { __scopeAlertDialog: s, children: r, ...a } = t, n = X(s), i = P2.useRef(null), o = H(e, i), l2 = P2.useRef(null);
    return S.jsx(
      ue,
      {
        contentName: oe2,
        titleName: St2,
        docsSlug: "alert-dialog",
        children: S.jsx(Is, { scope: s, cancelRef: l2, children: S.jsxs(
          me,
          {
            role: "alertdialog",
            ...n,
            ...a,
            ref: o,
            onOpenAutoFocus: J(a.onOpenAutoFocus, (d2) => {
              var f;
              d2.preventDefault(), (f = l2.current) == null || f.focus({ preventScroll: true });
            }),
            onPointerDownOutside: (d2) => d2.preventDefault(),
            onInteractOutside: (d2) => d2.preventDefault(),
            children: [
              S.jsx(Os, { children: r }),
              S.jsx(Ss, { contentRef: i })
            ]
          }
        ) })
      }
    );
  }
);
Rt.displayName = oe2;
var St2 = "AlertDialogTitle";
var $t = P2.forwardRef(
  (t, e) => {
    const { __scopeAlertDialog: s, ...r } = t, a = X(s);
    return S.jsx(De, { ...a, ...r, ref: e });
  }
);
$t.displayName = St2;
var Zt = "AlertDialogDescription";
var Lt = P2.forwardRef((t, e) => {
  const { __scopeAlertDialog: s, ...r } = t, a = X(s);
  return S.jsx(ve, { ...a, ...r, ref: e });
});
Lt.displayName = Zt;
var Rs = "AlertDialogAction";
var Pt = P2.forwardRef(
  (t, e) => {
    const { __scopeAlertDialog: s, ...r } = t, a = X(s);
    return S.jsx(he, { ...a, ...r, ref: e });
  }
);
Pt.displayName = Rs;
var Dt = "AlertDialogCancel";
var Mt2 = P2.forwardRef(
  (t, e) => {
    const { __scopeAlertDialog: s, ...r } = t, { cancelRef: a } = js(Dt, s), n = X(s), i = H(e, a);
    return S.jsx(he, { ...n, ...r, ref: i });
  }
);
Mt2.displayName = Dt;
var Ss = ({ contentRef: t }) => {
  const e = `\`${oe2}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${oe2}\` by passing a \`${Zt}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${oe2}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  return P2.useEffect(() => {
    var s;
    document.getElementById(
      (s = t.current) == null ? void 0 : s.getAttribute("aria-describedby")
    ) || console.warn(e);
  }, [e, t]), null;
};
var $s = At;
var Zs = It;
var Ls = jt;
var zt = Ot;
var Vt = Rt;
var Bt = Pt;
var Ft = Mt2;
var Ut = $t;
var Wt = Lt;
var qt = $s;
var Ht = Zs;
var Ps = Ls;
var Xt = P2.forwardRef(({ className: t, ...e }, s) => S.jsx(
  zt,
  {
    className: mo(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
      t
    ),
    ...e,
    ref: s
  }
));
Xt.displayName = zt.displayName;
var He2 = P2.forwardRef(({ className: t, ...e }, s) => S.jsxs(Ps, { children: [
  S.jsx(Xt, {}),
  S.jsx(
    Vt,
    {
      ref: s,
      className: mo(
        "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] fixed top-[50%] left-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border p-6 shadow-lg duration-200 sm:rounded-lg",
        t
      ),
      ...e
    }
  )
] }));
He2.displayName = Vt.displayName;
var Xe = ({
  className: t,
  ...e
}) => S.jsx(
  "div",
  {
    className: mo(
      "flex flex-col space-y-2 text-center sm:text-left",
      t
    ),
    ...e
  }
);
Xe.displayName = "AlertDialogHeader";
var Ye2 = ({
  className: t,
  ...e
}) => S.jsx("div", { className: mo("flex gap-2 sm:justify-end", t), ...e });
Ye2.displayName = "AlertDialogFooter";
var Je = P2.forwardRef(({ className: t, ...e }, s) => S.jsx(
  Ut,
  {
    ref: s,
    className: mo("text-lg font-semibold", t),
    ...e
  }
));
Je.displayName = Ut.displayName;
var Yt = P2.forwardRef(({ className: t, ...e }, s) => S.jsx(
  Wt,
  {
    ref: s,
    className: mo("text-muted-foreground text-sm", t),
    ...e
  }
));
Yt.displayName = Wt.displayName;
var Qe2 = P2.forwardRef(({ className: t, ...e }, s) => S.jsx(
  Bt,
  {
    ref: s,
    className: mo(V(), t),
    ...e
  }
));
Qe2.displayName = Bt.displayName;
var Ge2 = P2.forwardRef(({ className: t, ...e }, s) => S.jsx(
  Ft,
  {
    ref: s,
    className: mo(V({ variant: "tertiary" }), t),
    ...e
  }
));
Ge2.displayName = Ft.displayName;
var oa = ({
  title: t,
  description: e,
  children: s,
  onConfirm: r,
  ...a
}) => {
  const { t: n } = ne();
  return ae.jsxs(qt, { ...a, children: [
    s && ae.jsx(Ht, { children: s }),
    ae.jsxs(He2, { children: [
      ae.jsxs(Xe, { children: [
        ae.jsx(Je, { children: t || n("Are you absolutely sure?") }),
        ae.jsx(Yt, { children: e || n(
          "This action cannot be undone. This will permanently delete your data from our servers."
        ) })
      ] }),
      ae.jsxs(Ye2, { children: [
        ae.jsx(Ge2, { className: "mt-0", children: n("Cancel") }),
        ae.jsx(Qe2, { onClick: r, children: n("Confirm") })
      ] })
    ] })
  ] });
};
var st = (t, e, s) => {
  if (t && "reportValidity" in t) {
    const r = y(s, e);
    t.setCustomValidity(r && r.message || ""), t.reportValidity();
  }
};
var Jt = (t, e) => {
  for (const s in e.fields) {
    const r = e.fields[s];
    r && r.ref && "reportValidity" in r.ref ? st(r.ref, s, t) : r && r.refs && r.refs.forEach((a) => st(a, s, t));
  }
};
var Ds = (t, e) => {
  e.shouldUseNativeValidation && Jt(t, e);
  const s = {};
  for (const r in t) {
    const a = y(e.fields, r), n = Object.assign(t[r] || {}, { ref: a && a.ref });
    if (Ms(e.names || Object.keys(t), r)) {
      const i = Object.assign({}, y(s, r));
      m(i, "root", n), m(s, r, i);
    } else m(s, r, n);
  }
  return s;
};
var Ms = (t, e) => {
  const s = rt(e);
  return t.some((r) => rt(r).match(`^${s}\\.\\d+`));
};
function rt(t) {
  return t.replace(/\]|\[/g, "");
}
function zs(t, e) {
  for (var s = {}; t.length; ) {
    var r = t[0], a = r.code, n = r.message, i = r.path.join(".");
    if (!s[i]) if ("unionErrors" in r) {
      var o = r.unionErrors[0].errors[0];
      s[i] = { message: o.message, type: o.code };
    } else s[i] = { message: n, type: a };
    if ("unionErrors" in r && r.unionErrors.forEach(function(f) {
      return f.errors.forEach(function(E2) {
        return t.push(E2);
      });
    }), e) {
      var l2 = s[i].types, d2 = l2 && l2[r.code];
      s[i] = St(i, e, s, a, d2 ? [].concat(d2, r.message) : r.message);
    }
    t.shift();
  }
  return s;
}
function Vs(t, e, s) {
  return s === void 0 && (s = {}), function(r, a, n) {
    try {
      return Promise.resolve(function(i, o) {
        try {
          var l2 = Promise.resolve(t[s.mode === "sync" ? "parse" : "parseAsync"](r, e)).then(function(d2) {
            return n.shouldUseNativeValidation && Jt({}, n), { errors: {}, values: s.raw ? Object.assign({}, r) : d2 };
          });
        } catch (d2) {
          return o(d2);
        }
        return l2 && l2.then ? l2.then(void 0, o) : l2;
      }(0, function(i) {
        if (function(o) {
          return Array.isArray(o == null ? void 0 : o.errors);
        }(i)) return { values: {}, errors: Ds(zs(i.errors, !n.shouldUseNativeValidation && n.criteriaMode === "all"), n) };
        throw i;
      }));
    } catch (i) {
      return Promise.reject(i);
    }
  };
}
var b2;
(function(t) {
  t.assertEqual = (a) => {
  };
  function e(a) {
  }
  t.assertIs = e;
  function s(a) {
    throw new Error();
  }
  t.assertNever = s, t.arrayToEnum = (a) => {
    const n = {};
    for (const i of a)
      n[i] = i;
    return n;
  }, t.getValidEnumValues = (a) => {
    const n = t.objectKeys(a).filter((o) => typeof a[a[o]] != "number"), i = {};
    for (const o of n)
      i[o] = a[o];
    return t.objectValues(i);
  }, t.objectValues = (a) => t.objectKeys(a).map(function(n) {
    return a[n];
  }), t.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const n = [];
    for (const i in a)
      Object.prototype.hasOwnProperty.call(a, i) && n.push(i);
    return n;
  }, t.find = (a, n) => {
    for (const i of a)
      if (n(i))
        return i;
  }, t.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && Number.isFinite(a) && Math.floor(a) === a;
  function r(a, n = " | ") {
    return a.map((i) => typeof i == "string" ? `'${i}'` : i).join(n);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (a, n) => typeof n == "bigint" ? n.toString() : n;
})(b2 || (b2 = {}));
var at;
(function(t) {
  t.mergeShapes = (e, s) => ({
    ...e,
    ...s
    // second overwrites first
  });
})(at || (at = {}));
var h = b2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var J3 = (t) => {
  switch (typeof t) {
    case "undefined":
      return h.undefined;
    case "string":
      return h.string;
    case "number":
      return Number.isNaN(t) ? h.nan : h.number;
    case "boolean":
      return h.boolean;
    case "function":
      return h.function;
    case "bigint":
      return h.bigint;
    case "symbol":
      return h.symbol;
    case "object":
      return Array.isArray(t) ? h.array : t === null ? h.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? h.promise : typeof Map < "u" && t instanceof Map ? h.map : typeof Set < "u" && t instanceof Set ? h.set : typeof Date < "u" && t instanceof Date ? h.date : h.object;
    default:
      return h.unknown;
  }
};
var c = b2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var q = class _q extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const s = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, s) : this.__proto__ = s, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const s = e || function(n) {
      return n.message;
    }, r = { _errors: [] }, a = (n) => {
      for (const i of n.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(a);
        else if (i.code === "invalid_return_type")
          a(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          a(i.argumentsError);
        else if (i.path.length === 0)
          r._errors.push(s(i));
        else {
          let o = r, l2 = 0;
          for (; l2 < i.path.length; ) {
            const d2 = i.path[l2];
            l2 === i.path.length - 1 ? (o[d2] = o[d2] || { _errors: [] }, o[d2]._errors.push(s(i))) : o[d2] = o[d2] || { _errors: [] }, o = o[d2], l2++;
          }
        }
    };
    return a(this), r;
  }
  static assert(e) {
    if (!(e instanceof _q))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, b2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (s) => s.message) {
    const s = {}, r = [];
    for (const a of this.issues)
      a.path.length > 0 ? (s[a.path[0]] = s[a.path[0]] || [], s[a.path[0]].push(e(a))) : r.push(e(a));
    return { formErrors: r, fieldErrors: s };
  }
  get formErrors() {
    return this.flatten();
  }
};
q.create = (t) => new q(t);
var Pe2 = (t, e) => {
  let s;
  switch (t.code) {
    case c.invalid_type:
      t.received === h.undefined ? s = "Required" : s = `Expected ${t.expected}, received ${t.received}`;
      break;
    case c.invalid_literal:
      s = `Invalid literal value, expected ${JSON.stringify(t.expected, b2.jsonStringifyReplacer)}`;
      break;
    case c.unrecognized_keys:
      s = `Unrecognized key(s) in object: ${b2.joinValues(t.keys, ", ")}`;
      break;
    case c.invalid_union:
      s = "Invalid input";
      break;
    case c.invalid_union_discriminator:
      s = `Invalid discriminator value. Expected ${b2.joinValues(t.options)}`;
      break;
    case c.invalid_enum_value:
      s = `Invalid enum value. Expected ${b2.joinValues(t.options)}, received '${t.received}'`;
      break;
    case c.invalid_arguments:
      s = "Invalid function arguments";
      break;
    case c.invalid_return_type:
      s = "Invalid function return type";
      break;
    case c.invalid_date:
      s = "Invalid date";
      break;
    case c.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (s = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (s = `${s} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? s = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? s = `Invalid input: must end with "${t.validation.endsWith}"` : b2.assertNever(t.validation) : t.validation !== "regex" ? s = `Invalid ${t.validation}` : s = "Invalid";
      break;
    case c.too_small:
      t.type === "array" ? s = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? s = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? s = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? s = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : s = "Invalid input";
      break;
    case c.too_big:
      t.type === "array" ? s = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? s = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? s = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? s = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? s = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : s = "Invalid input";
      break;
    case c.custom:
      s = "Invalid input";
      break;
    case c.invalid_intersection_types:
      s = "Intersection results could not be merged";
      break;
    case c.not_multiple_of:
      s = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case c.not_finite:
      s = "Number must be finite";
      break;
    default:
      s = e.defaultError, b2.assertNever(t);
  }
  return { message: s };
};
var Bs = Pe2;
function Fs() {
  return Bs;
}
var Us = (t) => {
  const { data: e, path: s, errorMaps: r, issueData: a } = t, n = [...s, ...a.path || []], i = {
    ...a,
    path: n
  };
  if (a.message !== void 0)
    return {
      ...a,
      path: n,
      message: a.message
    };
  let o = "";
  const l2 = r.filter((d2) => !!d2).slice().reverse();
  for (const d2 of l2)
    o = d2(i, { data: e, defaultError: o }).message;
  return {
    ...a,
    path: n,
    message: o
  };
};
function u2(t, e) {
  const s = Fs(), r = Us({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      s,
      // then global override map
      s === Pe2 ? void 0 : Pe2
      // then global default map
    ].filter((a) => !!a)
  });
  t.common.issues.push(r);
}
var V2 = class _V {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, s) {
    const r = [];
    for (const a of s) {
      if (a.status === "aborted")
        return y2;
      a.status === "dirty" && e.dirty(), r.push(a.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, s) {
    const r = [];
    for (const a of s) {
      const n = await a.key, i = await a.value;
      r.push({
        key: n,
        value: i
      });
    }
    return _V.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, s) {
    const r = {};
    for (const a of s) {
      const { key: n, value: i } = a;
      if (n.status === "aborted" || i.status === "aborted")
        return y2;
      n.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), n.value !== "__proto__" && (typeof i.value < "u" || a.alwaysSet) && (r[n.value] = i.value);
    }
    return { status: e.value, value: r };
  }
};
var y2 = Object.freeze({
  status: "aborted"
});
var fe2 = (t) => ({ status: "dirty", value: t });
var B2 = (t) => ({ status: "valid", value: t });
var nt = (t) => t.status === "aborted";
var it = (t) => t.status === "dirty";
var le = (t) => t.status === "valid";
var be = (t) => typeof Promise < "u" && t instanceof Promise;
var m3;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(m3 || (m3 = {}));
var K = class {
  constructor(e, s, r, a) {
    this._cachedPath = [], this.parent = e, this.data = s, this._path = r, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var ot = (t, e) => {
  if (le(e))
    return { success: true, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const s = new q(t.common.issues);
      return this._error = s, this._error;
    }
  };
};
function _2(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: s, required_error: r, description: a } = t;
  if (e && (s || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: a } : { errorMap: (i, o) => {
    const { message: l2 } = t;
    return i.code === "invalid_enum_value" ? { message: l2 ?? o.defaultError } : typeof o.data > "u" ? { message: l2 ?? r ?? o.defaultError } : i.code !== "invalid_type" ? { message: o.defaultError } : { message: l2 ?? s ?? o.defaultError };
  }, description: a };
}
var k2 = class {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return J3(e.data);
  }
  _getOrReturnCtx(e, s) {
    return s || {
      common: e.parent.common,
      data: e.data,
      parsedType: J3(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new V2(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: J3(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const s = this._parse(e);
    if (be(s))
      throw new Error("Synchronous parse encountered promise.");
    return s;
  }
  _parseAsync(e) {
    const s = this._parse(e);
    return Promise.resolve(s);
  }
  parse(e, s) {
    const r = this.safeParse(e, s);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, s) {
    const r = {
      common: {
        issues: [],
        async: (s == null ? void 0 : s.async) ?? false,
        contextualErrorMap: s == null ? void 0 : s.errorMap
      },
      path: (s == null ? void 0 : s.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: J3(e)
    }, a = this._parseSync({ data: e, path: r.path, parent: r });
    return ot(r, a);
  }
  "~validate"(e) {
    var r, a;
    const s = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: J3(e)
    };
    if (!this["~standard"].async)
      try {
        const n = this._parseSync({ data: e, path: [], parent: s });
        return le(n) ? {
          value: n.value
        } : {
          issues: s.common.issues
        };
      } catch (n) {
        (a = (r = n == null ? void 0 : n.message) == null ? void 0 : r.toLowerCase()) != null && a.includes("encountered") && (this["~standard"].async = true), s.common = {
          issues: [],
          async: true
        };
      }
    return this._parseAsync({ data: e, path: [], parent: s }).then((n) => le(n) ? {
      value: n.value
    } : {
      issues: s.common.issues
    });
  }
  async parseAsync(e, s) {
    const r = await this.safeParseAsync(e, s);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, s) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: s == null ? void 0 : s.errorMap,
        async: true
      },
      path: (s == null ? void 0 : s.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: J3(e)
    }, a = this._parse({ data: e, path: r.path, parent: r }), n = await (be(a) ? a : Promise.resolve(a));
    return ot(r, n);
  }
  refine(e, s) {
    const r = (a) => typeof s == "string" || typeof s > "u" ? { message: s } : typeof s == "function" ? s(a) : s;
    return this._refinement((a, n) => {
      const i = e(a), o = () => n.addIssue({
        code: c.custom,
        ...r(a)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((l2) => l2 ? true : (o(), false)) : i ? true : (o(), false);
    });
  }
  refinement(e, s) {
    return this._refinement((r, a) => e(r) ? true : (a.addIssue(typeof s == "function" ? s(r, a) : s), false));
  }
  _refinement(e) {
    return new ce3({
      schema: this,
      typeName: v.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (s) => this["~validate"](s)
    };
  }
  optional() {
    return G.create(this, this._def);
  }
  nullable() {
    return ue2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return U.create(this);
  }
  promise() {
    return Ne.create(this, this._def);
  }
  or(e) {
    return Te.create([this, e], this._def);
  }
  and(e) {
    return Ce.create(this, e, this._def);
  }
  transform(e) {
    return new ce3({
      ..._2(this._def),
      schema: this,
      typeName: v.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const s = typeof e == "function" ? e : () => e;
    return new Me({
      ..._2(this._def),
      innerType: this,
      defaultValue: s,
      typeName: v.ZodDefault
    });
  }
  brand() {
    return new hr({
      typeName: v.ZodBranded,
      type: this,
      ..._2(this._def)
    });
  }
  catch(e) {
    const s = typeof e == "function" ? e : () => e;
    return new ze2({
      ..._2(this._def),
      innerType: this,
      catchValue: s,
      typeName: v.ZodCatch
    });
  }
  describe(e) {
    const s = this.constructor;
    return new s({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Ke.create(this, e);
  }
  readonly() {
    return Ve.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var Ws = /^c[^\s-]{8,}$/i;
var qs = /^[0-9a-z]+$/;
var Hs = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var Xs = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var Ys = /^[a-z0-9_-]{21}$/i;
var Js = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var Qs = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var Gs = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var Ks = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var $e;
var er = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var tr = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var sr = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var rr = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var ar = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var nr = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var Qt = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var ir = new RegExp(`^${Qt}$`);
function Gt(t) {
  let e = "[0-5]\\d";
  t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`);
  const s = t.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${s}`;
}
function or(t) {
  return new RegExp(`^${Gt(t)}$`);
}
function lr(t) {
  let e = `${Qt}T${Gt(t)}`;
  const s = [];
  return s.push(t.local ? "Z?" : "Z"), t.offset && s.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${s.join("|")})`, new RegExp(`^${e}$`);
}
function dr(t, e) {
  return !!((e === "v4" || !e) && er.test(t) || (e === "v6" || !e) && sr.test(t));
}
function cr(t, e) {
  if (!Js.test(t))
    return false;
  try {
    const [s] = t.split("."), r = s.replace(/-/g, "+").replace(/_/g, "/").padEnd(s.length + (4 - s.length % 4) % 4, "="), a = JSON.parse(atob(r));
    return !(typeof a != "object" || a === null || "typ" in a && (a == null ? void 0 : a.typ) !== "JWT" || !a.alg || e && a.alg !== e);
  } catch {
    return false;
  }
}
function ur(t, e) {
  return !!((e === "v4" || !e) && tr.test(t) || (e === "v6" || !e) && rr.test(t));
}
var Q = class _Q extends k2 {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== h.string) {
      const n = this._getOrReturnCtx(e);
      return u2(n, {
        code: c.invalid_type,
        expected: h.string,
        received: n.parsedType
      }), y2;
    }
    const r = new V2();
    let a;
    for (const n of this._def.checks)
      if (n.kind === "min")
        e.data.length < n.value && (a = this._getOrReturnCtx(e, a), u2(a, {
          code: c.too_small,
          minimum: n.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: n.message
        }), r.dirty());
      else if (n.kind === "max")
        e.data.length > n.value && (a = this._getOrReturnCtx(e, a), u2(a, {
          code: c.too_big,
          maximum: n.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: n.message
        }), r.dirty());
      else if (n.kind === "length") {
        const i = e.data.length > n.value, o = e.data.length < n.value;
        (i || o) && (a = this._getOrReturnCtx(e, a), i ? u2(a, {
          code: c.too_big,
          maximum: n.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: n.message
        }) : o && u2(a, {
          code: c.too_small,
          minimum: n.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: n.message
        }), r.dirty());
      } else if (n.kind === "email")
        Gs.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
          validation: "email",
          code: c.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "emoji")
        $e || ($e = new RegExp(Ks, "u")), $e.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
          validation: "emoji",
          code: c.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "uuid")
        Xs.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
          validation: "uuid",
          code: c.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "nanoid")
        Ys.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
          validation: "nanoid",
          code: c.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "cuid")
        Ws.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
          validation: "cuid",
          code: c.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "cuid2")
        qs.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
          validation: "cuid2",
          code: c.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "ulid")
        Hs.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
          validation: "ulid",
          code: c.invalid_string,
          message: n.message
        }), r.dirty());
      else if (n.kind === "url")
        try {
          new URL(e.data);
        } catch {
          a = this._getOrReturnCtx(e, a), u2(a, {
            validation: "url",
            code: c.invalid_string,
            message: n.message
          }), r.dirty();
        }
      else n.kind === "regex" ? (n.regex.lastIndex = 0, n.regex.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
        validation: "regex",
        code: c.invalid_string,
        message: n.message
      }), r.dirty())) : n.kind === "trim" ? e.data = e.data.trim() : n.kind === "includes" ? e.data.includes(n.value, n.position) || (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.invalid_string,
        validation: { includes: n.value, position: n.position },
        message: n.message
      }), r.dirty()) : n.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : n.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : n.kind === "startsWith" ? e.data.startsWith(n.value) || (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.invalid_string,
        validation: { startsWith: n.value },
        message: n.message
      }), r.dirty()) : n.kind === "endsWith" ? e.data.endsWith(n.value) || (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.invalid_string,
        validation: { endsWith: n.value },
        message: n.message
      }), r.dirty()) : n.kind === "datetime" ? lr(n).test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.invalid_string,
        validation: "datetime",
        message: n.message
      }), r.dirty()) : n.kind === "date" ? ir.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.invalid_string,
        validation: "date",
        message: n.message
      }), r.dirty()) : n.kind === "time" ? or(n).test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.invalid_string,
        validation: "time",
        message: n.message
      }), r.dirty()) : n.kind === "duration" ? Qs.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
        validation: "duration",
        code: c.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "ip" ? dr(e.data, n.version) || (a = this._getOrReturnCtx(e, a), u2(a, {
        validation: "ip",
        code: c.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "jwt" ? cr(e.data, n.alg) || (a = this._getOrReturnCtx(e, a), u2(a, {
        validation: "jwt",
        code: c.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "cidr" ? ur(e.data, n.version) || (a = this._getOrReturnCtx(e, a), u2(a, {
        validation: "cidr",
        code: c.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "base64" ? ar.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
        validation: "base64",
        code: c.invalid_string,
        message: n.message
      }), r.dirty()) : n.kind === "base64url" ? nr.test(e.data) || (a = this._getOrReturnCtx(e, a), u2(a, {
        validation: "base64url",
        code: c.invalid_string,
        message: n.message
      }), r.dirty()) : b2.assertNever(n);
    return { status: r.value, value: e.data };
  }
  _regex(e, s, r) {
    return this.refinement((a) => e.test(a), {
      validation: s,
      code: c.invalid_string,
      ...m3.errToObj(r)
    });
  }
  _addCheck(e) {
    return new _Q({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...m3.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...m3.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...m3.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...m3.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...m3.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...m3.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...m3.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...m3.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...m3.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...m3.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...m3.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...m3.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...m3.errToObj(e) });
  }
  datetime(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      local: false,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (e == null ? void 0 : e.offset) ?? false,
      local: (e == null ? void 0 : e.local) ?? false,
      ...m3.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ...m3.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...m3.errToObj(e) });
  }
  regex(e, s) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...m3.errToObj(s)
    });
  }
  includes(e, s) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: s == null ? void 0 : s.position,
      ...m3.errToObj(s == null ? void 0 : s.message)
    });
  }
  startsWith(e, s) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...m3.errToObj(s)
    });
  }
  endsWith(e, s) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...m3.errToObj(s)
    });
  }
  min(e, s) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...m3.errToObj(s)
    });
  }
  max(e, s) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...m3.errToObj(s)
    });
  }
  length(e, s) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...m3.errToObj(s)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, m3.errToObj(e));
  }
  trim() {
    return new _Q({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _Q({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _Q({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "min" && (e === null || s.value > e) && (e = s.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "max" && (e === null || s.value < e) && (e = s.value);
    return e;
  }
};
Q.create = (t) => new Q({
  checks: [],
  typeName: v.ZodString,
  coerce: (t == null ? void 0 : t.coerce) ?? false,
  ..._2(t)
});
function fr(t, e) {
  const s = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, a = s > r ? s : r, n = Number.parseInt(t.toFixed(a).replace(".", "")), i = Number.parseInt(e.toFixed(a).replace(".", ""));
  return n % i / 10 ** a;
}
var me2 = class _me extends k2 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== h.number) {
      const n = this._getOrReturnCtx(e);
      return u2(n, {
        code: c.invalid_type,
        expected: h.number,
        received: n.parsedType
      }), y2;
    }
    let r;
    const a = new V2();
    for (const n of this._def.checks)
      n.kind === "int" ? b2.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.invalid_type,
        expected: "integer",
        received: "float",
        message: n.message
      }), a.dirty()) : n.kind === "min" ? (n.inclusive ? e.data < n.value : e.data <= n.value) && (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.too_small,
        minimum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: false,
        message: n.message
      }), a.dirty()) : n.kind === "max" ? (n.inclusive ? e.data > n.value : e.data >= n.value) && (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.too_big,
        maximum: n.value,
        type: "number",
        inclusive: n.inclusive,
        exact: false,
        message: n.message
      }), a.dirty()) : n.kind === "multipleOf" ? fr(e.data, n.value) !== 0 && (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), a.dirty()) : n.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.not_finite,
        message: n.message
      }), a.dirty()) : b2.assertNever(n);
    return { status: a.value, value: e.data };
  }
  gte(e, s) {
    return this.setLimit("min", e, true, m3.toString(s));
  }
  gt(e, s) {
    return this.setLimit("min", e, false, m3.toString(s));
  }
  lte(e, s) {
    return this.setLimit("max", e, true, m3.toString(s));
  }
  lt(e, s) {
    return this.setLimit("max", e, false, m3.toString(s));
  }
  setLimit(e, s, r, a) {
    return new _me({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: s,
          inclusive: r,
          message: m3.toString(a)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _me({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: m3.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: m3.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: m3.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: m3.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: m3.toString(e)
    });
  }
  multipleOf(e, s) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: m3.toString(s)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: m3.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: m3.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: m3.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "min" && (e === null || s.value > e) && (e = s.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "max" && (e === null || s.value < e) && (e = s.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && b2.isInteger(e.value));
  }
  get isFinite() {
    let e = null, s = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return true;
      r.kind === "min" ? (s === null || r.value > s) && (s = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    }
    return Number.isFinite(s) && Number.isFinite(e);
  }
};
me2.create = (t) => new me2({
  checks: [],
  typeName: v.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ..._2(t)
});
var pe2 = class _pe extends k2 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== h.bigint)
      return this._getInvalidInput(e);
    let r;
    const a = new V2();
    for (const n of this._def.checks)
      n.kind === "min" ? (n.inclusive ? e.data < n.value : e.data <= n.value) && (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.too_small,
        type: "bigint",
        minimum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), a.dirty()) : n.kind === "max" ? (n.inclusive ? e.data > n.value : e.data >= n.value) && (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.too_big,
        type: "bigint",
        maximum: n.value,
        inclusive: n.inclusive,
        message: n.message
      }), a.dirty()) : n.kind === "multipleOf" ? e.data % n.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), u2(r, {
        code: c.not_multiple_of,
        multipleOf: n.value,
        message: n.message
      }), a.dirty()) : b2.assertNever(n);
    return { status: a.value, value: e.data };
  }
  _getInvalidInput(e) {
    const s = this._getOrReturnCtx(e);
    return u2(s, {
      code: c.invalid_type,
      expected: h.bigint,
      received: s.parsedType
    }), y2;
  }
  gte(e, s) {
    return this.setLimit("min", e, true, m3.toString(s));
  }
  gt(e, s) {
    return this.setLimit("min", e, false, m3.toString(s));
  }
  lte(e, s) {
    return this.setLimit("max", e, true, m3.toString(s));
  }
  lt(e, s) {
    return this.setLimit("max", e, false, m3.toString(s));
  }
  setLimit(e, s, r, a) {
    return new _pe({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: s,
          inclusive: r,
          message: m3.toString(a)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _pe({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: m3.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: m3.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: m3.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: m3.toString(e)
    });
  }
  multipleOf(e, s) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: m3.toString(s)
    });
  }
  get minValue() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "min" && (e === null || s.value > e) && (e = s.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "max" && (e === null || s.value < e) && (e = s.value);
    return e;
  }
};
pe2.create = (t) => new pe2({
  checks: [],
  typeName: v.ZodBigInt,
  coerce: (t == null ? void 0 : t.coerce) ?? false,
  ..._2(t)
});
var lt = class extends k2 {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== h.boolean) {
      const r = this._getOrReturnCtx(e);
      return u2(r, {
        code: c.invalid_type,
        expected: h.boolean,
        received: r.parsedType
      }), y2;
    }
    return B2(e.data);
  }
};
lt.create = (t) => new lt({
  typeName: v.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ..._2(t)
});
var we = class _we extends k2 {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== h.date) {
      const n = this._getOrReturnCtx(e);
      return u2(n, {
        code: c.invalid_type,
        expected: h.date,
        received: n.parsedType
      }), y2;
    }
    if (Number.isNaN(e.data.getTime())) {
      const n = this._getOrReturnCtx(e);
      return u2(n, {
        code: c.invalid_date
      }), y2;
    }
    const r = new V2();
    let a;
    for (const n of this._def.checks)
      n.kind === "min" ? e.data.getTime() < n.value && (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.too_small,
        message: n.message,
        inclusive: true,
        exact: false,
        minimum: n.value,
        type: "date"
      }), r.dirty()) : n.kind === "max" ? e.data.getTime() > n.value && (a = this._getOrReturnCtx(e, a), u2(a, {
        code: c.too_big,
        message: n.message,
        inclusive: true,
        exact: false,
        maximum: n.value,
        type: "date"
      }), r.dirty()) : b2.assertNever(n);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new _we({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, s) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: m3.toString(s)
    });
  }
  max(e, s) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: m3.toString(s)
    });
  }
  get minDate() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "min" && (e === null || s.value > e) && (e = s.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const s of this._def.checks)
      s.kind === "max" && (e === null || s.value < e) && (e = s.value);
    return e != null ? new Date(e) : null;
  }
};
we.create = (t) => new we({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || false,
  typeName: v.ZodDate,
  ..._2(t)
});
var dt = class extends k2 {
  _parse(e) {
    if (this._getType(e) !== h.symbol) {
      const r = this._getOrReturnCtx(e);
      return u2(r, {
        code: c.invalid_type,
        expected: h.symbol,
        received: r.parsedType
      }), y2;
    }
    return B2(e.data);
  }
};
dt.create = (t) => new dt({
  typeName: v.ZodSymbol,
  ..._2(t)
});
var ct = class extends k2 {
  _parse(e) {
    if (this._getType(e) !== h.undefined) {
      const r = this._getOrReturnCtx(e);
      return u2(r, {
        code: c.invalid_type,
        expected: h.undefined,
        received: r.parsedType
      }), y2;
    }
    return B2(e.data);
  }
};
ct.create = (t) => new ct({
  typeName: v.ZodUndefined,
  ..._2(t)
});
var ut = class extends k2 {
  _parse(e) {
    if (this._getType(e) !== h.null) {
      const r = this._getOrReturnCtx(e);
      return u2(r, {
        code: c.invalid_type,
        expected: h.null,
        received: r.parsedType
      }), y2;
    }
    return B2(e.data);
  }
};
ut.create = (t) => new ut({
  typeName: v.ZodNull,
  ..._2(t)
});
var ft = class extends k2 {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e) {
    return B2(e.data);
  }
};
ft.create = (t) => new ft({
  typeName: v.ZodAny,
  ..._2(t)
});
var ht2 = class extends k2 {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e) {
    return B2(e.data);
  }
};
ht2.create = (t) => new ht2({
  typeName: v.ZodUnknown,
  ..._2(t)
});
var ee2 = class extends k2 {
  _parse(e) {
    const s = this._getOrReturnCtx(e);
    return u2(s, {
      code: c.invalid_type,
      expected: h.never,
      received: s.parsedType
    }), y2;
  }
};
ee2.create = (t) => new ee2({
  typeName: v.ZodNever,
  ..._2(t)
});
var mt = class extends k2 {
  _parse(e) {
    if (this._getType(e) !== h.undefined) {
      const r = this._getOrReturnCtx(e);
      return u2(r, {
        code: c.invalid_type,
        expected: h.void,
        received: r.parsedType
      }), y2;
    }
    return B2(e.data);
  }
};
mt.create = (t) => new mt({
  typeName: v.ZodVoid,
  ..._2(t)
});
var U = class _U extends k2 {
  _parse(e) {
    const { ctx: s, status: r } = this._processInputParams(e), a = this._def;
    if (s.parsedType !== h.array)
      return u2(s, {
        code: c.invalid_type,
        expected: h.array,
        received: s.parsedType
      }), y2;
    if (a.exactLength !== null) {
      const i = s.data.length > a.exactLength.value, o = s.data.length < a.exactLength.value;
      (i || o) && (u2(s, {
        code: i ? c.too_big : c.too_small,
        minimum: o ? a.exactLength.value : void 0,
        maximum: i ? a.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: a.exactLength.message
      }), r.dirty());
    }
    if (a.minLength !== null && s.data.length < a.minLength.value && (u2(s, {
      code: c.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: a.minLength.message
    }), r.dirty()), a.maxLength !== null && s.data.length > a.maxLength.value && (u2(s, {
      code: c.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: a.maxLength.message
    }), r.dirty()), s.common.async)
      return Promise.all([...s.data].map((i, o) => a.type._parseAsync(new K(s, i, s.path, o)))).then((i) => V2.mergeArray(r, i));
    const n = [...s.data].map((i, o) => a.type._parseSync(new K(s, i, s.path, o)));
    return V2.mergeArray(r, n);
  }
  get element() {
    return this._def.type;
  }
  min(e, s) {
    return new _U({
      ...this._def,
      minLength: { value: e, message: m3.toString(s) }
    });
  }
  max(e, s) {
    return new _U({
      ...this._def,
      maxLength: { value: e, message: m3.toString(s) }
    });
  }
  length(e, s) {
    return new _U({
      ...this._def,
      exactLength: { value: e, message: m3.toString(s) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
U.create = (t, e) => new U({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: v.ZodArray,
  ..._2(e)
});
function ie(t) {
  if (t instanceof S3) {
    const e = {};
    for (const s in t.shape) {
      const r = t.shape[s];
      e[s] = G.create(ie(r));
    }
    return new S3({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof U ? new U({
    ...t._def,
    type: ie(t.element)
  }) : t instanceof G ? G.create(ie(t.unwrap())) : t instanceof ue2 ? ue2.create(ie(t.unwrap())) : t instanceof ae3 ? ae3.create(t.items.map((e) => ie(e))) : t;
}
var S3 = class _S extends k2 {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), s = b2.objectKeys(e);
    return this._cached = { shape: e, keys: s }, this._cached;
  }
  _parse(e) {
    if (this._getType(e) !== h.object) {
      const d2 = this._getOrReturnCtx(e);
      return u2(d2, {
        code: c.invalid_type,
        expected: h.object,
        received: d2.parsedType
      }), y2;
    }
    const { status: r, ctx: a } = this._processInputParams(e), { shape: n, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof ee2 && this._def.unknownKeys === "strip"))
      for (const d2 in a.data)
        i.includes(d2) || o.push(d2);
    const l2 = [];
    for (const d2 of i) {
      const f = n[d2], E2 = a.data[d2];
      l2.push({
        key: { status: "valid", value: d2 },
        value: f._parse(new K(a, E2, a.path, d2)),
        alwaysSet: d2 in a.data
      });
    }
    if (this._def.catchall instanceof ee2) {
      const d2 = this._def.unknownKeys;
      if (d2 === "passthrough")
        for (const f of o)
          l2.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: a.data[f] }
          });
      else if (d2 === "strict")
        o.length > 0 && (u2(a, {
          code: c.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (d2 !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const d2 = this._def.catchall;
      for (const f of o) {
        const E2 = a.data[f];
        l2.push({
          key: { status: "valid", value: f },
          value: d2._parse(
            new K(a, E2, a.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const d2 = [];
      for (const f of l2) {
        const E2 = await f.key, Z = await f.value;
        d2.push({
          key: E2,
          value: Z,
          alwaysSet: f.alwaysSet
        });
      }
      return d2;
    }).then((d2) => V2.mergeObjectSync(r, d2)) : V2.mergeObjectSync(r, l2);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return m3.errToObj, new _S({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (s, r) => {
          var n, i;
          const a = ((i = (n = this._def).errorMap) == null ? void 0 : i.call(n, s, r).message) ?? r.defaultError;
          return s.code === "unrecognized_keys" ? {
            message: m3.errToObj(e).message ?? a
          } : {
            message: a
          };
        }
      } : {}
    });
  }
  strip() {
    return new _S({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _S({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new _S({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new _S({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: v.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, s) {
    return this.augment({ [e]: s });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new _S({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const s = {};
    for (const r of b2.objectKeys(e))
      e[r] && this.shape[r] && (s[r] = this.shape[r]);
    return new _S({
      ...this._def,
      shape: () => s
    });
  }
  omit(e) {
    const s = {};
    for (const r of b2.objectKeys(this.shape))
      e[r] || (s[r] = this.shape[r]);
    return new _S({
      ...this._def,
      shape: () => s
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ie(this);
  }
  partial(e) {
    const s = {};
    for (const r of b2.objectKeys(this.shape)) {
      const a = this.shape[r];
      e && !e[r] ? s[r] = a : s[r] = a.optional();
    }
    return new _S({
      ...this._def,
      shape: () => s
    });
  }
  required(e) {
    const s = {};
    for (const r of b2.objectKeys(this.shape))
      if (e && !e[r])
        s[r] = this.shape[r];
      else {
        let n = this.shape[r];
        for (; n instanceof G; )
          n = n._def.innerType;
        s[r] = n;
      }
    return new _S({
      ...this._def,
      shape: () => s
    });
  }
  keyof() {
    return Kt(b2.objectKeys(this.shape));
  }
};
S3.create = (t, e) => new S3({
  shape: () => t,
  unknownKeys: "strip",
  catchall: ee2.create(),
  typeName: v.ZodObject,
  ..._2(e)
});
S3.strictCreate = (t, e) => new S3({
  shape: () => t,
  unknownKeys: "strict",
  catchall: ee2.create(),
  typeName: v.ZodObject,
  ..._2(e)
});
S3.lazycreate = (t, e) => new S3({
  shape: t,
  unknownKeys: "strip",
  catchall: ee2.create(),
  typeName: v.ZodObject,
  ..._2(e)
});
var Te = class extends k2 {
  _parse(e) {
    const { ctx: s } = this._processInputParams(e), r = this._def.options;
    function a(n) {
      for (const o of n)
        if (o.result.status === "valid")
          return o.result;
      for (const o of n)
        if (o.result.status === "dirty")
          return s.common.issues.push(...o.ctx.common.issues), o.result;
      const i = n.map((o) => new q(o.ctx.common.issues));
      return u2(s, {
        code: c.invalid_union,
        unionErrors: i
      }), y2;
    }
    if (s.common.async)
      return Promise.all(r.map(async (n) => {
        const i = {
          ...s,
          common: {
            ...s.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await n._parseAsync({
            data: s.data,
            path: s.path,
            parent: i
          }),
          ctx: i
        };
      })).then(a);
    {
      let n;
      const i = [];
      for (const l2 of r) {
        const d2 = {
          ...s,
          common: {
            ...s.common,
            issues: []
          },
          parent: null
        }, f = l2._parseSync({
          data: s.data,
          path: s.path,
          parent: d2
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !n && (n = { result: f, ctx: d2 }), d2.common.issues.length && i.push(d2.common.issues);
      }
      if (n)
        return s.common.issues.push(...n.ctx.common.issues), n.result;
      const o = i.map((l2) => new q(l2));
      return u2(s, {
        code: c.invalid_union,
        unionErrors: o
      }), y2;
    }
  }
  get options() {
    return this._def.options;
  }
};
Te.create = (t, e) => new Te({
  options: t,
  typeName: v.ZodUnion,
  ..._2(e)
});
function De2(t, e) {
  const s = J3(t), r = J3(e);
  if (t === e)
    return { valid: true, data: t };
  if (s === h.object && r === h.object) {
    const a = b2.objectKeys(e), n = b2.objectKeys(t).filter((o) => a.indexOf(o) !== -1), i = { ...t, ...e };
    for (const o of n) {
      const l2 = De2(t[o], e[o]);
      if (!l2.valid)
        return { valid: false };
      i[o] = l2.data;
    }
    return { valid: true, data: i };
  } else if (s === h.array && r === h.array) {
    if (t.length !== e.length)
      return { valid: false };
    const a = [];
    for (let n = 0; n < t.length; n++) {
      const i = t[n], o = e[n], l2 = De2(i, o);
      if (!l2.valid)
        return { valid: false };
      a.push(l2.data);
    }
    return { valid: true, data: a };
  } else return s === h.date && r === h.date && +t == +e ? { valid: true, data: t } : { valid: false };
}
var Ce = class extends k2 {
  _parse(e) {
    const { status: s, ctx: r } = this._processInputParams(e), a = (n, i) => {
      if (nt(n) || nt(i))
        return y2;
      const o = De2(n.value, i.value);
      return o.valid ? ((it(n) || it(i)) && s.dirty(), { status: s.value, value: o.data }) : (u2(r, {
        code: c.invalid_intersection_types
      }), y2);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([n, i]) => a(n, i)) : a(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
Ce.create = (t, e, s) => new Ce({
  left: t,
  right: e,
  typeName: v.ZodIntersection,
  ..._2(s)
});
var ae3 = class _ae extends k2 {
  _parse(e) {
    const { status: s, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== h.array)
      return u2(r, {
        code: c.invalid_type,
        expected: h.array,
        received: r.parsedType
      }), y2;
    if (r.data.length < this._def.items.length)
      return u2(r, {
        code: c.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), y2;
    !this._def.rest && r.data.length > this._def.items.length && (u2(r, {
      code: c.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), s.dirty());
    const n = [...r.data].map((i, o) => {
      const l2 = this._def.items[o] || this._def.rest;
      return l2 ? l2._parse(new K(r, i, r.path, o)) : null;
    }).filter((i) => !!i);
    return r.common.async ? Promise.all(n).then((i) => V2.mergeArray(s, i)) : V2.mergeArray(s, n);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new _ae({
      ...this._def,
      rest: e
    });
  }
};
ae3.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ae3({
    items: t,
    typeName: v.ZodTuple,
    rest: null,
    ..._2(e)
  });
};
var pt2 = class extends k2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: s, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== h.map)
      return u2(r, {
        code: c.invalid_type,
        expected: h.map,
        received: r.parsedType
      }), y2;
    const a = this._def.keyType, n = this._def.valueType, i = [...r.data.entries()].map(([o, l2], d2) => ({
      key: a._parse(new K(r, o, r.path, [d2, "key"])),
      value: n._parse(new K(r, l2, r.path, [d2, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l2 of i) {
          const d2 = await l2.key, f = await l2.value;
          if (d2.status === "aborted" || f.status === "aborted")
            return y2;
          (d2.status === "dirty" || f.status === "dirty") && s.dirty(), o.set(d2.value, f.value);
        }
        return { status: s.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const l2 of i) {
        const d2 = l2.key, f = l2.value;
        if (d2.status === "aborted" || f.status === "aborted")
          return y2;
        (d2.status === "dirty" || f.status === "dirty") && s.dirty(), o.set(d2.value, f.value);
      }
      return { status: s.value, value: o };
    }
  }
};
pt2.create = (t, e, s) => new pt2({
  valueType: e,
  keyType: t,
  typeName: v.ZodMap,
  ..._2(s)
});
var ge2 = class _ge extends k2 {
  _parse(e) {
    const { status: s, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== h.set)
      return u2(r, {
        code: c.invalid_type,
        expected: h.set,
        received: r.parsedType
      }), y2;
    const a = this._def;
    a.minSize !== null && r.data.size < a.minSize.value && (u2(r, {
      code: c.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: a.minSize.message
    }), s.dirty()), a.maxSize !== null && r.data.size > a.maxSize.value && (u2(r, {
      code: c.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: a.maxSize.message
    }), s.dirty());
    const n = this._def.valueType;
    function i(l2) {
      const d2 = /* @__PURE__ */ new Set();
      for (const f of l2) {
        if (f.status === "aborted")
          return y2;
        f.status === "dirty" && s.dirty(), d2.add(f.value);
      }
      return { status: s.value, value: d2 };
    }
    const o = [...r.data.values()].map((l2, d2) => n._parse(new K(r, l2, r.path, d2)));
    return r.common.async ? Promise.all(o).then((l2) => i(l2)) : i(o);
  }
  min(e, s) {
    return new _ge({
      ...this._def,
      minSize: { value: e, message: m3.toString(s) }
    });
  }
  max(e, s) {
    return new _ge({
      ...this._def,
      maxSize: { value: e, message: m3.toString(s) }
    });
  }
  size(e, s) {
    return this.min(e, s).max(e, s);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
ge2.create = (t, e) => new ge2({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: v.ZodSet,
  ..._2(e)
});
var gt = class extends k2 {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: s } = this._processInputParams(e);
    return this._def.getter()._parse({ data: s.data, path: s.path, parent: s });
  }
};
gt.create = (t, e) => new gt({
  getter: t,
  typeName: v.ZodLazy,
  ..._2(e)
});
var yt = class extends k2 {
  _parse(e) {
    if (e.data !== this._def.value) {
      const s = this._getOrReturnCtx(e);
      return u2(s, {
        received: s.data,
        code: c.invalid_literal,
        expected: this._def.value
      }), y2;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
yt.create = (t, e) => new yt({
  value: t,
  typeName: v.ZodLiteral,
  ..._2(e)
});
function Kt(t, e) {
  return new de3({
    values: t,
    typeName: v.ZodEnum,
    ..._2(e)
  });
}
var de3 = class _de extends k2 {
  _parse(e) {
    if (typeof e.data != "string") {
      const s = this._getOrReturnCtx(e), r = this._def.values;
      return u2(s, {
        expected: b2.joinValues(r),
        received: s.parsedType,
        code: c.invalid_type
      }), y2;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e.data)) {
      const s = this._getOrReturnCtx(e), r = this._def.values;
      return u2(s, {
        received: s.data,
        code: c.invalid_enum_value,
        options: r
      }), y2;
    }
    return B2(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const s of this._def.values)
      e[s] = s;
    return e;
  }
  get Values() {
    const e = {};
    for (const s of this._def.values)
      e[s] = s;
    return e;
  }
  get Enum() {
    const e = {};
    for (const s of this._def.values)
      e[s] = s;
    return e;
  }
  extract(e, s = this._def) {
    return _de.create(e, {
      ...this._def,
      ...s
    });
  }
  exclude(e, s = this._def) {
    return _de.create(this.options.filter((r) => !e.includes(r)), {
      ...this._def,
      ...s
    });
  }
};
de3.create = Kt;
var vt = class extends k2 {
  _parse(e) {
    const s = b2.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== h.string && r.parsedType !== h.number) {
      const a = b2.objectValues(s);
      return u2(r, {
        expected: b2.joinValues(a),
        received: r.parsedType,
        code: c.invalid_type
      }), y2;
    }
    if (this._cache || (this._cache = new Set(b2.getValidEnumValues(this._def.values))), !this._cache.has(e.data)) {
      const a = b2.objectValues(s);
      return u2(r, {
        received: r.data,
        code: c.invalid_enum_value,
        options: a
      }), y2;
    }
    return B2(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
vt.create = (t, e) => new vt({
  values: t,
  typeName: v.ZodNativeEnum,
  ..._2(e)
});
var Ne = class extends k2 {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: s } = this._processInputParams(e);
    if (s.parsedType !== h.promise && s.common.async === false)
      return u2(s, {
        code: c.invalid_type,
        expected: h.promise,
        received: s.parsedType
      }), y2;
    const r = s.parsedType === h.promise ? s.data : Promise.resolve(s.data);
    return B2(r.then((a) => this._def.type.parseAsync(a, {
      path: s.path,
      errorMap: s.common.contextualErrorMap
    })));
  }
};
Ne.create = (t, e) => new Ne({
  type: t,
  typeName: v.ZodPromise,
  ..._2(e)
});
var ce3 = class extends k2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === v.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: s, ctx: r } = this._processInputParams(e), a = this._def.effect || null, n = {
      addIssue: (i) => {
        u2(r, i), i.fatal ? s.abort() : s.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (n.addIssue = n.addIssue.bind(n), a.type === "preprocess") {
      const i = a.transform(r.data, n);
      if (r.common.async)
        return Promise.resolve(i).then(async (o) => {
          if (s.value === "aborted")
            return y2;
          const l2 = await this._def.schema._parseAsync({
            data: o,
            path: r.path,
            parent: r
          });
          return l2.status === "aborted" ? y2 : l2.status === "dirty" || s.value === "dirty" ? fe2(l2.value) : l2;
        });
      {
        if (s.value === "aborted")
          return y2;
        const o = this._def.schema._parseSync({
          data: i,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? y2 : o.status === "dirty" || s.value === "dirty" ? fe2(o.value) : o;
      }
    }
    if (a.type === "refinement") {
      const i = (o) => {
        const l2 = a.refinement(o, n);
        if (r.common.async)
          return Promise.resolve(l2);
        if (l2 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === false) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? y2 : (o.status === "dirty" && s.dirty(), i(o.value), { status: s.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? y2 : (o.status === "dirty" && s.dirty(), i(o.value).then(() => ({ status: s.value, value: o.value }))));
    }
    if (a.type === "transform")
      if (r.common.async === false) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!le(i))
          return y2;
        const o = a.transform(i.value, n);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: s.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => le(i) ? Promise.resolve(a.transform(i.value, n)).then((o) => ({
          status: s.value,
          value: o
        })) : y2);
    b2.assertNever(a);
  }
};
ce3.create = (t, e, s) => new ce3({
  schema: t,
  typeName: v.ZodEffects,
  effect: e,
  ..._2(s)
});
ce3.createWithPreprocess = (t, e, s) => new ce3({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: v.ZodEffects,
  ..._2(s)
});
var G = class extends k2 {
  _parse(e) {
    return this._getType(e) === h.undefined ? B2(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
G.create = (t, e) => new G({
  innerType: t,
  typeName: v.ZodOptional,
  ..._2(e)
});
var ue2 = class extends k2 {
  _parse(e) {
    return this._getType(e) === h.null ? B2(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ue2.create = (t, e) => new ue2({
  innerType: t,
  typeName: v.ZodNullable,
  ..._2(e)
});
var Me = class extends k2 {
  _parse(e) {
    const { ctx: s } = this._processInputParams(e);
    let r = s.data;
    return s.parsedType === h.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: s.path,
      parent: s
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Me.create = (t, e) => new Me({
  innerType: t,
  typeName: v.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ..._2(e)
});
var ze2 = class extends k2 {
  _parse(e) {
    const { ctx: s } = this._processInputParams(e), r = {
      ...s,
      common: {
        ...s.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return be(a) ? a.then((n) => ({
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new q(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new q(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ze2.create = (t, e) => new ze2({
  innerType: t,
  typeName: v.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ..._2(e)
});
var _t = class extends k2 {
  _parse(e) {
    if (this._getType(e) !== h.nan) {
      const r = this._getOrReturnCtx(e);
      return u2(r, {
        code: c.invalid_type,
        expected: h.nan,
        received: r.parsedType
      }), y2;
    }
    return { status: "valid", value: e.data };
  }
};
_t.create = (t) => new _t({
  typeName: v.ZodNaN,
  ..._2(t)
});
var hr = class extends k2 {
  _parse(e) {
    const { ctx: s } = this._processInputParams(e), r = s.data;
    return this._def.type._parse({
      data: r,
      path: s.path,
      parent: s
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Ke = class _Ke extends k2 {
  _parse(e) {
    const { status: s, ctx: r } = this._processInputParams(e);
    if (r.common.async)
      return (async () => {
        const n = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return n.status === "aborted" ? y2 : n.status === "dirty" ? (s.dirty(), fe2(n.value)) : this._def.out._parseAsync({
          data: n.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return a.status === "aborted" ? y2 : a.status === "dirty" ? (s.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(e, s) {
    return new _Ke({
      in: e,
      out: s,
      typeName: v.ZodPipeline
    });
  }
};
var Ve = class extends k2 {
  _parse(e) {
    const s = this._def.innerType._parse(e), r = (a) => (le(a) && (a.value = Object.freeze(a.value)), a);
    return be(s) ? s.then((a) => r(a)) : r(s);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Ve.create = (t, e) => new Ve({
  innerType: t,
  typeName: v.ZodReadonly,
  ..._2(e)
});
var v;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(v || (v = {}));
var mr = Q.create;
ee2.create;
U.create;
var pr = S3.create;
Te.create;
Ce.create;
ae3.create;
de3.create;
Ne.create;
G.create;
ue2.create;
var gr = (t) => pr({
  password: mr().nonempty(t("required", { field: t("Password"), ns: "validation" }))
});
var la = ({
  title: t,
  description: e,
  children: s,
  onSubmit: r,
  ...a
}) => {
  const { t: n } = ne(), i = (0, import_react.useMemo)(() => gr(n), [n]), o = pt({
    resolver: Vs(i),
    defaultValues: {
      password: ""
    }
  });
  return ae.jsxs(qt, { ...a, children: [
    s && ae.jsx(Ht, { children: s }),
    ae.jsx(He2, { children: ae.jsx(aw, { ...o, children: ae.jsxs("form", { onSubmit: o.handleSubmit(r), className: "space-y-3", children: [
      ae.jsxs(Xe, { children: [
        ae.jsx(Je, { children: t || n("Confirm your password") }),
        ae.jsxs("div", { className: "text-secondary text-body-sm-medium space-y-3", children: [
          e || n("Enter your account password to complete this action"),
          ae.jsx(
            zo,
            {
              required: true,
              type: "password",
              control: o.control,
              name: "password",
              placeholder: n("Password")
            }
          )
        ] })
      ] }),
      ae.jsxs(Ye2, { children: [
        ae.jsx(Ge2, { type: "reset", onClick: () => o.reset(), children: n("Cancel") }),
        ae.jsx(Qe2, { type: "submit", children: n("Confirm") })
      ] })
    ] }) }) })
  ] });
};
function es(t) {
  var e, s, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var a = t.length;
    for (e = 0; e < a; e++) t[e] && (s = es(t[e])) && (r && (r += " "), r += s);
  } else for (s in t) t[s] && (r && (r += " "), r += s);
  return r;
}
function re2() {
  for (var t, e, s = 0, r = "", a = arguments.length; s < a; s++) (t = arguments[s]) && (e = es(t)) && (r && (r += " "), r += e);
  return r;
}
var ve2 = (t) => typeof t == "number" && !isNaN(t);
var ne3 = (t) => typeof t == "string";
var H2 = (t) => typeof t == "function";
var yr = (t) => ne3(t) || ve2(t);
var Be = (t) => ne3(t) || H2(t) ? t : null;
var vr = (t, e) => t === false || ve2(t) && t > 0 ? t : e;
var Fe = (t) => (0, import_react.isValidElement)(t) || ne3(t) || H2(t) || ve2(t);
function _r(t, e, s = 300) {
  let { scrollHeight: r, style: a } = t;
  requestAnimationFrame(() => {
    a.minHeight = "initial", a.height = r + "px", a.transition = `all ${s}ms`, requestAnimationFrame(() => {
      a.height = "0", a.padding = "0", a.margin = "0", setTimeout(e, s);
    });
  });
}
function xr({ enter: t, exit: e, appendPosition: s = false, collapse: r = true, collapseDuration: a = 300 }) {
  return function({ children: n, position: i, preventExitTransition: o, done: l2, nodeRef: d2, isIn: f, playToast: E2 }) {
    let Z = s ? `${t}--${i}` : t, L = s ? `${e}--${i}` : e, M2 = (0, import_react.useRef)(0);
    return (0, import_react.useLayoutEffect)(() => {
      let I2 = d2.current, C2 = Z.split(" "), T2 = (p) => {
        p.target === d2.current && (E2(), I2.removeEventListener("animationend", T2), I2.removeEventListener("animationcancel", T2), M2.current === 0 && p.type !== "animationcancel" && I2.classList.remove(...C2));
      };
      I2.classList.add(...C2), I2.addEventListener("animationend", T2), I2.addEventListener("animationcancel", T2);
    }, []), (0, import_react.useEffect)(() => {
      let I2 = d2.current, C2 = () => {
        I2.removeEventListener("animationend", C2), r ? _r(I2, l2, a) : l2();
      };
      f || (o ? C2() : (M2.current = 1, I2.className += ` ${L}`, I2.addEventListener("animationend", C2)));
    }, [f]), import_react.default.createElement(import_react.default.Fragment, null, n);
  };
}
function xt(t, e) {
  return { content: ts(t.content, t.props), containerId: t.props.containerId, id: t.props.toastId, theme: t.props.theme, type: t.props.type, data: t.props.data || {}, isLoading: t.props.isLoading, icon: t.props.icon, reason: t.removalReason, status: e };
}
function ts(t, e, s = false) {
  return (0, import_react.isValidElement)(t) && !ne3(t.type) ? (0, import_react.cloneElement)(t, { closeToast: e.closeToast, toastProps: e, data: e.data, isPaused: s }) : H2(t) ? t({ closeToast: e.closeToast, toastProps: e, data: e.data, isPaused: s }) : t;
}
function kr({ closeToast: t, theme: e, ariaLabel: s = "close" }) {
  return import_react.default.createElement("button", { className: `Toastify__close-button Toastify__close-button--${e}`, type: "button", onClick: (r) => {
    r.stopPropagation(), t(true);
  }, "aria-label": s }, import_react.default.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, import_react.default.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
}
function br({ delay: t, isRunning: e, closeToast: s, type: r = "default", hide: a, className: n, controlledProgress: i, progress: o, rtl: l2, isIn: d2, theme: f }) {
  let E2 = a || i && o === 0, Z = { animationDuration: `${t}ms`, animationPlayState: e ? "running" : "paused" };
  i && (Z.transform = `scaleX(${o})`);
  let L = re2("Toastify__progress-bar", i ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${f}`, `Toastify__progress-bar--${r}`, { "Toastify__progress-bar--rtl": l2 }), M2 = H2(n) ? n({ rtl: l2, type: r, defaultClassName: L }) : re2(L, n), I2 = { [i && o >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: i && o < 1 ? null : () => {
    d2 && s();
  } };
  return import_react.default.createElement("div", { className: "Toastify__progress-bar--wrp", "data-hidden": E2 }, import_react.default.createElement("div", { className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${f} Toastify__progress-bar--${r}` }), import_react.default.createElement("div", { role: "progressbar", "aria-hidden": E2 ? "true" : "false", "aria-label": "notification timer", className: M2, style: Z, ...I2 }));
}
var wr = 1;
var ss = () => `${wr++}`;
function Tr(t, e, s) {
  let r = 1, a = 0, n = [], i = [], o = e, l2 = /* @__PURE__ */ new Map(), d2 = /* @__PURE__ */ new Set(), f = (p) => (d2.add(p), () => d2.delete(p)), E2 = () => {
    i = Array.from(l2.values()), d2.forEach((p) => p());
  }, Z = ({ containerId: p, toastId: g, updateId: x }) => {
    let $2 = p ? p !== t : t !== 1, z = l2.has(g) && x == null;
    return $2 || z;
  }, L = (p, g) => {
    l2.forEach((x) => {
      var $2;
      (g == null || g === x.props.toastId) && (($2 = x.toggle) == null || $2.call(x, p));
    });
  }, M2 = (p) => {
    var g, x;
    (x = (g = p.props) == null ? void 0 : g.onClose) == null || x.call(g, p.removalReason), p.isActive = false;
  }, I2 = (p) => {
    if (p == null) l2.forEach(M2);
    else {
      let g = l2.get(p);
      g && M2(g);
    }
    E2();
  }, C2 = () => {
    a -= n.length, n = [];
  }, T2 = (p) => {
    var g, x;
    let { toastId: $2, updateId: z } = p.props, w2 = z == null;
    p.staleId && l2.delete(p.staleId), p.isActive = true, l2.set($2, p), E2(), s(xt(p, w2 ? "added" : "updated")), w2 && ((x = (g = p.props).onOpen) == null || x.call(g));
  };
  return { id: t, props: o, observe: f, toggle: L, removeToast: I2, toasts: l2, clearQueue: C2, buildToast: (p, g) => {
    if (Z(g)) return;
    let { toastId: x, updateId: $2, data: z, staleId: w2, delay: A2 } = g, F2 = $2 == null;
    F2 && a++;
    let Y2 = { ...o, style: o.toastStyle, key: r++, ...Object.fromEntries(Object.entries(g).filter(([se2, xe]) => xe != null)), toastId: x, updateId: $2, data: z, isIn: false, className: Be(g.className || o.toastClassName), progressClassName: Be(g.progressClassName || o.progressClassName), autoClose: g.isLoading ? false : vr(g.autoClose, o.autoClose), closeToast(se2) {
      l2.get(x).removalReason = se2, I2(x);
    }, deleteToast() {
      let se2 = l2.get(x);
      if (se2 != null) {
        if (s(xt(se2, "removed")), l2.delete(x), a--, a < 0 && (a = 0), n.length > 0) {
          T2(n.shift());
          return;
        }
        E2();
      }
    } };
    Y2.closeButton = o.closeButton, g.closeButton === false || Fe(g.closeButton) ? Y2.closeButton = g.closeButton : g.closeButton === true && (Y2.closeButton = Fe(o.closeButton) ? o.closeButton : true);
    let W2 = { content: p, props: Y2, staleId: w2 };
    o.limit && o.limit > 0 && a > o.limit && F2 ? n.push(W2) : ve2(A2) ? setTimeout(() => {
      T2(W2);
    }, A2) : T2(W2);
  }, setProps(p) {
    o = p;
  }, setToggle: (p, g) => {
    let x = l2.get(p);
    x && (x.toggle = g);
  }, isToastActive: (p) => {
    var g;
    return (g = l2.get(p)) == null ? void 0 : g.isActive;
  }, getSnapshot: () => i };
}
var D2 = /* @__PURE__ */ new Map();
var ye = [];
var Ue = /* @__PURE__ */ new Set();
var Cr = (t) => Ue.forEach((e) => e(t));
var rs = () => D2.size > 0;
function Nr() {
  ye.forEach((t) => ns(t.content, t.options)), ye = [];
}
var Er = (t, { containerId: e }) => {
  var s;
  return (s = D2.get(e || 1)) == null ? void 0 : s.toasts.get(t);
};
function as(t, e) {
  var s;
  if (e) return !!((s = D2.get(e)) != null && s.isToastActive(t));
  let r = false;
  return D2.forEach((a) => {
    a.isToastActive(t) && (r = true);
  }), r;
}
function Ar(t) {
  if (!rs()) {
    ye = ye.filter((e) => t != null && e.options.toastId !== t);
    return;
  }
  if (t == null || yr(t)) D2.forEach((e) => {
    e.removeToast(t);
  });
  else if (t && ("containerId" in t || "id" in t)) {
    let e = D2.get(t.containerId);
    e ? e.removeToast(t.id) : D2.forEach((s) => {
      s.removeToast(t.id);
    });
  }
}
var Ir = (t = {}) => {
  D2.forEach((e) => {
    e.props.limit && (!t.containerId || e.id === t.containerId) && e.clearQueue();
  });
};
function ns(t, e) {
  Fe(t) && (rs() || ye.push({ content: t, options: e }), D2.forEach((s) => {
    s.buildToast(t, e);
  }));
}
function jr(t) {
  var e;
  (e = D2.get(t.containerId || 1)) == null || e.setToggle(t.id, t.fn);
}
function is(t, e) {
  D2.forEach((s) => {
    (e == null || !(e != null && e.containerId) || (e == null ? void 0 : e.containerId) === s.id) && s.toggle(t, e == null ? void 0 : e.id);
  });
}
function Or(t) {
  let e = t.containerId || 1;
  return { subscribe(s) {
    let r = Tr(e, t, Cr);
    D2.set(e, r);
    let a = r.observe(s);
    return Nr(), () => {
      a(), D2.delete(e);
    };
  }, setProps(s) {
    var r;
    (r = D2.get(e)) == null || r.setProps(s);
  }, getSnapshot() {
    var s;
    return (s = D2.get(e)) == null ? void 0 : s.getSnapshot();
  } };
}
function Rr(t) {
  return Ue.add(t), () => {
    Ue.delete(t);
  };
}
function Sr(t) {
  return t && (ne3(t.toastId) || ve2(t.toastId)) ? t.toastId : ss();
}
function _e(t, e) {
  return ns(t, e), e.toastId;
}
function Ie(t, e) {
  return { ...e, type: e && e.type || t, toastId: Sr(e) };
}
function je(t) {
  return (e, s) => _e(e, Ie(t, s));
}
function N2(t, e) {
  return _e(t, Ie("default", e));
}
N2.loading = (t, e) => _e(t, Ie("default", { isLoading: true, autoClose: false, closeOnClick: false, closeButton: false, draggable: false, ...e }));
function $r(t, { pending: e, error: s, success: r }, a) {
  let n;
  e && (n = ne3(e) ? N2.loading(e, a) : N2.loading(e.render, { ...a, ...e }));
  let i = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, o = (d2, f, E2) => {
    if (f == null) {
      N2.dismiss(n);
      return;
    }
    let Z = { type: d2, ...i, ...a, data: E2 }, L = ne3(f) ? { render: f } : f;
    return n ? N2.update(n, { ...Z, ...L }) : N2(L.render, { ...Z, ...L }), E2;
  }, l2 = H2(t) ? t() : t;
  return l2.then((d2) => o("success", r, d2)).catch((d2) => o("error", s, d2)), l2;
}
N2.promise = $r;
N2.success = je("success");
N2.info = je("info");
N2.error = je("error");
N2.warning = je("warning");
N2.warn = N2.warning;
N2.dark = (t, e) => _e(t, Ie("default", { theme: "dark", ...e }));
function Zr(t) {
  Ar(t);
}
N2.dismiss = Zr;
N2.clearWaitingQueue = Ir;
N2.isActive = as;
N2.update = (t, e = {}) => {
  let s = Er(t, e);
  if (s) {
    let { props: r, content: a } = s, n = { delay: 100, ...r, ...e, toastId: e.toastId || t, updateId: ss() };
    n.toastId !== t && (n.staleId = t);
    let i = n.render || a;
    delete n.render, _e(i, n);
  }
};
N2.done = (t) => {
  N2.update(t, { progress: 1 });
};
N2.onChange = Rr;
N2.play = (t) => is(true, t);
N2.pause = (t) => is(false, t);
function Lr(t) {
  var e;
  let { subscribe: s, getSnapshot: r, setProps: a } = (0, import_react.useRef)(Or(t)).current;
  a(t);
  let n = (e = (0, import_react.useSyncExternalStore)(s, r, r)) == null ? void 0 : e.slice();
  function i(o) {
    if (!n) return [];
    let l2 = /* @__PURE__ */ new Map();
    return t.newestOnTop && n.reverse(), n.forEach((d2) => {
      let { position: f } = d2.props;
      l2.has(f) || l2.set(f, []), l2.get(f).push(d2);
    }), Array.from(l2, (d2) => o(d2[0], d2[1]));
  }
  return { getToastToRender: i, isToastActive: as, count: n == null ? void 0 : n.length };
}
function Pr(t) {
  let [e, s] = (0, import_react.useState)(false), [r, a] = (0, import_react.useState)(false), n = (0, import_react.useRef)(null), i = (0, import_react.useRef)({ start: 0, delta: 0, removalDistance: 0, canCloseOnClick: true, canDrag: false, didMove: false }).current, { autoClose: o, pauseOnHover: l2, closeToast: d2, onClick: f, closeOnClick: E2 } = t;
  jr({ id: t.toastId, containerId: t.containerId, fn: s }), (0, import_react.useEffect)(() => {
    if (t.pauseOnFocusLoss) return Z(), () => {
      L();
    };
  }, [t.pauseOnFocusLoss]);
  function Z() {
    document.hasFocus() || T2(), window.addEventListener("focus", C2), window.addEventListener("blur", T2);
  }
  function L() {
    window.removeEventListener("focus", C2), window.removeEventListener("blur", T2);
  }
  function M2(w2) {
    if (t.draggable === true || t.draggable === w2.pointerType) {
      p();
      let A2 = n.current;
      i.canCloseOnClick = true, i.canDrag = true, A2.style.transition = "none", t.draggableDirection === "x" ? (i.start = w2.clientX, i.removalDistance = A2.offsetWidth * (t.draggablePercent / 100)) : (i.start = w2.clientY, i.removalDistance = A2.offsetHeight * (t.draggablePercent === 80 ? t.draggablePercent * 1.5 : t.draggablePercent) / 100);
    }
  }
  function I2(w2) {
    let { top: A2, bottom: F2, left: Y2, right: W2 } = n.current.getBoundingClientRect();
    w2.nativeEvent.type !== "touchend" && t.pauseOnHover && w2.clientX >= Y2 && w2.clientX <= W2 && w2.clientY >= A2 && w2.clientY <= F2 ? T2() : C2();
  }
  function C2() {
    s(true);
  }
  function T2() {
    s(false);
  }
  function p() {
    i.didMove = false, document.addEventListener("pointermove", x), document.addEventListener("pointerup", $2);
  }
  function g() {
    document.removeEventListener("pointermove", x), document.removeEventListener("pointerup", $2);
  }
  function x(w2) {
    let A2 = n.current;
    if (i.canDrag && A2) {
      i.didMove = true, e && T2(), t.draggableDirection === "x" ? i.delta = w2.clientX - i.start : i.delta = w2.clientY - i.start, i.start !== w2.clientX && (i.canCloseOnClick = false);
      let F2 = t.draggableDirection === "x" ? `${i.delta}px, var(--y)` : `0, calc(${i.delta}px + var(--y))`;
      A2.style.transform = `translate3d(${F2},0)`, A2.style.opacity = `${1 - Math.abs(i.delta / i.removalDistance)}`;
    }
  }
  function $2() {
    g();
    let w2 = n.current;
    if (i.canDrag && i.didMove && w2) {
      if (i.canDrag = false, Math.abs(i.delta) > i.removalDistance) {
        a(true), t.closeToast(true), t.collapseAll();
        return;
      }
      w2.style.transition = "transform 0.2s, opacity 0.2s", w2.style.removeProperty("transform"), w2.style.removeProperty("opacity");
    }
  }
  let z = { onPointerDown: M2, onPointerUp: I2 };
  return o && l2 && (z.onMouseEnter = T2, t.stacked || (z.onMouseLeave = C2)), E2 && (z.onClick = (w2) => {
    f && f(w2), i.canCloseOnClick && d2(true);
  }), { playToast: C2, pauseToast: T2, isRunning: e, preventExitTransition: r, toastRef: n, eventHandlers: z };
}
var Dr = typeof window < "u" ? import_react.useLayoutEffect : import_react.useEffect;
var Oe2 = ({ theme: t, type: e, isLoading: s, ...r }) => import_react.default.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: t === "colored" ? "currentColor" : `var(--toastify-icon-color-${e})`, ...r });
function Mr(t) {
  return import_react.default.createElement(Oe2, { ...t }, import_react.default.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}
function zr(t) {
  return import_react.default.createElement(Oe2, { ...t }, import_react.default.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}
function Vr(t) {
  return import_react.default.createElement(Oe2, { ...t }, import_react.default.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}
function Br(t) {
  return import_react.default.createElement(Oe2, { ...t }, import_react.default.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}
function Fr() {
  return import_react.default.createElement("div", { className: "Toastify__spinner" });
}
var We = { info: zr, warning: Mr, success: Vr, error: Br, spinner: Fr };
var Ur = (t) => t in We;
function Wr({ theme: t, type: e, isLoading: s, icon: r }) {
  let a = null, n = { theme: t, type: e };
  return r === false || (H2(r) ? a = r({ ...n, isLoading: s }) : (0, import_react.isValidElement)(r) ? a = (0, import_react.cloneElement)(r, n) : s ? a = We.spinner() : Ur(e) && (a = We[e](n))), a;
}
var qr = (t) => {
  let { isRunning: e, preventExitTransition: s, toastRef: r, eventHandlers: a, playToast: n } = Pr(t), { closeButton: i, children: o, autoClose: l2, onClick: d2, type: f, hideProgressBar: E2, closeToast: Z, transition: L, position: M2, className: I2, style: C2, progressClassName: T2, updateId: p, role: g, progress: x, rtl: $2, toastId: z, deleteToast: w2, isIn: A2, isLoading: F2, closeOnClick: Y2, theme: W2, ariaLabel: se2 } = t, xe = re2("Toastify__toast", `Toastify__toast-theme--${W2}`, `Toastify__toast--${f}`, { "Toastify__toast--rtl": $2 }, { "Toastify__toast--close-on-click": Y2 }), os = H2(I2) ? I2({ rtl: $2, position: M2, type: f, defaultClassName: xe }) : re2(xe, I2), et = Wr(t), tt = !!x || !l2, Re = { closeToast: Z, type: f, theme: W2 }, ke2 = null;
  return i === false || (H2(i) ? ke2 = i(Re) : (0, import_react.isValidElement)(i) ? ke2 = (0, import_react.cloneElement)(i, Re) : ke2 = kr(Re)), import_react.default.createElement(L, { isIn: A2, done: w2, position: M2, preventExitTransition: s, nodeRef: r, playToast: n }, import_react.default.createElement("div", { id: z, tabIndex: 0, onClick: d2, "data-in": A2, className: os, ...a, style: C2, ref: r, ...A2 && { role: g, "aria-label": se2 } }, et != null && import_react.default.createElement("div", { className: re2("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !F2 }) }, et), ts(o, t, !e), ke2, !t.customProgressBar && import_react.default.createElement(br, { ...p && !tt ? { key: `p-${p}` } : {}, rtl: $2, theme: W2, delay: l2, isRunning: e, isIn: A2, closeToast: Z, hide: E2, type: f, className: T2, controlledProgress: tt, progress: x || 0 })));
};
var Hr = (t, e = false) => ({ enter: `Toastify--animate Toastify__${t}-enter`, exit: `Toastify--animate Toastify__${t}-exit`, appendPosition: e });
var Xr = xr(Hr("bounce", true));
var Yr = { position: "top-right", transition: Xr, autoClose: 5e3, closeButton: true, pauseOnHover: true, pauseOnFocusLoss: true, draggable: "touch", draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light", "aria-label": "Notifications Alt+T", hotKeys: (t) => t.altKey && t.code === "KeyT" };
function da(t) {
  let e = { ...Yr, ...t }, s = t.stacked, [r, a] = (0, import_react.useState)(true), n = (0, import_react.useRef)(null), { getToastToRender: i, isToastActive: o, count: l2 } = Lr(e), { className: d2, style: f, rtl: E2, containerId: Z, hotKeys: L } = e;
  function M2(C2) {
    let T2 = re2("Toastify__toast-container", `Toastify__toast-container--${C2}`, { "Toastify__toast-container--rtl": E2 });
    return H2(d2) ? d2({ position: C2, rtl: E2, defaultClassName: T2 }) : re2(T2, Be(d2));
  }
  function I2() {
    s && (a(true), N2.play());
  }
  return Dr(() => {
    var C2;
    if (s) {
      let T2 = n.current.querySelectorAll('[data-in="true"]'), p = 12, g = (C2 = e.position) == null ? void 0 : C2.includes("top"), x = 0, $2 = 0;
      Array.from(T2).reverse().forEach((z, w2) => {
        let A2 = z;
        A2.classList.add("Toastify__toast--stacked"), w2 > 0 && (A2.dataset.collapsed = `${r}`), A2.dataset.pos || (A2.dataset.pos = g ? "top" : "bot");
        let F2 = x * (r ? 0.2 : 1) + (r ? 0 : p * w2);
        A2.style.setProperty("--y", `${g ? F2 : F2 * -1}px`), A2.style.setProperty("--g", `${p}`), A2.style.setProperty("--s", `${1 - (r ? $2 : 0)}`), x += A2.offsetHeight, $2 += 0.025;
      });
    }
  }, [r, l2, s]), (0, import_react.useEffect)(() => {
    function C2(T2) {
      var p;
      let g = n.current;
      L(T2) && ((p = g.querySelector('[tabIndex="0"]')) == null || p.focus(), a(false), N2.pause()), T2.key === "Escape" && (document.activeElement === g || g != null && g.contains(document.activeElement)) && (a(true), N2.play());
    }
    return document.addEventListener("keydown", C2), () => {
      document.removeEventListener("keydown", C2);
    };
  }, [L]), import_react.default.createElement("section", { ref: n, className: "Toastify", id: Z, onMouseEnter: () => {
    s && (a(false), N2.pause());
  }, onMouseLeave: I2, "aria-live": "polite", "aria-atomic": "false", "aria-relevant": "additions text", "aria-label": e["aria-label"] }, i((C2, T2) => {
    let p = T2.length ? { ...f } : { ...f, pointerEvents: "none" };
    return import_react.default.createElement("div", { tabIndex: -1, className: M2(C2), "data-stacked": s, style: p, key: `c-${C2}` }, T2.map(({ content: g, props: x }) => import_react.default.createElement(qr, { ...x, stacked: s, collapseAll: I2, isIn: o(x.toastId, x.containerId), key: `t-${x.key}` }, g)));
  }));
}

export {
  oa,
  la,
  N2 as N,
  da
};
//# sourceMappingURL=chunk-WUQGQEHT.js.map
