import {
  H,
  He,
  J,
  Lt,
  Qe,
  S,
  Ze,
  ce,
  de,
  q
} from "./chunk-ADAJDLRA.js";
import {
  require_react
} from "./chunk-4373DSHM.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/dgz-ui-shared/dist/circle-COtEidYe-DaI8pjYh.js
var l = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var Q = l.createContext(void 0);
function W(e) {
  const r = l.useContext(Q);
  return e || r || "ltr";
}
function ee(e) {
  const r = e + "CollectionProvider", [i, n] = He(r), [S2, b] = i(
    r,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), v = (f) => {
    const { scope: t, children: a } = f, o = import_react.default.useRef(null), c = import_react.default.useRef(/* @__PURE__ */ new Map()).current;
    return S.jsx(S2, { scope: t, itemMap: c, collectionRef: o, children: a });
  };
  v.displayName = r;
  const h = e + "CollectionSlot", C = ce(h), m = import_react.default.forwardRef(
    (f, t) => {
      const { scope: a, children: o } = f, c = b(h, a), d = H(t, c.collectionRef);
      return S.jsx(C, { ref: d, children: o });
    }
  );
  m.displayName = h;
  const s = e + "CollectionItemSlot", y = "data-radix-collection-item", x = ce(s), R = import_react.default.forwardRef(
    (f, t) => {
      const { scope: a, children: o, ...c } = f, d = import_react.default.useRef(null), A = H(t, d), E = b(s, a);
      return import_react.default.useEffect(() => (E.itemMap.set(d, { ref: d, ...c }), () => void E.itemMap.delete(d))), S.jsx(x, { [y]: "", ref: A, children: o });
    }
  );
  R.displayName = s;
  function I(f) {
    const t = b(e + "CollectionConsumer", f);
    return import_react.default.useCallback(() => {
      const a = t.collectionRef.current;
      if (!a) return [];
      const o = Array.from(a.querySelectorAll(`[${y}]`));
      return Array.from(t.itemMap.values()).sort(
        (c, d) => o.indexOf(c.ref.current) - o.indexOf(d.ref.current)
      );
    }, [t.collectionRef, t.itemMap]);
  }
  return [
    { Provider: v, Slot: m, ItemSlot: R },
    I,
    n
  ];
}
var k = "rovingFocusGroup.onEntryFocus";
var te = { bubbles: false, cancelable: true };
var T = "RovingFocusGroup";
var [$, N, re] = ee(T);
var [oe, be] = He(
  T,
  [re]
);
var [ne, ce2] = oe(T);
var O = l.forwardRef(
  (e, r) => S.jsx($.Provider, { scope: e.__scopeRovingFocusGroup, children: S.jsx($.Slot, { scope: e.__scopeRovingFocusGroup, children: S.jsx(ae, { ...e, ref: r }) }) })
);
O.displayName = T;
var ae = l.forwardRef((e, r) => {
  const {
    __scopeRovingFocusGroup: i,
    orientation: n,
    loop: S2 = false,
    dir: b,
    currentTabStopId: v,
    defaultCurrentTabStopId: h,
    onCurrentTabStopIdChange: C,
    onEntryFocus: m,
    preventScrollOnEntryFocus: s = false,
    ...y
  } = e, x = l.useRef(null), R = H(r, x), I = W(b), [f, t] = Qe({
    prop: v,
    defaultProp: h ?? null,
    onChange: C,
    caller: T
  }), [a, o] = l.useState(false), c = q(m), d = N(i), A = l.useRef(false), [E, D] = l.useState(0);
  return l.useEffect(() => {
    const u = x.current;
    if (u)
      return u.addEventListener(k, c), () => u.removeEventListener(k, c);
  }, [c]), S.jsx(
    ne,
    {
      scope: i,
      orientation: n,
      dir: I,
      loop: S2,
      currentTabStopId: f,
      onItemFocus: l.useCallback(
        (u) => t(u),
        [t]
      ),
      onItemShiftTab: l.useCallback(() => o(true), []),
      onFocusableItemAdd: l.useCallback(
        () => D((u) => u + 1),
        []
      ),
      onFocusableItemRemove: l.useCallback(
        () => D((u) => u - 1),
        []
      ),
      children: S.jsx(
        de.div,
        {
          tabIndex: a || E === 0 ? -1 : 0,
          "data-orientation": n,
          ...y,
          ref: R,
          style: { outline: "none", ...e.style },
          onMouseDown: J(e.onMouseDown, () => {
            A.current = true;
          }),
          onFocus: J(e.onFocus, (u) => {
            const z = !A.current;
            if (u.target === u.currentTarget && z && !a) {
              const j = new CustomEvent(k, te);
              if (u.currentTarget.dispatchEvent(j), !j.defaultPrevented) {
                const M = d().filter((g) => g.focusable), H2 = M.find((g) => g.active), V = M.find((g) => g.id === f), X = [H2, V, ...M].filter(
                  Boolean
                ).map((g) => g.ref.current);
                q2(X, s);
              }
            }
            A.current = false;
          }),
          onBlur: J(e.onBlur, () => o(false))
        }
      )
    }
  );
});
var B = "RovingFocusGroupItem";
var U = l.forwardRef(
  (e, r) => {
    const {
      __scopeRovingFocusGroup: i,
      focusable: n = true,
      active: S2 = false,
      tabStopId: b,
      children: v,
      ...h
    } = e, C = Ze(), m = b || C, s = ce2(B, i), y = s.currentTabStopId === m, x = N(i), { onFocusableItemAdd: R, onFocusableItemRemove: I, currentTabStopId: f } = s;
    return l.useEffect(() => {
      if (n)
        return R(), () => I();
    }, [n, R, I]), S.jsx(
      $.ItemSlot,
      {
        scope: i,
        id: m,
        focusable: n,
        active: S2,
        children: S.jsx(
          de.span,
          {
            tabIndex: y ? 0 : -1,
            "data-orientation": s.orientation,
            ...h,
            ref: r,
            onMouseDown: J(e.onMouseDown, (t) => {
              n ? s.onItemFocus(m) : t.preventDefault();
            }),
            onFocus: J(e.onFocus, () => s.onItemFocus(m)),
            onKeyDown: J(e.onKeyDown, (t) => {
              if (t.key === "Tab" && t.shiftKey) {
                s.onItemShiftTab();
                return;
              }
              if (t.target !== t.currentTarget) return;
              const a = ie(t, s.orientation, s.dir);
              if (a !== void 0) {
                if (t.metaKey || t.ctrlKey || t.altKey || t.shiftKey) return;
                t.preventDefault();
                let o = x().filter((c) => c.focusable).map((c) => c.ref.current);
                if (a === "last") o.reverse();
                else if (a === "prev" || a === "next") {
                  a === "prev" && o.reverse();
                  const c = o.indexOf(t.currentTarget);
                  o = s.loop ? ue(o, c + 1) : o.slice(c + 1);
                }
                setTimeout(() => q2(o));
              }
            }),
            children: typeof v == "function" ? v({ isCurrentTabStop: y, hasTabStop: f != null }) : v
          }
        )
      }
    );
  }
);
U.displayName = B;
var se = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function le(e, r) {
  return r !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function ie(e, r, i) {
  const n = le(e.key, i);
  if (!(r === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(r === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return se[n];
}
function q2(e, r = false) {
  const i = document.activeElement;
  for (const n of e)
    if (n === i || (n.focus({ preventScroll: r }), document.activeElement !== i)) return;
}
function ue(e, r) {
  return e.map((i, n) => e[(r + n) % e.length]);
}
var he = O;
var ye = U;
var fe = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]];
var Re = Lt("check", fe);
var de2 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]];
var ge = Lt("circle", de2);

export {
  W,
  ee,
  be,
  he,
  ye,
  Re,
  ge
};
/*! Bundled license information:

dgz-ui-shared/dist/circle-COtEidYe-DaI8pjYh.js:
  (**
   * @license lucide-react v0.511.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-AHG2KM6N.js.map
