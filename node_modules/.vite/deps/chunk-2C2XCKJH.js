import {
  c
} from "./chunk-AIM6H4MF.js";
import {
  n as n2
} from "./chunk-X5RGD3A7.js";
import {
  n
} from "./chunk-374ZSSDZ.js";
import {
  R,
  y
} from "./chunk-PM2IHWHB.js";
import {
  j,
  w
} from "./chunk-HUVX2E5O.js";
import {
  h
} from "./chunk-MVM2C7P2.js";
import {
  x
} from "./chunk-7EER3O2F.js";
import {
  mo
} from "./chunk-R7QRGPF3.js";
import {
  ae
} from "./chunk-NMWROSO4.js";
import {
  require_react
} from "./chunk-4373DSHM.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/dgz-ui/dist/scroll-area-JqD01-EB.js
var s = __toESM(require_react(), 1);
function fe(e, o) {
  return s.useReducer((r, n3) => o[r][n3] ?? r, e);
}
var U = "ScrollArea";
var [q, ze] = j(U);
var [he, v] = q(U);
var G = s.forwardRef(
  (e, o) => {
    const {
      __scopeScrollArea: r,
      type: n3 = "hover",
      dir: t,
      scrollHideDelay: l = 600,
      ...c2
    } = e, [a, i] = s.useState(null), [f, d] = s.useState(null), [b, u] = s.useState(null), [m, p] = s.useState(null), [T, Y] = s.useState(null), [x2, _] = s.useState(0), [M, D] = s.useState(0), [j2, y2] = s.useState(false), [N, W] = s.useState(false), S = x(o, (R2) => i(R2)), w2 = n2(t);
    return ae.jsx(
      he,
      {
        scope: r,
        type: n3,
        dir: w2,
        scrollHideDelay: l,
        scrollArea: a,
        viewport: f,
        onViewportChange: d,
        content: b,
        onContentChange: u,
        scrollbarX: m,
        onScrollbarXChange: p,
        scrollbarXEnabled: j2,
        onScrollbarXEnabledChange: y2,
        scrollbarY: T,
        onScrollbarYChange: Y,
        scrollbarYEnabled: N,
        onScrollbarYEnabledChange: W,
        onCornerWidthChange: _,
        onCornerHeightChange: D,
        children: ae.jsx(
          h.div,
          {
            dir: w2,
            ...c2,
            ref: S,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": x2 + "px",
              "--radix-scroll-area-corner-height": M + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
G.displayName = U;
var J = "ScrollAreaViewport";
var K = s.forwardRef(
  (e, o) => {
    const { __scopeScrollArea: r, children: n3, nonce: t, ...l } = e, c2 = v(J, r), a = s.useRef(null), i = x(o, a, c2.onViewportChange);
    return ae.jsxs(ae.Fragment, { children: [
      ae.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: t
        }
      ),
      ae.jsx(
        h.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...l,
          ref: i,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: c2.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: c2.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: ae.jsx("div", { ref: c2.onContentChange, style: { minWidth: "100%", display: "table" }, children: n3 })
        }
      )
    ] });
  }
);
K.displayName = J;
var g = "ScrollAreaScrollbar";
var V = s.forwardRef(
  (e, o) => {
    const { forceMount: r, ...n3 } = e, t = v(g, e.__scopeScrollArea), { onScrollbarXEnabledChange: l, onScrollbarYEnabledChange: c2 } = t, a = e.orientation === "horizontal";
    return s.useEffect(() => (a ? l(true) : c2(true), () => {
      a ? l(false) : c2(false);
    }), [a, l, c2]), t.type === "hover" ? ae.jsx(be, { ...n3, ref: o, forceMount: r }) : t.type === "scroll" ? ae.jsx(me, { ...n3, ref: o, forceMount: r }) : t.type === "auto" ? ae.jsx(Q, { ...n3, ref: o, forceMount: r }) : t.type === "always" ? ae.jsx(B, { ...n3, ref: o }) : null;
  }
);
V.displayName = g;
var be = s.forwardRef((e, o) => {
  const { forceMount: r, ...n3 } = e, t = v(g, e.__scopeScrollArea), [l, c2] = s.useState(false);
  return s.useEffect(() => {
    const a = t.scrollArea;
    let i = 0;
    if (a) {
      const f = () => {
        window.clearTimeout(i), c2(true);
      }, d = () => {
        i = window.setTimeout(() => c2(false), t.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", f), a.addEventListener("pointerleave", d), () => {
        window.clearTimeout(i), a.removeEventListener("pointerenter", f), a.removeEventListener("pointerleave", d);
      };
    }
  }, [t.scrollArea, t.scrollHideDelay]), ae.jsx(R, { present: r || l, children: ae.jsx(
    Q,
    {
      "data-state": l ? "visible" : "hidden",
      ...n3,
      ref: o
    }
  ) });
});
var me = s.forwardRef((e, o) => {
  const { forceMount: r, ...n3 } = e, t = v(g, e.__scopeScrollArea), l = e.orientation === "horizontal", c2 = X(() => i("SCROLL_END"), 100), [a, i] = fe("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return s.useEffect(() => {
    if (a === "idle") {
      const f = window.setTimeout(() => i("HIDE"), t.scrollHideDelay);
      return () => window.clearTimeout(f);
    }
  }, [a, t.scrollHideDelay, i]), s.useEffect(() => {
    const f = t.viewport, d = l ? "scrollLeft" : "scrollTop";
    if (f) {
      let b = f[d];
      const u = () => {
        const m = f[d];
        b !== m && (i("SCROLL"), c2()), b = m;
      };
      return f.addEventListener("scroll", u), () => f.removeEventListener("scroll", u);
    }
  }, [t.viewport, l, i, c2]), ae.jsx(R, { present: r || a !== "hidden", children: ae.jsx(
    B,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...n3,
      ref: o,
      onPointerEnter: y(e.onPointerEnter, () => i("POINTER_ENTER")),
      onPointerLeave: y(e.onPointerLeave, () => i("POINTER_LEAVE"))
    }
  ) });
});
var Q = s.forwardRef((e, o) => {
  const r = v(g, e.__scopeScrollArea), { forceMount: n3, ...t } = e, [l, c2] = s.useState(false), a = e.orientation === "horizontal", i = X(() => {
    if (r.viewport) {
      const f = r.viewport.offsetWidth < r.viewport.scrollWidth, d = r.viewport.offsetHeight < r.viewport.scrollHeight;
      c2(a ? f : d);
    }
  }, 10);
  return E(r.viewport, i), E(r.content, i), ae.jsx(R, { present: n3 || l, children: ae.jsx(
    B,
    {
      "data-state": l ? "visible" : "hidden",
      ...t,
      ref: o
    }
  ) });
});
var B = s.forwardRef((e, o) => {
  const { orientation: r = "vertical", ...n3 } = e, t = v(g, e.__scopeScrollArea), l = s.useRef(null), c2 = s.useRef(0), [a, i] = s.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), f = te(a.viewport, a.content), d = {
    ...n3,
    sizes: a,
    onSizesChange: i,
    hasThumb: f > 0 && f < 1,
    onThumbChange: (u) => l.current = u,
    onThumbPointerUp: () => c2.current = 0,
    onThumbPointerDown: (u) => c2.current = u
  };
  function b(u, m) {
    return xe(u, c2.current, a, m);
  }
  return r === "horizontal" ? ae.jsx(
    Se,
    {
      ...d,
      ref: o,
      onThumbPositionChange: () => {
        if (t.viewport && l.current) {
          const u = t.viewport.scrollLeft, m = F(u, a, t.dir);
          l.current.style.transform = `translate3d(${m}px, 0, 0)`;
        }
      },
      onWheelScroll: (u) => {
        t.viewport && (t.viewport.scrollLeft = u);
      },
      onDragScroll: (u) => {
        t.viewport && (t.viewport.scrollLeft = b(u, t.dir));
      }
    }
  ) : r === "vertical" ? ae.jsx(
    pe,
    {
      ...d,
      ref: o,
      onThumbPositionChange: () => {
        if (t.viewport && l.current) {
          const u = t.viewport.scrollTop, m = F(u, a);
          l.current.style.transform = `translate3d(0, ${m}px, 0)`;
        }
      },
      onWheelScroll: (u) => {
        t.viewport && (t.viewport.scrollTop = u);
      },
      onDragScroll: (u) => {
        t.viewport && (t.viewport.scrollTop = b(u));
      }
    }
  ) : null;
});
var Se = s.forwardRef((e, o) => {
  const { sizes: r, onSizesChange: n3, ...t } = e, l = v(g, e.__scopeScrollArea), [c2, a] = s.useState(), i = s.useRef(null), f = x(o, i, l.onScrollbarXChange);
  return s.useEffect(() => {
    i.current && a(getComputedStyle(i.current));
  }, [i]), ae.jsx(
    ee,
    {
      "data-orientation": "horizontal",
      ...t,
      ref: f,
      sizes: r,
      style: {
        bottom: 0,
        left: l.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: l.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": I(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (d) => e.onThumbPointerDown(d.x),
      onDragScroll: (d) => e.onDragScroll(d.x),
      onWheelScroll: (d, b) => {
        if (l.viewport) {
          const u = l.viewport.scrollLeft + d.deltaX;
          e.onWheelScroll(u), le(u, b) && d.preventDefault();
        }
      },
      onResize: () => {
        i.current && l.viewport && c2 && n3({
          content: l.viewport.scrollWidth,
          viewport: l.viewport.offsetWidth,
          scrollbar: {
            size: i.current.clientWidth,
            paddingStart: z(c2.paddingLeft),
            paddingEnd: z(c2.paddingRight)
          }
        });
      }
    }
  );
});
var pe = s.forwardRef((e, o) => {
  const { sizes: r, onSizesChange: n3, ...t } = e, l = v(g, e.__scopeScrollArea), [c2, a] = s.useState(), i = s.useRef(null), f = x(o, i, l.onScrollbarYChange);
  return s.useEffect(() => {
    i.current && a(getComputedStyle(i.current));
  }, [i]), ae.jsx(
    ee,
    {
      "data-orientation": "vertical",
      ...t,
      ref: f,
      sizes: r,
      style: {
        top: 0,
        right: l.dir === "ltr" ? 0 : void 0,
        left: l.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": I(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (d) => e.onThumbPointerDown(d.y),
      onDragScroll: (d) => e.onDragScroll(d.y),
      onWheelScroll: (d, b) => {
        if (l.viewport) {
          const u = l.viewport.scrollTop + d.deltaY;
          e.onWheelScroll(u), le(u, b) && d.preventDefault();
        }
      },
      onResize: () => {
        i.current && l.viewport && c2 && n3({
          content: l.viewport.scrollHeight,
          viewport: l.viewport.offsetHeight,
          scrollbar: {
            size: i.current.clientHeight,
            paddingStart: z(c2.paddingTop),
            paddingEnd: z(c2.paddingBottom)
          }
        });
      }
    }
  );
});
var [ve, Z] = q(g);
var ee = s.forwardRef((e, o) => {
  const {
    __scopeScrollArea: r,
    sizes: n3,
    hasThumb: t,
    onThumbChange: l,
    onThumbPointerUp: c2,
    onThumbPointerDown: a,
    onThumbPositionChange: i,
    onDragScroll: f,
    onWheelScroll: d,
    onResize: b,
    ...u
  } = e, m = v(g, r), [p, T] = s.useState(null), Y = x(o, (S) => T(S)), x2 = s.useRef(null), _ = s.useRef(""), M = m.viewport, D = n3.content - n3.viewport, j2 = n(d), y2 = n(i), N = X(b, 10);
  function W(S) {
    if (x2.current) {
      const w2 = S.clientX - x2.current.left, R2 = S.clientY - x2.current.top;
      f({ x: w2, y: R2 });
    }
  }
  return s.useEffect(() => {
    const S = (w2) => {
      const R2 = w2.target;
      (p == null ? void 0 : p.contains(R2)) && j2(w2, D);
    };
    return document.addEventListener("wheel", S, { passive: false }), () => document.removeEventListener("wheel", S, { passive: false });
  }, [M, p, D, j2]), s.useEffect(y2, [n3, y2]), E(p, N), E(m.content, N), ae.jsx(
    ve,
    {
      scope: r,
      scrollbar: p,
      hasThumb: t,
      onThumbChange: n(l),
      onThumbPointerUp: n(c2),
      onThumbPositionChange: y2,
      onThumbPointerDown: n(a),
      children: ae.jsx(
        h.div,
        {
          ...u,
          ref: Y,
          style: { position: "absolute", ...u.style },
          onPointerDown: y(e.onPointerDown, (S) => {
            S.button === 0 && (S.target.setPointerCapture(S.pointerId), x2.current = p.getBoundingClientRect(), _.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", m.viewport && (m.viewport.style.scrollBehavior = "auto"), W(S));
          }),
          onPointerMove: y(e.onPointerMove, W),
          onPointerUp: y(e.onPointerUp, (S) => {
            const w2 = S.target;
            w2.hasPointerCapture(S.pointerId) && w2.releasePointerCapture(S.pointerId), document.body.style.webkitUserSelect = _.current, m.viewport && (m.viewport.style.scrollBehavior = ""), x2.current = null;
          })
        }
      )
    }
  );
});
var H = "ScrollAreaThumb";
var re = s.forwardRef(
  (e, o) => {
    const { forceMount: r, ...n3 } = e, t = Z(H, e.__scopeScrollArea);
    return ae.jsx(R, { present: r || t.hasThumb, children: ae.jsx(we, { ref: o, ...n3 }) });
  }
);
var we = s.forwardRef(
  (e, o) => {
    const { __scopeScrollArea: r, style: n3, ...t } = e, l = v(H, r), c2 = Z(H, r), { onThumbPositionChange: a } = c2, i = x(
      o,
      (b) => c2.onThumbChange(b)
    ), f = s.useRef(void 0), d = X(() => {
      f.current && (f.current(), f.current = void 0);
    }, 100);
    return s.useEffect(() => {
      const b = l.viewport;
      if (b) {
        const u = () => {
          if (d(), !f.current) {
            const m = Pe(b, a);
            f.current = m, a();
          }
        };
        return a(), b.addEventListener("scroll", u), () => b.removeEventListener("scroll", u);
      }
    }, [l.viewport, d, a]), ae.jsx(
      h.div,
      {
        "data-state": c2.hasThumb ? "visible" : "hidden",
        ...t,
        ref: i,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n3
        },
        onPointerDownCapture: y(e.onPointerDownCapture, (b) => {
          const m = b.target.getBoundingClientRect(), p = b.clientX - m.left, T = b.clientY - m.top;
          c2.onThumbPointerDown({ x: p, y: T });
        }),
        onPointerUp: y(e.onPointerUp, c2.onThumbPointerUp)
      }
    );
  }
);
re.displayName = H;
var k = "ScrollAreaCorner";
var oe = s.forwardRef(
  (e, o) => {
    const r = v(k, e.__scopeScrollArea), n3 = !!(r.scrollbarX && r.scrollbarY);
    return r.type !== "scroll" && n3 ? ae.jsx(ge, { ...e, ref: o }) : null;
  }
);
oe.displayName = k;
var ge = s.forwardRef((e, o) => {
  const { __scopeScrollArea: r, ...n3 } = e, t = v(k, r), [l, c2] = s.useState(0), [a, i] = s.useState(0), f = !!(l && a);
  return E(t.scrollbarX, () => {
    var b;
    const d = ((b = t.scrollbarX) == null ? void 0 : b.offsetHeight) || 0;
    t.onCornerHeightChange(d), i(d);
  }), E(t.scrollbarY, () => {
    var b;
    const d = ((b = t.scrollbarY) == null ? void 0 : b.offsetWidth) || 0;
    t.onCornerWidthChange(d), c2(d);
  }), f ? ae.jsx(
    h.div,
    {
      ...n3,
      ref: o,
      style: {
        width: l,
        height: a,
        position: "absolute",
        right: t.dir === "ltr" ? 0 : void 0,
        left: t.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function z(e) {
  return e ? parseInt(e, 10) : 0;
}
function te(e, o) {
  const r = e / o;
  return isNaN(r) ? 0 : r;
}
function I(e) {
  const o = te(e.viewport, e.content), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, n3 = (e.scrollbar.size - r) * o;
  return Math.max(n3, 18);
}
function xe(e, o, r, n3 = "ltr") {
  const t = I(r), l = t / 2, c2 = o || l, a = t - c2, i = r.scrollbar.paddingStart + c2, f = r.scrollbar.size - r.scrollbar.paddingEnd - a, d = r.content - r.viewport, b = n3 === "ltr" ? [0, d] : [d * -1, 0];
  return ne([i, f], b)(e);
}
function F(e, o, r = "ltr") {
  const n3 = I(o), t = o.scrollbar.paddingStart + o.scrollbar.paddingEnd, l = o.scrollbar.size - t, c2 = o.content - o.viewport, a = l - n3, i = r === "ltr" ? [0, c2] : [c2 * -1, 0], f = c(e, i);
  return ne([0, c2], [0, a])(f);
}
function ne(e, o) {
  return (r) => {
    if (e[0] === e[1] || o[0] === o[1]) return o[0];
    const n3 = (o[1] - o[0]) / (e[1] - e[0]);
    return o[0] + n3 * (r - e[0]);
  };
}
function le(e, o) {
  return e > 0 && e < o;
}
var Pe = (e, o = () => {
}) => {
  let r = { left: e.scrollLeft, top: e.scrollTop }, n3 = 0;
  return function t() {
    const l = { left: e.scrollLeft, top: e.scrollTop }, c2 = r.left !== l.left, a = r.top !== l.top;
    (c2 || a) && o(), r = l, n3 = window.requestAnimationFrame(t);
  }(), () => window.cancelAnimationFrame(n3);
};
function X(e, o) {
  const r = n(e), n3 = s.useRef(0);
  return s.useEffect(() => () => window.clearTimeout(n3.current), []), s.useCallback(() => {
    window.clearTimeout(n3.current), n3.current = window.setTimeout(r, o);
  }, [r, o]);
}
function E(e, o) {
  const r = n(o);
  w(() => {
    let n3 = 0;
    if (e) {
      const t = new ResizeObserver(() => {
        cancelAnimationFrame(n3), n3 = window.requestAnimationFrame(r);
      });
      return t.observe(e), () => {
        window.cancelAnimationFrame(n3), t.unobserve(e);
      };
    }
  }, [e, r]);
}
var se = G;
var Ce = K;
var Re = oe;
var Ee = s.forwardRef(({ className: e, children: o, ...r }, n3) => ae.jsxs(
  se,
  {
    ref: n3,
    className: mo("relative overflow-auto", e),
    ...r,
    children: [
      ae.jsx(Ce, { className: "h-full w-full rounded-[inherit]", children: o }),
      ae.jsx(ce, {}),
      ae.jsx(Re, {})
    ]
  }
));
Ee.displayName = se.displayName;
var ce = s.forwardRef(({ className: e, orientation: o = "vertical", ...r }, n3) => ae.jsx(
  V,
  {
    ref: n3,
    orientation: o,
    className: mo(
      "flex touch-none transition-colors select-none",
      o === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      o === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      e
    ),
    ...r,
    children: ae.jsx(re, { className: "bg-border relative flex-1 rounded-full" })
  }
));
ce.displayName = V.displayName;

export {
  Ee,
  ce
};
//# sourceMappingURL=chunk-2C2XCKJH.js.map
