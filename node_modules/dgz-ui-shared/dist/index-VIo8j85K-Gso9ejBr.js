import * as R from "react";
import { useLayoutEffect as Lt } from "react";
import * as Ct from "react-dom";
import { j as Et, a as X, x as qe, h as Pe, n as Ot, e as be } from "./index-DqTIeHVj-CeLMF2B2.js";
const Dt = ["top", "right", "bottom", "left"], Z = Math.min, M = Math.max, ue = Math.round, ce = Math.floor, _ = (e) => ({
  x: e,
  y: e
}), kt = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Ht = {
  start: "end",
  end: "start"
};
function Re(e, t, n) {
  return M(e, Z(t, n));
}
function q(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function U(e) {
  return e.split("-")[0];
}
function te(e) {
  return e.split("-")[1];
}
function Te(e) {
  return e === "x" ? "y" : "x";
}
function Le(e) {
  return e === "y" ? "height" : "width";
}
const Ft = /* @__PURE__ */ new Set(["top", "bottom"]);
function V(e) {
  return Ft.has(U(e)) ? "y" : "x";
}
function Ce(e) {
  return Te(V(e));
}
function Wt(e, t, n) {
  n === void 0 && (n = !1);
  const r = te(e), o = Ce(e), i = Le(o);
  let l = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (l = de(l)), [l, de(l)];
}
function Mt(e) {
  const t = de(e);
  return [Ae(e), t, Ae(t)];
}
function Ae(e) {
  return e.replace(/start|end/g, (t) => Ht[t]);
}
const je = ["left", "right"], ze = ["right", "left"], jt = ["top", "bottom"], zt = ["bottom", "top"];
function Bt(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? ze : je : t ? je : ze;
    case "left":
    case "right":
      return t ? jt : zt;
    default:
      return [];
  }
}
function Nt(e, t, n, r) {
  const o = te(e);
  let i = Bt(U(e), n === "start", r);
  return o && (i = i.map((l) => l + "-" + o), t && (i = i.concat(i.map(Ae)))), i;
}
function de(e) {
  return e.replace(/left|right|bottom|top/g, (t) => kt[t]);
}
function $t(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Ue(e) {
  return typeof e != "number" ? $t(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function pe(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function Be(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = V(t), l = Ce(t), s = Le(l), a = U(t), u = i === "y", c = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, h = r[s] / 2 - o[s] / 2;
  let f;
  switch (a) {
    case "top":
      f = {
        x: c,
        y: r.y - o.height
      };
      break;
    case "bottom":
      f = {
        x: c,
        y: r.y + r.height
      };
      break;
    case "right":
      f = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      f = {
        x: r.x,
        y: r.y
      };
  }
  switch (te(t)) {
    case "start":
      f[l] -= h * (n && u ? -1 : 1);
      break;
    case "end":
      f[l] += h * (n && u ? -1 : 1);
      break;
  }
  return f;
}
const Vt = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: l
  } = n, s = i.filter(Boolean), a = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let u = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: c,
    y: d
  } = Be(u, r, a), h = r, f = {}, p = 0;
  for (let m = 0; m < s.length; m++) {
    const {
      name: g,
      fn: y
    } = s[m], {
      x: w,
      y: x,
      data: v,
      reset: b
    } = await y({
      x: c,
      y: d,
      initialPlacement: r,
      placement: h,
      strategy: o,
      middlewareData: f,
      rects: u,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = w ?? c, d = x ?? d, f = {
      ...f,
      [g]: {
        ...f[g],
        ...v
      }
    }, b && p <= 50 && (p++, typeof b == "object" && (b.placement && (h = b.placement), b.rects && (u = b.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : b.rects), {
      x: c,
      y: d
    } = Be(u, h, a)), m = -1);
  }
  return {
    x: c,
    y: d,
    placement: h,
    strategy: o,
    middlewareData: f
  };
};
async function oe(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: l,
    elements: s,
    strategy: a
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: d = "floating",
    altBoundary: h = !1,
    padding: f = 0
  } = q(t, e), p = Ue(f), m = s[h ? d === "floating" ? "reference" : "floating" : d], g = pe(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(m))) == null || n ? m : m.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(s.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: a
  })), y = d === "floating" ? {
    x: r,
    y: o,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(s.floating)), x = await (i.isElement == null ? void 0 : i.isElement(w)) ? await (i.getScale == null ? void 0 : i.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, v = pe(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: y,
    offsetParent: w,
    strategy: a
  }) : y);
  return {
    top: (g.top - v.top + p.top) / x.y,
    bottom: (v.bottom - g.bottom + p.bottom) / x.y,
    left: (g.left - v.left + p.left) / x.x,
    right: (v.right - g.right + p.right) / x.x
  };
}
const _t = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: l,
      elements: s,
      middlewareData: a
    } = t, {
      element: u,
      padding: c = 0
    } = q(e, t) || {};
    if (u == null)
      return {};
    const d = Ue(c), h = {
      x: n,
      y: r
    }, f = Ce(o), p = Le(f), m = await l.getDimensions(u), g = f === "y", y = g ? "top" : "left", w = g ? "bottom" : "right", x = g ? "clientHeight" : "clientWidth", v = i.reference[p] + i.reference[f] - h[f] - i.floating[p], b = h[f] - i.reference[f], S = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(u));
    let P = S ? S[x] : 0;
    (!P || !await (l.isElement == null ? void 0 : l.isElement(S))) && (P = s.floating[x] || i.floating[p]);
    const k = v / 2 - b / 2, F = P / 2 - m[p] / 2 - 1, L = Z(d[y], F), W = Z(d[w], F), O = L, H = P - m[p] - W, T = P / 2 - m[p] / 2 + k, z = Re(O, T, H), C = !a.arrow && te(o) != null && T !== z && i.reference[p] / 2 - (T < O ? L : W) - m[p] / 2 < 0, E = C ? T < O ? T - O : T - H : 0;
    return {
      [f]: h[f] + E,
      data: {
        [f]: z,
        centerOffset: T - z - E,
        ...C && {
          alignmentOffset: E
        }
      },
      reset: C
    };
  }
}), Yt = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: l,
        initialPlacement: s,
        platform: a,
        elements: u
      } = t, {
        mainAxis: c = !0,
        crossAxis: d = !0,
        fallbackPlacements: h,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = q(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const y = U(o), w = V(s), x = U(s) === s, v = await (a.isRTL == null ? void 0 : a.isRTL(u.floating)), b = h || (x || !m ? [de(s)] : Mt(s)), S = p !== "none";
      !h && S && b.push(...Nt(s, m, p, v));
      const P = [s, ...b], k = await oe(t, g), F = [];
      let L = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (c && F.push(k[y]), d) {
        const T = Wt(o, l, v);
        F.push(k[T[0]], k[T[1]]);
      }
      if (L = [...L, {
        placement: o,
        overflows: F
      }], !F.every((T) => T <= 0)) {
        var W, O;
        const T = (((W = i.flip) == null ? void 0 : W.index) || 0) + 1, z = P[T];
        if (z && (!(d === "alignment" && w !== V(z)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        L.every((E) => E.overflows[0] > 0 && V(E.placement) === w)))
          return {
            data: {
              index: T,
              overflows: L
            },
            reset: {
              placement: z
            }
          };
        let C = (O = L.filter((E) => E.overflows[0] <= 0).sort((E, A) => E.overflows[1] - A.overflows[1])[0]) == null ? void 0 : O.placement;
        if (!C)
          switch (f) {
            case "bestFit": {
              var H;
              const E = (H = L.filter((A) => {
                if (S) {
                  const D = V(A.placement);
                  return D === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  D === "y";
                }
                return !0;
              }).map((A) => [A.placement, A.overflows.filter((D) => D > 0).reduce((D, $) => D + $, 0)]).sort((A, D) => A[1] - D[1])[0]) == null ? void 0 : H[0];
              E && (C = E);
              break;
            }
            case "initialPlacement":
              C = s;
              break;
          }
        if (o !== C)
          return {
            reset: {
              placement: C
            }
          };
      }
      return {};
    }
  };
};
function Ne(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function $e(e) {
  return Dt.some((t) => e[t] >= 0);
}
const It = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = q(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await oe(t, {
            ...o,
            elementContext: "reference"
          }), l = Ne(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: $e(l)
            }
          };
        }
        case "escaped": {
          const i = await oe(t, {
            ...o,
            altBoundary: !0
          }), l = Ne(i, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: $e(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, Ze = /* @__PURE__ */ new Set(["left", "top"]);
async function Xt(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), l = U(n), s = te(n), a = V(n) === "y", u = Ze.has(l) ? -1 : 1, c = i && a ? -1 : 1, d = q(t, e);
  let {
    mainAxis: h,
    crossAxis: f,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return s && typeof p == "number" && (f = s === "end" ? p * -1 : p), a ? {
    x: f * c,
    y: h * u
  } : {
    x: h * u,
    y: f * c
  };
}
const qt = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: l,
        middlewareData: s
      } = t, a = await Xt(t, e);
      return l === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: o + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: l
        }
      };
    }
  };
}, Ut = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: l = !1,
        limiter: s = {
          fn: (g) => {
            let {
              x: y,
              y: w
            } = g;
            return {
              x: y,
              y: w
            };
          }
        },
        ...a
      } = q(e, t), u = {
        x: n,
        y: r
      }, c = await oe(t, a), d = V(U(o)), h = Te(d);
      let f = u[h], p = u[d];
      if (i) {
        const g = h === "y" ? "top" : "left", y = h === "y" ? "bottom" : "right", w = f + c[g], x = f - c[y];
        f = Re(w, f, x);
      }
      if (l) {
        const g = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", w = p + c[g], x = p - c[y];
        p = Re(w, p, x);
      }
      const m = s.fn({
        ...t,
        [h]: f,
        [d]: p
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r,
          enabled: {
            [h]: i,
            [d]: l
          }
        }
      };
    }
  };
}, Zt = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        middlewareData: l
      } = t, {
        offset: s = 0,
        mainAxis: a = !0,
        crossAxis: u = !0
      } = q(e, t), c = {
        x: n,
        y: r
      }, d = V(o), h = Te(d);
      let f = c[h], p = c[d];
      const m = q(s, t), g = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (a) {
        const x = h === "y" ? "height" : "width", v = i.reference[h] - i.floating[x] + g.mainAxis, b = i.reference[h] + i.reference[x] - g.mainAxis;
        f < v ? f = v : f > b && (f = b);
      }
      if (u) {
        var y, w;
        const x = h === "y" ? "width" : "height", v = Ze.has(U(o)), b = i.reference[d] - i.floating[x] + (v && ((y = l.offset) == null ? void 0 : y[d]) || 0) + (v ? 0 : g.crossAxis), S = i.reference[d] + i.reference[x] + (v ? 0 : ((w = l.offset) == null ? void 0 : w[d]) || 0) - (v ? g.crossAxis : 0);
        p < b ? p = b : p > S && (p = S);
      }
      return {
        [h]: f,
        [d]: p
      };
    }
  };
}, Gt = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        rects: i,
        platform: l,
        elements: s
      } = t, {
        apply: a = () => {
        },
        ...u
      } = q(e, t), c = await oe(t, u), d = U(o), h = te(o), f = V(o) === "y", {
        width: p,
        height: m
      } = i.floating;
      let g, y;
      d === "top" || d === "bottom" ? (g = d, y = h === (await (l.isRTL == null ? void 0 : l.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (y = d, g = h === "end" ? "top" : "bottom");
      const w = m - c.top - c.bottom, x = p - c.left - c.right, v = Z(m - c[g], w), b = Z(p - c[y], x), S = !t.middlewareData.shift;
      let P = v, k = b;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (k = x), (r = t.middlewareData.shift) != null && r.enabled.y && (P = w), S && !h) {
        const L = M(c.left, 0), W = M(c.right, 0), O = M(c.top, 0), H = M(c.bottom, 0);
        f ? k = p - 2 * (L !== 0 || W !== 0 ? L + W : M(c.left, c.right)) : P = m - 2 * (O !== 0 || H !== 0 ? O + H : M(c.top, c.bottom));
      }
      await a({
        ...t,
        availableWidth: k,
        availableHeight: P
      });
      const F = await l.getDimensions(s.floating);
      return p !== F.width || m !== F.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function me() {
  return typeof window < "u";
}
function ne(e) {
  return Ge(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function j(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function I(e) {
  var t;
  return (t = (Ge(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Ge(e) {
  return me() ? e instanceof Node || e instanceof j(e).Node : !1;
}
function B(e) {
  return me() ? e instanceof Element || e instanceof j(e).Element : !1;
}
function Y(e) {
  return me() ? e instanceof HTMLElement || e instanceof j(e).HTMLElement : !1;
}
function Ve(e) {
  return !me() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof j(e).ShadowRoot;
}
const Jt = /* @__PURE__ */ new Set(["inline", "contents"]);
function le(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = N(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !Jt.has(o);
}
const Kt = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Qt(e) {
  return Kt.has(ne(e));
}
const en = [":popover-open", ":modal"];
function ge(e) {
  return en.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const tn = ["transform", "translate", "scale", "rotate", "perspective"], nn = ["transform", "translate", "scale", "rotate", "perspective", "filter"], rn = ["paint", "layout", "strict", "content"];
function Ee(e) {
  const t = Oe(), n = B(e) ? N(e) : e;
  return tn.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || nn.some((r) => (n.willChange || "").includes(r)) || rn.some((r) => (n.contain || "").includes(r));
}
function on(e) {
  let t = G(e);
  for (; Y(t) && !ee(t); ) {
    if (Ee(t))
      return t;
    if (ge(t))
      return null;
    t = G(t);
  }
  return null;
}
function Oe() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const ln = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function ee(e) {
  return ln.has(ne(e));
}
function N(e) {
  return j(e).getComputedStyle(e);
}
function ye(e) {
  return B(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function G(e) {
  if (ne(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Ve(e) && e.host || // Fallback.
    I(e)
  );
  return Ve(t) ? t.host : t;
}
function Je(e) {
  const t = G(e);
  return ee(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Y(t) && le(t) ? t : Je(t);
}
function ie(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = Je(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), l = j(o);
  if (i) {
    const s = Se(l);
    return t.concat(l, l.visualViewport || [], le(o) ? o : [], s && n ? ie(s) : []);
  }
  return t.concat(o, ie(o, [], n));
}
function Se(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Ke(e) {
  const t = N(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = Y(e), i = o ? e.offsetWidth : n, l = o ? e.offsetHeight : r, s = ue(n) !== i || ue(r) !== l;
  return s && (n = i, r = l), {
    width: n,
    height: r,
    $: s
  };
}
function De(e) {
  return B(e) ? e : e.contextElement;
}
function Q(e) {
  const t = De(e);
  if (!Y(t))
    return _(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = Ke(t);
  let l = (i ? ue(n.width) : n.width) / r, s = (i ? ue(n.height) : n.height) / o;
  return (!l || !Number.isFinite(l)) && (l = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: l,
    y: s
  };
}
const sn = /* @__PURE__ */ _(0);
function Qe(e) {
  const t = j(e);
  return !Oe() || !t.visualViewport ? sn : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function an(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== j(e) ? !1 : t;
}
function J(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = De(e);
  let l = _(1);
  t && (r ? B(r) && (l = Q(r)) : l = Q(e));
  const s = an(i, n, r) ? Qe(i) : _(0);
  let a = (o.left + s.x) / l.x, u = (o.top + s.y) / l.y, c = o.width / l.x, d = o.height / l.y;
  if (i) {
    const h = j(i), f = r && B(r) ? j(r) : r;
    let p = h, m = Se(p);
    for (; m && r && f !== p; ) {
      const g = Q(m), y = m.getBoundingClientRect(), w = N(m), x = y.left + (m.clientLeft + parseFloat(w.paddingLeft)) * g.x, v = y.top + (m.clientTop + parseFloat(w.paddingTop)) * g.y;
      a *= g.x, u *= g.y, c *= g.x, d *= g.y, a += x, u += v, p = j(m), m = Se(p);
    }
  }
  return pe({
    width: c,
    height: d,
    x: a,
    y: u
  });
}
function ke(e, t) {
  const n = ye(e).scrollLeft;
  return t ? t.left + n : J(I(e)).left + n;
}
function et(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    ke(e, r)
  )), i = r.top + t.scrollTop;
  return {
    x: o,
    y: i
  };
}
function cn(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const i = o === "fixed", l = I(r), s = t ? ge(t.floating) : !1;
  if (r === l || s && i)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = _(1);
  const c = _(0), d = Y(r);
  if ((d || !d && !i) && ((ne(r) !== "body" || le(l)) && (a = ye(r)), Y(r))) {
    const f = J(r);
    u = Q(r), c.x = f.x + r.clientLeft, c.y = f.y + r.clientTop;
  }
  const h = l && !d && !i ? et(l, a, !0) : _(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - a.scrollLeft * u.x + c.x + h.x,
    y: n.y * u.y - a.scrollTop * u.y + c.y + h.y
  };
}
function fn(e) {
  return Array.from(e.getClientRects());
}
function un(e) {
  const t = I(e), n = ye(e), r = e.ownerDocument.body, o = M(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = M(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + ke(e);
  const s = -n.scrollTop;
  return N(r).direction === "rtl" && (l += M(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: l,
    y: s
  };
}
function dn(e, t) {
  const n = j(e), r = I(e), o = n.visualViewport;
  let i = r.clientWidth, l = r.clientHeight, s = 0, a = 0;
  if (o) {
    i = o.width, l = o.height;
    const u = Oe();
    (!u || u && t === "fixed") && (s = o.offsetLeft, a = o.offsetTop);
  }
  return {
    width: i,
    height: l,
    x: s,
    y: a
  };
}
const pn = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function hn(e, t) {
  const n = J(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = Y(e) ? Q(e) : _(1), l = e.clientWidth * i.x, s = e.clientHeight * i.y, a = o * i.x, u = r * i.y;
  return {
    width: l,
    height: s,
    x: a,
    y: u
  };
}
function _e(e, t, n) {
  let r;
  if (t === "viewport")
    r = dn(e, n);
  else if (t === "document")
    r = un(I(e));
  else if (B(t))
    r = hn(t, n);
  else {
    const o = Qe(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return pe(r);
}
function tt(e, t) {
  const n = G(e);
  return n === t || !B(n) || ee(n) ? !1 : N(n).position === "fixed" || tt(n, t);
}
function mn(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = ie(e, [], !1).filter((s) => B(s) && ne(s) !== "body"), o = null;
  const i = N(e).position === "fixed";
  let l = i ? G(e) : e;
  for (; B(l) && !ee(l); ) {
    const s = N(l), a = Ee(l);
    !a && s.position === "fixed" && (o = null), (i ? !a && !o : !a && s.position === "static" && o && pn.has(o.position) || le(l) && !a && tt(e, l)) ? r = r.filter((u) => u !== l) : o = s, l = G(l);
  }
  return t.set(e, r), r;
}
function gn(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const i = [...n === "clippingAncestors" ? ge(t) ? [] : mn(t, this._c) : [].concat(n), r], l = i[0], s = i.reduce((a, u) => {
    const c = _e(t, u, o);
    return a.top = M(c.top, a.top), a.right = Z(c.right, a.right), a.bottom = Z(c.bottom, a.bottom), a.left = M(c.left, a.left), a;
  }, _e(t, l, o));
  return {
    width: s.right - s.left,
    height: s.bottom - s.top,
    x: s.left,
    y: s.top
  };
}
function yn(e) {
  const {
    width: t,
    height: n
  } = Ke(e);
  return {
    width: t,
    height: n
  };
}
function wn(e, t, n) {
  const r = Y(t), o = I(t), i = n === "fixed", l = J(e, !0, i, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = _(0);
  function u() {
    a.x = ke(o);
  }
  if (r || !r && !i)
    if ((ne(t) !== "body" || le(o)) && (s = ye(t)), r) {
      const f = J(t, !0, i, t);
      a.x = f.x + t.clientLeft, a.y = f.y + t.clientTop;
    } else o && u();
  i && !r && o && u();
  const c = o && !r && !i ? et(o, s) : _(0), d = l.left + s.scrollLeft - a.x - c.x, h = l.top + s.scrollTop - a.y - c.y;
  return {
    x: d,
    y: h,
    width: l.width,
    height: l.height
  };
}
function xe(e) {
  return N(e).position === "static";
}
function Ye(e, t) {
  if (!Y(e) || N(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return I(e) === n && (n = n.ownerDocument.body), n;
}
function nt(e, t) {
  const n = j(e);
  if (ge(e))
    return n;
  if (!Y(e)) {
    let o = G(e);
    for (; o && !ee(o); ) {
      if (B(o) && !xe(o))
        return o;
      o = G(o);
    }
    return n;
  }
  let r = Ye(e, t);
  for (; r && Qt(r) && xe(r); )
    r = Ye(r, t);
  return r && ee(r) && xe(r) && !Ee(r) ? n : r || on(e) || n;
}
const xn = async function(e) {
  const t = this.getOffsetParent || nt, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: wn(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function vn(e) {
  return N(e).direction === "rtl";
}
const bn = {
  convertOffsetParentRelativeRectToViewportRelativeRect: cn,
  getDocumentElement: I,
  getClippingRect: gn,
  getOffsetParent: nt,
  getElementRects: xn,
  getClientRects: fn,
  getDimensions: yn,
  getScale: Q,
  isElement: B,
  isRTL: vn
};
function rt(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Rn(e, t) {
  let n = null, r;
  const o = I(e);
  function i() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function l(s, a) {
    s === void 0 && (s = !1), a === void 0 && (a = 1), i();
    const u = e.getBoundingClientRect(), {
      left: c,
      top: d,
      width: h,
      height: f
    } = u;
    if (s || t(), !h || !f)
      return;
    const p = ce(d), m = ce(o.clientWidth - (c + h)), g = ce(o.clientHeight - (d + f)), y = ce(c), w = {
      rootMargin: -p + "px " + -m + "px " + -g + "px " + -y + "px",
      threshold: M(0, Z(1, a)) || 1
    };
    let x = !0;
    function v(b) {
      const S = b[0].intersectionRatio;
      if (S !== a) {
        if (!x)
          return l();
        S ? l(!1, S) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      S === 1 && !rt(u, e.getBoundingClientRect()) && l(), x = !1;
    }
    try {
      n = new IntersectionObserver(v, {
        ...w,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(v, w);
    }
    n.observe(e);
  }
  return l(!0), i;
}
function An(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, u = De(e), c = o || i ? [...u ? ie(u) : [], ...ie(t)] : [];
  c.forEach((y) => {
    o && y.addEventListener("scroll", n, {
      passive: !0
    }), i && y.addEventListener("resize", n);
  });
  const d = u && s ? Rn(u, n) : null;
  let h = -1, f = null;
  l && (f = new ResizeObserver((y) => {
    let [w] = y;
    w && w.target === u && f && (f.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var x;
      (x = f) == null || x.observe(t);
    })), n();
  }), u && !a && f.observe(u), f.observe(t));
  let p, m = a ? J(e) : null;
  a && g();
  function g() {
    const y = J(e);
    m && !rt(m, y) && n(), m = y, p = requestAnimationFrame(g);
  }
  return n(), () => {
    var y;
    c.forEach((w) => {
      o && w.removeEventListener("scroll", n), i && w.removeEventListener("resize", n);
    }), d == null || d(), (y = f) == null || y.disconnect(), f = null, a && cancelAnimationFrame(p);
  };
}
const Sn = qt, Pn = Ut, Tn = Yt, Ln = Gt, Cn = It, Ie = _t, En = Zt, On = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: bn,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return Vt(e, t, {
    ...o,
    platform: i
  });
};
var Dn = typeof document < "u", kn = function() {
}, fe = Dn ? Lt : kn;
function he(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!he(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && e.$$typeof) && !he(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function ot(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Xe(e, t) {
  const n = ot(e);
  return Math.round(t * n) / n;
}
function ve(e) {
  const t = R.useRef(e);
  return fe(() => {
    t.current = e;
  }), t;
}
function Hn(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: i,
      floating: l
    } = {},
    transform: s = !0,
    whileElementsMounted: a,
    open: u
  } = e, [c, d] = R.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [h, f] = R.useState(r);
  he(h, r) || f(r);
  const [p, m] = R.useState(null), [g, y] = R.useState(null), w = R.useCallback((A) => {
    A !== S.current && (S.current = A, m(A));
  }, []), x = R.useCallback((A) => {
    A !== P.current && (P.current = A, y(A));
  }, []), v = i || p, b = l || g, S = R.useRef(null), P = R.useRef(null), k = R.useRef(c), F = a != null, L = ve(a), W = ve(o), O = ve(u), H = R.useCallback(() => {
    if (!S.current || !P.current)
      return;
    const A = {
      placement: t,
      strategy: n,
      middleware: h
    };
    W.current && (A.platform = W.current), On(S.current, P.current, A).then((D) => {
      const $ = {
        ...D,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: O.current !== !1
      };
      T.current && !he(k.current, $) && (k.current = $, Ct.flushSync(() => {
        d($);
      }));
    });
  }, [h, t, n, W, O]);
  fe(() => {
    u === !1 && k.current.isPositioned && (k.current.isPositioned = !1, d((A) => ({
      ...A,
      isPositioned: !1
    })));
  }, [u]);
  const T = R.useRef(!1);
  fe(() => (T.current = !0, () => {
    T.current = !1;
  }), []), fe(() => {
    if (v && (S.current = v), b && (P.current = b), v && b) {
      if (L.current)
        return L.current(v, b, H);
      H();
    }
  }, [v, b, H, L, F]);
  const z = R.useMemo(() => ({
    reference: S,
    floating: P,
    setReference: w,
    setFloating: x
  }), [w, x]), C = R.useMemo(() => ({
    reference: v,
    floating: b
  }), [v, b]), E = R.useMemo(() => {
    const A = {
      position: n,
      left: 0,
      top: 0
    };
    if (!C.floating)
      return A;
    const D = Xe(C.floating, c.x), $ = Xe(C.floating, c.y);
    return s ? {
      ...A,
      transform: "translate(" + D + "px, " + $ + "px)",
      ...ot(C.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: D,
      top: $
    };
  }, [n, s, C.floating, c.x, c.y]);
  return R.useMemo(() => ({
    ...c,
    update: H,
    refs: z,
    elements: C,
    floatingStyles: E
  }), [c, H, z, C, E]);
}
const Fn = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? Ie({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? Ie({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, Wn = (e, t) => ({
  ...Sn(e),
  options: [e, t]
}), Mn = (e, t) => ({
  ...Pn(e),
  options: [e, t]
}), jn = (e, t) => ({
  ...En(e),
  options: [e, t]
}), zn = (e, t) => ({
  ...Tn(e),
  options: [e, t]
}), Bn = (e, t) => ({
  ...Ln(e),
  options: [e, t]
}), Nn = (e, t) => ({
  ...Cn(e),
  options: [e, t]
}), $n = (e, t) => ({
  ...Fn(e),
  options: [e, t]
});
var Vn = "Arrow", it = R.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...i } = e;
  return /* @__PURE__ */ X.jsx(
    Pe.svg,
    {
      ...i,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ X.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
it.displayName = Vn;
var _n = it;
function Yn(e) {
  const [t, n] = R.useState(void 0);
  return be(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const i = o[0];
        let l, s;
        if ("borderBoxSize" in i) {
          const a = i.borderBoxSize, u = Array.isArray(a) ? a[0] : a;
          l = u.inlineSize, s = u.blockSize;
        } else
          l = e.offsetWidth, s = e.offsetHeight;
        n({ width: l, height: s });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var He = "Popper", [lt, Qn] = Et(He), [In, st] = lt(He), at = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = R.useState(null);
  return /* @__PURE__ */ X.jsx(In, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
at.displayName = He;
var ct = "PopperAnchor", ft = R.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, i = st(ct, n), l = R.useRef(null), s = qe(t, l);
    return R.useEffect(() => {
      i.onAnchorChange((r == null ? void 0 : r.current) || l.current);
    }), r ? null : /* @__PURE__ */ X.jsx(Pe.div, { ...o, ref: s });
  }
);
ft.displayName = ct;
var Fe = "PopperContent", [Xn, qn] = lt(Fe), ut = R.forwardRef(
  (e, t) => {
    var n, r, o, i, l, s;
    const {
      __scopePopper: a,
      side: u = "bottom",
      sideOffset: c = 0,
      align: d = "center",
      alignOffset: h = 0,
      arrowPadding: f = 0,
      avoidCollisions: p = !0,
      collisionBoundary: m = [],
      collisionPadding: g = 0,
      sticky: y = "partial",
      hideWhenDetached: w = !1,
      updatePositionStrategy: x = "optimized",
      onPlaced: v,
      ...b
    } = e, S = st(Fe, a), [P, k] = R.useState(null), F = qe(t, (re) => k(re)), [L, W] = R.useState(null), O = Yn(L), H = (O == null ? void 0 : O.width) ?? 0, T = (O == null ? void 0 : O.height) ?? 0, z = u + (d !== "center" ? "-" + d : ""), C = typeof g == "number" ? g : { top: 0, right: 0, bottom: 0, left: 0, ...g }, E = Array.isArray(m) ? m : [m], A = E.length > 0, D = {
      padding: C,
      boundary: E.filter(Zn),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: A
    }, { refs: $, floatingStyles: We, placement: mt, isPositioned: se, middlewareData: K } = Hn({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: z,
      whileElementsMounted: (...re) => An(...re, {
        animationFrame: x === "always"
      }),
      elements: {
        reference: S.anchor
      },
      middleware: [
        Wn({ mainAxis: c + T, alignmentAxis: h }),
        p && Mn({
          mainAxis: !0,
          crossAxis: !1,
          limiter: y === "partial" ? jn() : void 0,
          ...D
        }),
        p && zn({ ...D }),
        Bn({
          ...D,
          apply: ({ elements: re, rects: Rt, availableWidth: At, availableHeight: St }) => {
            const { width: Pt, height: Tt } = Rt.reference, ae = re.floating.style;
            ae.setProperty("--radix-popper-available-width", `${At}px`), ae.setProperty("--radix-popper-available-height", `${St}px`), ae.setProperty("--radix-popper-anchor-width", `${Pt}px`), ae.setProperty("--radix-popper-anchor-height", `${Tt}px`);
          }
        }),
        L && $n({ element: L, padding: f }),
        Gn({ arrowWidth: H, arrowHeight: T }),
        w && Nn({ strategy: "referenceHidden", ...D })
      ]
    }), [Me, gt] = ht(mt), we = Ot(v);
    be(() => {
      se && (we == null || we());
    }, [se, we]);
    const yt = (n = K.arrow) == null ? void 0 : n.x, wt = (r = K.arrow) == null ? void 0 : r.y, xt = ((o = K.arrow) == null ? void 0 : o.centerOffset) !== 0, [vt, bt] = R.useState();
    return be(() => {
      P && bt(window.getComputedStyle(P).zIndex);
    }, [P]), /* @__PURE__ */ X.jsx(
      "div",
      {
        ref: $.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...We,
          transform: se ? We.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: vt,
          "--radix-popper-transform-origin": [
            (i = K.transformOrigin) == null ? void 0 : i.x,
            (l = K.transformOrigin) == null ? void 0 : l.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((s = K.hide) == null ? void 0 : s.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ X.jsx(
          Xn,
          {
            scope: a,
            placedSide: Me,
            onArrowChange: W,
            arrowX: yt,
            arrowY: wt,
            shouldHideArrow: xt,
            children: /* @__PURE__ */ X.jsx(
              Pe.div,
              {
                "data-side": Me,
                "data-align": gt,
                ...b,
                ref: F,
                style: {
                  ...b.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: se ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
ut.displayName = Fe;
var dt = "PopperArrow", Un = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, pt = R.forwardRef(function(e, t) {
  const { __scopePopper: n, ...r } = e, o = qn(dt, n), i = Un[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ X.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [i]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ X.jsx(
          _n,
          {
            ...r,
            ref: t,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
pt.displayName = dt;
function Zn(e) {
  return e !== null;
}
var Gn = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var n, r, o;
    const { placement: i, rects: l, middlewareData: s } = t, a = ((n = s.arrow) == null ? void 0 : n.centerOffset) !== 0, u = a ? 0 : e.arrowWidth, c = a ? 0 : e.arrowHeight, [d, h] = ht(i), f = { start: "0%", center: "50%", end: "100%" }[h], p = (((r = s.arrow) == null ? void 0 : r.x) ?? 0) + u / 2, m = (((o = s.arrow) == null ? void 0 : o.y) ?? 0) + c / 2;
    let g = "", y = "";
    return d === "bottom" ? (g = a ? f : `${p}px`, y = `${-c}px`) : d === "top" ? (g = a ? f : `${p}px`, y = `${l.floating.height + c}px`) : d === "right" ? (g = `${-c}px`, y = a ? f : `${m}px`) : d === "left" && (g = `${l.floating.width + c}px`, y = a ? f : `${m}px`), { data: { x: g, y } };
  }
});
function ht(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var er = at, tr = ft, nr = ut, rr = pt;
export {
  Yn as I,
  An as R,
  rr as c,
  er as i,
  Qn as o,
  tr as r,
  nr as s
};
