import * as u from "react";
import be from "react";
import * as ge from "react-dom";
var X = { exports: {} }, x = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var re;
function he() {
  if (re) return x;
  re = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function s(n, o, i) {
    var a = null;
    if (i !== void 0 && (a = "" + i), o.key !== void 0 && (a = "" + o.key), "key" in o) {
      i = {};
      for (var l in o)
        l !== "key" && (i[l] = o[l]);
    } else i = o;
    return o = i.ref, {
      $$typeof: e,
      type: n,
      key: a,
      ref: o !== void 0 ? o : null,
      props: i
    };
  }
  return x.Fragment = t, x.jsx = s, x.jsxs = s, x;
}
var L = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oe;
function Ee() {
  return oe || (oe = 1, process.env.NODE_ENV !== "production" && function() {
    function e(r) {
      if (r == null) return null;
      if (typeof r == "function")
        return r.$$typeof === W ? null : r.displayName || r.name || null;
      if (typeof r == "string") return r;
      switch (r) {
        case w:
          return "Fragment";
        case _:
          return "Profiler";
        case P:
          return "StrictMode";
        case F:
          return "Suspense";
        case D:
          return "SuspenseList";
        case $:
          return "Activity";
      }
      if (typeof r == "object")
        switch (typeof r.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), r.$$typeof) {
          case N:
            return "Portal";
          case I:
            return (r.displayName || "Context") + ".Provider";
          case R:
            return (r._context.displayName || "Context") + ".Consumer";
          case T:
            var f = r.render;
            return r = r.displayName, r || (r = f.displayName || f.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
          case b:
            return f = r.displayName || null, f !== null ? f : e(r.type) || "Memo";
          case j:
            f = r._payload, r = r._init;
            try {
              return e(r(f));
            } catch {
            }
        }
      return null;
    }
    function t(r) {
      return "" + r;
    }
    function s(r) {
      try {
        t(r);
        var f = !1;
      } catch {
        f = !0;
      }
      if (f) {
        f = console;
        var v = f.error, g = typeof Symbol == "function" && Symbol.toStringTag && r[Symbol.toStringTag] || r.constructor.name || "Object";
        return v.call(
          f,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          g
        ), t(r);
      }
    }
    function n(r) {
      if (r === w) return "<>";
      if (typeof r == "object" && r !== null && r.$$typeof === j)
        return "<...>";
      try {
        var f = e(r);
        return f ? "<" + f + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function o() {
      var r = U.A;
      return r === null ? null : r.getOwner();
    }
    function i() {
      return Error("react-stack-top-frame");
    }
    function a(r) {
      if (G.call(r, "key")) {
        var f = Object.getOwnPropertyDescriptor(r, "key").get;
        if (f && f.isReactWarning) return !1;
      }
      return r.key !== void 0;
    }
    function l(r, f) {
      function v() {
        Z || (Z = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          f
        ));
      }
      v.isReactWarning = !0, Object.defineProperty(r, "key", {
        get: v,
        configurable: !0
      });
    }
    function p() {
      var r = e(this.type);
      return Q[r] || (Q[r] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), r = this.props.ref, r !== void 0 ? r : null;
    }
    function c(r, f, v, g, k, O, B, V) {
      return v = O.ref, r = {
        $$typeof: E,
        type: r,
        key: f,
        props: O,
        _owner: k
      }, (v !== void 0 ? v : null) !== null ? Object.defineProperty(r, "ref", {
        enumerable: !1,
        get: p
      }) : Object.defineProperty(r, "ref", { enumerable: !1, value: null }), r._store = {}, Object.defineProperty(r._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(r, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(r, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: B
      }), Object.defineProperty(r, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: V
      }), Object.freeze && (Object.freeze(r.props), Object.freeze(r)), r;
    }
    function d(r, f, v, g, k, O, B, V) {
      var h = f.children;
      if (h !== void 0)
        if (g)
          if (ye(h)) {
            for (g = 0; g < h.length; g++)
              y(h[g]);
            Object.freeze && Object.freeze(h);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else y(h);
      if (G.call(f, "key")) {
        h = e(r);
        var C = Object.keys(f).filter(function(ve) {
          return ve !== "key";
        });
        g = 0 < C.length ? "{key: someKey, " + C.join(": ..., ") + ": ...}" : "{key: someKey}", ne[h + g] || (C = 0 < C.length ? "{" + C.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          g,
          h,
          C,
          h
        ), ne[h + g] = !0);
      }
      if (h = null, v !== void 0 && (s(v), h = "" + v), a(f) && (s(f.key), h = "" + f.key), "key" in f) {
        v = {};
        for (var K in f)
          K !== "key" && (v[K] = f[K]);
      } else v = f;
      return h && l(
        v,
        typeof r == "function" ? r.displayName || r.name || "Unknown" : r
      ), c(
        r,
        h,
        O,
        k,
        o(),
        v,
        B,
        V
      );
    }
    function y(r) {
      typeof r == "object" && r !== null && r.$$typeof === E && r._store && (r._store.validated = 1);
    }
    var m = be, E = Symbol.for("react.transitional.element"), N = Symbol.for("react.portal"), w = Symbol.for("react.fragment"), P = Symbol.for("react.strict_mode"), _ = Symbol.for("react.profiler"), R = Symbol.for("react.consumer"), I = Symbol.for("react.context"), T = Symbol.for("react.forward_ref"), F = Symbol.for("react.suspense"), D = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), j = Symbol.for("react.lazy"), $ = Symbol.for("react.activity"), W = Symbol.for("react.client.reference"), U = m.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, G = Object.prototype.hasOwnProperty, ye = Array.isArray, z = console.createTask ? console.createTask : function() {
      return null;
    };
    m = {
      "react-stack-bottom-frame": function(r) {
        return r();
      }
    };
    var Z, Q = {}, ee = m["react-stack-bottom-frame"].bind(
      m,
      i
    )(), te = z(n(i)), ne = {};
    L.Fragment = w, L.jsx = function(r, f, v, g, k) {
      var O = 1e4 > U.recentlyCreatedOwnerStacks++;
      return d(
        r,
        f,
        v,
        !1,
        g,
        k,
        O ? Error("react-stack-top-frame") : ee,
        O ? z(n(r)) : te
      );
    }, L.jsxs = function(r, f, v, g, k) {
      var O = 1e4 > U.recentlyCreatedOwnerStacks++;
      return d(
        r,
        f,
        v,
        !0,
        g,
        k,
        O ? Error("react-stack-top-frame") : ee,
        O ? z(n(r)) : te
      );
    };
  }()), L;
}
var se;
function we() {
  return se || (se = 1, process.env.NODE_ENV === "production" ? X.exports = he() : X.exports = Ee()), X.exports;
}
var S = we();
function Ye(e, t) {
  const s = u.createContext(t), n = (i) => {
    const { children: a, ...l } = i, p = u.useMemo(() => l, Object.values(l));
    return /* @__PURE__ */ S.jsx(s.Provider, { value: p, children: a });
  };
  n.displayName = e + "Provider";
  function o(i) {
    const a = u.useContext(s);
    if (a) return a;
    if (t !== void 0) return t;
    throw new Error(`\`${i}\` must be used within \`${e}\``);
  }
  return [n, o];
}
function He(e, t = []) {
  let s = [];
  function n(i, a) {
    const l = u.createContext(a), p = s.length;
    s = [...s, a];
    const c = (y) => {
      var m;
      const { scope: E, children: N, ...w } = y, P = ((m = E == null ? void 0 : E[e]) == null ? void 0 : m[p]) || l, _ = u.useMemo(() => w, Object.values(w));
      return /* @__PURE__ */ S.jsx(P.Provider, { value: _, children: N });
    };
    c.displayName = i + "Provider";
    function d(y, m) {
      var E;
      const N = ((E = m == null ? void 0 : m[e]) == null ? void 0 : E[p]) || l, w = u.useContext(N);
      if (w) return w;
      if (a !== void 0) return a;
      throw new Error(`\`${y}\` must be used within \`${i}\``);
    }
    return [c, d];
  }
  const o = () => {
    const i = s.map((a) => u.createContext(a));
    return function(a) {
      const l = (a == null ? void 0 : a[e]) || i;
      return u.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: l } }),
        [a, l]
      );
    };
  };
  return o.scopeName = e, [n, Oe(o, ...t)];
}
function Oe(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const s = () => {
    const n = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(o) {
      const i = n.reduce((a, { useScope: l, scopeName: p }) => {
        const c = l(o)[`__scope${p}`];
        return { ...a, ...c };
      }, {});
      return u.useMemo(() => ({ [`__scope${t.scopeName}`]: i }), [i]);
    };
  };
  return s.scopeName = t.scopeName, s;
}
var A = globalThis != null && globalThis.document ? u.useLayoutEffect : () => {
};
function ie(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function le(...e) {
  return (t) => {
    let s = !1;
    const n = e.map((o) => {
      const i = ie(o, t);
      return !s && typeof i == "function" && (s = !0), i;
    });
    if (s)
      return () => {
        for (let o = 0; o < n.length; o++) {
          const i = n[o];
          typeof i == "function" ? i() : ie(e[o], null);
        }
      };
  };
}
function H(...e) {
  return u.useCallback(le(...e), e);
}
// @__NO_SIDE_EFFECTS__
function ce(e) {
  const t = /* @__PURE__ */ Ne(e), s = u.forwardRef((n, o) => {
    const { children: i, ...a } = n, l = u.Children.toArray(i), p = l.find(Se);
    if (p) {
      const c = p.props.children, d = l.map((y) => y === p ? u.Children.count(c) > 1 ? u.Children.only(null) : u.isValidElement(c) ? c.props.children : null : y);
      return /* @__PURE__ */ S.jsx(t, { ...a, ref: o, children: u.isValidElement(c) ? u.cloneElement(c, void 0, d) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...a, ref: o, children: i });
  });
  return s.displayName = `${e}.Slot`, s;
}
var qe = /* @__PURE__ */ ce("Slot");
// @__NO_SIDE_EFFECTS__
function Ne(e) {
  const t = u.forwardRef((s, n) => {
    const { children: o, ...i } = s;
    if (u.isValidElement(o)) {
      const a = je(o), l = ke(i, o.props);
      return o.type !== u.Fragment && (l.ref = n ? le(n, a) : a), u.cloneElement(o, l);
    }
    return u.Children.count(o) > 1 ? u.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var fe = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function Ge(e) {
  const t = ({ children: s }) => /* @__PURE__ */ S.jsx(S.Fragment, { children: s });
  return t.displayName = `${e}.Slottable`, t.__radixId = fe, t;
}
function Se(e) {
  return u.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === fe;
}
function ke(e, t) {
  const s = { ...t };
  for (const n in t) {
    const o = e[n], i = t[n];
    /^on[A-Z]/.test(n) ? o && i ? s[n] = (...a) => {
      const l = i(...a);
      return o(...a), l;
    } : o && (s[n] = o) : n === "style" ? s[n] = { ...o, ...i } : n === "className" && (s[n] = [o, i].filter(Boolean).join(" "));
  }
  return { ...e, ...s };
}
function je(e) {
  var t, s;
  let n = (t = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : t.get, o = n && "isReactWarning" in n && n.isReactWarning;
  return o ? e.ref : (n = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, o = n && "isReactWarning" in n && n.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
function J(e, t, { checkForDefaultPrevented: s = !0 } = {}) {
  return function(n) {
    if (e == null || e(n), s === !1 || !n.defaultPrevented)
      return t == null ? void 0 : t(n);
  };
}
function Ce(e, t) {
  return u.useReducer((s, n) => t[s][n] ?? s, e);
}
var Pe = (e) => {
  const { present: t, children: s } = e, n = _e(t), o = typeof s == "function" ? s({ present: n.isPresent }) : u.Children.only(s), i = H(n.ref, $e(o));
  return typeof s == "function" || n.isPresent ? u.cloneElement(o, { ref: i }) : null;
};
Pe.displayName = "Presence";
function _e(e) {
  const [t, s] = u.useState(), n = u.useRef(null), o = u.useRef(e), i = u.useRef("none"), a = e ? "mounted" : "unmounted", [l, p] = Ce(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return u.useEffect(() => {
    const c = M(n.current);
    i.current = l === "mounted" ? c : "none";
  }, [l]), A(() => {
    const c = n.current, d = o.current;
    if (d !== e) {
      const y = i.current, m = M(c);
      e ? p("MOUNT") : m === "none" || (c == null ? void 0 : c.display) === "none" ? p("UNMOUNT") : p(d && y !== m ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [e, p]), A(() => {
    if (t) {
      let c;
      const d = t.ownerDocument.defaultView ?? window, y = (E) => {
        const N = M(n.current).includes(E.animationName);
        if (E.target === t && N && (p("ANIMATION_END"), !o.current)) {
          const w = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = d.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = w);
          });
        }
      }, m = (E) => {
        E.target === t && (i.current = M(n.current));
      };
      return t.addEventListener("animationstart", m), t.addEventListener("animationcancel", y), t.addEventListener("animationend", y), () => {
        d.clearTimeout(c), t.removeEventListener("animationstart", m), t.removeEventListener("animationcancel", y), t.removeEventListener("animationend", y);
      };
    } else
      p("ANIMATION_END");
  }, [t, p]), {
    isPresent: ["mounted", "unmountSuspended"].includes(l),
    ref: u.useCallback((c) => {
      n.current = c ? getComputedStyle(c) : null, s(c);
    }, [])
  };
}
function M(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function $e(e) {
  var t, s;
  let n = (t = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : t.get, o = n && "isReactWarning" in n && n.isReactWarning;
  return o ? e.ref : (n = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, o = n && "isReactWarning" in n && n.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
var xe = u[" useId ".trim().toString()] || (() => {
}), Re = 0;
function Ze(e) {
  const [t, s] = u.useState(xe());
  return A(() => {
    s((n) => n ?? String(Re++));
  }, [e]), t ? `radix-${t}` : "";
}
var Te = u[" useInsertionEffect ".trim().toString()] || A;
function Qe({
  prop: e,
  defaultProp: t,
  onChange: s = () => {
  },
  caller: n
}) {
  const [o, i, a] = De({
    defaultProp: t,
    onChange: s
  }), l = e !== void 0, p = l ? e : o;
  {
    const d = u.useRef(e !== void 0);
    u.useEffect(() => {
      const y = d.current;
      y !== l && console.warn(
        `${n} is changing from ${y ? "controlled" : "uncontrolled"} to ${l ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), d.current = l;
    }, [l, n]);
  }
  const c = u.useCallback(
    (d) => {
      var y;
      if (l) {
        const m = Le(d) ? d(e) : d;
        m !== e && ((y = a.current) == null || y.call(a, m));
      } else
        i(d);
    },
    [l, e, i, a]
  );
  return [p, c];
}
function De({
  defaultProp: e,
  onChange: t
}) {
  const [s, n] = u.useState(e), o = u.useRef(s), i = u.useRef(t);
  return Te(() => {
    i.current = t;
  }, [t]), u.useEffect(() => {
    var a;
    o.current !== s && ((a = i.current) == null || a.call(i, s), o.current = s);
  }, [s, o]), [s, n, i];
}
function Le(e) {
  return typeof e == "function";
}
var Me = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], de = Me.reduce((e, t) => {
  const s = /* @__PURE__ */ ce(`Primitive.${t}`), n = u.forwardRef((o, i) => {
    const { asChild: a, ...l } = o, p = a ? s : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(p, { ...l, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function Ae(e, t) {
  e && ge.flushSync(() => e.dispatchEvent(t));
}
function q(e) {
  const t = u.useRef(e);
  return u.useEffect(() => {
    t.current = e;
  }), u.useMemo(() => (...s) => {
    var n;
    return (n = t.current) == null ? void 0 : n.call(t, ...s);
  }, []);
}
function Ie(e, t = globalThis == null ? void 0 : globalThis.document) {
  const s = q(e);
  u.useEffect(() => {
    const n = (o) => {
      o.key === "Escape" && s(o);
    };
    return t.addEventListener("keydown", n, { capture: !0 }), () => t.removeEventListener("keydown", n, { capture: !0 });
  }, [s, t]);
}
var Fe = "DismissableLayer", Y = "dismissableLayer.update", We = "dismissableLayer.pointerDownOutside", Ue = "dismissableLayer.focusOutside", ue, pe = u.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), ze = u.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: s = !1,
      onEscapeKeyDown: n,
      onPointerDownOutside: o,
      onFocusOutside: i,
      onInteractOutside: a,
      onDismiss: l,
      ...p
    } = e, c = u.useContext(pe), [d, y] = u.useState(null), m = (d == null ? void 0 : d.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, E] = u.useState({}), N = H(t, (b) => y(b)), w = Array.from(c.layers), [P] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), _ = w.indexOf(P), R = d ? w.indexOf(d) : -1, I = c.layersWithOutsidePointerEventsDisabled.size > 0, T = R >= _, F = Ke((b) => {
      const j = b.target, $ = [...c.branches].some((W) => W.contains(j));
      !T || $ || (o == null || o(b), a == null || a(b), b.defaultPrevented || l == null || l());
    }, m), D = Xe((b) => {
      const j = b.target;
      [...c.branches].some(($) => $.contains(j)) || (i == null || i(b), a == null || a(b), b.defaultPrevented || l == null || l());
    }, m);
    return Ie((b) => {
      R === c.layers.size - 1 && (n == null || n(b), !b.defaultPrevented && l && (b.preventDefault(), l()));
    }, m), u.useEffect(() => {
      if (d)
        return s && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (ue = m.body.style.pointerEvents, m.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(d)), c.layers.add(d), ae(), () => {
          s && c.layersWithOutsidePointerEventsDisabled.size === 1 && (m.body.style.pointerEvents = ue);
        };
    }, [d, m, s, c]), u.useEffect(() => () => {
      d && (c.layers.delete(d), c.layersWithOutsidePointerEventsDisabled.delete(d), ae());
    }, [d, c]), u.useEffect(() => {
      const b = () => E({});
      return document.addEventListener(Y, b), () => document.removeEventListener(Y, b);
    }, []), /* @__PURE__ */ S.jsx(
      de.div,
      {
        ...p,
        ref: N,
        style: {
          pointerEvents: I ? T ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: J(e.onFocusCapture, D.onFocusCapture),
        onBlurCapture: J(e.onBlurCapture, D.onBlurCapture),
        onPointerDownCapture: J(
          e.onPointerDownCapture,
          F.onPointerDownCapture
        )
      }
    );
  }
);
ze.displayName = Fe;
var Be = "DismissableLayerBranch", Ve = u.forwardRef((e, t) => {
  const s = u.useContext(pe), n = u.useRef(null), o = H(t, n);
  return u.useEffect(() => {
    const i = n.current;
    if (i)
      return s.branches.add(i), () => {
        s.branches.delete(i);
      };
  }, [s.branches]), /* @__PURE__ */ S.jsx(de.div, { ...e, ref: o });
});
Ve.displayName = Be;
function Ke(e, t = globalThis == null ? void 0 : globalThis.document) {
  const s = q(e), n = u.useRef(!1), o = u.useRef(() => {
  });
  return u.useEffect(() => {
    const i = (l) => {
      if (l.target && !n.current) {
        let p = function() {
          me(
            We,
            s,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: l };
        l.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = p, t.addEventListener("click", o.current, { once: !0 })) : p();
      } else
        t.removeEventListener("click", o.current);
      n.current = !1;
    }, a = window.setTimeout(() => {
      t.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(a), t.removeEventListener("pointerdown", i), t.removeEventListener("click", o.current);
    };
  }, [t, s]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => n.current = !0
  };
}
function Xe(e, t = globalThis == null ? void 0 : globalThis.document) {
  const s = q(e), n = u.useRef(!1);
  return u.useEffect(() => {
    const o = (i) => {
      i.target && !n.current && me(Ue, s, { originalEvent: i }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, s]), {
    onFocusCapture: () => n.current = !0,
    onBlurCapture: () => n.current = !1
  };
}
function ae() {
  const e = new CustomEvent(Y);
  document.dispatchEvent(e);
}
function me(e, t, s, { discrete: n }) {
  const o = s.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: s });
  t && o.addEventListener(e, t, { once: !0 }), n ? Ae(o, i) : o.dispatchEvent(i);
}
export {
  ze as M,
  Pe as R,
  Ge as _,
  S as a,
  J as b,
  ce as c,
  Ye as d,
  A as e,
  qe as f,
  Ze as g,
  de as h,
  He as j,
  le as m,
  q as n,
  Ae as w,
  H as x,
  Qe as y
};
