import { useEffect as C, useMemo as O, useCallback as a, useState as E } from "react";
import { l as u } from "./lodash-CYNxjS-I.js";
import { u as j } from "./useColumnsStore-CllOTGkk.js";
import { S as b } from "./SortOrder-CwuehjY1.js";
const F = ({
  key: n,
  columns: e = []
}) => {
  const { storedColumns: t, setColumns: l } = j();
  C(() => {
    if (u.isEmpty(u.get(t, n)) && !u.isEmpty(e)) {
      const o = {};
      e.forEach((s) => {
        u.set(o, s.key, !!s.hidden);
      }), l({
        ...t,
        [n]: o
      });
    }
  }, [n, e, t, l]);
  const m = O(() => {
    const o = u.get(t, n, {});
    return e.filter((s) => s.type !== "action").map((s) => {
      const { hidden: c, ...i } = s;
      return {
        ...i,
        hidden: u.get(o, s.key, !!c)
      };
    });
  }, [n, t, e]), f = a(
    (o, s) => {
      const c = u.get(t, n, {});
      u.set(c, o.key, s), l({
        ...t,
        [n]: c
      });
    },
    [n, l, t]
  ), r = a(() => {
    const o = {};
    e.forEach((s) => {
      u.set(o, s.key, !!s.hidden);
    }), l({
      ...t,
      [n]: o
    });
  }, [n, l, t, e]);
  return {
    formattedColumns: m,
    handleColumnsChange: f,
    resetColumns: r
  };
}, S = ({
  rows: n = [],
  defaultSelectedRows: e = []
}) => {
  const [t, l] = E([]), m = a(
    (s, c) => {
      l((i) => {
        const d = n.map((h) => h[s]) || [], g = i.filter(
          (h) => !d.includes(h)
        );
        return c ? [...g, ...d] : g;
      });
    },
    [n]
  );
  C(() => {
    e && l(
      (s) => u.isEqual(s, e) ? s : e
    );
  }, [e]);
  const f = a(
    (s, c) => {
      l((i) => c ? [...i, s] : i.filter((d) => d !== s));
    },
    []
  ), r = a(
    (s) => t.includes(s),
    [t]
  ), o = a(
    (s) => {
      const c = n.map((d) => d[s]) || [];
      let i = 0;
      for (const d of c)
        t.includes(d) && i++;
      return c.length === i ? !0 : i ? "indeterminate" : !1;
    },
    [t, n]
  );
  return {
    selectedRows: t,
    isRowSelected: r,
    isAllRowsSelected: o,
    handleSelectAllRows: m,
    handleSelectRow: f
  };
}, x = ({
  sortField: n,
  sortOrder: e,
  onSortOrderChange: t
}) => {
  const [l, m] = E();
  C(() => {
    n && m(
      (r) => (r == null ? void 0 : r.sortField) === e && (r == null ? void 0 : r.sortOrder) === e ? r : {
        sortField: n,
        sortOrder: e || void 0
      }
    );
  }, [n, e]);
  const f = a(
    (r) => {
      m((o) => {
        const c = (o == null ? void 0 : o.sortField) === r ? (o == null ? void 0 : o.sortOrder) === b.ASC ? b.DESC : void 0 : b.ASC, i = {
          sortField: c ? r : void 0,
          sortOrder: c
        };
        return t && t(i), i;
      });
    },
    [t]
  );
  return {
    sortObject: l,
    handleSort: f
  };
};
export {
  S as a,
  F as b,
  x as u
};
