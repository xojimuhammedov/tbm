import { a as R, f as gp, y as js, j as zs, g as Oa, h as Ct, x as Mt, e as Xe, R as ec, b as Nt, c as vp, M as bp, n as yp } from "./index-DqTIeHVj-CeLMF2B2.js";
import * as C from "react";
import ut, { forwardRef as kp, useState as dl, useEffect as xp, createRef as pl, useDebugValue as fl, createElement as wp, useRef as Ep, useContext as _p } from "react";
import { o as rc, i as Ap, r as Np, I as Ta, s as Sp, c as Cp } from "./index-VIo8j85K-Gso9ejBr.js";
import { C as Op, i as Tp, w as Rp, m as Lp, J as Ra, a as ze } from "./react-select-Dr-07nIb-DE_aB_nz.js";
import { m as St } from "./utils-B6fNqzRf-B1_jG1K7.js";
import { j as La, u as Ip } from "./button-Bp2lHjov-BTlHPcva.js";
import * as sc from "react-dom";
import { a as qp, n as nc, X as jp, t as Mp, b as ic, S as Bp, g as Dp } from "./circle-COtEidYe-DaI8pjYh.js";
import { k as oc, M as Fp, R as Pp, C as Vp, d as Up, S as $p } from "./createLucideIcon-B950nf2d-C2YhAyqE.js";
import { s as zp } from "./index-CYIFqWxx-6SIsOs0F.js";
function ml(r, [t, e]) {
  return Math.min(e, Math.max(t, r));
}
var Hp = Object.defineProperty, Kp = (r, t, e) => t in r ? Hp(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e, Q = (r, t, e) => Kp(r, typeof t != "symbol" ? t + "" : t, e);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Gp = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], ac = oc("chevron-down", Gp);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wp = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], Zp = oc("chevron-up", Wp);
function ti(r) {
  const t = C.useRef({ value: r, previous: r });
  return C.useMemo(() => (t.current.value !== r && (t.current.previous = t.current.value, t.current.value = r), t.current.previous), [r]);
}
var ei = "Checkbox", [Xp, ow] = zs(ei), [Yp, Ia] = Xp(ei);
function Jp(r) {
  const {
    __scopeCheckbox: t,
    checked: e,
    children: s,
    defaultChecked: n,
    disabled: i,
    form: o,
    name: a,
    onCheckedChange: l,
    required: c,
    value: d = "on",
    // @ts-expect-error
    internal_do_not_use_render: g
  } = r, [h, f] = js({
    prop: e,
    defaultProp: n ?? !1,
    onChange: l,
    caller: ei
  }), [v, m] = C.useState(null), [k, _] = C.useState(null), E = C.useRef(!1), N = v ? !!o || !!v.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), q = {
    checked: h,
    disabled: i,
    setChecked: f,
    control: v,
    setControl: m,
    name: a,
    form: o,
    value: d,
    hasConsumerStoppedPropagationRef: E,
    required: c,
    defaultChecked: Ge(n) ? !1 : n,
    isFormControl: N,
    bubbleInput: k,
    setBubbleInput: _
  };
  return /* @__PURE__ */ R.jsx(
    Yp,
    {
      scope: t,
      ...q,
      children: Qp(g) ? g(q) : s
    }
  );
}
var lc = "CheckboxTrigger", uc = C.forwardRef(
  ({ __scopeCheckbox: r, onKeyDown: t, onClick: e, ...s }, n) => {
    const {
      control: i,
      value: o,
      disabled: a,
      checked: l,
      required: c,
      setControl: d,
      setChecked: g,
      hasConsumerStoppedPropagationRef: h,
      isFormControl: f,
      bubbleInput: v
    } = Ia(lc, r), m = Mt(n, d), k = C.useRef(l);
    return C.useEffect(() => {
      const _ = i == null ? void 0 : i.form;
      if (_) {
        const E = () => g(k.current);
        return _.addEventListener("reset", E), () => _.removeEventListener("reset", E);
      }
    }, [i, g]), /* @__PURE__ */ R.jsx(
      Ct.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": Ge(l) ? "mixed" : l,
        "aria-required": c,
        "data-state": fc(l),
        "data-disabled": a ? "" : void 0,
        disabled: a,
        value: o,
        ...s,
        ref: m,
        onKeyDown: Nt(t, (_) => {
          _.key === "Enter" && _.preventDefault();
        }),
        onClick: Nt(e, (_) => {
          g((E) => Ge(E) ? !0 : !E), v && f && (h.current = _.isPropagationStopped(), h.current || _.stopPropagation());
        })
      }
    );
  }
);
uc.displayName = lc;
var qa = C.forwardRef(
  (r, t) => {
    const {
      __scopeCheckbox: e,
      name: s,
      checked: n,
      defaultChecked: i,
      required: o,
      disabled: a,
      value: l,
      onCheckedChange: c,
      form: d,
      ...g
    } = r;
    return /* @__PURE__ */ R.jsx(
      Jp,
      {
        __scopeCheckbox: e,
        checked: n,
        defaultChecked: i,
        disabled: a,
        required: o,
        onCheckedChange: c,
        name: s,
        form: d,
        value: l,
        internal_do_not_use_render: ({ isFormControl: h }) => /* @__PURE__ */ R.jsxs(R.Fragment, { children: [
          /* @__PURE__ */ R.jsx(
            uc,
            {
              ...g,
              ref: t,
              __scopeCheckbox: e
            }
          ),
          h && /* @__PURE__ */ R.jsx(
            pc,
            {
              __scopeCheckbox: e
            }
          )
        ] })
      }
    );
  }
);
qa.displayName = ei;
var cc = "CheckboxIndicator", hc = C.forwardRef(
  (r, t) => {
    const { __scopeCheckbox: e, forceMount: s, ...n } = r, i = Ia(cc, e);
    return /* @__PURE__ */ R.jsx(
      ec,
      {
        present: s || Ge(i.checked) || i.checked === !0,
        children: /* @__PURE__ */ R.jsx(
          Ct.span,
          {
            "data-state": fc(i.checked),
            "data-disabled": i.disabled ? "" : void 0,
            ...n,
            ref: t,
            style: { pointerEvents: "none", ...r.style }
          }
        )
      }
    );
  }
);
hc.displayName = cc;
var dc = "CheckboxBubbleInput", pc = C.forwardRef(
  ({ __scopeCheckbox: r, ...t }, e) => {
    const {
      control: s,
      hasConsumerStoppedPropagationRef: n,
      checked: i,
      defaultChecked: o,
      required: a,
      disabled: l,
      name: c,
      value: d,
      form: g,
      bubbleInput: h,
      setBubbleInput: f
    } = Ia(dc, r), v = Mt(e, f), m = ti(i), k = Ta(s);
    C.useEffect(() => {
      const E = h;
      if (!E) return;
      const N = window.HTMLInputElement.prototype, q = Object.getOwnPropertyDescriptor(
        N,
        "checked"
      ).set, A = !n.current;
      if (m !== i && q) {
        const X = new Event("click", { bubbles: A });
        E.indeterminate = Ge(i), q.call(E, Ge(i) ? !1 : i), E.dispatchEvent(X);
      }
    }, [h, m, i, n]);
    const _ = C.useRef(Ge(i) ? !1 : i);
    return /* @__PURE__ */ R.jsx(
      Ct.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: o ?? _.current,
        required: a,
        disabled: l,
        name: c,
        value: d,
        form: g,
        ...t,
        tabIndex: -1,
        ref: v,
        style: {
          ...t.style,
          ...k,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
pc.displayName = dc;
function Qp(r) {
  return typeof r == "function";
}
function Ge(r) {
  return r === "indeterminate";
}
function fc(r) {
  return Ge(r) ? "indeterminate" : r ? "checked" : "unchecked";
}
const tf = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  qa,
  {
    ref: e,
    className: St(
      "peer border-primary ring-offset-background focus-visible:ring-ring data-[state=checked]:text-primary size-4 shrink-0 rounded-sm border focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
      r
    ),
    ...t,
    children: /* @__PURE__ */ R.jsx(
      hc,
      {
        className: St("flex size-4 items-center justify-center text-current"),
        children: t.checked === "indeterminate" ? /* @__PURE__ */ R.jsx(Op, { className: "text-primary mr-0.5 mb-0.5 size-3.5" }) : /* @__PURE__ */ R.jsx(Tp, { className: "text-primary mr-0.5 mb-0.5 size-3.5" })
      }
    )
  }
));
tf.displayName = qa.displayName;
const ja = La(
  "flex h-10 w-full rounded-lg border border-border-alpha-strong px-3 py-2 dark:bg-transparent file:border-0 placeholder:text-secondary placeholder:text-body-sm-regular focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-bg focus-visible:ring-offset-2 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "focus-visible:ring-item-primary",
        failure: "focus-visible:ring-item-destructive bg-item-destructive-focus placeholder:text-item-destructive border-item-destructive text-destructive",
        success: "focus-visible:ring-success bg-success/20 placeholder:text-success/80 border-success text-success"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), ef = C.forwardRef(
  ({ className: r, type: t, variant: e, ...s }, n) => {
    const [i, o] = dl(!1), [a, l] = dl(!1);
    return xp(() => {
      o(t === "password");
    }, [t]), /* @__PURE__ */ R.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ R.jsx(
        "input",
        {
          type: a ? "text" : t,
          className: St(
            ja({ variant: e }),
            r,
            i && "pr-10"
          ),
          ref: n,
          ...s
        }
      ),
      i && /* @__PURE__ */ R.jsx(
        Ip,
        {
          type: "button",
          size: "icon",
          variant: "tertiary",
          className: "absolute top-1 right-1 size-8 cursor-pointer rounded-md p-2 !ring-0 !ring-offset-0",
          onClick: () => {
            l(!a);
          },
          children: a ? /* @__PURE__ */ R.jsx(Rp, {}) : /* @__PURE__ */ R.jsx(Lp, {})
        }
      )
    ] });
  }
);
ef.displayName = "Input";
var Wt = function() {
  return Wt = Object.assign || function(r) {
    for (var t, e = 1, s = arguments.length; e < s; e++) {
      t = arguments[e];
      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Wt.apply(this, arguments);
};
function Yr(r, t, e) {
  if (e || arguments.length === 2) for (var s = 0, n = t.length, i; s < n; s++)
    (i || !(s in t)) && (i || (i = Array.prototype.slice.call(t, 0, s)), i[s] = t[s]);
  return r.concat(i || Array.prototype.slice.call(t));
}
function rf(r) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(e) {
    return t[e] === void 0 && (t[e] = r(e)), t[e];
  };
}
var sf = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, nf = /* @__PURE__ */ rf(
  function(r) {
    return sf.test(r) || r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && r.charCodeAt(2) < 91;
  }
  /* Z+1 */
), Et = "-ms-", Ls = "-moz-", bt = "-webkit-", mc = "comm", ri = "rule", Ma = "decl", of = "@import", gc = "@keyframes", af = "@layer", vc = Math.abs, Ba = String.fromCharCode, zo = Object.assign;
function lf(r, t) {
  return Lt(r, 0) ^ 45 ? (((t << 2 ^ Lt(r, 0)) << 2 ^ Lt(r, 1)) << 2 ^ Lt(r, 2)) << 2 ^ Lt(r, 3) : 0;
}
function bc(r) {
  return r.trim();
}
function Te(r, t) {
  return (r = t.exec(r)) ? r[0] : r;
}
function ht(r, t, e) {
  return r.replace(t, e);
}
function Tn(r, t, e) {
  return r.indexOf(t, e);
}
function Lt(r, t) {
  return r.charCodeAt(t) | 0;
}
function Jr(r, t, e) {
  return r.slice(t, e);
}
function be(r) {
  return r.length;
}
function yc(r) {
  return r.length;
}
function Ss(r, t) {
  return t.push(r), r;
}
function uf(r, t) {
  return r.map(t).join("");
}
function gl(r, t) {
  return r.filter(function(e) {
    return !Te(e, t);
  });
}
var si = 1, Qr = 1, kc = 0, re = 0, Tt = 0, os = "";
function ni(r, t, e, s, n, i, o, a) {
  return { value: r, root: t, parent: e, type: s, props: n, children: i, line: si, column: Qr, length: o, return: "", siblings: a };
}
function Ve(r, t) {
  return zo(ni("", null, null, "", null, null, 0, r.siblings), r, { length: -r.length }, t);
}
function Fr(r) {
  for (; r.root; )
    r = Ve(r.root, { children: [r] });
  Ss(r, r.siblings);
}
function cf() {
  return Tt;
}
function hf() {
  return Tt = re > 0 ? Lt(os, --re) : 0, Qr--, Tt === 10 && (Qr = 1, si--), Tt;
}
function le() {
  return Tt = re < kc ? Lt(os, re++) : 0, Qr++, Tt === 10 && (Qr = 1, si++), Tt;
}
function fr() {
  return Lt(os, re);
}
function Rn() {
  return re;
}
function ii(r, t) {
  return Jr(os, r, t);
}
function Ho(r) {
  switch (r) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function df(r) {
  return si = Qr = 1, kc = be(os = r), re = 0, [];
}
function pf(r) {
  return os = "", r;
}
function bo(r) {
  return bc(ii(re - 1, Ko(r === 91 ? r + 2 : r === 40 ? r + 1 : r)));
}
function ff(r) {
  for (; (Tt = fr()) && Tt < 33; )
    le();
  return Ho(r) > 2 || Ho(Tt) > 3 ? "" : " ";
}
function mf(r, t) {
  for (; --t && le() && !(Tt < 48 || Tt > 102 || Tt > 57 && Tt < 65 || Tt > 70 && Tt < 97); )
    ;
  return ii(r, Rn() + (t < 6 && fr() == 32 && le() == 32));
}
function Ko(r) {
  for (; le(); )
    switch (Tt) {
      // ] ) " '
      case r:
        return re;
      // " '
      case 34:
      case 39:
        r !== 34 && r !== 39 && Ko(Tt);
        break;
      // (
      case 40:
        r === 41 && Ko(r);
        break;
      // \
      case 92:
        le();
        break;
    }
  return re;
}
function gf(r, t) {
  for (; le() && r + Tt !== 57 && !(r + Tt === 84 && fr() === 47); )
    ;
  return "/*" + ii(t, re - 1) + "*" + Ba(r === 47 ? r : le());
}
function vf(r) {
  for (; !Ho(fr()); )
    le();
  return ii(r, re);
}
function bf(r) {
  return pf(Ln("", null, null, null, [""], r = df(r), 0, [0], r));
}
function Ln(r, t, e, s, n, i, o, a, l) {
  for (var c = 0, d = 0, g = o, h = 0, f = 0, v = 0, m = 1, k = 1, _ = 1, E = 0, N = "", q = n, A = i, X = s, G = N; k; )
    switch (v = E, E = le()) {
      // (
      case 40:
        if (v != 108 && Lt(G, g - 1) == 58) {
          Tn(G += ht(bo(E), "&", "&\f"), "&\f", vc(c ? a[c - 1] : 0)) != -1 && (_ = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        G += bo(E);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        G += ff(v);
        break;
      // \
      case 92:
        G += mf(Rn() - 1, 7);
        continue;
      // /
      case 47:
        switch (fr()) {
          case 42:
          case 47:
            Ss(yf(gf(le(), Rn()), t, e, l), l);
            break;
          default:
            G += "/";
        }
        break;
      // {
      case 123 * m:
        a[c++] = be(G) * _;
      // } ; \0
      case 125 * m:
      case 59:
      case 0:
        switch (E) {
          // \0 }
          case 0:
          case 125:
            k = 0;
          // ;
          case 59 + d:
            _ == -1 && (G = ht(G, /\f/g, "")), f > 0 && be(G) - g && Ss(f > 32 ? bl(G + ";", s, e, g - 1, l) : bl(ht(G, " ", "") + ";", s, e, g - 2, l), l);
            break;
          // @ ;
          case 59:
            G += ";";
          // { rule/at-rule
          default:
            if (Ss(X = vl(G, t, e, c, d, n, a, N, q = [], A = [], g, i), i), E === 123)
              if (d === 0)
                Ln(G, t, X, X, q, i, g, a, A);
              else
                switch (h === 99 && Lt(G, 3) === 110 ? 100 : h) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Ln(r, X, X, s && Ss(vl(r, X, X, 0, 0, n, a, N, n, q = [], g, A), A), n, A, g, a, s ? q : A);
                    break;
                  default:
                    Ln(G, X, X, X, [""], A, 0, a, A);
                }
        }
        c = d = f = 0, m = _ = 1, N = G = "", g = o;
        break;
      // :
      case 58:
        g = 1 + be(G), f = v;
      default:
        if (m < 1) {
          if (E == 123)
            --m;
          else if (E == 125 && m++ == 0 && hf() == 125)
            continue;
        }
        switch (G += Ba(E), E * m) {
          // &
          case 38:
            _ = d > 0 ? 1 : (G += "\f", -1);
            break;
          // ,
          case 44:
            a[c++] = (be(G) - 1) * _, _ = 1;
            break;
          // @
          case 64:
            fr() === 45 && (G += bo(le())), h = fr(), d = g = be(N = G += vf(Rn())), E++;
            break;
          // -
          case 45:
            v === 45 && be(G) == 2 && (m = 0);
        }
    }
  return i;
}
function vl(r, t, e, s, n, i, o, a, l, c, d, g) {
  for (var h = n - 1, f = n === 0 ? i : [""], v = yc(f), m = 0, k = 0, _ = 0; m < s; ++m)
    for (var E = 0, N = Jr(r, h + 1, h = vc(k = o[m])), q = r; E < v; ++E)
      (q = bc(k > 0 ? f[E] + " " + N : ht(N, /&\f/g, f[E]))) && (l[_++] = q);
  return ni(r, t, e, n === 0 ? ri : a, l, c, d, g);
}
function yf(r, t, e, s) {
  return ni(r, t, e, mc, Ba(cf()), Jr(r, 2, -2), 0, s);
}
function bl(r, t, e, s, n) {
  return ni(r, t, e, Ma, Jr(r, 0, s), Jr(r, s + 1, -1), s, n);
}
function xc(r, t, e) {
  switch (lf(r, t)) {
    // color-adjust
    case 5103:
      return bt + "print-" + r + r;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return bt + r + r;
    // tab-size
    case 4789:
      return Ls + r + r;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return bt + r + Ls + r + Et + r + r;
    // writing-mode
    case 5936:
      switch (Lt(r, t + 11)) {
        // vertical-l(r)
        case 114:
          return bt + r + Et + ht(r, /[svh]\w+-[tblr]{2}/, "tb") + r;
        // vertical-r(l)
        case 108:
          return bt + r + Et + ht(r, /[svh]\w+-[tblr]{2}/, "tb-rl") + r;
        // horizontal(-)tb
        case 45:
          return bt + r + Et + ht(r, /[svh]\w+-[tblr]{2}/, "lr") + r;
      }
    // flex, flex-direction, scroll-snap-type, writing-mode
    case 6828:
    case 4268:
    case 2903:
      return bt + r + Et + r + r;
    // order
    case 6165:
      return bt + r + Et + "flex-" + r + r;
    // align-items
    case 5187:
      return bt + r + ht(r, /(\w+).+(:[^]+)/, bt + "box-$1$2" + Et + "flex-$1$2") + r;
    // align-self
    case 5443:
      return bt + r + Et + "flex-item-" + ht(r, /flex-|-self/g, "") + (Te(r, /flex-|baseline/) ? "" : Et + "grid-row-" + ht(r, /flex-|-self/g, "")) + r;
    // align-content
    case 4675:
      return bt + r + Et + "flex-line-pack" + ht(r, /align-content|flex-|-self/g, "") + r;
    // flex-shrink
    case 5548:
      return bt + r + Et + ht(r, "shrink", "negative") + r;
    // flex-basis
    case 5292:
      return bt + r + Et + ht(r, "basis", "preferred-size") + r;
    // flex-grow
    case 6060:
      return bt + "box-" + ht(r, "-grow", "") + bt + r + Et + ht(r, "grow", "positive") + r;
    // transition
    case 4554:
      return bt + ht(r, /([^-])(transform)/g, "$1" + bt + "$2") + r;
    // cursor
    case 6187:
      return ht(ht(ht(r, /(zoom-|grab)/, bt + "$1"), /(image-set)/, bt + "$1"), r, "") + r;
    // background, background-image
    case 5495:
    case 3959:
      return ht(r, /(image-set\([^]*)/, bt + "$1$`$1");
    // justify-content
    case 4968:
      return ht(ht(r, /(.+:)(flex-)?(.*)/, bt + "box-pack:$3" + Et + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + bt + r + r;
    // justify-self
    case 4200:
      if (!Te(r, /flex-|baseline/)) return Et + "grid-column-align" + Jr(r, t) + r;
      break;
    // grid-template-(columns|rows)
    case 2592:
    case 3360:
      return Et + ht(r, "template-", "") + r;
    // grid-(row|column)-start
    case 4384:
    case 3616:
      return e && e.some(function(s, n) {
        return t = n, Te(s.props, /grid-\w+-end/);
      }) ? ~Tn(r + (e = e[t].value), "span", 0) ? r : Et + ht(r, "-start", "") + r + Et + "grid-row-span:" + (~Tn(e, "span", 0) ? Te(e, /\d+/) : +Te(e, /\d+/) - +Te(r, /\d+/)) + ";" : Et + ht(r, "-start", "") + r;
    // grid-(row|column)-end
    case 4896:
    case 4128:
      return e && e.some(function(s) {
        return Te(s.props, /grid-\w+-start/);
      }) ? r : Et + ht(ht(r, "-end", "-span"), "span ", "") + r;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return ht(r, /(.+)-inline(.+)/, bt + "$1$2") + r;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (be(r) - 1 - t > 6)
        switch (Lt(r, t + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (Lt(r, t + 4) !== 45)
              break;
          // (f)ill-available, (f)it-content
          case 102:
            return ht(r, /(.+:)(.+)-([^]+)/, "$1" + bt + "$2-$3$1" + Ls + (Lt(r, t + 3) == 108 ? "$3" : "$2-$3")) + r;
          // (s)tretch
          case 115:
            return ~Tn(r, "stretch", 0) ? xc(ht(r, "stretch", "fill-available"), t, e) + r : r;
        }
      break;
    // grid-(column|row)
    case 5152:
    case 5920:
      return ht(r, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(s, n, i, o, a, l, c) {
        return Et + n + ":" + i + c + (o ? Et + n + "-span:" + (a ? l : +l - +i) + c : "") + r;
      });
    // position: sticky
    case 4949:
      if (Lt(r, t + 6) === 121)
        return ht(r, ":", ":" + bt) + r;
      break;
    // display: (flex|inline-flex|grid|inline-grid)
    case 6444:
      switch (Lt(r, Lt(r, 14) === 45 ? 18 : 11)) {
        // (inline-)?fle(x)
        case 120:
          return ht(r, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + bt + (Lt(r, 14) === 45 ? "inline-" : "") + "box$3$1" + bt + "$2$3$1" + Et + "$2box$3") + r;
        // (inline-)?gri(d)
        case 100:
          return ht(r, ":", ":" + Et) + r;
      }
      break;
    // scroll-margin, scroll-margin-(top|right|bottom|left)
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return ht(r, "scroll-", "scroll-snap-") + r;
  }
  return r;
}
function zn(r, t) {
  for (var e = "", s = 0; s < r.length; s++)
    e += t(r[s], s, r, t) || "";
  return e;
}
function kf(r, t, e, s) {
  switch (r.type) {
    case af:
      if (r.children.length) break;
    case of:
    case Ma:
      return r.return = r.return || r.value;
    case mc:
      return "";
    case gc:
      return r.return = r.value + "{" + zn(r.children, s) + "}";
    case ri:
      if (!be(r.value = r.props.join(","))) return "";
  }
  return be(e = zn(r.children, s)) ? r.return = r.value + "{" + e + "}" : "";
}
function xf(r) {
  var t = yc(r);
  return function(e, s, n, i) {
    for (var o = "", a = 0; a < t; a++)
      o += r[a](e, s, n, i) || "";
    return o;
  };
}
function wf(r) {
  return function(t) {
    t.root || (t = t.return) && r(t);
  };
}
function Ef(r, t, e, s) {
  if (r.length > -1 && !r.return)
    switch (r.type) {
      case Ma:
        r.return = xc(r.value, r.length, e);
        return;
      case gc:
        return zn([Ve(r, { value: ht(r.value, "@", "@" + bt) })], s);
      case ri:
        if (r.length)
          return uf(e = r.props, function(n) {
            switch (Te(n, s = /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ":read-only":
              case ":read-write":
                Fr(Ve(r, { props: [ht(n, /:(read-\w+)/, ":" + Ls + "$1")] })), Fr(Ve(r, { props: [n] })), zo(r, { props: gl(e, s) });
                break;
              // :placeholder
              case "::placeholder":
                Fr(Ve(r, { props: [ht(n, /:(plac\w+)/, ":" + bt + "input-$1")] })), Fr(Ve(r, { props: [ht(n, /:(plac\w+)/, ":" + Ls + "$1")] })), Fr(Ve(r, { props: [ht(n, /:(plac\w+)/, Et + "input-$1")] })), Fr(Ve(r, { props: [n] })), zo(r, { props: gl(e, s) });
                break;
            }
            return "";
          });
    }
}
var _f = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, gr = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", wc = "active", Ec = "data-styled-version", oi = "6.1.19", Da = `/*!sc*/
`, Hn = typeof window < "u" && typeof document < "u", Af = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : process.env.NODE_ENV !== "production"), yl = /invalid hook call/i, vn = /* @__PURE__ */ new Set(), Nf = function(r, t) {
  if (process.env.NODE_ENV !== "production") {
    var e = t ? ' with the id of "'.concat(t, '"') : "", s = "The component ".concat(r).concat(e, ` has been created dynamically.
`) + `You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.
See https://styled-components.com/docs/basics#define-styled-components-outside-of-the-render-method for more info.
`, n = console.error;
    try {
      var i = !0;
      console.error = function(o) {
        for (var a = [], l = 1; l < arguments.length; l++) a[l - 1] = arguments[l];
        yl.test(o) ? (i = !1, vn.delete(s)) : n.apply(void 0, Yr([o], a, !1));
      }, Ep(), i && !vn.has(s) && (console.warn(s), vn.add(s));
    } catch (o) {
      yl.test(o.message) && vn.delete(s);
    } finally {
      console.error = n;
    }
  }
}, ai = Object.freeze([]), ts = Object.freeze({});
function Sf(r, t, e) {
  return e === void 0 && (e = ts), r.theme !== e.theme && r.theme || t || e.theme;
}
var Go = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), Cf = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, Of = /(^-|-$)/g;
function kl(r) {
  return r.replace(Cf, "-").replace(Of, "");
}
var Tf = /(a)(d)/gi, bn = 52, xl = function(r) {
  return String.fromCharCode(r + (r > 25 ? 39 : 97));
};
function Wo(r) {
  var t, e = "";
  for (t = Math.abs(r); t > bn; t = t / bn | 0) e = xl(t % bn) + e;
  return (xl(t % bn) + e).replace(Tf, "$1-$2");
}
var yo, _c = 5381, hr = function(r, t) {
  for (var e = t.length; e; ) r = 33 * r ^ t.charCodeAt(--e);
  return r;
}, Ac = function(r) {
  return hr(_c, r);
};
function Rf(r) {
  return Wo(Ac(r) >>> 0);
}
function Nc(r) {
  return process.env.NODE_ENV !== "production" && typeof r == "string" && r || r.displayName || r.name || "Component";
}
function ko(r) {
  return typeof r == "string" && (process.env.NODE_ENV === "production" || r.charAt(0) === r.charAt(0).toLowerCase());
}
var Sc = typeof Symbol == "function" && Symbol.for, Cc = Sc ? Symbol.for("react.memo") : 60115, Lf = Sc ? Symbol.for("react.forward_ref") : 60112, If = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, qf = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, Oc = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, jf = ((yo = {})[Lf] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, yo[Cc] = Oc, yo);
function wl(r) {
  return ("type" in (t = r) && t.type.$$typeof) === Cc ? Oc : "$$typeof" in r ? jf[r.$$typeof] : If;
  var t;
}
var Mf = Object.defineProperty, Bf = Object.getOwnPropertyNames, El = Object.getOwnPropertySymbols, Df = Object.getOwnPropertyDescriptor, Ff = Object.getPrototypeOf, _l = Object.prototype;
function Tc(r, t, e) {
  if (typeof t != "string") {
    if (_l) {
      var s = Ff(t);
      s && s !== _l && Tc(r, s, e);
    }
    var n = Bf(t);
    El && (n = n.concat(El(t)));
    for (var i = wl(r), o = wl(t), a = 0; a < n.length; ++a) {
      var l = n[a];
      if (!(l in qf || e && e[l] || o && l in o || i && l in i)) {
        var c = Df(t, l);
        try {
          Mf(r, l, c);
        } catch {
        }
      }
    }
  }
  return r;
}
function es(r) {
  return typeof r == "function";
}
function Fa(r) {
  return typeof r == "object" && "styledComponentId" in r;
}
function dr(r, t) {
  return r && t ? "".concat(r, " ").concat(t) : r || t || "";
}
function Al(r, t) {
  if (r.length === 0) return "";
  for (var e = r[0], s = 1; s < r.length; s++) e += r[s];
  return e;
}
function rs(r) {
  return r !== null && typeof r == "object" && r.constructor.name === Object.name && !("props" in r && r.$$typeof);
}
function Zo(r, t, e) {
  if (e === void 0 && (e = !1), !e && !rs(r) && !Array.isArray(r)) return t;
  if (Array.isArray(t)) for (var s = 0; s < t.length; s++) r[s] = Zo(r[s], t[s]);
  else if (rs(t)) for (var s in t) r[s] = Zo(r[s], t[s]);
  return r;
}
function Pa(r, t) {
  Object.defineProperty(r, "toString", { value: t });
}
var Pf = process.env.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
`, 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function Vf() {
  for (var r = [], t = 0; t < arguments.length; t++) r[t] = arguments[t];
  for (var e = r[0], s = [], n = 1, i = r.length; n < i; n += 1) s.push(r[n]);
  return s.forEach(function(o) {
    e = e.replace(/%[a-z]/, o);
  }), e;
}
function as(r) {
  for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
  return process.env.NODE_ENV === "production" ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(r, " for more information.").concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : "")) : new Error(Vf.apply(void 0, Yr([Pf[r]], t, !1)).trim());
}
var Uf = function() {
  function r(t) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t;
  }
  return r.prototype.indexOfGroup = function(t) {
    for (var e = 0, s = 0; s < t; s++) e += this.groupSizes[s];
    return e;
  }, r.prototype.insertRules = function(t, e) {
    if (t >= this.groupSizes.length) {
      for (var s = this.groupSizes, n = s.length, i = n; t >= i; ) if ((i <<= 1) < 0) throw as(16, "".concat(t));
      this.groupSizes = new Uint32Array(i), this.groupSizes.set(s), this.length = i;
      for (var o = n; o < i; o++) this.groupSizes[o] = 0;
    }
    for (var a = this.indexOfGroup(t + 1), l = (o = 0, e.length); o < l; o++) this.tag.insertRule(a, e[o]) && (this.groupSizes[t]++, a++);
  }, r.prototype.clearGroup = function(t) {
    if (t < this.length) {
      var e = this.groupSizes[t], s = this.indexOfGroup(t), n = s + e;
      this.groupSizes[t] = 0;
      for (var i = s; i < n; i++) this.tag.deleteRule(s);
    }
  }, r.prototype.getGroup = function(t) {
    var e = "";
    if (t >= this.length || this.groupSizes[t] === 0) return e;
    for (var s = this.groupSizes[t], n = this.indexOfGroup(t), i = n + s, o = n; o < i; o++) e += "".concat(this.tag.getRule(o)).concat(Da);
    return e;
  }, r;
}(), $f = 1 << 30, In = /* @__PURE__ */ new Map(), Kn = /* @__PURE__ */ new Map(), qn = 1, yn = function(r) {
  if (In.has(r)) return In.get(r);
  for (; Kn.has(qn); ) qn++;
  var t = qn++;
  if (process.env.NODE_ENV !== "production" && ((0 | t) < 0 || t > $f)) throw as(16, "".concat(t));
  return In.set(r, t), Kn.set(t, r), t;
}, zf = function(r, t) {
  qn = t + 1, In.set(r, t), Kn.set(t, r);
}, Hf = "style[".concat(gr, "][").concat(Ec, '="').concat(oi, '"]'), Kf = new RegExp("^".concat(gr, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), Gf = function(r, t, e) {
  for (var s, n = e.split(","), i = 0, o = n.length; i < o; i++) (s = n[i]) && r.registerName(t, s);
}, Wf = function(r, t) {
  for (var e, s = ((e = t.textContent) !== null && e !== void 0 ? e : "").split(Da), n = [], i = 0, o = s.length; i < o; i++) {
    var a = s[i].trim();
    if (a) {
      var l = a.match(Kf);
      if (l) {
        var c = 0 | parseInt(l[1], 10), d = l[2];
        c !== 0 && (zf(d, c), Gf(r, d, l[3]), r.getTag().insertRules(c, n)), n.length = 0;
      } else n.push(a);
    }
  }
}, Nl = function(r) {
  for (var t = document.querySelectorAll(Hf), e = 0, s = t.length; e < s; e++) {
    var n = t[e];
    n && n.getAttribute(gr) !== wc && (Wf(r, n), n.parentNode && n.parentNode.removeChild(n));
  }
};
function Zf() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var Rc = function(r) {
  var t = document.head, e = r || t, s = document.createElement("style"), n = function(a) {
    var l = Array.from(a.querySelectorAll("style[".concat(gr, "]")));
    return l[l.length - 1];
  }(e), i = n !== void 0 ? n.nextSibling : null;
  s.setAttribute(gr, wc), s.setAttribute(Ec, oi);
  var o = Zf();
  return o && s.setAttribute("nonce", o), e.insertBefore(s, i), s;
}, Xf = function() {
  function r(t) {
    this.element = Rc(t), this.element.appendChild(document.createTextNode("")), this.sheet = function(e) {
      if (e.sheet) return e.sheet;
      for (var s = document.styleSheets, n = 0, i = s.length; n < i; n++) {
        var o = s[n];
        if (o.ownerNode === e) return o;
      }
      throw as(17);
    }(this.element), this.length = 0;
  }
  return r.prototype.insertRule = function(t, e) {
    try {
      return this.sheet.insertRule(e, t), this.length++, !0;
    } catch {
      return !1;
    }
  }, r.prototype.deleteRule = function(t) {
    this.sheet.deleteRule(t), this.length--;
  }, r.prototype.getRule = function(t) {
    var e = this.sheet.cssRules[t];
    return e && e.cssText ? e.cssText : "";
  }, r;
}(), Yf = function() {
  function r(t) {
    this.element = Rc(t), this.nodes = this.element.childNodes, this.length = 0;
  }
  return r.prototype.insertRule = function(t, e) {
    if (t <= this.length && t >= 0) {
      var s = document.createTextNode(e);
      return this.element.insertBefore(s, this.nodes[t] || null), this.length++, !0;
    }
    return !1;
  }, r.prototype.deleteRule = function(t) {
    this.element.removeChild(this.nodes[t]), this.length--;
  }, r.prototype.getRule = function(t) {
    return t < this.length ? this.nodes[t].textContent : "";
  }, r;
}(), Jf = function() {
  function r(t) {
    this.rules = [], this.length = 0;
  }
  return r.prototype.insertRule = function(t, e) {
    return t <= this.length && (this.rules.splice(t, 0, e), this.length++, !0);
  }, r.prototype.deleteRule = function(t) {
    this.rules.splice(t, 1), this.length--;
  }, r.prototype.getRule = function(t) {
    return t < this.length ? this.rules[t] : "";
  }, r;
}(), Sl = Hn, Qf = { isServer: !Hn, useCSSOMInjection: !Af }, Lc = function() {
  function r(t, e, s) {
    t === void 0 && (t = ts), e === void 0 && (e = {});
    var n = this;
    this.options = Wt(Wt({}, Qf), t), this.gs = e, this.names = new Map(s), this.server = !!t.isServer, !this.server && Hn && Sl && (Sl = !1, Nl(this)), Pa(this, function() {
      return function(i) {
        for (var o = i.getTag(), a = o.length, l = "", c = function(g) {
          var h = function(_) {
            return Kn.get(_);
          }(g);
          if (h === void 0) return "continue";
          var f = i.names.get(h), v = o.getGroup(g);
          if (f === void 0 || !f.size || v.length === 0) return "continue";
          var m = "".concat(gr, ".g").concat(g, '[id="').concat(h, '"]'), k = "";
          f !== void 0 && f.forEach(function(_) {
            _.length > 0 && (k += "".concat(_, ","));
          }), l += "".concat(v).concat(m, '{content:"').concat(k, '"}').concat(Da);
        }, d = 0; d < a; d++) c(d);
        return l;
      }(n);
    });
  }
  return r.registerId = function(t) {
    return yn(t);
  }, r.prototype.rehydrate = function() {
    !this.server && Hn && Nl(this);
  }, r.prototype.reconstructWithOptions = function(t, e) {
    return e === void 0 && (e = !0), new r(Wt(Wt({}, this.options), t), this.gs, e && this.names || void 0);
  }, r.prototype.allocateGSInstance = function(t) {
    return this.gs[t] = (this.gs[t] || 0) + 1;
  }, r.prototype.getTag = function() {
    return this.tag || (this.tag = (t = function(e) {
      var s = e.useCSSOMInjection, n = e.target;
      return e.isServer ? new Jf(n) : s ? new Xf(n) : new Yf(n);
    }(this.options), new Uf(t)));
    var t;
  }, r.prototype.hasNameForId = function(t, e) {
    return this.names.has(t) && this.names.get(t).has(e);
  }, r.prototype.registerName = function(t, e) {
    if (yn(t), this.names.has(t)) this.names.get(t).add(e);
    else {
      var s = /* @__PURE__ */ new Set();
      s.add(e), this.names.set(t, s);
    }
  }, r.prototype.insertRules = function(t, e, s) {
    this.registerName(t, e), this.getTag().insertRules(yn(t), s);
  }, r.prototype.clearNames = function(t) {
    this.names.has(t) && this.names.get(t).clear();
  }, r.prototype.clearRules = function(t) {
    this.getTag().clearGroup(yn(t)), this.clearNames(t);
  }, r.prototype.clearTag = function() {
    this.tag = void 0;
  }, r;
}(), tm = /&/g, em = /^\s*\/\/.*$/gm;
function Ic(r, t) {
  return r.map(function(e) {
    return e.type === "rule" && (e.value = "".concat(t, " ").concat(e.value), e.value = e.value.replaceAll(",", ",".concat(t, " ")), e.props = e.props.map(function(s) {
      return "".concat(t, " ").concat(s);
    })), Array.isArray(e.children) && e.type !== "@keyframes" && (e.children = Ic(e.children, t)), e;
  });
}
function rm(r) {
  var t, e, s, n = ts, i = n.options, o = i === void 0 ? ts : i, a = n.plugins, l = a === void 0 ? ai : a, c = function(h, f, v) {
    return v.startsWith(e) && v.endsWith(e) && v.replaceAll(e, "").length > 0 ? ".".concat(t) : h;
  }, d = l.slice();
  d.push(function(h) {
    h.type === ri && h.value.includes("&") && (h.props[0] = h.props[0].replace(tm, e).replace(s, c));
  }), o.prefix && d.push(Ef), d.push(kf);
  var g = function(h, f, v, m) {
    f === void 0 && (f = ""), v === void 0 && (v = ""), m === void 0 && (m = "&"), t = m, e = f, s = new RegExp("\\".concat(e, "\\b"), "g");
    var k = h.replace(em, ""), _ = bf(v || f ? "".concat(v, " ").concat(f, " { ").concat(k, " }") : k);
    o.namespace && (_ = Ic(_, o.namespace));
    var E = [];
    return zn(_, xf(d.concat(wf(function(N) {
      return E.push(N);
    })))), E;
  };
  return g.hash = l.length ? l.reduce(function(h, f) {
    return f.name || as(15), hr(h, f.name);
  }, _c).toString() : "", g;
}
var sm = new Lc(), Xo = rm(), qc = ut.createContext({ shouldForwardProp: void 0, styleSheet: sm, stylis: Xo });
qc.Consumer;
ut.createContext(void 0);
function Cl() {
  return _p(qc);
}
var Ol = function() {
  function r(t, e) {
    var s = this;
    this.inject = function(n, i) {
      i === void 0 && (i = Xo);
      var o = s.name + i.hash;
      n.hasNameForId(s.id, o) || n.insertRules(s.id, o, i(s.rules, o, "@keyframes"));
    }, this.name = t, this.id = "sc-keyframes-".concat(t), this.rules = e, Pa(this, function() {
      throw as(12, String(s.name));
    });
  }
  return r.prototype.getName = function(t) {
    return t === void 0 && (t = Xo), this.name + t.hash;
  }, r;
}(), nm = function(r) {
  return r >= "A" && r <= "Z";
};
function Tl(r) {
  for (var t = "", e = 0; e < r.length; e++) {
    var s = r[e];
    if (e === 1 && s === "-" && r[0] === "-") return r;
    nm(s) ? t += "-" + s.toLowerCase() : t += s;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var jc = function(r) {
  return r == null || r === !1 || r === "";
}, Mc = function(r) {
  var t, e, s = [];
  for (var n in r) {
    var i = r[n];
    r.hasOwnProperty(n) && !jc(i) && (Array.isArray(i) && i.isCss || es(i) ? s.push("".concat(Tl(n), ":"), i, ";") : rs(i) ? s.push.apply(s, Yr(Yr(["".concat(n, " {")], Mc(i), !1), ["}"], !1)) : s.push("".concat(Tl(n), ": ").concat((t = n, (e = i) == null || typeof e == "boolean" || e === "" ? "" : typeof e != "number" || e === 0 || t in _f || t.startsWith("--") ? String(e).trim() : "".concat(e, "px")), ";")));
  }
  return s;
};
function mr(r, t, e, s) {
  if (jc(r)) return [];
  if (Fa(r)) return [".".concat(r.styledComponentId)];
  if (es(r)) {
    if (!es(i = r) || i.prototype && i.prototype.isReactComponent || !t) return [r];
    var n = r(t);
    return process.env.NODE_ENV === "production" || typeof n != "object" || Array.isArray(n) || n instanceof Ol || rs(n) || n === null || console.error("".concat(Nc(r), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), mr(n, t, e, s);
  }
  var i;
  return r instanceof Ol ? e ? (r.inject(e, s), [r.getName(s)]) : [r] : rs(r) ? Mc(r) : Array.isArray(r) ? Array.prototype.concat.apply(ai, r.map(function(o) {
    return mr(o, t, e, s);
  })) : [r.toString()];
}
function im(r) {
  for (var t = 0; t < r.length; t += 1) {
    var e = r[t];
    if (es(e) && !Fa(e)) return !1;
  }
  return !0;
}
var om = Ac(oi), am = function() {
  function r(t, e, s) {
    this.rules = t, this.staticRulesId = "", this.isStatic = process.env.NODE_ENV === "production" && (s === void 0 || s.isStatic) && im(t), this.componentId = e, this.baseHash = hr(om, e), this.baseStyle = s, Lc.registerId(e);
  }
  return r.prototype.generateAndInjectStyles = function(t, e, s) {
    var n = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t, e, s) : "";
    if (this.isStatic && !s.hash) if (this.staticRulesId && e.hasNameForId(this.componentId, this.staticRulesId)) n = dr(n, this.staticRulesId);
    else {
      var i = Al(mr(this.rules, t, e, s)), o = Wo(hr(this.baseHash, i) >>> 0);
      if (!e.hasNameForId(this.componentId, o)) {
        var a = s(i, ".".concat(o), void 0, this.componentId);
        e.insertRules(this.componentId, o, a);
      }
      n = dr(n, o), this.staticRulesId = o;
    }
    else {
      for (var l = hr(this.baseHash, s.hash), c = "", d = 0; d < this.rules.length; d++) {
        var g = this.rules[d];
        if (typeof g == "string") c += g, process.env.NODE_ENV !== "production" && (l = hr(l, g));
        else if (g) {
          var h = Al(mr(g, t, e, s));
          l = hr(l, h + d), c += h;
        }
      }
      if (c) {
        var f = Wo(l >>> 0);
        e.hasNameForId(this.componentId, f) || e.insertRules(this.componentId, f, s(c, ".".concat(f), void 0, this.componentId)), n = dr(n, f);
      }
    }
    return n;
  }, r;
}(), Bc = ut.createContext(void 0);
Bc.Consumer;
var xo = {}, Rl = /* @__PURE__ */ new Set();
function lm(r, t, e) {
  var s = Fa(r), n = r, i = !ko(r), o = t.attrs, a = o === void 0 ? ai : o, l = t.componentId, c = l === void 0 ? function(q, A) {
    var X = typeof q != "string" ? "sc" : kl(q);
    xo[X] = (xo[X] || 0) + 1;
    var G = "".concat(X, "-").concat(Rf(oi + X + xo[X]));
    return A ? "".concat(A, "-").concat(G) : G;
  }(t.displayName, t.parentComponentId) : l, d = t.displayName, g = d === void 0 ? function(q) {
    return ko(q) ? "styled.".concat(q) : "Styled(".concat(Nc(q), ")");
  }(r) : d, h = t.displayName && t.componentId ? "".concat(kl(t.displayName), "-").concat(t.componentId) : t.componentId || c, f = s && n.attrs ? n.attrs.concat(a).filter(Boolean) : a, v = t.shouldForwardProp;
  if (s && n.shouldForwardProp) {
    var m = n.shouldForwardProp;
    if (t.shouldForwardProp) {
      var k = t.shouldForwardProp;
      v = function(q, A) {
        return m(q, A) && k(q, A);
      };
    } else v = m;
  }
  var _ = new am(e, h, s ? n.componentStyle : void 0);
  function E(q, A) {
    return function(X, G, ct) {
      var mt = X.attrs, xt = X.componentStyle, b = X.defaultProps, M = X.foldedComponentIds, x = X.styledComponentId, $ = X.target, P = ut.useContext(Bc), S = Cl(), B = X.shouldForwardProp || S.shouldForwardProp;
      process.env.NODE_ENV !== "production" && fl(x);
      var W = Sf(G, P, b) || ts, Z = function(U, Y, j) {
        for (var D, H = Wt(Wt({}, Y), { className: void 0, theme: j }), F = 0; F < U.length; F += 1) {
          var J = es(D = U[F]) ? D(H) : D;
          for (var T in J) H[T] = T === "className" ? dr(H[T], J[T]) : T === "style" ? Wt(Wt({}, H[T]), J[T]) : J[T];
        }
        return Y.className && (H.className = dr(H.className, Y.className)), H;
      }(mt, G, W), w = Z.as || $, L = {};
      for (var V in Z) Z[V] === void 0 || V[0] === "$" || V === "as" || V === "theme" && Z.theme === W || (V === "forwardedAs" ? L.as = Z.forwardedAs : B && !B(V, w) || (L[V] = Z[V], B || process.env.NODE_ENV !== "development" || nf(V) || Rl.has(V) || !Go.has(w) || (Rl.add(V), console.warn('styled-components: it looks like an unknown prop "'.concat(V, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var K = function(U, Y) {
        var j = Cl(), D = U.generateAndInjectStyles(Y, j.styleSheet, j.stylis);
        return process.env.NODE_ENV !== "production" && fl(D), D;
      }(xt, Z);
      process.env.NODE_ENV !== "production" && X.warnTooManyClasses && X.warnTooManyClasses(K);
      var z = dr(M, x);
      return K && (z += " " + K), Z.className && (z += " " + Z.className), L[ko(w) && !Go.has(w) ? "class" : "className"] = z, ct && (L.ref = ct), wp(w, L);
    }(N, q, A);
  }
  E.displayName = g;
  var N = ut.forwardRef(E);
  return N.attrs = f, N.componentStyle = _, N.displayName = g, N.shouldForwardProp = v, N.foldedComponentIds = s ? dr(n.foldedComponentIds, n.styledComponentId) : "", N.styledComponentId = h, N.target = s ? n.target : r, Object.defineProperty(N, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(q) {
    this._foldedDefaultProps = s ? function(A) {
      for (var X = [], G = 1; G < arguments.length; G++) X[G - 1] = arguments[G];
      for (var ct = 0, mt = X; ct < mt.length; ct++) Zo(A, mt[ct], !0);
      return A;
    }({}, n.defaultProps, q) : q;
  } }), process.env.NODE_ENV !== "production" && (Nf(g, h), N.warnTooManyClasses = /* @__PURE__ */ function(q, A) {
    var X = {}, G = !1;
    return function(ct) {
      if (!G && (X[ct] = !0, Object.keys(X).length >= 200)) {
        var mt = A ? ' with the id of "'.concat(A, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(q).concat(mt, `.
`) + `Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), G = !0, X = {};
      }
    };
  }(g, h)), Pa(N, function() {
    return ".".concat(N.styledComponentId);
  }), i && Tc(N, r, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), N;
}
function Ll(r, t) {
  for (var e = [r[0]], s = 0, n = t.length; s < n; s += 1) e.push(t[s], r[s + 1]);
  return e;
}
var Il = function(r) {
  return Object.assign(r, { isCss: !0 });
};
function um(r) {
  for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e];
  if (es(r) || rs(r)) return Il(mr(Ll(ai, Yr([r], t, !0))));
  var s = r;
  return t.length === 0 && s.length === 1 && typeof s[0] == "string" ? mr(s) : Il(mr(Ll(s, t)));
}
function Yo(r, t, e) {
  if (e === void 0 && (e = ts), !t) throw as(1, t);
  var s = function(n) {
    for (var i = [], o = 1; o < arguments.length; o++) i[o - 1] = arguments[o];
    return r(t, e, um.apply(void 0, Yr([n], i, !1)));
  };
  return s.attrs = function(n) {
    return Yo(r, t, Wt(Wt({}, e), { attrs: Array.prototype.concat(e.attrs, n).filter(Boolean) }));
  }, s.withConfig = function(n) {
    return Yo(r, t, Wt(Wt({}, e), n));
  }, s;
}
var Dc = function(r) {
  return Yo(lm, r);
}, Va = Dc;
Go.forEach(function(r) {
  Va[r] = Dc(r);
});
process.env.NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`);
var kn = "__sc-".concat(gr, "__");
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && typeof window < "u" && (window[kn] || (window[kn] = 0), window[kn] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window[kn] += 1);
const cm = Va.div`
  .filepond {
    &--drop-label {
      label {
        color: ${({ $invalid: r }) => r ? "var(--color-item-primary-destructive)" : "inherit"} !important;
      }
    }

    &--root {
      margin-bottom: 0.5rem;
      border-radius: 0.75rem;
    }

    &--panel {
      border-radius: 0.8rem;
      overflow: hidden;

      &-root {
        background-color: transparent;
      }
    }

    &--drip {
      border: 1px solid
        ${({ $invalid: r }) => r ? "var(--color-item-primary-destructive)" : "var(--color-border-alpha-strong)"};
      background-color: transparent;
      opacity: 1;
      outline-offset: 2px;
      border-radius: 0.75rem;
    }
  }

  &:focus-within {
    .filepond {
      &--drip {
        outline: 2px solid
          ${({ $invalid: r }) => r ? "var(--color-item-primary-destructive)" : "var(--color-item-primary-primary)"};
      }
    }
  }
`;
function hm({
  variant: r = "default",
  ...t
}) {
  return /* @__PURE__ */ R.jsx(cm, { $invalid: r === "failure", ...t });
}
hm.displayName = "FilepondContainer";
var dm = "Label", Fc = C.forwardRef((r, t) => /* @__PURE__ */ R.jsx(
  Ct.label,
  {
    ...r,
    ref: t,
    onMouseDown: (e) => {
      var s;
      e.target.closest("button, input, select, textarea") || ((s = r.onMouseDown) == null || s.call(r, e), !e.defaultPrevented && e.detail > 1 && e.preventDefault());
    }
  }
));
Fc.displayName = dm;
var Pc = Fc, pm = (r) => r.type === "checkbox", fm = (r) => r instanceof Date, Vc = (r) => r == null;
const mm = (r) => typeof r == "object";
var Hs = (r) => !Vc(r) && !Array.isArray(r) && mm(r) && !fm(r), gm = (r) => Hs(r) && r.target ? pm(r.target) ? r.target.checked : r.target.value : r, vm = (r) => r.substring(0, r.search(/\.\d+(\.|$)/)) || r, bm = (r, t) => r.has(vm(t)), ym = (r) => {
  const t = r.constructor && r.constructor.prototype;
  return Hs(t) && t.hasOwnProperty("isPrototypeOf");
}, km = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function Uc(r) {
  let t;
  const e = Array.isArray(r), s = typeof FileList < "u" ? r instanceof FileList : !1;
  if (r instanceof Date)
    t = new Date(r);
  else if (!(km && (r instanceof Blob || s)) && (e || Hs(r)))
    if (t = e ? [] : {}, !e && !ym(r))
      t = r;
    else
      for (const n in r)
        r.hasOwnProperty(n) && (t[n] = Uc(r[n]));
  else
    return r;
  return t;
}
var $c = (r) => /^\w*$/.test(r), Jo = (r) => r === void 0, xm = (r) => Array.isArray(r) ? r.filter(Boolean) : [], zc = (r) => xm(r.replace(/["|']|\]/g, "").split(/\.|\[/)), Gt = (r, t, e) => {
  if (!t || !Hs(r))
    return e;
  const s = ($c(t) ? [t] : zc(t)).reduce((n, i) => Vc(n) ? n : n[i], r);
  return Jo(s) || s === r ? Jo(r[t]) ? e : r[t] : s;
}, wo = (r) => typeof r == "boolean", ql = (r, t, e) => {
  let s = -1;
  const n = $c(t) ? [t] : zc(t), i = n.length, o = i - 1;
  for (; ++s < i; ) {
    const a = n[s];
    let l = e;
    if (s !== o) {
      const c = r[a];
      l = Hs(c) || Array.isArray(c) ? c : isNaN(+n[s + 1]) ? {} : [];
    }
    if (a === "__proto__" || a === "constructor" || a === "prototype")
      return;
    r[a] = l, r = r[a];
  }
};
const jl = {
  BLUR: "blur",
  CHANGE: "change"
}, Ml = {
  all: "all"
}, Ua = ut.createContext(null);
Ua.displayName = "HookFormContext";
const li = () => ut.useContext(Ua), wm = (r) => {
  const { children: t, ...e } = r;
  return ut.createElement(Ua.Provider, { value: e }, t);
};
var Em = (r, t, e, s = !0) => {
  const n = {
    defaultValues: t._defaultValues
  };
  for (const i in r)
    Object.defineProperty(n, i, {
      get: () => {
        const o = i;
        return t._proxyFormState[o] !== Ml.all && (t._proxyFormState[o] = !s || Ml.all), e && (e[o] = !0), r[o];
      }
    });
  return n;
};
const Hc = typeof window < "u" ? C.useLayoutEffect : C.useEffect;
function _m(r) {
  const t = li(), { control: e = t.control, disabled: s, name: n, exact: i } = r || {}, [o, a] = ut.useState(e._formState), l = ut.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    validatingFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  });
  return Hc(() => e._subscribe({
    name: n,
    formState: l.current,
    exact: i,
    callback: (c) => {
      !s && a({
        ...e._formState,
        ...c
      });
    }
  }), [n, s, i]), ut.useEffect(() => {
    l.current.isValid && e._setValid(!0);
  }, [e]), ut.useMemo(() => Em(o, e, l.current, !1), [o, e]);
}
var Am = (r) => typeof r == "string", Nm = (r, t, e, s, n) => Am(r) ? Gt(e, r, n) : Array.isArray(r) ? r.map((i) => Gt(e, i)) : e;
function Sm(r) {
  const t = li(), { control: e = t.control, name: s, defaultValue: n, disabled: i, exact: o } = r || {}, a = ut.useRef(n), [l, c] = ut.useState(e._getWatch(s, a.current));
  return Hc(() => e._subscribe({
    name: s,
    formState: {
      values: !0
    },
    exact: o,
    callback: (d) => !i && c(Nm(s, e._names, d.values || e._formValues, !1, a.current))
  }), [s, e, i, o]), ut.useEffect(() => e._removeUnmounted()), l;
}
function Cm(r) {
  const t = li(), { name: e, disabled: s, control: n = t.control, shouldUnregister: i } = r, o = bm(n._names.array, e), a = Sm({
    control: n,
    name: e,
    defaultValue: Gt(n._formValues, e, Gt(n._defaultValues, e, r.defaultValue)),
    exact: !0
  }), l = _m({
    control: n,
    name: e,
    exact: !0
  }), c = ut.useRef(r), d = ut.useRef(n.register(e, {
    ...r.rules,
    value: a,
    ...wo(r.disabled) ? { disabled: r.disabled } : {}
  })), g = ut.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: !0,
      get: () => !!Gt(l.errors, e)
    },
    isDirty: {
      enumerable: !0,
      get: () => !!Gt(l.dirtyFields, e)
    },
    isTouched: {
      enumerable: !0,
      get: () => !!Gt(l.touchedFields, e)
    },
    isValidating: {
      enumerable: !0,
      get: () => !!Gt(l.validatingFields, e)
    },
    error: {
      enumerable: !0,
      get: () => Gt(l.errors, e)
    }
  }), [l, e]), h = ut.useCallback((k) => d.current.onChange({
    target: {
      value: gm(k),
      name: e
    },
    type: jl.CHANGE
  }), [e]), f = ut.useCallback(() => d.current.onBlur({
    target: {
      value: Gt(n._formValues, e),
      name: e
    },
    type: jl.BLUR
  }), [e, n._formValues]), v = ut.useCallback((k) => {
    const _ = Gt(n._fields, e);
    _ && k && (_._f.ref = {
      focus: () => k.focus && k.focus(),
      select: () => k.select && k.select(),
      setCustomValidity: (E) => k.setCustomValidity(E),
      reportValidity: () => k.reportValidity()
    });
  }, [n._fields, e]), m = ut.useMemo(() => ({
    name: e,
    value: a,
    ...wo(s) || l.disabled ? { disabled: l.disabled || s } : {},
    onChange: h,
    onBlur: f,
    ref: v
  }), [e, s, l.disabled, h, f, v, a]);
  return ut.useEffect(() => {
    const k = n._options.shouldUnregister || i;
    n.register(e, {
      ...c.current.rules,
      ...wo(c.current.disabled) ? { disabled: c.current.disabled } : {}
    });
    const _ = (E, N) => {
      const q = Gt(n._fields, E);
      q && q._f && (q._f.mount = N);
    };
    if (_(e, !0), k) {
      const E = Uc(Gt(n._options.defaultValues, e));
      ql(n._defaultValues, e, E), Jo(Gt(n._formValues, e)) && ql(n._formValues, e, E);
    }
    return !o && n.register(e), () => {
      (o ? k && !n._state.action : k) ? n.unregister(e) : _(e, !1);
    };
  }, [e, n, o, i]), ut.useEffect(() => {
    n._setDisabledField({
      disabled: s,
      name: e
    });
  }, [s, e, n]), ut.useMemo(() => ({
    field: m,
    formState: l,
    fieldState: g
  }), [m, l, g]);
}
const Om = (r) => r.render(Cm(r)), Tm = La(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
), Kc = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  Pc,
  {
    ref: e,
    className: St(Tm(), r),
    ...t
  }
));
Kc.displayName = Pc.displayName;
const aw = wm, Gc = C.createContext(
  {}
), lw = ({
  ...r
}) => /* @__PURE__ */ R.jsx(Gc.Provider, { value: { name: r.name }, children: /* @__PURE__ */ R.jsx(Om, { ...r }) }), ui = () => {
  const r = C.useContext(Gc), t = C.useContext(Wc), { getFieldState: e, formState: s } = li(), n = e(r.name, s);
  if (!r)
    throw new Error("useFormField should be used within <FormField>");
  const { id: i } = t;
  return {
    id: i,
    name: r.name,
    formItemId: `${i}-form-item`,
    formDescriptionId: `${i}-form-item-description`,
    formMessageId: `${i}-form-item-message`,
    ...n
  };
}, Wc = C.createContext(
  {}
), Rm = C.forwardRef(({ className: r, ...t }, e) => {
  const s = C.useId();
  return /* @__PURE__ */ R.jsx(Wc.Provider, { value: { id: s }, children: /* @__PURE__ */ R.jsx(
    "div",
    {
      ref: e,
      className: St("relative space-y-2", r),
      ...t
    }
  ) });
});
Rm.displayName = "FormItem";
const Lm = C.forwardRef(({ className: r, ...t }, e) => {
  const { error: s, formItemId: n } = ui();
  return /* @__PURE__ */ R.jsx(
    Kc,
    {
      ref: e,
      className: St(
        "!text-body-xs-medium",
        r,
        s && "text-destructive"
      ),
      htmlFor: n,
      ...t
    }
  );
});
Lm.displayName = "FormLabel";
const Im = C.forwardRef(({ ...r }, t) => {
  const { error: e, formItemId: s, formDescriptionId: n, formMessageId: i } = ui();
  return /* @__PURE__ */ R.jsx(
    gp,
    {
      ref: t,
      id: s,
      "aria-describedby": e ? `${n} ${i}` : `${n}`,
      "aria-invalid": !!e,
      ...r
    }
  );
});
Im.displayName = "FormControl";
const qm = C.forwardRef(({ className: r, ...t }, e) => {
  const { formDescriptionId: s } = ui();
  return /* @__PURE__ */ R.jsx(
    "p",
    {
      ref: e,
      id: s,
      className: St("text-muted-foreground text-sm", r),
      ...t
    }
  );
});
qm.displayName = "FormDescription";
const jm = C.forwardRef(({ className: r, children: t, ...e }, s) => {
  const { error: n, formMessageId: i } = ui(), o = n ? String(n == null ? void 0 : n.message) : t;
  return o ? /* @__PURE__ */ R.jsx(
    "p",
    {
      ref: s,
      id: i,
      className: St("!text-body-xs-medium text-destructive", r),
      ...e,
      children: o
    }
  ) : null;
});
jm.displayName = "FormMessage";
var ci = "Switch", [Mm, uw] = zs(ci), [Bm, Dm] = Mm(ci), Zc = C.forwardRef(
  (r, t) => {
    const {
      __scopeSwitch: e,
      name: s,
      checked: n,
      defaultChecked: i,
      required: o,
      disabled: a,
      value: l = "on",
      onCheckedChange: c,
      form: d,
      ...g
    } = r, [h, f] = C.useState(null), v = Mt(t, (N) => f(N)), m = C.useRef(!1), k = h ? d || !!h.closest("form") : !0, [_, E] = js({
      prop: n,
      defaultProp: i ?? !1,
      onChange: c,
      caller: ci
    });
    return /* @__PURE__ */ R.jsxs(Bm, { scope: e, checked: _, disabled: a, children: [
      /* @__PURE__ */ R.jsx(
        Ct.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": _,
          "aria-required": o,
          "data-state": Qc(_),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: l,
          ...g,
          ref: v,
          onClick: Nt(r.onClick, (N) => {
            E((q) => !q), k && (m.current = N.isPropagationStopped(), m.current || N.stopPropagation());
          })
        }
      ),
      k && /* @__PURE__ */ R.jsx(
        Jc,
        {
          control: h,
          bubbles: !m.current,
          name: s,
          value: l,
          checked: _,
          required: o,
          disabled: a,
          form: d,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Zc.displayName = ci;
var Xc = "SwitchThumb", Yc = C.forwardRef(
  (r, t) => {
    const { __scopeSwitch: e, ...s } = r, n = Dm(Xc, e);
    return /* @__PURE__ */ R.jsx(
      Ct.span,
      {
        "data-state": Qc(n.checked),
        "data-disabled": n.disabled ? "" : void 0,
        ...s,
        ref: t
      }
    );
  }
);
Yc.displayName = Xc;
var Fm = "SwitchBubbleInput", Jc = C.forwardRef(
  ({
    __scopeSwitch: r,
    control: t,
    checked: e,
    bubbles: s = !0,
    ...n
  }, i) => {
    const o = C.useRef(null), a = Mt(o, i), l = ti(e), c = Ta(t);
    return C.useEffect(() => {
      const d = o.current;
      if (!d) return;
      const g = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(
        g,
        "checked"
      ).set;
      if (l !== e && h) {
        const f = new Event("click", { bubbles: s });
        h.call(d, e), d.dispatchEvent(f);
      }
    }, [l, e, s]), /* @__PURE__ */ R.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: e,
        ...n,
        tabIndex: -1,
        ref: a,
        style: {
          ...n.style,
          ...c,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
Jc.displayName = Fm;
function Qc(r) {
  return r ? "checked" : "unchecked";
}
var th = Zc, Pm = Yc;
const Vm = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  th,
  {
    className: St(
      "peer focus-visible:ring-ring focus-visible:ring-offset-background data-[state=checked]:bg-item-primary data-[state=unchecked]:bg-input inline-flex h-4 w-7 shrink-0 cursor-pointer items-center rounded-full border border-transparent transition-colors focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-40",
      r
    ),
    ...t,
    ref: e,
    children: /* @__PURE__ */ R.jsx(
      Pm,
      {
        className: St(
          "bg-background pointer-events-none block size-3.5 rounded-full shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-3 data-[state=unchecked]:translate-x-0"
        )
      }
    )
  }
));
Vm.displayName = th.displayName;
const Um = C.forwardRef(
  ({ className: r, variant: t, ...e }, s) => /* @__PURE__ */ R.jsx(
    "textarea",
    {
      className: St(
        "min-h-20 px-3 py-2",
        ja({ variant: t }),
        r
      ),
      ref: s,
      ...e
    }
  )
);
Um.displayName = "Textarea";
var $m = [" ", "Enter", "ArrowUp", "ArrowDown"], zm = [" ", "Enter"], vr = "Select", [hi, di, Hm] = jp(vr), [ls, cw] = zs(vr, [
  Hm,
  rc
]), pi = rc(), [Km, Je] = ls(vr), [Gm, Wm] = ls(vr), eh = (r) => {
  const {
    __scopeSelect: t,
    children: e,
    open: s,
    defaultOpen: n,
    onOpenChange: i,
    value: o,
    defaultValue: a,
    onValueChange: l,
    dir: c,
    name: d,
    autoComplete: g,
    disabled: h,
    required: f,
    form: v
  } = r, m = pi(t), [k, _] = C.useState(null), [E, N] = C.useState(null), [q, A] = C.useState(!1), X = nc(c), [G, ct] = js({
    prop: s,
    defaultProp: n ?? !1,
    onChange: i,
    caller: vr
  }), [mt, xt] = js({
    prop: o,
    defaultProp: a,
    onChange: l,
    caller: vr
  }), b = C.useRef(null), M = k ? v || !!k.closest("form") : !0, [x, $] = C.useState(/* @__PURE__ */ new Set()), P = Array.from(x).map((S) => S.props.value).join(";");
  return /* @__PURE__ */ R.jsx(Ap, { ...m, children: /* @__PURE__ */ R.jsxs(
    Km,
    {
      required: f,
      scope: t,
      trigger: k,
      onTriggerChange: _,
      valueNode: E,
      onValueNodeChange: N,
      valueNodeHasChildren: q,
      onValueNodeHasChildrenChange: A,
      contentId: Oa(),
      value: mt,
      onValueChange: xt,
      open: G,
      onOpenChange: ct,
      dir: X,
      triggerPointerDownPosRef: b,
      disabled: h,
      children: [
        /* @__PURE__ */ R.jsx(hi.Provider, { scope: t, children: /* @__PURE__ */ R.jsx(
          Gm,
          {
            scope: r.__scopeSelect,
            onNativeOptionAdd: C.useCallback((S) => {
              $((B) => new Set(B).add(S));
            }, []),
            onNativeOptionRemove: C.useCallback((S) => {
              $((B) => {
                const W = new Set(B);
                return W.delete(S), W;
              });
            }, []),
            children: e
          }
        ) }),
        M ? /* @__PURE__ */ R.jsxs(
          Nh,
          {
            "aria-hidden": !0,
            required: f,
            tabIndex: -1,
            name: d,
            autoComplete: g,
            value: mt,
            onChange: (S) => xt(S.target.value),
            disabled: h,
            form: v,
            children: [
              mt === void 0 ? /* @__PURE__ */ R.jsx("option", { value: "" }) : null,
              Array.from(x)
            ]
          },
          P
        ) : null
      ]
    }
  ) });
};
eh.displayName = vr;
var rh = "SelectTrigger", sh = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, disabled: s = !1, ...n } = r, i = pi(e), o = Je(rh, e), a = o.disabled || s, l = Mt(t, o.onTriggerChange), c = di(e), d = C.useRef("touch"), [g, h, f] = Ch((m) => {
      const k = c().filter((N) => !N.disabled), _ = k.find((N) => N.value === o.value), E = Oh(k, m, _);
      E !== void 0 && o.onValueChange(E.value);
    }), v = (m) => {
      a || (o.onOpenChange(!0), f()), m && (o.triggerPointerDownPosRef.current = {
        x: Math.round(m.pageX),
        y: Math.round(m.pageY)
      });
    };
    return /* @__PURE__ */ R.jsx(Np, { asChild: !0, ...i, children: /* @__PURE__ */ R.jsx(
      Ct.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": o.contentId,
        "aria-expanded": o.open,
        "aria-required": o.required,
        "aria-autocomplete": "none",
        dir: o.dir,
        "data-state": o.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": Sh(o.value) ? "" : void 0,
        ...n,
        ref: l,
        onClick: Nt(n.onClick, (m) => {
          m.currentTarget.focus(), d.current !== "mouse" && v(m);
        }),
        onPointerDown: Nt(n.onPointerDown, (m) => {
          d.current = m.pointerType;
          const k = m.target;
          k.hasPointerCapture(m.pointerId) && k.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && m.pointerType === "mouse" && (v(m), m.preventDefault());
        }),
        onKeyDown: Nt(n.onKeyDown, (m) => {
          const k = g.current !== "";
          !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && h(m.key), !(k && m.key === " ") && $m.includes(m.key) && (v(), m.preventDefault());
        })
      }
    ) });
  }
);
sh.displayName = rh;
var nh = "SelectValue", ih = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, className: s, style: n, children: i, placeholder: o = "", ...a } = r, l = Je(nh, e), { onValueNodeHasChildrenChange: c } = l, d = i !== void 0, g = Mt(t, l.onValueNodeChange);
    return Xe(() => {
      c(d);
    }, [c, d]), /* @__PURE__ */ R.jsx(
      Ct.span,
      {
        ...a,
        ref: g,
        style: { pointerEvents: "none" },
        children: Sh(l.value) ? /* @__PURE__ */ R.jsx(R.Fragment, { children: o }) : i
      }
    );
  }
);
ih.displayName = nh;
var Zm = "SelectIcon", oh = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, children: s, ...n } = r;
    return /* @__PURE__ */ R.jsx(Ct.span, { "aria-hidden": !0, ...n, ref: t, children: s || "" });
  }
);
oh.displayName = Zm;
var Xm = "SelectPortal", ah = (r) => /* @__PURE__ */ R.jsx(Fp, { asChild: !0, ...r });
ah.displayName = Xm;
var br = "SelectContent", lh = C.forwardRef(
  (r, t) => {
    const e = Je(br, r.__scopeSelect), [s, n] = C.useState();
    if (Xe(() => {
      n(new DocumentFragment());
    }, []), !e.open) {
      const i = s;
      return i ? sc.createPortal(
        /* @__PURE__ */ R.jsx(uh, { scope: r.__scopeSelect, children: /* @__PURE__ */ R.jsx(hi.Slot, { scope: r.__scopeSelect, children: /* @__PURE__ */ R.jsx("div", { children: r.children }) }) }),
        i
      ) : null;
    }
    return /* @__PURE__ */ R.jsx(ch, { ...r, ref: t });
  }
);
lh.displayName = br;
var oe = 10, [uh, Qe] = ls(br), Ym = "SelectContentImpl", Jm = vp("SelectContent.RemoveScroll"), ch = C.forwardRef(
  (r, t) => {
    const {
      __scopeSelect: e,
      position: s = "item-aligned",
      onCloseAutoFocus: n,
      onEscapeKeyDown: i,
      onPointerDownOutside: o,
      //
      // PopperContent props
      side: a,
      sideOffset: l,
      align: c,
      alignOffset: d,
      arrowPadding: g,
      collisionBoundary: h,
      collisionPadding: f,
      sticky: v,
      hideWhenDetached: m,
      avoidCollisions: k,
      //
      ..._
    } = r, E = Je(br, e), [N, q] = C.useState(null), [A, X] = C.useState(null), G = Mt(t, (j) => q(j)), [ct, mt] = C.useState(null), [xt, b] = C.useState(
      null
    ), M = di(e), [x, $] = C.useState(!1), P = C.useRef(!1);
    C.useEffect(() => {
      if (N) return Pp(N);
    }, [N]), Vp();
    const S = C.useCallback(
      (j) => {
        const [D, ...H] = M().map((T) => T.ref.current), [F] = H.slice(-1), J = document.activeElement;
        for (const T of j)
          if (T === J || (T == null || T.scrollIntoView({ block: "nearest" }), T === D && A && (A.scrollTop = 0), T === F && A && (A.scrollTop = A.scrollHeight), T == null || T.focus(), document.activeElement !== J)) return;
      },
      [M, A]
    ), B = C.useCallback(
      () => S([ct, N]),
      [S, ct, N]
    );
    C.useEffect(() => {
      x && B();
    }, [x, B]);
    const { onOpenChange: W, triggerPointerDownPosRef: Z } = E;
    C.useEffect(() => {
      if (N) {
        let j = { x: 0, y: 0 };
        const D = (F) => {
          var J, T;
          j = {
            x: Math.abs(Math.round(F.pageX) - (((J = Z.current) == null ? void 0 : J.x) ?? 0)),
            y: Math.abs(Math.round(F.pageY) - (((T = Z.current) == null ? void 0 : T.y) ?? 0))
          };
        }, H = (F) => {
          j.x <= 10 && j.y <= 10 ? F.preventDefault() : N.contains(F.target) || W(!1), document.removeEventListener("pointermove", D), Z.current = null;
        };
        return Z.current !== null && (document.addEventListener("pointermove", D), document.addEventListener("pointerup", H, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", D), document.removeEventListener("pointerup", H, { capture: !0 });
        };
      }
    }, [N, W, Z]), C.useEffect(() => {
      const j = () => W(!1);
      return window.addEventListener("blur", j), window.addEventListener("resize", j), () => {
        window.removeEventListener("blur", j), window.removeEventListener("resize", j);
      };
    }, [W]);
    const [w, L] = Ch((j) => {
      const D = M().filter((J) => !J.disabled), H = D.find((J) => J.ref.current === document.activeElement), F = Oh(D, j, H);
      F && setTimeout(() => F.ref.current.focus());
    }), V = C.useCallback(
      (j, D, H) => {
        const F = !P.current && !H;
        (E.value !== void 0 && E.value === D || F) && (mt(j), F && (P.current = !0));
      },
      [E.value]
    ), K = C.useCallback(() => N == null ? void 0 : N.focus(), [N]), z = C.useCallback(
      (j, D, H) => {
        const F = !P.current && !H;
        (E.value !== void 0 && E.value === D || F) && b(j);
      },
      [E.value]
    ), U = s === "popper" ? Qo : hh, Y = U === Qo ? {
      side: a,
      sideOffset: l,
      align: c,
      alignOffset: d,
      arrowPadding: g,
      collisionBoundary: h,
      collisionPadding: f,
      sticky: v,
      hideWhenDetached: m,
      avoidCollisions: k
    } : {};
    return /* @__PURE__ */ R.jsx(
      uh,
      {
        scope: e,
        content: N,
        viewport: A,
        onViewportChange: X,
        itemRefCallback: V,
        selectedItem: ct,
        onItemLeave: K,
        itemTextRefCallback: z,
        focusSelectedItem: B,
        selectedItemText: xt,
        position: s,
        isPositioned: x,
        searchRef: w,
        children: /* @__PURE__ */ R.jsx(Up, { as: Jm, allowPinchZoom: !0, children: /* @__PURE__ */ R.jsx(
          $p,
          {
            asChild: !0,
            trapped: E.open,
            onMountAutoFocus: (j) => {
              j.preventDefault();
            },
            onUnmountAutoFocus: Nt(n, (j) => {
              var D;
              (D = E.trigger) == null || D.focus({ preventScroll: !0 }), j.preventDefault();
            }),
            children: /* @__PURE__ */ R.jsx(
              bp,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: i,
                onPointerDownOutside: o,
                onFocusOutside: (j) => j.preventDefault(),
                onDismiss: () => E.onOpenChange(!1),
                children: /* @__PURE__ */ R.jsx(
                  U,
                  {
                    role: "listbox",
                    id: E.contentId,
                    "data-state": E.open ? "open" : "closed",
                    dir: E.dir,
                    onContextMenu: (j) => j.preventDefault(),
                    ..._,
                    ...Y,
                    onPlaced: () => $(!0),
                    ref: G,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ..._.style
                    },
                    onKeyDown: Nt(_.onKeyDown, (j) => {
                      const D = j.ctrlKey || j.altKey || j.metaKey;
                      if (j.key === "Tab" && j.preventDefault(), !D && j.key.length === 1 && L(j.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(j.key)) {
                        let H = M().filter((F) => !F.disabled).map((F) => F.ref.current);
                        if (["ArrowUp", "End"].includes(j.key) && (H = H.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(j.key)) {
                          const F = j.target, J = H.indexOf(F);
                          H = H.slice(J + 1);
                        }
                        setTimeout(() => S(H)), j.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
ch.displayName = Ym;
var Qm = "SelectItemAlignedPosition", hh = C.forwardRef((r, t) => {
  const { __scopeSelect: e, onPlaced: s, ...n } = r, i = Je(br, e), o = Qe(br, e), [a, l] = C.useState(null), [c, d] = C.useState(null), g = Mt(t, (G) => d(G)), h = di(e), f = C.useRef(!1), v = C.useRef(!0), { viewport: m, selectedItem: k, selectedItemText: _, focusSelectedItem: E } = o, N = C.useCallback(() => {
    if (i.trigger && i.valueNode && a && c && m && k && _) {
      const G = i.trigger.getBoundingClientRect(), ct = c.getBoundingClientRect(), mt = i.valueNode.getBoundingClientRect(), xt = _.getBoundingClientRect();
      if (i.dir !== "rtl") {
        const F = xt.left - ct.left, J = mt.left - F, T = G.left - J, at = G.width + T, yt = Math.max(at, ct.width), At = window.innerWidth - oe, _e = ml(J, [
          oe,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(oe, At - yt)
        ]);
        a.style.minWidth = at + "px", a.style.left = _e + "px";
      } else {
        const F = ct.right - xt.right, J = window.innerWidth - mt.right - F, T = window.innerWidth - G.right - J, at = G.width + T, yt = Math.max(at, ct.width), At = window.innerWidth - oe, _e = ml(J, [
          oe,
          Math.max(oe, At - yt)
        ]);
        a.style.minWidth = at + "px", a.style.right = _e + "px";
      }
      const b = h(), M = window.innerHeight - oe * 2, x = m.scrollHeight, $ = window.getComputedStyle(c), P = parseInt($.borderTopWidth, 10), S = parseInt($.paddingTop, 10), B = parseInt($.borderBottomWidth, 10), W = parseInt($.paddingBottom, 10), Z = P + S + x + W + B, w = Math.min(k.offsetHeight * 5, Z), L = window.getComputedStyle(m), V = parseInt(L.paddingTop, 10), K = parseInt(L.paddingBottom, 10), z = G.top + G.height / 2 - oe, U = M - z, Y = k.offsetHeight / 2, j = k.offsetTop + Y, D = P + S + j, H = Z - D;
      if (D <= z) {
        const F = b.length > 0 && k === b[b.length - 1].ref.current;
        a.style.bottom = "0px";
        const J = c.clientHeight - m.offsetTop - m.offsetHeight, T = Math.max(
          U,
          Y + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (F ? K : 0) + J + B
        ), at = D + T;
        a.style.height = at + "px";
      } else {
        const F = b.length > 0 && k === b[0].ref.current;
        a.style.top = "0px";
        const J = Math.max(
          z,
          P + m.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (F ? V : 0) + Y
        ) + H;
        a.style.height = J + "px", m.scrollTop = D - z + m.offsetTop;
      }
      a.style.margin = `${oe}px 0`, a.style.minHeight = w + "px", a.style.maxHeight = M + "px", s == null || s(), requestAnimationFrame(() => f.current = !0);
    }
  }, [
    h,
    i.trigger,
    i.valueNode,
    a,
    c,
    m,
    k,
    _,
    i.dir,
    s
  ]);
  Xe(() => N(), [N]);
  const [q, A] = C.useState();
  Xe(() => {
    c && A(window.getComputedStyle(c).zIndex);
  }, [c]);
  const X = C.useCallback(
    (G) => {
      G && v.current === !0 && (N(), E == null || E(), v.current = !1);
    },
    [N, E]
  );
  return /* @__PURE__ */ R.jsx(
    eg,
    {
      scope: e,
      contentWrapper: a,
      shouldExpandOnScrollRef: f,
      onScrollButtonChange: X,
      children: /* @__PURE__ */ R.jsx(
        "div",
        {
          ref: l,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: q
          },
          children: /* @__PURE__ */ R.jsx(
            Ct.div,
            {
              ...n,
              ref: g,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...n.style
              }
            }
          )
        }
      )
    }
  );
});
hh.displayName = Qm;
var tg = "SelectPopperPosition", Qo = C.forwardRef((r, t) => {
  const {
    __scopeSelect: e,
    align: s = "start",
    collisionPadding: n = oe,
    ...i
  } = r, o = pi(e);
  return /* @__PURE__ */ R.jsx(
    Sp,
    {
      ...o,
      ...i,
      ref: t,
      align: s,
      collisionPadding: n,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...i.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
Qo.displayName = tg;
var [eg, $a] = ls(br, {}), ta = "SelectViewport", dh = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, nonce: s, ...n } = r, i = Qe(ta, e), o = $a(ta, e), a = Mt(t, i.onViewportChange), l = C.useRef(0);
    return /* @__PURE__ */ R.jsxs(R.Fragment, { children: [
      /* @__PURE__ */ R.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: s
        }
      ),
      /* @__PURE__ */ R.jsx(hi.Slot, { scope: e, children: /* @__PURE__ */ R.jsx(
        Ct.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...n,
          ref: a,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...n.style
          },
          onScroll: Nt(n.onScroll, (c) => {
            const d = c.currentTarget, { contentWrapper: g, shouldExpandOnScrollRef: h } = o;
            if (h != null && h.current && g) {
              const f = Math.abs(l.current - d.scrollTop);
              if (f > 0) {
                const v = window.innerHeight - oe * 2, m = parseFloat(g.style.minHeight), k = parseFloat(g.style.height), _ = Math.max(m, k);
                if (_ < v) {
                  const E = _ + f, N = Math.min(v, E), q = E - N;
                  g.style.height = N + "px", g.style.bottom === "0px" && (d.scrollTop = q > 0 ? q : 0, g.style.justifyContent = "flex-end");
                }
              }
            }
            l.current = d.scrollTop;
          })
        }
      ) })
    ] });
  }
);
dh.displayName = ta;
var ph = "SelectGroup", [rg, sg] = ls(ph), fh = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, ...s } = r, n = Oa();
    return /* @__PURE__ */ R.jsx(rg, { scope: e, id: n, children: /* @__PURE__ */ R.jsx(Ct.div, { role: "group", "aria-labelledby": n, ...s, ref: t }) });
  }
);
fh.displayName = ph;
var mh = "SelectLabel", gh = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, ...s } = r, n = sg(mh, e);
    return /* @__PURE__ */ R.jsx(Ct.div, { id: n.id, ...s, ref: t });
  }
);
gh.displayName = mh;
var Gn = "SelectItem", [ng, vh] = ls(Gn), bh = C.forwardRef(
  (r, t) => {
    const {
      __scopeSelect: e,
      value: s,
      disabled: n = !1,
      textValue: i,
      ...o
    } = r, a = Je(Gn, e), l = Qe(Gn, e), c = a.value === s, [d, g] = C.useState(i ?? ""), [h, f] = C.useState(!1), v = Mt(
      t,
      (E) => {
        var N;
        return (N = l.itemRefCallback) == null ? void 0 : N.call(l, E, s, n);
      }
    ), m = Oa(), k = C.useRef("touch"), _ = () => {
      n || (a.onValueChange(s), a.onOpenChange(!1));
    };
    if (s === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ R.jsx(
      ng,
      {
        scope: e,
        value: s,
        disabled: n,
        textId: m,
        isSelected: c,
        onItemTextChange: C.useCallback((E) => {
          g((N) => N || ((E == null ? void 0 : E.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ R.jsx(
          hi.ItemSlot,
          {
            scope: e,
            value: s,
            disabled: n,
            textValue: d,
            children: /* @__PURE__ */ R.jsx(
              Ct.div,
              {
                role: "option",
                "aria-labelledby": m,
                "data-highlighted": h ? "" : void 0,
                "aria-selected": c && h,
                "data-state": c ? "checked" : "unchecked",
                "aria-disabled": n || void 0,
                "data-disabled": n ? "" : void 0,
                tabIndex: n ? void 0 : -1,
                ...o,
                ref: v,
                onFocus: Nt(o.onFocus, () => f(!0)),
                onBlur: Nt(o.onBlur, () => f(!1)),
                onClick: Nt(o.onClick, () => {
                  k.current !== "mouse" && _();
                }),
                onPointerUp: Nt(o.onPointerUp, () => {
                  k.current === "mouse" && _();
                }),
                onPointerDown: Nt(o.onPointerDown, (E) => {
                  k.current = E.pointerType;
                }),
                onPointerMove: Nt(o.onPointerMove, (E) => {
                  var N;
                  k.current = E.pointerType, n ? (N = l.onItemLeave) == null || N.call(l) : k.current === "mouse" && E.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: Nt(o.onPointerLeave, (E) => {
                  var N;
                  E.currentTarget === document.activeElement && ((N = l.onItemLeave) == null || N.call(l));
                }),
                onKeyDown: Nt(o.onKeyDown, (E) => {
                  var N;
                  ((N = l.searchRef) == null ? void 0 : N.current) !== "" && E.key === " " || (zm.includes(E.key) && _(), E.key === " " && E.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
bh.displayName = Gn;
var Cs = "SelectItemText", yh = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, className: s, style: n, ...i } = r, o = Je(Cs, e), a = Qe(Cs, e), l = vh(Cs, e), c = Wm(Cs, e), [d, g] = C.useState(null), h = Mt(
      t,
      (_) => g(_),
      l.onItemTextChange,
      (_) => {
        var E;
        return (E = a.itemTextRefCallback) == null ? void 0 : E.call(a, _, l.value, l.disabled);
      }
    ), f = d == null ? void 0 : d.textContent, v = C.useMemo(
      () => /* @__PURE__ */ R.jsx("option", { value: l.value, disabled: l.disabled, children: f }, l.value),
      [l.disabled, l.value, f]
    ), { onNativeOptionAdd: m, onNativeOptionRemove: k } = c;
    return Xe(() => (m(v), () => k(v)), [m, k, v]), /* @__PURE__ */ R.jsxs(R.Fragment, { children: [
      /* @__PURE__ */ R.jsx(Ct.span, { id: l.textId, ...i, ref: h }),
      l.isSelected && o.valueNode && !o.valueNodeHasChildren ? sc.createPortal(i.children, o.valueNode) : null
    ] });
  }
);
yh.displayName = Cs;
var kh = "SelectItemIndicator", xh = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, ...s } = r;
    return vh(kh, e).isSelected ? /* @__PURE__ */ R.jsx(Ct.span, { "aria-hidden": !0, ...s, ref: t }) : null;
  }
);
xh.displayName = kh;
var ea = "SelectScrollUpButton", wh = C.forwardRef((r, t) => {
  const e = Qe(ea, r.__scopeSelect), s = $a(ea, r.__scopeSelect), [n, i] = C.useState(!1), o = Mt(t, s.onScrollButtonChange);
  return Xe(() => {
    if (e.viewport && e.isPositioned) {
      let a = function() {
        const c = l.scrollTop > 0;
        i(c);
      };
      const l = e.viewport;
      return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a);
    }
  }, [e.viewport, e.isPositioned]), n ? /* @__PURE__ */ R.jsx(
    _h,
    {
      ...r,
      ref: o,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: l } = e;
        a && l && (a.scrollTop = a.scrollTop - l.offsetHeight);
      }
    }
  ) : null;
});
wh.displayName = ea;
var ra = "SelectScrollDownButton", Eh = C.forwardRef((r, t) => {
  const e = Qe(ra, r.__scopeSelect), s = $a(ra, r.__scopeSelect), [n, i] = C.useState(!1), o = Mt(t, s.onScrollButtonChange);
  return Xe(() => {
    if (e.viewport && e.isPositioned) {
      let a = function() {
        const c = l.scrollHeight - l.clientHeight, d = Math.ceil(l.scrollTop) < c;
        i(d);
      };
      const l = e.viewport;
      return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a);
    }
  }, [e.viewport, e.isPositioned]), n ? /* @__PURE__ */ R.jsx(
    _h,
    {
      ...r,
      ref: o,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: l } = e;
        a && l && (a.scrollTop = a.scrollTop + l.offsetHeight);
      }
    }
  ) : null;
});
Eh.displayName = ra;
var _h = C.forwardRef((r, t) => {
  const { __scopeSelect: e, onAutoScroll: s, ...n } = r, i = Qe("SelectScrollButton", e), o = C.useRef(null), a = di(e), l = C.useCallback(() => {
    o.current !== null && (window.clearInterval(o.current), o.current = null);
  }, []);
  return C.useEffect(() => () => l(), [l]), Xe(() => {
    var c;
    const d = a().find((g) => g.ref.current === document.activeElement);
    (c = d == null ? void 0 : d.ref.current) == null || c.scrollIntoView({ block: "nearest" });
  }, [a]), /* @__PURE__ */ R.jsx(
    Ct.div,
    {
      "aria-hidden": !0,
      ...n,
      ref: t,
      style: { flexShrink: 0, ...n.style },
      onPointerDown: Nt(n.onPointerDown, () => {
        o.current === null && (o.current = window.setInterval(s, 50));
      }),
      onPointerMove: Nt(n.onPointerMove, () => {
        var c;
        (c = i.onItemLeave) == null || c.call(i), o.current === null && (o.current = window.setInterval(s, 50));
      }),
      onPointerLeave: Nt(n.onPointerLeave, () => {
        l();
      })
    }
  );
}), ig = "SelectSeparator", Ah = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, ...s } = r;
    return /* @__PURE__ */ R.jsx(Ct.div, { "aria-hidden": !0, ...s, ref: t });
  }
);
Ah.displayName = ig;
var sa = "SelectArrow", og = C.forwardRef(
  (r, t) => {
    const { __scopeSelect: e, ...s } = r, n = pi(e), i = Je(sa, e), o = Qe(sa, e);
    return i.open && o.position === "popper" ? /* @__PURE__ */ R.jsx(Cp, { ...n, ...s, ref: t }) : null;
  }
);
og.displayName = sa;
var ag = "SelectBubbleInput", Nh = C.forwardRef(
  ({ __scopeSelect: r, value: t, ...e }, s) => {
    const n = C.useRef(null), i = Mt(s, n), o = ti(t);
    return C.useEffect(() => {
      const a = n.current;
      if (!a) return;
      const l = window.HTMLSelectElement.prototype, c = Object.getOwnPropertyDescriptor(
        l,
        "value"
      ).set;
      if (o !== t && c) {
        const d = new Event("change", { bubbles: !0 });
        c.call(a, t), a.dispatchEvent(d);
      }
    }, [o, t]), /* @__PURE__ */ R.jsx(
      Ct.select,
      {
        ...e,
        style: { ...zp, ...e.style },
        ref: i,
        defaultValue: t
      }
    );
  }
);
Nh.displayName = ag;
function Sh(r) {
  return r === "" || r === void 0;
}
function Ch(r) {
  const t = yp(r), e = C.useRef(""), s = C.useRef(0), n = C.useCallback(
    (o) => {
      const a = e.current + o;
      t(a), function l(c) {
        e.current = c, window.clearTimeout(s.current), c !== "" && (s.current = window.setTimeout(() => l(""), 1e3));
      }(a);
    },
    [t]
  ), i = C.useCallback(() => {
    e.current = "", window.clearTimeout(s.current);
  }, []);
  return C.useEffect(() => () => window.clearTimeout(s.current), []), [e, n, i];
}
function Oh(r, t, e) {
  const s = t.length > 1 && Array.from(t).every((a) => a === t[0]) ? t[0] : t, n = e ? r.indexOf(e) : -1;
  let i = lg(r, Math.max(n, 0));
  s.length === 1 && (i = i.filter((a) => a !== e));
  const o = i.find(
    (a) => a.textValue.toLowerCase().startsWith(s.toLowerCase())
  );
  return o !== e ? o : void 0;
}
function lg(r, t) {
  return r.map((e, s) => r[(t + s) % r.length]);
}
var ug = eh, Th = sh, cg = ih, hg = oh, dg = ah, Rh = lh, pg = dh, fg = fh, Lh = gh, Ih = bh, mg = yh, gg = xh, qh = wh, jh = Eh, Mh = Ah;
const hw = ug, dw = fg, pw = cg, vg = C.forwardRef(({ className: r, children: t, variant: e = "default", ...s }, n) => /* @__PURE__ */ R.jsxs(
  Th,
  {
    ref: n,
    className: St(
      "border-border ring-offset-background placeholder:text-muted-foreground focus:ring-offset-none focus:ring-primary flex h-10 w-full items-center justify-between rounded-md border bg-white px-3 py-2 text-sm focus:ring-2 focus:ring-offset-transparent focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-transparent [&>span]:line-clamp-1",
      e === "failure" && "focus:ring-destructive hover:bg-destructive/20 bg-destructive/20 border-destructive !text-destructive",
      r
    ),
    ...s,
    children: [
      t,
      /* @__PURE__ */ R.jsx(hg, { asChild: !0, children: /* @__PURE__ */ R.jsx(ac, { className: "h-4 w-4 opacity-50" }) })
    ]
  }
));
vg.displayName = Th.displayName;
const Bh = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  qh,
  {
    ref: e,
    className: St(
      "flex cursor-default items-center justify-center py-1",
      r
    ),
    ...t,
    children: /* @__PURE__ */ R.jsx(Zp, { className: "h-4 w-4" })
  }
));
Bh.displayName = qh.displayName;
const Dh = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  jh,
  {
    ref: e,
    className: St(
      "flex cursor-default items-center justify-center py-1",
      r
    ),
    ...t,
    children: /* @__PURE__ */ R.jsx(ac, { className: "h-4 w-4" })
  }
));
Dh.displayName = jh.displayName;
const bg = C.forwardRef(({ className: r, children: t, position: e = "popper", ...s }, n) => /* @__PURE__ */ R.jsx(dg, { children: /* @__PURE__ */ R.jsxs(
  Rh,
  {
    ref: n,
    className: St(
      "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
      e === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      r
    ),
    position: e,
    ...s,
    children: [
      /* @__PURE__ */ R.jsx(Bh, {}),
      /* @__PURE__ */ R.jsx(
        pg,
        {
          className: St(
            "p-1",
            e === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children: t
        }
      ),
      /* @__PURE__ */ R.jsx(Dh, {})
    ]
  }
) }));
bg.displayName = Rh.displayName;
const yg = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  Lh,
  {
    ref: e,
    className: St("py-1.5 pr-2 pl-8 text-sm font-semibold", r),
    ...t
  }
));
yg.displayName = Lh.displayName;
const kg = C.forwardRef(({ className: r, children: t, ...e }, s) => /* @__PURE__ */ R.jsxs(
  Ih,
  {
    ref: s,
    className: St(
      "focus:bg-accent focus:text-accent-foreground relative flex w-full cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      r
    ),
    ...e,
    children: [
      /* @__PURE__ */ R.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ R.jsx(gg, { children: /* @__PURE__ */ R.jsx(Mp, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ R.jsx(mg, { children: t })
    ]
  }
));
kg.displayName = Ih.displayName;
const xg = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  Mh,
  {
    ref: e,
    className: St("bg-muted -mx-1 my-1 h-px", r),
    ...t
  }
));
xg.displayName = Mh.displayName;
var za = "Radio", [wg, Fh] = zs(za), [Eg, _g] = wg(za), Ph = C.forwardRef(
  (r, t) => {
    const {
      __scopeRadio: e,
      name: s,
      checked: n = !1,
      required: i,
      disabled: o,
      value: a = "on",
      onCheck: l,
      form: c,
      ...d
    } = r, [g, h] = C.useState(null), f = Mt(t, (k) => h(k)), v = C.useRef(!1), m = g ? c || !!g.closest("form") : !0;
    return /* @__PURE__ */ R.jsxs(Eg, { scope: e, checked: n, disabled: o, children: [
      /* @__PURE__ */ R.jsx(
        Ct.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": n,
          "data-state": zh(n),
          "data-disabled": o ? "" : void 0,
          disabled: o,
          value: a,
          ...d,
          ref: f,
          onClick: Nt(r.onClick, (k) => {
            n || l == null || l(), m && (v.current = k.isPropagationStopped(), v.current || k.stopPropagation());
          })
        }
      ),
      m && /* @__PURE__ */ R.jsx(
        $h,
        {
          control: g,
          bubbles: !v.current,
          name: s,
          value: a,
          checked: n,
          required: i,
          disabled: o,
          form: c,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Ph.displayName = za;
var Vh = "RadioIndicator", Uh = C.forwardRef(
  (r, t) => {
    const { __scopeRadio: e, forceMount: s, ...n } = r, i = _g(Vh, e);
    return /* @__PURE__ */ R.jsx(ec, { present: s || i.checked, children: /* @__PURE__ */ R.jsx(
      Ct.span,
      {
        "data-state": zh(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...n,
        ref: t
      }
    ) });
  }
);
Uh.displayName = Vh;
var Ag = "RadioBubbleInput", $h = C.forwardRef(
  ({
    __scopeRadio: r,
    control: t,
    checked: e,
    bubbles: s = !0,
    ...n
  }, i) => {
    const o = C.useRef(null), a = Mt(o, i), l = ti(e), c = Ta(t);
    return C.useEffect(() => {
      const d = o.current;
      if (!d) return;
      const g = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(
        g,
        "checked"
      ).set;
      if (l !== e && h) {
        const f = new Event("click", { bubbles: s });
        h.call(d, e), d.dispatchEvent(f);
      }
    }, [l, e, s]), /* @__PURE__ */ R.jsx(
      Ct.input,
      {
        type: "radio",
        "aria-hidden": !0,
        defaultChecked: e,
        ...n,
        tabIndex: -1,
        ref: a,
        style: {
          ...n.style,
          ...c,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
$h.displayName = Ag;
function zh(r) {
  return r ? "checked" : "unchecked";
}
var Ng = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], fi = "RadioGroup", [Sg, fw] = zs(fi, [
  ic,
  Fh
]), Hh = ic(), Kh = Fh(), [Cg, Og] = Sg(fi), Gh = C.forwardRef(
  (r, t) => {
    const {
      __scopeRadioGroup: e,
      name: s,
      defaultValue: n,
      value: i,
      required: o = !1,
      disabled: a = !1,
      orientation: l,
      dir: c,
      loop: d = !0,
      onValueChange: g,
      ...h
    } = r, f = Hh(e), v = nc(c), [m, k] = js({
      prop: i,
      defaultProp: n ?? null,
      onChange: g,
      caller: fi
    });
    return /* @__PURE__ */ R.jsx(
      Cg,
      {
        scope: e,
        name: s,
        required: o,
        disabled: a,
        value: m,
        onValueChange: k,
        children: /* @__PURE__ */ R.jsx(
          Bp,
          {
            asChild: !0,
            ...f,
            orientation: l,
            dir: v,
            loop: d,
            children: /* @__PURE__ */ R.jsx(
              Ct.div,
              {
                role: "radiogroup",
                "aria-required": o,
                "aria-orientation": l,
                "data-disabled": a ? "" : void 0,
                dir: v,
                ...h,
                ref: t
              }
            )
          }
        )
      }
    );
  }
);
Gh.displayName = fi;
var Wh = "RadioGroupItem", Zh = C.forwardRef(
  (r, t) => {
    const { __scopeRadioGroup: e, disabled: s, ...n } = r, i = Og(Wh, e), o = i.disabled || s, a = Hh(e), l = Kh(e), c = C.useRef(null), d = Mt(t, c), g = i.value === n.value, h = C.useRef(!1);
    return C.useEffect(() => {
      const f = (m) => {
        Ng.includes(m.key) && (h.current = !0);
      }, v = () => h.current = !1;
      return document.addEventListener("keydown", f), document.addEventListener("keyup", v), () => {
        document.removeEventListener("keydown", f), document.removeEventListener("keyup", v);
      };
    }, []), /* @__PURE__ */ R.jsx(
      Dp,
      {
        asChild: !0,
        ...a,
        focusable: !o,
        active: g,
        children: /* @__PURE__ */ R.jsx(
          Ph,
          {
            disabled: o,
            required: i.required,
            checked: g,
            ...l,
            ...n,
            name: i.name,
            ref: d,
            onCheck: () => i.onValueChange(n.value),
            onKeyDown: Nt((f) => {
              f.key === "Enter" && f.preventDefault();
            }),
            onFocus: Nt(n.onFocus, () => {
              var f;
              h.current && ((f = c.current) == null || f.click());
            })
          }
        )
      }
    );
  }
);
Zh.displayName = Wh;
var Tg = "RadioGroupIndicator", Xh = C.forwardRef(
  (r, t) => {
    const { __scopeRadioGroup: e, ...s } = r, n = Kh(e);
    return /* @__PURE__ */ R.jsx(Uh, { ...n, ...s, ref: t });
  }
);
Xh.displayName = Tg;
var Yh = Gh, Jh = Zh, Rg = Xh;
const Lg = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  Yh,
  {
    className: St("grid gap-2", r),
    ...t,
    ref: e
  }
));
Lg.displayName = Yh.displayName;
const Ig = C.forwardRef(({ className: r, ...t }, e) => /* @__PURE__ */ R.jsx(
  Jh,
  {
    ref: e,
    className: St(
      "border-primary text-primary ring-offset-background focus-visible:ring-ring aspect-square h-4 w-4 rounded-full border focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      r
    ),
    ...t,
    children: /* @__PURE__ */ R.jsx(Rg, { className: "flex items-center justify-center", children: /* @__PURE__ */ R.jsx(qp, { className: "h-2.5 w-2.5 fill-current text-current" }) })
  }
));
Ig.displayName = Jh.displayName;
var Qh = typeof global == "object" && global && global.Object === Object && global, qg = typeof self == "object" && self && self.Object === Object && self, Ee = Qh || qg || Function("return this")(), Ye = Ee.Symbol, td = Object.prototype, jg = td.hasOwnProperty, Mg = td.toString, As = Ye ? Ye.toStringTag : void 0;
function Bg(r) {
  var t = jg.call(r, As), e = r[As];
  try {
    r[As] = void 0;
    var s = !0;
  } catch {
  }
  var n = Mg.call(r);
  return s && (t ? r[As] = e : delete r[As]), n;
}
var Dg = Object.prototype, Fg = Dg.toString;
function Pg(r) {
  return Fg.call(r);
}
var Vg = "[object Null]", Ug = "[object Undefined]", Bl = Ye ? Ye.toStringTag : void 0;
function us(r) {
  return r == null ? r === void 0 ? Ug : Vg : Bl && Bl in Object(r) ? Bg(r) : Pg(r);
}
function Ie(r) {
  return r != null && typeof r == "object";
}
var yr = Array.isArray;
function tr(r) {
  var t = typeof r;
  return r != null && (t == "object" || t == "function");
}
function ed(r) {
  return r;
}
var $g = "[object AsyncFunction]", zg = "[object Function]", Hg = "[object GeneratorFunction]", Kg = "[object Proxy]";
function Ha(r) {
  if (!tr(r))
    return !1;
  var t = us(r);
  return t == zg || t == Hg || t == $g || t == Kg;
}
var Eo = Ee["__core-js_shared__"], Dl = function() {
  var r = /[^.]+$/.exec(Eo && Eo.keys && Eo.keys.IE_PROTO || "");
  return r ? "Symbol(src)_1." + r : "";
}();
function Gg(r) {
  return !!Dl && Dl in r;
}
var Wg = Function.prototype, Zg = Wg.toString;
function wr(r) {
  if (r != null) {
    try {
      return Zg.call(r);
    } catch {
    }
    try {
      return r + "";
    } catch {
    }
  }
  return "";
}
var Xg = /[\\^$.*+?()[\]{}|]/g, Yg = /^\[object .+?Constructor\]$/, Jg = Function.prototype, Qg = Object.prototype, t0 = Jg.toString, e0 = Qg.hasOwnProperty, r0 = RegExp(
  "^" + t0.call(e0).replace(Xg, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function s0(r) {
  if (!tr(r) || Gg(r))
    return !1;
  var t = Ha(r) ? r0 : Yg;
  return t.test(wr(r));
}
function n0(r, t) {
  return r == null ? void 0 : r[t];
}
function Er(r, t) {
  var e = n0(r, t);
  return s0(e) ? e : void 0;
}
var na = Er(Ee, "WeakMap"), Fl = Object.create, i0 = /* @__PURE__ */ function() {
  function r() {
  }
  return function(t) {
    if (!tr(t))
      return {};
    if (Fl)
      return Fl(t);
    r.prototype = t;
    var e = new r();
    return r.prototype = void 0, e;
  };
}();
function o0(r, t, e) {
  switch (e.length) {
    case 0:
      return r.call(t);
    case 1:
      return r.call(t, e[0]);
    case 2:
      return r.call(t, e[0], e[1]);
    case 3:
      return r.call(t, e[0], e[1], e[2]);
  }
  return r.apply(t, e);
}
function a0(r, t) {
  var e = -1, s = r.length;
  for (t || (t = Array(s)); ++e < s; )
    t[e] = r[e];
  return t;
}
var l0 = 800, u0 = 16, c0 = Date.now;
function h0(r) {
  var t = 0, e = 0;
  return function() {
    var s = c0(), n = u0 - (s - e);
    if (e = s, n > 0) {
      if (++t >= l0)
        return arguments[0];
    } else
      t = 0;
    return r.apply(void 0, arguments);
  };
}
function d0(r) {
  return function() {
    return r;
  };
}
var Wn = function() {
  try {
    var r = Er(Object, "defineProperty");
    return r({}, "", {}), r;
  } catch {
  }
}(), p0 = Wn ? function(r, t) {
  return Wn(r, "toString", {
    configurable: !0,
    enumerable: !1,
    value: d0(t),
    writable: !0
  });
} : ed, f0 = h0(p0);
function m0(r, t) {
  for (var e = -1, s = r == null ? 0 : r.length; ++e < s && t(r[e], e, r) !== !1; )
    ;
  return r;
}
var g0 = 9007199254740991, v0 = /^(?:0|[1-9]\d*)$/;
function rd(r, t) {
  var e = typeof r;
  return t = t ?? g0, !!t && (e == "number" || e != "symbol" && v0.test(r)) && r > -1 && r % 1 == 0 && r < t;
}
function Ka(r, t, e) {
  t == "__proto__" && Wn ? Wn(r, t, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : r[t] = e;
}
function Ks(r, t) {
  return r === t || r !== r && t !== t;
}
var b0 = Object.prototype, y0 = b0.hasOwnProperty;
function sd(r, t, e) {
  var s = r[t];
  (!(y0.call(r, t) && Ks(s, e)) || e === void 0 && !(t in r)) && Ka(r, t, e);
}
function k0(r, t, e, s) {
  var n = !e;
  e || (e = {});
  for (var i = -1, o = t.length; ++i < o; ) {
    var a = t[i], l = void 0;
    l === void 0 && (l = r[a]), n ? Ka(e, a, l) : sd(e, a, l);
  }
  return e;
}
var Pl = Math.max;
function x0(r, t, e) {
  return t = Pl(t === void 0 ? r.length - 1 : t, 0), function() {
    for (var s = arguments, n = -1, i = Pl(s.length - t, 0), o = Array(i); ++n < i; )
      o[n] = s[t + n];
    n = -1;
    for (var a = Array(t + 1); ++n < t; )
      a[n] = s[n];
    return a[t] = e(o), o0(r, this, a);
  };
}
function w0(r, t) {
  return f0(x0(r, t, ed), r + "");
}
var E0 = 9007199254740991;
function nd(r) {
  return typeof r == "number" && r > -1 && r % 1 == 0 && r <= E0;
}
function mi(r) {
  return r != null && nd(r.length) && !Ha(r);
}
function _0(r, t, e) {
  if (!tr(e))
    return !1;
  var s = typeof t;
  return (s == "number" ? mi(e) && rd(t, e.length) : s == "string" && t in e) ? Ks(e[t], r) : !1;
}
function A0(r) {
  return w0(function(t, e) {
    var s = -1, n = e.length, i = n > 1 ? e[n - 1] : void 0, o = n > 2 ? e[2] : void 0;
    for (i = r.length > 3 && typeof i == "function" ? (n--, i) : void 0, o && _0(e[0], e[1], o) && (i = n < 3 ? void 0 : i, n = 1), t = Object(t); ++s < n; ) {
      var a = e[s];
      a && r(t, a, s, i);
    }
    return t;
  });
}
var N0 = Object.prototype;
function Ga(r) {
  var t = r && r.constructor, e = typeof t == "function" && t.prototype || N0;
  return r === e;
}
function S0(r, t) {
  for (var e = -1, s = Array(r); ++e < r; )
    s[e] = t(e);
  return s;
}
var C0 = "[object Arguments]";
function Vl(r) {
  return Ie(r) && us(r) == C0;
}
var id = Object.prototype, O0 = id.hasOwnProperty, T0 = id.propertyIsEnumerable, ia = Vl(/* @__PURE__ */ function() {
  return arguments;
}()) ? Vl : function(r) {
  return Ie(r) && O0.call(r, "callee") && !T0.call(r, "callee");
};
function R0() {
  return !1;
}
var od = typeof exports == "object" && exports && !exports.nodeType && exports, Ul = od && typeof module == "object" && module && !module.nodeType && module, L0 = Ul && Ul.exports === od, $l = L0 ? Ee.Buffer : void 0, I0 = $l ? $l.isBuffer : void 0, Ms = I0 || R0, q0 = "[object Arguments]", j0 = "[object Array]", M0 = "[object Boolean]", B0 = "[object Date]", D0 = "[object Error]", F0 = "[object Function]", P0 = "[object Map]", V0 = "[object Number]", U0 = "[object Object]", $0 = "[object RegExp]", z0 = "[object Set]", H0 = "[object String]", K0 = "[object WeakMap]", G0 = "[object ArrayBuffer]", W0 = "[object DataView]", Z0 = "[object Float32Array]", X0 = "[object Float64Array]", Y0 = "[object Int8Array]", J0 = "[object Int16Array]", Q0 = "[object Int32Array]", t1 = "[object Uint8Array]", e1 = "[object Uint8ClampedArray]", r1 = "[object Uint16Array]", s1 = "[object Uint32Array]", _t = {};
_t[Z0] = _t[X0] = _t[Y0] = _t[J0] = _t[Q0] = _t[t1] = _t[e1] = _t[r1] = _t[s1] = !0;
_t[q0] = _t[j0] = _t[G0] = _t[M0] = _t[W0] = _t[B0] = _t[D0] = _t[F0] = _t[P0] = _t[V0] = _t[U0] = _t[$0] = _t[z0] = _t[H0] = _t[K0] = !1;
function n1(r) {
  return Ie(r) && nd(r.length) && !!_t[us(r)];
}
function Wa(r) {
  return function(t) {
    return r(t);
  };
}
var ad = typeof exports == "object" && exports && !exports.nodeType && exports, Is = ad && typeof module == "object" && module && !module.nodeType && module, i1 = Is && Is.exports === ad, _o = i1 && Qh.process, ss = function() {
  try {
    var r = Is && Is.require && Is.require("util").types;
    return r || _o && _o.binding && _o.binding("util");
  } catch {
  }
}(), zl = ss && ss.isTypedArray, Za = zl ? Wa(zl) : n1, o1 = Object.prototype, a1 = o1.hasOwnProperty;
function ld(r, t) {
  var e = yr(r), s = !e && ia(r), n = !e && !s && Ms(r), i = !e && !s && !n && Za(r), o = e || s || n || i, a = o ? S0(r.length, String) : [], l = a.length;
  for (var c in r)
    (t || a1.call(r, c)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    n && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    rd(c, l))) && a.push(c);
  return a;
}
function ud(r, t) {
  return function(e) {
    return r(t(e));
  };
}
var l1 = ud(Object.keys, Object), u1 = Object.prototype, c1 = u1.hasOwnProperty;
function h1(r) {
  if (!Ga(r))
    return l1(r);
  var t = [];
  for (var e in Object(r))
    c1.call(r, e) && e != "constructor" && t.push(e);
  return t;
}
function d1(r) {
  return mi(r) ? ld(r) : h1(r);
}
function p1(r) {
  var t = [];
  if (r != null)
    for (var e in Object(r))
      t.push(e);
  return t;
}
var f1 = Object.prototype, m1 = f1.hasOwnProperty;
function g1(r) {
  if (!tr(r))
    return p1(r);
  var t = Ga(r), e = [];
  for (var s in r)
    s == "constructor" && (t || !m1.call(r, s)) || e.push(s);
  return e;
}
function cd(r) {
  return mi(r) ? ld(r, !0) : g1(r);
}
var Bs = Er(Object, "create");
function v1() {
  this.__data__ = Bs ? Bs(null) : {}, this.size = 0;
}
function b1(r) {
  var t = this.has(r) && delete this.__data__[r];
  return this.size -= t ? 1 : 0, t;
}
var y1 = "__lodash_hash_undefined__", k1 = Object.prototype, x1 = k1.hasOwnProperty;
function w1(r) {
  var t = this.__data__;
  if (Bs) {
    var e = t[r];
    return e === y1 ? void 0 : e;
  }
  return x1.call(t, r) ? t[r] : void 0;
}
var E1 = Object.prototype, _1 = E1.hasOwnProperty;
function A1(r) {
  var t = this.__data__;
  return Bs ? t[r] !== void 0 : _1.call(t, r);
}
var N1 = "__lodash_hash_undefined__";
function S1(r, t) {
  var e = this.__data__;
  return this.size += this.has(r) ? 0 : 1, e[r] = Bs && t === void 0 ? N1 : t, this;
}
function kr(r) {
  var t = -1, e = r == null ? 0 : r.length;
  for (this.clear(); ++t < e; ) {
    var s = r[t];
    this.set(s[0], s[1]);
  }
}
kr.prototype.clear = v1;
kr.prototype.delete = b1;
kr.prototype.get = w1;
kr.prototype.has = A1;
kr.prototype.set = S1;
function C1() {
  this.__data__ = [], this.size = 0;
}
function gi(r, t) {
  for (var e = r.length; e--; )
    if (Ks(r[e][0], t))
      return e;
  return -1;
}
var O1 = Array.prototype, T1 = O1.splice;
function R1(r) {
  var t = this.__data__, e = gi(t, r);
  if (e < 0)
    return !1;
  var s = t.length - 1;
  return e == s ? t.pop() : T1.call(t, e, 1), --this.size, !0;
}
function L1(r) {
  var t = this.__data__, e = gi(t, r);
  return e < 0 ? void 0 : t[e][1];
}
function I1(r) {
  return gi(this.__data__, r) > -1;
}
function q1(r, t) {
  var e = this.__data__, s = gi(e, r);
  return s < 0 ? (++this.size, e.push([r, t])) : e[s][1] = t, this;
}
function Be(r) {
  var t = -1, e = r == null ? 0 : r.length;
  for (this.clear(); ++t < e; ) {
    var s = r[t];
    this.set(s[0], s[1]);
  }
}
Be.prototype.clear = C1;
Be.prototype.delete = R1;
Be.prototype.get = L1;
Be.prototype.has = I1;
Be.prototype.set = q1;
var Ds = Er(Ee, "Map");
function j1() {
  this.size = 0, this.__data__ = {
    hash: new kr(),
    map: new (Ds || Be)(),
    string: new kr()
  };
}
function M1(r) {
  var t = typeof r;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? r !== "__proto__" : r === null;
}
function vi(r, t) {
  var e = r.__data__;
  return M1(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function B1(r) {
  var t = vi(this, r).delete(r);
  return this.size -= t ? 1 : 0, t;
}
function D1(r) {
  return vi(this, r).get(r);
}
function F1(r) {
  return vi(this, r).has(r);
}
function P1(r, t) {
  var e = vi(this, r), s = e.size;
  return e.set(r, t), this.size += e.size == s ? 0 : 1, this;
}
function _r(r) {
  var t = -1, e = r == null ? 0 : r.length;
  for (this.clear(); ++t < e; ) {
    var s = r[t];
    this.set(s[0], s[1]);
  }
}
_r.prototype.clear = j1;
_r.prototype.delete = B1;
_r.prototype.get = D1;
_r.prototype.has = F1;
_r.prototype.set = P1;
function V1(r, t) {
  for (var e = -1, s = t.length, n = r.length; ++e < s; )
    r[n + e] = t[e];
  return r;
}
var hd = ud(Object.getPrototypeOf, Object), U1 = "[object Object]", $1 = Function.prototype, z1 = Object.prototype, dd = $1.toString, H1 = z1.hasOwnProperty, K1 = dd.call(Object);
function G1(r) {
  if (!Ie(r) || us(r) != U1)
    return !1;
  var t = hd(r);
  if (t === null)
    return !0;
  var e = H1.call(t, "constructor") && t.constructor;
  return typeof e == "function" && e instanceof e && dd.call(e) == K1;
}
function W1() {
  this.__data__ = new Be(), this.size = 0;
}
function Z1(r) {
  var t = this.__data__, e = t.delete(r);
  return this.size = t.size, e;
}
function X1(r) {
  return this.__data__.get(r);
}
function Y1(r) {
  return this.__data__.has(r);
}
var J1 = 200;
function Q1(r, t) {
  var e = this.__data__;
  if (e instanceof Be) {
    var s = e.__data__;
    if (!Ds || s.length < J1 - 1)
      return s.push([r, t]), this.size = ++e.size, this;
    e = this.__data__ = new _r(s);
  }
  return e.set(r, t), this.size = e.size, this;
}
function ke(r) {
  var t = this.__data__ = new Be(r);
  this.size = t.size;
}
ke.prototype.clear = W1;
ke.prototype.delete = Z1;
ke.prototype.get = X1;
ke.prototype.has = Y1;
ke.prototype.set = Q1;
var pd = typeof exports == "object" && exports && !exports.nodeType && exports, Hl = pd && typeof module == "object" && module && !module.nodeType && module, tv = Hl && Hl.exports === pd, Kl = tv ? Ee.Buffer : void 0, Gl = Kl ? Kl.allocUnsafe : void 0;
function fd(r, t) {
  if (t)
    return r.slice();
  var e = r.length, s = Gl ? Gl(e) : new r.constructor(e);
  return r.copy(s), s;
}
function ev(r, t) {
  for (var e = -1, s = r == null ? 0 : r.length, n = 0, i = []; ++e < s; ) {
    var o = r[e];
    t(o, e, r) && (i[n++] = o);
  }
  return i;
}
function rv() {
  return [];
}
var sv = Object.prototype, nv = sv.propertyIsEnumerable, Wl = Object.getOwnPropertySymbols, iv = Wl ? function(r) {
  return r == null ? [] : (r = Object(r), ev(Wl(r), function(t) {
    return nv.call(r, t);
  }));
} : rv;
function ov(r, t, e) {
  var s = t(r);
  return yr(r) ? s : V1(s, e(r));
}
function oa(r) {
  return ov(r, d1, iv);
}
var aa = Er(Ee, "DataView"), la = Er(Ee, "Promise"), ua = Er(Ee, "Set"), Zl = "[object Map]", av = "[object Object]", Xl = "[object Promise]", Yl = "[object Set]", Jl = "[object WeakMap]", Ql = "[object DataView]", lv = wr(aa), uv = wr(Ds), cv = wr(la), hv = wr(ua), dv = wr(na), ae = us;
(aa && ae(new aa(new ArrayBuffer(1))) != Ql || Ds && ae(new Ds()) != Zl || la && ae(la.resolve()) != Xl || ua && ae(new ua()) != Yl || na && ae(new na()) != Jl) && (ae = function(r) {
  var t = us(r), e = t == av ? r.constructor : void 0, s = e ? wr(e) : "";
  if (s)
    switch (s) {
      case lv:
        return Ql;
      case uv:
        return Zl;
      case cv:
        return Xl;
      case hv:
        return Yl;
      case dv:
        return Jl;
    }
  return t;
});
var pv = Object.prototype, fv = pv.hasOwnProperty;
function mv(r) {
  var t = r.length, e = new r.constructor(t);
  return t && typeof r[0] == "string" && fv.call(r, "index") && (e.index = r.index, e.input = r.input), e;
}
var Zn = Ee.Uint8Array;
function Xa(r) {
  var t = new r.constructor(r.byteLength);
  return new Zn(t).set(new Zn(r)), t;
}
function gv(r, t) {
  var e = Xa(r.buffer);
  return new r.constructor(e, r.byteOffset, r.byteLength);
}
var vv = /\w*$/;
function bv(r) {
  var t = new r.constructor(r.source, vv.exec(r));
  return t.lastIndex = r.lastIndex, t;
}
var tu = Ye ? Ye.prototype : void 0, eu = tu ? tu.valueOf : void 0;
function yv(r) {
  return eu ? Object(eu.call(r)) : {};
}
function md(r, t) {
  var e = t ? Xa(r.buffer) : r.buffer;
  return new r.constructor(e, r.byteOffset, r.length);
}
var kv = "[object Boolean]", xv = "[object Date]", wv = "[object Map]", Ev = "[object Number]", _v = "[object RegExp]", Av = "[object Set]", Nv = "[object String]", Sv = "[object Symbol]", Cv = "[object ArrayBuffer]", Ov = "[object DataView]", Tv = "[object Float32Array]", Rv = "[object Float64Array]", Lv = "[object Int8Array]", Iv = "[object Int16Array]", qv = "[object Int32Array]", jv = "[object Uint8Array]", Mv = "[object Uint8ClampedArray]", Bv = "[object Uint16Array]", Dv = "[object Uint32Array]";
function Fv(r, t, e) {
  var s = r.constructor;
  switch (t) {
    case Cv:
      return Xa(r);
    case kv:
    case xv:
      return new s(+r);
    case Ov:
      return gv(r);
    case Tv:
    case Rv:
    case Lv:
    case Iv:
    case qv:
    case jv:
    case Mv:
    case Bv:
    case Dv:
      return md(r, e);
    case wv:
      return new s();
    case Ev:
    case Nv:
      return new s(r);
    case _v:
      return bv(r);
    case Av:
      return new s();
    case Sv:
      return yv(r);
  }
}
function gd(r) {
  return typeof r.constructor == "function" && !Ga(r) ? i0(hd(r)) : {};
}
var Pv = "[object Map]";
function Vv(r) {
  return Ie(r) && ae(r) == Pv;
}
var ru = ss && ss.isMap, Uv = ru ? Wa(ru) : Vv, $v = "[object Set]";
function zv(r) {
  return Ie(r) && ae(r) == $v;
}
var su = ss && ss.isSet, Hv = su ? Wa(su) : zv, Kv = 1, vd = "[object Arguments]", Gv = "[object Array]", Wv = "[object Boolean]", Zv = "[object Date]", Xv = "[object Error]", bd = "[object Function]", Yv = "[object GeneratorFunction]", Jv = "[object Map]", Qv = "[object Number]", yd = "[object Object]", tb = "[object RegExp]", eb = "[object Set]", rb = "[object String]", sb = "[object Symbol]", nb = "[object WeakMap]", ib = "[object ArrayBuffer]", ob = "[object DataView]", ab = "[object Float32Array]", lb = "[object Float64Array]", ub = "[object Int8Array]", cb = "[object Int16Array]", hb = "[object Int32Array]", db = "[object Uint8Array]", pb = "[object Uint8ClampedArray]", fb = "[object Uint16Array]", mb = "[object Uint32Array]", wt = {};
wt[vd] = wt[Gv] = wt[ib] = wt[ob] = wt[Wv] = wt[Zv] = wt[ab] = wt[lb] = wt[ub] = wt[cb] = wt[hb] = wt[Jv] = wt[Qv] = wt[yd] = wt[tb] = wt[eb] = wt[rb] = wt[sb] = wt[db] = wt[pb] = wt[fb] = wt[mb] = !0;
wt[Xv] = wt[bd] = wt[nb] = !1;
function jn(r, t, e, s, n, i) {
  var o, a = t & Kv;
  if (o !== void 0)
    return o;
  if (!tr(r))
    return r;
  var l = yr(r);
  if (l)
    o = mv(r);
  else {
    var c = ae(r), d = c == bd || c == Yv;
    if (Ms(r))
      return fd(r, a);
    if (c == yd || c == vd || d && !n)
      o = d ? {} : gd(r);
    else {
      if (!wt[c])
        return n ? r : {};
      o = Fv(r, c, a);
    }
  }
  i || (i = new ke());
  var g = i.get(r);
  if (g)
    return g;
  i.set(r, o), Hv(r) ? r.forEach(function(v) {
    o.add(jn(v, t, e, v, r, i));
  }) : Uv(r) && r.forEach(function(v, m) {
    o.set(m, jn(v, t, e, m, r, i));
  });
  var h = oa, f = l ? void 0 : h(r);
  return m0(f || r, function(v, m) {
    f && (m = v, v = r[m]), sd(o, m, jn(v, t, e, m, r, i));
  }), o;
}
var gb = 1, vb = 4;
function Wr(r) {
  return jn(r, gb | vb);
}
var bb = "__lodash_hash_undefined__";
function yb(r) {
  return this.__data__.set(r, bb), this;
}
function kb(r) {
  return this.__data__.has(r);
}
function Xn(r) {
  var t = -1, e = r == null ? 0 : r.length;
  for (this.__data__ = new _r(); ++t < e; )
    this.add(r[t]);
}
Xn.prototype.add = Xn.prototype.push = yb;
Xn.prototype.has = kb;
function xb(r, t) {
  for (var e = -1, s = r == null ? 0 : r.length; ++e < s; )
    if (t(r[e], e, r))
      return !0;
  return !1;
}
function wb(r, t) {
  return r.has(t);
}
var Eb = 1, _b = 2;
function kd(r, t, e, s, n, i) {
  var o = e & Eb, a = r.length, l = t.length;
  if (a != l && !(o && l > a))
    return !1;
  var c = i.get(r), d = i.get(t);
  if (c && d)
    return c == t && d == r;
  var g = -1, h = !0, f = e & _b ? new Xn() : void 0;
  for (i.set(r, t), i.set(t, r); ++g < a; ) {
    var v = r[g], m = t[g];
    if (s)
      var k = o ? s(m, v, g, t, r, i) : s(v, m, g, r, t, i);
    if (k !== void 0) {
      if (k)
        continue;
      h = !1;
      break;
    }
    if (f) {
      if (!xb(t, function(_, E) {
        if (!wb(f, E) && (v === _ || n(v, _, e, s, i)))
          return f.push(E);
      })) {
        h = !1;
        break;
      }
    } else if (!(v === m || n(v, m, e, s, i))) {
      h = !1;
      break;
    }
  }
  return i.delete(r), i.delete(t), h;
}
function Ab(r) {
  var t = -1, e = Array(r.size);
  return r.forEach(function(s, n) {
    e[++t] = [n, s];
  }), e;
}
function Nb(r) {
  var t = -1, e = Array(r.size);
  return r.forEach(function(s) {
    e[++t] = s;
  }), e;
}
var Sb = 1, Cb = 2, Ob = "[object Boolean]", Tb = "[object Date]", Rb = "[object Error]", Lb = "[object Map]", Ib = "[object Number]", qb = "[object RegExp]", jb = "[object Set]", Mb = "[object String]", Bb = "[object Symbol]", Db = "[object ArrayBuffer]", Fb = "[object DataView]", nu = Ye ? Ye.prototype : void 0, Ao = nu ? nu.valueOf : void 0;
function Pb(r, t, e, s, n, i, o) {
  switch (e) {
    case Fb:
      if (r.byteLength != t.byteLength || r.byteOffset != t.byteOffset)
        return !1;
      r = r.buffer, t = t.buffer;
    case Db:
      return !(r.byteLength != t.byteLength || !i(new Zn(r), new Zn(t)));
    case Ob:
    case Tb:
    case Ib:
      return Ks(+r, +t);
    case Rb:
      return r.name == t.name && r.message == t.message;
    case qb:
    case Mb:
      return r == t + "";
    case Lb:
      var a = Ab;
    case jb:
      var l = s & Sb;
      if (a || (a = Nb), r.size != t.size && !l)
        return !1;
      var c = o.get(r);
      if (c)
        return c == t;
      s |= Cb, o.set(r, t);
      var d = kd(a(r), a(t), s, n, i, o);
      return o.delete(r), d;
    case Bb:
      if (Ao)
        return Ao.call(r) == Ao.call(t);
  }
  return !1;
}
var Vb = 1, Ub = Object.prototype, $b = Ub.hasOwnProperty;
function zb(r, t, e, s, n, i) {
  var o = e & Vb, a = oa(r), l = a.length, c = oa(t), d = c.length;
  if (l != d && !o)
    return !1;
  for (var g = l; g--; ) {
    var h = a[g];
    if (!(o ? h in t : $b.call(t, h)))
      return !1;
  }
  var f = i.get(r), v = i.get(t);
  if (f && v)
    return f == t && v == r;
  var m = !0;
  i.set(r, t), i.set(t, r);
  for (var k = o; ++g < l; ) {
    h = a[g];
    var _ = r[h], E = t[h];
    if (s)
      var N = o ? s(E, _, h, t, r, i) : s(_, E, h, r, t, i);
    if (!(N === void 0 ? _ === E || n(_, E, e, s, i) : N)) {
      m = !1;
      break;
    }
    k || (k = h == "constructor");
  }
  if (m && !k) {
    var q = r.constructor, A = t.constructor;
    q != A && "constructor" in r && "constructor" in t && !(typeof q == "function" && q instanceof q && typeof A == "function" && A instanceof A) && (m = !1);
  }
  return i.delete(r), i.delete(t), m;
}
var Hb = 1, iu = "[object Arguments]", ou = "[object Array]", xn = "[object Object]", Kb = Object.prototype, au = Kb.hasOwnProperty;
function Gb(r, t, e, s, n, i) {
  var o = yr(r), a = yr(t), l = o ? ou : ae(r), c = a ? ou : ae(t);
  l = l == iu ? xn : l, c = c == iu ? xn : c;
  var d = l == xn, g = c == xn, h = l == c;
  if (h && Ms(r)) {
    if (!Ms(t))
      return !1;
    o = !0, d = !1;
  }
  if (h && !d)
    return i || (i = new ke()), o || Za(r) ? kd(r, t, e, s, n, i) : Pb(r, t, l, e, s, n, i);
  if (!(e & Hb)) {
    var f = d && au.call(r, "__wrapped__"), v = g && au.call(t, "__wrapped__");
    if (f || v) {
      var m = f ? r.value() : r, k = v ? t.value() : t;
      return i || (i = new ke()), n(m, k, e, s, i);
    }
  }
  return h ? (i || (i = new ke()), zb(r, t, e, s, n, i)) : !1;
}
function xd(r, t, e, s, n) {
  return r === t ? !0 : r == null || t == null || !Ie(r) && !Ie(t) ? r !== r && t !== t : Gb(r, t, e, s, xd, n);
}
function Wb(r) {
  return function(t, e, s) {
    for (var n = -1, i = Object(t), o = s(t), a = o.length; a--; ) {
      var l = o[++n];
      if (e(i[l], l, i) === !1)
        break;
    }
    return t;
  };
}
var Zb = Wb();
function ca(r, t, e) {
  (e !== void 0 && !Ks(r[t], e) || e === void 0 && !(t in r)) && Ka(r, t, e);
}
function Xb(r) {
  return Ie(r) && mi(r);
}
function ha(r, t) {
  if (!(t === "constructor" && typeof r[t] == "function") && t != "__proto__")
    return r[t];
}
function Yb(r) {
  return k0(r, cd(r));
}
function Jb(r, t, e, s, n, i, o) {
  var a = ha(r, e), l = ha(t, e), c = o.get(l);
  if (c) {
    ca(r, e, c);
    return;
  }
  var d = i ? i(a, l, e + "", r, t, o) : void 0, g = d === void 0;
  if (g) {
    var h = yr(l), f = !h && Ms(l), v = !h && !f && Za(l);
    d = l, h || f || v ? yr(a) ? d = a : Xb(a) ? d = a0(a) : f ? (g = !1, d = fd(l, !0)) : v ? (g = !1, d = md(l, !0)) : d = [] : G1(l) || ia(l) ? (d = a, ia(a) ? d = Yb(a) : (!tr(a) || Ha(a)) && (d = gd(l))) : g = !1;
  }
  g && (o.set(l, d), n(d, l, s, i, o), o.delete(l)), ca(r, e, d);
}
function wd(r, t, e, s, n) {
  r !== t && Zb(t, function(i, o) {
    if (n || (n = new ke()), tr(i))
      Jb(r, t, o, e, wd, s, n);
    else {
      var a = s ? s(ha(r, o), i, o + "", r, t, n) : void 0;
      a === void 0 && (a = i), ca(r, o, a);
    }
  }, cd);
}
function $e(r, t) {
  return xd(r, t);
}
var We = A0(function(r, t, e) {
  wd(r, t, e);
}), rt = /* @__PURE__ */ ((r) => (r[r.TYPE = 3] = "TYPE", r[r.LEVEL = 12] = "LEVEL", r[r.ATTRIBUTE = 13] = "ATTRIBUTE", r[r.BLOT = 14] = "BLOT", r[r.INLINE = 7] = "INLINE", r[r.BLOCK = 11] = "BLOCK", r[r.BLOCK_BLOT = 10] = "BLOCK_BLOT", r[r.INLINE_BLOT = 6] = "INLINE_BLOT", r[r.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", r[r.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", r[r.ANY = 15] = "ANY", r))(rt || {});
class we {
  constructor(t, e, s = {}) {
    this.attrName = t, this.keyName = e;
    const n = rt.TYPE & rt.ATTRIBUTE;
    this.scope = s.scope != null ? (
      // Ignore type bits, force attribute bit
      s.scope & rt.LEVEL | n
    ) : rt.ATTRIBUTE, s.whitelist != null && (this.whitelist = s.whitelist);
  }
  static keys(t) {
    return Array.from(t.attributes).map((e) => e.name);
  }
  add(t, e) {
    return this.canAdd(t, e) ? (t.setAttribute(this.keyName, e), !0) : !1;
  }
  canAdd(t, e) {
    return this.whitelist == null ? !0 : typeof e == "string" ? this.whitelist.indexOf(e.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e) > -1;
  }
  remove(t) {
    t.removeAttribute(this.keyName);
  }
  value(t) {
    const e = t.getAttribute(this.keyName);
    return this.canAdd(t, e) && e ? e : "";
  }
}
class Zr extends Error {
  constructor(t) {
    t = "[Parchment] " + t, super(t), this.message = t, this.name = this.constructor.name;
  }
}
const Ed = class da {
  constructor() {
    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
  }
  static find(t, e = !1) {
    if (t == null)
      return null;
    if (this.blots.has(t))
      return this.blots.get(t) || null;
    if (e) {
      let s = null;
      try {
        s = t.parentNode;
      } catch {
        return null;
      }
      return this.find(s, e);
    }
    return null;
  }
  create(t, e, s) {
    const n = this.query(e);
    if (n == null)
      throw new Zr(`Unable to create ${e} blot`);
    const i = n, o = (
      // @ts-expect-error Fix me later
      e instanceof Node || e.nodeType === Node.TEXT_NODE ? e : i.create(s)
    ), a = new i(t, o, s);
    return da.blots.set(a.domNode, a), a;
  }
  find(t, e = !1) {
    return da.find(t, e);
  }
  query(t, e = rt.ANY) {
    let s;
    return typeof t == "string" ? s = this.types[t] || this.attributes[t] : t instanceof Text || t.nodeType === Node.TEXT_NODE ? s = this.types.text : typeof t == "number" ? t & rt.LEVEL & rt.BLOCK ? s = this.types.block : t & rt.LEVEL & rt.INLINE && (s = this.types.inline) : t instanceof Element && ((t.getAttribute("class") || "").split(/\s+/).some((n) => (s = this.classes[n], !!s)), s = s || this.tags[t.tagName]), s == null ? null : "scope" in s && e & rt.LEVEL & s.scope && e & rt.TYPE & s.scope ? s : null;
  }
  register(...t) {
    return t.map((e) => {
      const s = "blotName" in e, n = "attrName" in e;
      if (!s && !n)
        throw new Zr("Invalid definition");
      if (s && e.blotName === "abstract")
        throw new Zr("Cannot register abstract class");
      const i = s ? e.blotName : n ? e.attrName : void 0;
      return this.types[i] = e, n ? typeof e.keyName == "string" && (this.attributes[e.keyName] = e) : s && (e.className && (this.classes[e.className] = e), e.tagName && (Array.isArray(e.tagName) ? e.tagName = e.tagName.map((o) => o.toUpperCase()) : e.tagName = e.tagName.toUpperCase(), (Array.isArray(e.tagName) ? e.tagName : [e.tagName]).forEach((o) => {
        (this.tags[o] == null || e.className == null) && (this.tags[o] = e);
      }))), e;
    });
  }
};
Ed.blots = /* @__PURE__ */ new WeakMap();
let ns = Ed;
function lu(r, t) {
  return (r.getAttribute("class") || "").split(/\s+/).filter((e) => e.indexOf(`${t}-`) === 0);
}
class Qb extends we {
  static keys(t) {
    return (t.getAttribute("class") || "").split(/\s+/).map((e) => e.split("-").slice(0, -1).join("-"));
  }
  add(t, e) {
    return this.canAdd(t, e) ? (this.remove(t), t.classList.add(`${this.keyName}-${e}`), !0) : !1;
  }
  remove(t) {
    lu(t, this.keyName).forEach((e) => {
      t.classList.remove(e);
    }), t.classList.length === 0 && t.removeAttribute("class");
  }
  value(t) {
    const e = (lu(t, this.keyName)[0] || "").slice(this.keyName.length + 1);
    return this.canAdd(t, e) ? e : "";
  }
}
const he = Qb;
function No(r) {
  const t = r.split("-"), e = t.slice(1).map((s) => s[0].toUpperCase() + s.slice(1)).join("");
  return t[0] + e;
}
class ty extends we {
  static keys(t) {
    return (t.getAttribute("style") || "").split(";").map((e) => e.split(":")[0].trim());
  }
  add(t, e) {
    return this.canAdd(t, e) ? (t.style[No(this.keyName)] = e, !0) : !1;
  }
  remove(t) {
    t.style[No(this.keyName)] = "", t.getAttribute("style") || t.removeAttribute("style");
  }
  value(t) {
    const e = t.style[No(this.keyName)];
    return this.canAdd(t, e) ? e : "";
  }
}
const er = ty;
class ey {
  constructor(t) {
    this.attributes = {}, this.domNode = t, this.build();
  }
  attribute(t, e) {
    e ? t.add(this.domNode, e) && (t.value(this.domNode) != null ? this.attributes[t.attrName] = t : delete this.attributes[t.attrName]) : (t.remove(this.domNode), delete this.attributes[t.attrName]);
  }
  build() {
    this.attributes = {};
    const t = ns.find(this.domNode);
    if (t == null)
      return;
    const e = we.keys(this.domNode), s = he.keys(this.domNode), n = er.keys(this.domNode);
    e.concat(s).concat(n).forEach((i) => {
      const o = t.scroll.query(i, rt.ATTRIBUTE);
      o instanceof we && (this.attributes[o.attrName] = o);
    });
  }
  copy(t) {
    Object.keys(this.attributes).forEach((e) => {
      const s = this.attributes[e].value(this.domNode);
      t.format(e, s);
    });
  }
  move(t) {
    this.copy(t), Object.keys(this.attributes).forEach((e) => {
      this.attributes[e].remove(this.domNode);
    }), this.attributes = {};
  }
  values() {
    return Object.keys(this.attributes).reduce(
      (t, e) => (t[e] = this.attributes[e].value(this.domNode), t),
      {}
    );
  }
}
const bi = ey, _d = class {
  constructor(r, t) {
    this.scroll = r, this.domNode = t, ns.blots.set(t, this), this.prev = null, this.next = null;
  }
  static create(r) {
    if (this.tagName == null)
      throw new Zr("Blot definition missing tagName");
    let t, e;
    return Array.isArray(this.tagName) ? (typeof r == "string" ? (e = r.toUpperCase(), parseInt(e, 10).toString() === e && (e = parseInt(e, 10))) : typeof r == "number" && (e = r), typeof e == "number" ? t = document.createElement(this.tagName[e - 1]) : e && this.tagName.indexOf(e) > -1 ? t = document.createElement(e) : t = document.createElement(this.tagName[0])) : t = document.createElement(this.tagName), this.className && t.classList.add(this.className), t;
  }
  // Hack for accessing inherited static methods
  get statics() {
    return this.constructor;
  }
  attach() {
  }
  clone() {
    const r = this.domNode.cloneNode(!1);
    return this.scroll.create(r);
  }
  detach() {
    this.parent != null && this.parent.removeChild(this), ns.blots.delete(this.domNode);
  }
  deleteAt(r, t) {
    this.isolate(r, t).remove();
  }
  formatAt(r, t, e, s) {
    const n = this.isolate(r, t);
    if (this.scroll.query(e, rt.BLOT) != null && s)
      n.wrap(e, s);
    else if (this.scroll.query(e, rt.ATTRIBUTE) != null) {
      const i = this.scroll.create(this.statics.scope);
      n.wrap(i), i.format(e, s);
    }
  }
  insertAt(r, t, e) {
    const s = e == null ? this.scroll.create("text", t) : this.scroll.create(t, e), n = this.split(r);
    this.parent.insertBefore(s, n || void 0);
  }
  isolate(r, t) {
    const e = this.split(r);
    if (e == null)
      throw new Error("Attempt to isolate at end");
    return e.split(t), e;
  }
  length() {
    return 1;
  }
  offset(r = this.parent) {
    return this.parent == null || this === r ? 0 : this.parent.children.offset(this) + this.parent.offset(r);
  }
  optimize(r) {
    this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
  }
  remove() {
    this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();
  }
  replaceWith(r, t) {
    const e = typeof r == "string" ? this.scroll.create(r, t) : r;
    return this.parent != null && (this.parent.insertBefore(e, this.next || void 0), this.remove()), e;
  }
  split(r, t) {
    return r === 0 ? this : this.next;
  }
  update(r, t) {
  }
  wrap(r, t) {
    const e = typeof r == "string" ? this.scroll.create(r, t) : r;
    if (this.parent != null && this.parent.insertBefore(e, this.next || void 0), typeof e.appendChild != "function")
      throw new Zr(`Cannot wrap ${r}`);
    return e.appendChild(this), e;
  }
};
_d.blotName = "abstract";
let Ad = _d;
const Nd = class extends Ad {
  /**
   * Returns the value represented by domNode if it is this Blot's type
   * No checking that domNode can represent this Blot type is required so
   * applications needing it should check externally before calling.
   */
  static value(r) {
    return !0;
  }
  /**
   * Given location represented by node and offset from DOM Selection Range,
   * return index to that location.
   */
  index(r, t) {
    return this.domNode === r || this.domNode.compareDocumentPosition(r) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(t, 1) : -1;
  }
  /**
   * Given index to location within blot, return node and offset representing
   * that location, consumable by DOM Selection Range
   */
  position(r, t) {
    let e = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
    return r > 0 && (e += 1), [this.parent.domNode, e];
  }
  /**
   * Return value represented by this blot
   * Should not change without interaction from API or
   * user change detectable by update()
   */
  value() {
    return {
      [this.statics.blotName]: this.statics.value(this.domNode) || !0
    };
  }
};
Nd.scope = rt.INLINE_BLOT;
let ry = Nd;
const Pt = ry;
class sy {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  append(...t) {
    if (this.insertBefore(t[0], null), t.length > 1) {
      const e = t.slice(1);
      this.append(...e);
    }
  }
  at(t) {
    const e = this.iterator();
    let s = e();
    for (; s && t > 0; )
      t -= 1, s = e();
    return s;
  }
  contains(t) {
    const e = this.iterator();
    let s = e();
    for (; s; ) {
      if (s === t)
        return !0;
      s = e();
    }
    return !1;
  }
  indexOf(t) {
    const e = this.iterator();
    let s = e(), n = 0;
    for (; s; ) {
      if (s === t)
        return n;
      n += 1, s = e();
    }
    return -1;
  }
  insertBefore(t, e) {
    t != null && (this.remove(t), t.next = e, e != null ? (t.prev = e.prev, e.prev != null && (e.prev.next = t), e.prev = t, e === this.head && (this.head = t)) : this.tail != null ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : (t.prev = null, this.head = this.tail = t), this.length += 1);
  }
  offset(t) {
    let e = 0, s = this.head;
    for (; s != null; ) {
      if (s === t)
        return e;
      e += s.length(), s = s.next;
    }
    return -1;
  }
  remove(t) {
    this.contains(t) && (t.prev != null && (t.prev.next = t.next), t.next != null && (t.next.prev = t.prev), t === this.head && (this.head = t.next), t === this.tail && (this.tail = t.prev), this.length -= 1);
  }
  iterator(t = this.head) {
    return () => {
      const e = t;
      return t != null && (t = t.next), e;
    };
  }
  find(t, e = !1) {
    const s = this.iterator();
    let n = s();
    for (; n; ) {
      const i = n.length();
      if (t < i || e && t === i && (n.next == null || n.next.length() !== 0))
        return [n, t];
      t -= i, n = s();
    }
    return [null, 0];
  }
  forEach(t) {
    const e = this.iterator();
    let s = e();
    for (; s; )
      t(s), s = e();
  }
  forEachAt(t, e, s) {
    if (e <= 0)
      return;
    const [n, i] = this.find(t);
    let o = t - i;
    const a = this.iterator(n);
    let l = a();
    for (; l && o < t + e; ) {
      const c = l.length();
      t > o ? s(
        l,
        t - o,
        Math.min(e, o + c - t)
      ) : s(l, 0, Math.min(c, t + e - o)), o += c, l = a();
    }
  }
  map(t) {
    return this.reduce((e, s) => (e.push(t(s)), e), []);
  }
  reduce(t, e) {
    const s = this.iterator();
    let n = s();
    for (; n; )
      e = t(e, n), n = s();
    return e;
  }
}
function uu(r, t) {
  const e = t.find(r);
  if (e)
    return e;
  try {
    return t.create(r);
  } catch {
    const s = t.create(rt.INLINE);
    return Array.from(r.childNodes).forEach((n) => {
      s.domNode.appendChild(n);
    }), r.parentNode && r.parentNode.replaceChild(s.domNode, r), s.attach(), s;
  }
}
const Sd = class Ue extends Ad {
  constructor(t, e) {
    super(t, e), this.uiNode = null, this.build();
  }
  appendChild(t) {
    this.insertBefore(t);
  }
  attach() {
    super.attach(), this.children.forEach((t) => {
      t.attach();
    });
  }
  attachUI(t) {
    this.uiNode != null && this.uiNode.remove(), this.uiNode = t, Ue.uiClass && this.uiNode.classList.add(Ue.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
  }
  /**
   * Called during construction, should fill its own children LinkedList.
   */
  build() {
    this.children = new sy(), Array.from(this.domNode.childNodes).filter((t) => t !== this.uiNode).reverse().forEach((t) => {
      try {
        const e = uu(t, this.scroll);
        this.insertBefore(e, this.children.head || void 0);
      } catch (e) {
        if (e instanceof Zr)
          return;
        throw e;
      }
    });
  }
  deleteAt(t, e) {
    if (t === 0 && e === this.length())
      return this.remove();
    this.children.forEachAt(t, e, (s, n, i) => {
      s.deleteAt(n, i);
    });
  }
  descendant(t, e = 0) {
    const [s, n] = this.children.find(e);
    return t.blotName == null && t(s) || t.blotName != null && s instanceof t ? [s, n] : s instanceof Ue ? s.descendant(t, n) : [null, -1];
  }
  descendants(t, e = 0, s = Number.MAX_VALUE) {
    let n = [], i = s;
    return this.children.forEachAt(
      e,
      s,
      (o, a, l) => {
        (t.blotName == null && t(o) || t.blotName != null && o instanceof t) && n.push(o), o instanceof Ue && (n = n.concat(
          o.descendants(t, a, i)
        )), i -= l;
      }
    ), n;
  }
  detach() {
    this.children.forEach((t) => {
      t.detach();
    }), super.detach();
  }
  enforceAllowedChildren() {
    let t = !1;
    this.children.forEach((e) => {
      t || this.statics.allowedChildren.some(
        (s) => e instanceof s
      ) || (e.statics.scope === rt.BLOCK_BLOT ? (e.next != null && this.splitAfter(e), e.prev != null && this.splitAfter(e.prev), e.parent.unwrap(), t = !0) : e instanceof Ue ? e.unwrap() : e.remove());
    });
  }
  formatAt(t, e, s, n) {
    this.children.forEachAt(t, e, (i, o, a) => {
      i.formatAt(o, a, s, n);
    });
  }
  insertAt(t, e, s) {
    const [n, i] = this.children.find(t);
    if (n)
      n.insertAt(i, e, s);
    else {
      const o = s == null ? this.scroll.create("text", e) : this.scroll.create(e, s);
      this.appendChild(o);
    }
  }
  insertBefore(t, e) {
    t.parent != null && t.parent.children.remove(t);
    let s = null;
    this.children.insertBefore(t, e || null), t.parent = this, e != null && (s = e.domNode), (this.domNode.parentNode !== t.domNode || this.domNode.nextSibling !== s) && this.domNode.insertBefore(t.domNode, s), t.attach();
  }
  length() {
    return this.children.reduce((t, e) => t + e.length(), 0);
  }
  moveChildren(t, e) {
    this.children.forEach((s) => {
      t.insertBefore(s, e);
    });
  }
  optimize(t) {
    if (super.optimize(t), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0)
      if (this.statics.defaultChild != null) {
        const e = this.scroll.create(this.statics.defaultChild.blotName);
        this.appendChild(e);
      } else
        this.remove();
  }
  path(t, e = !1) {
    const [s, n] = this.children.find(t, e), i = [[this, t]];
    return s instanceof Ue ? i.concat(s.path(n, e)) : (s != null && i.push([s, n]), i);
  }
  removeChild(t) {
    this.children.remove(t);
  }
  replaceWith(t, e) {
    const s = typeof t == "string" ? this.scroll.create(t, e) : t;
    return s instanceof Ue && this.moveChildren(s), super.replaceWith(s);
  }
  split(t, e = !1) {
    if (!e) {
      if (t === 0)
        return this;
      if (t === this.length())
        return this.next;
    }
    const s = this.clone();
    return this.parent && this.parent.insertBefore(s, this.next || void 0), this.children.forEachAt(t, this.length(), (n, i, o) => {
      const a = n.split(i, e);
      a != null && s.appendChild(a);
    }), s;
  }
  splitAfter(t) {
    const e = this.clone();
    for (; t.next != null; )
      e.appendChild(t.next);
    return this.parent && this.parent.insertBefore(e, this.next || void 0), e;
  }
  unwrap() {
    this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
  }
  update(t, e) {
    const s = [], n = [];
    t.forEach((i) => {
      i.target === this.domNode && i.type === "childList" && (s.push(...i.addedNodes), n.push(...i.removedNodes));
    }), n.forEach((i) => {
      if (i.parentNode != null && // @ts-expect-error Fix me later
      i.tagName !== "IFRAME" && document.body.compareDocumentPosition(i) & Node.DOCUMENT_POSITION_CONTAINED_BY)
        return;
      const o = this.scroll.find(i);
      o != null && (o.domNode.parentNode == null || o.domNode.parentNode === this.domNode) && o.detach();
    }), s.filter((i) => i.parentNode === this.domNode && i !== this.uiNode).sort((i, o) => i === o ? 0 : i.compareDocumentPosition(o) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((i) => {
      let o = null;
      i.nextSibling != null && (o = this.scroll.find(i.nextSibling));
      const a = uu(i, this.scroll);
      (a.next !== o || a.next == null) && (a.parent != null && a.parent.removeChild(this), this.insertBefore(a, o || void 0));
    }), this.enforceAllowedChildren();
  }
};
Sd.uiClass = "";
let ny = Sd;
const ue = ny;
function iy(r, t) {
  if (Object.keys(r).length !== Object.keys(t).length)
    return !1;
  for (const e in r)
    if (r[e] !== t[e])
      return !1;
  return !0;
}
const Pr = class Vr extends ue {
  static create(t) {
    return super.create(t);
  }
  static formats(t, e) {
    const s = e.query(Vr.blotName);
    if (!(s != null && t.tagName === s.tagName)) {
      if (typeof this.tagName == "string")
        return !0;
      if (Array.isArray(this.tagName))
        return t.tagName.toLowerCase();
    }
  }
  constructor(t, e) {
    super(t, e), this.attributes = new bi(this.domNode);
  }
  format(t, e) {
    if (t === this.statics.blotName && !e)
      this.children.forEach((s) => {
        s instanceof Vr || (s = s.wrap(Vr.blotName, !0)), this.attributes.copy(s);
      }), this.unwrap();
    else {
      const s = this.scroll.query(t, rt.INLINE);
      if (s == null)
        return;
      s instanceof we ? this.attributes.attribute(s, e) : e && (t !== this.statics.blotName || this.formats()[t] !== e) && this.replaceWith(t, e);
    }
  }
  formats() {
    const t = this.attributes.values(), e = this.statics.formats(this.domNode, this.scroll);
    return e != null && (t[this.statics.blotName] = e), t;
  }
  formatAt(t, e, s, n) {
    this.formats()[s] != null || this.scroll.query(s, rt.ATTRIBUTE) ? this.isolate(t, e).format(s, n) : super.formatAt(t, e, s, n);
  }
  optimize(t) {
    super.optimize(t);
    const e = this.formats();
    if (Object.keys(e).length === 0)
      return this.unwrap();
    const s = this.next;
    s instanceof Vr && s.prev === this && iy(e, s.formats()) && (s.moveChildren(this), s.remove());
  }
  replaceWith(t, e) {
    const s = super.replaceWith(t, e);
    return this.attributes.copy(s), s;
  }
  update(t, e) {
    super.update(t, e), t.some(
      (s) => s.target === this.domNode && s.type === "attributes"
    ) && this.attributes.build();
  }
  wrap(t, e) {
    const s = super.wrap(t, e);
    return s instanceof Vr && this.attributes.move(s), s;
  }
};
Pr.allowedChildren = [Pr, Pt], Pr.blotName = "inline", Pr.scope = rt.INLINE_BLOT, Pr.tagName = "SPAN";
let oy = Pr;
const Ya = oy, Ur = class pa extends ue {
  static create(t) {
    return super.create(t);
  }
  static formats(t, e) {
    const s = e.query(pa.blotName);
    if (!(s != null && t.tagName === s.tagName)) {
      if (typeof this.tagName == "string")
        return !0;
      if (Array.isArray(this.tagName))
        return t.tagName.toLowerCase();
    }
  }
  constructor(t, e) {
    super(t, e), this.attributes = new bi(this.domNode);
  }
  format(t, e) {
    const s = this.scroll.query(t, rt.BLOCK);
    s != null && (s instanceof we ? this.attributes.attribute(s, e) : t === this.statics.blotName && !e ? this.replaceWith(pa.blotName) : e && (t !== this.statics.blotName || this.formats()[t] !== e) && this.replaceWith(t, e));
  }
  formats() {
    const t = this.attributes.values(), e = this.statics.formats(this.domNode, this.scroll);
    return e != null && (t[this.statics.blotName] = e), t;
  }
  formatAt(t, e, s, n) {
    this.scroll.query(s, rt.BLOCK) != null ? this.format(s, n) : super.formatAt(t, e, s, n);
  }
  insertAt(t, e, s) {
    if (s == null || this.scroll.query(e, rt.INLINE) != null)
      super.insertAt(t, e, s);
    else {
      const n = this.split(t);
      if (n != null) {
        const i = this.scroll.create(e, s);
        n.parent.insertBefore(i, n);
      } else
        throw new Error("Attempt to insertAt after block boundaries");
    }
  }
  replaceWith(t, e) {
    const s = super.replaceWith(t, e);
    return this.attributes.copy(s), s;
  }
  update(t, e) {
    super.update(t, e), t.some(
      (s) => s.target === this.domNode && s.type === "attributes"
    ) && this.attributes.build();
  }
};
Ur.blotName = "block", Ur.scope = rt.BLOCK_BLOT, Ur.tagName = "P", Ur.allowedChildren = [
  Ya,
  Ur,
  Pt
];
let ay = Ur;
const Fs = ay, fa = class extends ue {
  checkMerge() {
    return this.next !== null && this.next.statics.blotName === this.statics.blotName;
  }
  deleteAt(r, t) {
    super.deleteAt(r, t), this.enforceAllowedChildren();
  }
  formatAt(r, t, e, s) {
    super.formatAt(r, t, e, s), this.enforceAllowedChildren();
  }
  insertAt(r, t, e) {
    super.insertAt(r, t, e), this.enforceAllowedChildren();
  }
  optimize(r) {
    super.optimize(r), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
  }
};
fa.blotName = "container", fa.scope = rt.BLOCK_BLOT;
let ly = fa;
const yi = ly;
class uy extends Pt {
  static formats(t, e) {
  }
  format(t, e) {
    super.formatAt(0, this.length(), t, e);
  }
  formatAt(t, e, s, n) {
    t === 0 && e === this.length() ? this.format(s, n) : super.formatAt(t, e, s, n);
  }
  formats() {
    return this.statics.formats(this.domNode, this.scroll);
  }
}
const Xt = uy, cy = {
  attributes: !0,
  characterData: !0,
  characterDataOldValue: !0,
  childList: !0,
  subtree: !0
}, hy = 100, $r = class extends ue {
  constructor(r, t) {
    super(null, t), this.registry = r, this.scroll = this, this.build(), this.observer = new MutationObserver((e) => {
      this.update(e);
    }), this.observer.observe(this.domNode, cy), this.attach();
  }
  create(r, t) {
    return this.registry.create(this, r, t);
  }
  find(r, t = !1) {
    const e = this.registry.find(r, t);
    return e ? e.scroll === this ? e : t ? this.find(e.scroll.domNode.parentNode, !0) : null : null;
  }
  query(r, t = rt.ANY) {
    return this.registry.query(r, t);
  }
  register(...r) {
    return this.registry.register(...r);
  }
  build() {
    this.scroll != null && super.build();
  }
  detach() {
    super.detach(), this.observer.disconnect();
  }
  deleteAt(r, t) {
    this.update(), r === 0 && t === this.length() ? this.children.forEach((e) => {
      e.remove();
    }) : super.deleteAt(r, t);
  }
  formatAt(r, t, e, s) {
    this.update(), super.formatAt(r, t, e, s);
  }
  insertAt(r, t, e) {
    this.update(), super.insertAt(r, t, e);
  }
  optimize(r = [], t = {}) {
    super.optimize(t);
    const e = t.mutationsMap || /* @__PURE__ */ new WeakMap();
    let s = Array.from(this.observer.takeRecords());
    for (; s.length > 0; )
      r.push(s.pop());
    const n = (a, l = !0) => {
      a == null || a === this || a.domNode.parentNode != null && (e.has(a.domNode) || e.set(a.domNode, []), l && n(a.parent));
    }, i = (a) => {
      e.has(a.domNode) && (a instanceof ue && a.children.forEach(i), e.delete(a.domNode), a.optimize(t));
    };
    let o = r;
    for (let a = 0; o.length > 0; a += 1) {
      if (a >= hy)
        throw new Error("[Parchment] Maximum optimize iterations reached");
      for (o.forEach((l) => {
        const c = this.find(l.target, !0);
        c != null && (c.domNode === l.target && (l.type === "childList" ? (n(this.find(l.previousSibling, !1)), Array.from(l.addedNodes).forEach((d) => {
          const g = this.find(d, !1);
          n(g, !1), g instanceof ue && g.children.forEach((h) => {
            n(h, !1);
          });
        })) : l.type === "attributes" && n(c.prev)), n(c));
      }), this.children.forEach(i), o = Array.from(this.observer.takeRecords()), s = o.slice(); s.length > 0; )
        r.push(s.pop());
    }
  }
  update(r, t = {}) {
    r = r || this.observer.takeRecords();
    const e = /* @__PURE__ */ new WeakMap();
    r.map((s) => {
      const n = this.find(s.target, !0);
      return n == null ? null : e.has(n.domNode) ? (e.get(n.domNode).push(s), null) : (e.set(n.domNode, [s]), n);
    }).forEach((s) => {
      s != null && s !== this && e.has(s.domNode) && s.update(e.get(s.domNode) || [], t);
    }), t.mutationsMap = e, e.has(this.domNode) && super.update(e.get(this.domNode), t), this.optimize(r, t);
  }
};
$r.blotName = "scroll", $r.defaultChild = Fs, $r.allowedChildren = [Fs, yi], $r.scope = rt.BLOCK_BLOT, $r.tagName = "DIV";
let dy = $r;
const Ja = dy, ma = class Cd extends Pt {
  static create(t) {
    return document.createTextNode(t);
  }
  static value(t) {
    return t.data;
  }
  constructor(t, e) {
    super(t, e), this.text = this.statics.value(this.domNode);
  }
  deleteAt(t, e) {
    this.domNode.data = this.text = this.text.slice(0, t) + this.text.slice(t + e);
  }
  index(t, e) {
    return this.domNode === t ? e : -1;
  }
  insertAt(t, e, s) {
    s == null ? (this.text = this.text.slice(0, t) + e + this.text.slice(t), this.domNode.data = this.text) : super.insertAt(t, e, s);
  }
  length() {
    return this.text.length;
  }
  optimize(t) {
    super.optimize(t), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof Cd && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
  }
  position(t, e = !1) {
    return [this.domNode, t];
  }
  split(t, e = !1) {
    if (!e) {
      if (t === 0)
        return this;
      if (t === this.length())
        return this.next;
    }
    const s = this.scroll.create(this.domNode.splitText(t));
    return this.parent.insertBefore(s, this.next || void 0), this.text = this.statics.value(this.domNode), s;
  }
  update(t, e) {
    t.some((s) => s.type === "characterData" && s.target === this.domNode) && (this.text = this.statics.value(this.domNode));
  }
  value() {
    return this.text;
  }
};
ma.blotName = "text", ma.scope = rt.INLINE_BLOT;
let py = ma;
const Yn = py, fy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Attributor: we,
  AttributorStore: bi,
  BlockBlot: Fs,
  ClassAttributor: he,
  ContainerBlot: yi,
  EmbedBlot: Xt,
  InlineBlot: Ya,
  LeafBlot: Pt,
  ParentBlot: ue,
  Registry: ns,
  Scope: rt,
  ScrollBlot: Ja,
  StyleAttributor: er,
  TextBlot: Yn
}, Symbol.toStringTag, { value: "Module" }));
var So = { exports: {} }, Co, cu;
function my() {
  if (cu) return Co;
  cu = 1;
  var r = -1, t = 1, e = 0;
  function s(b, M, x, $, P) {
    if (b === M)
      return b ? [[e, b]] : [];
    if (x != null) {
      var S = mt(b, M, x);
      if (S)
        return S;
    }
    var B = a(b, M), W = b.substring(0, B);
    b = b.substring(B), M = M.substring(B), B = c(b, M);
    var Z = b.substring(b.length - B);
    b = b.substring(0, b.length - B), M = M.substring(0, M.length - B);
    var w = n(b, M);
    return W && w.unshift([e, W]), Z && w.push([e, Z]), E(w, P), $ && g(w), w;
  }
  function n(b, M) {
    var x;
    if (!b)
      return [[t, M]];
    if (!M)
      return [[r, b]];
    var $ = b.length > M.length ? b : M, P = b.length > M.length ? M : b, S = $.indexOf(P);
    if (S !== -1)
      return x = [
        [t, $.substring(0, S)],
        [e, P],
        [t, $.substring(S + P.length)]
      ], b.length > M.length && (x[0][0] = x[2][0] = r), x;
    if (P.length === 1)
      return [
        [r, b],
        [t, M]
      ];
    var B = d(b, M);
    if (B) {
      var W = B[0], Z = B[1], w = B[2], L = B[3], V = B[4], K = s(W, w), z = s(Z, L);
      return K.concat([[e, V]], z);
    }
    return i(b, M);
  }
  function i(b, M) {
    for (var x = b.length, $ = M.length, P = Math.ceil((x + $) / 2), S = P, B = 2 * P, W = new Array(B), Z = new Array(B), w = 0; w < B; w++)
      W[w] = -1, Z[w] = -1;
    W[S + 1] = 0, Z[S + 1] = 0;
    for (var L = x - $, V = L % 2 !== 0, K = 0, z = 0, U = 0, Y = 0, j = 0; j < P; j++) {
      for (var D = -j + K; D <= j - z; D += 2) {
        var H = S + D, F;
        D === -j || D !== j && W[H - 1] < W[H + 1] ? F = W[H + 1] : F = W[H - 1] + 1;
        for (var J = F - D; F < x && J < $ && b.charAt(F) === M.charAt(J); )
          F++, J++;
        if (W[H] = F, F > x)
          z += 2;
        else if (J > $)
          K += 2;
        else if (V) {
          var T = S + L - D;
          if (T >= 0 && T < B && Z[T] !== -1) {
            var at = x - Z[T];
            if (F >= at)
              return o(b, M, F, J);
          }
        }
      }
      for (var yt = -j + U; yt <= j - Y; yt += 2) {
        var T = S + yt, at;
        yt === -j || yt !== j && Z[T - 1] < Z[T + 1] ? at = Z[T + 1] : at = Z[T - 1] + 1;
        for (var At = at - yt; at < x && At < $ && b.charAt(x - at - 1) === M.charAt($ - At - 1); )
          at++, At++;
        if (Z[T] = at, at > x)
          Y += 2;
        else if (At > $)
          U += 2;
        else if (!V) {
          var H = S + L - yt;
          if (H >= 0 && H < B && W[H] !== -1) {
            var F = W[H], J = S + F - H;
            if (at = x - at, F >= at)
              return o(b, M, F, J);
          }
        }
      }
    }
    return [
      [r, b],
      [t, M]
    ];
  }
  function o(b, M, x, $) {
    var P = b.substring(0, x), S = M.substring(0, $), B = b.substring(x), W = M.substring($), Z = s(P, S), w = s(B, W);
    return Z.concat(w);
  }
  function a(b, M) {
    if (!b || !M || b.charAt(0) !== M.charAt(0))
      return 0;
    for (var x = 0, $ = Math.min(b.length, M.length), P = $, S = 0; x < P; )
      b.substring(S, P) == M.substring(S, P) ? (x = P, S = x) : $ = P, P = Math.floor(($ - x) / 2 + x);
    return N(b.charCodeAt(P - 1)) && P--, P;
  }
  function l(b, M) {
    var x = b.length, $ = M.length;
    if (x == 0 || $ == 0)
      return 0;
    x > $ ? b = b.substring(x - $) : x < $ && (M = M.substring(0, x));
    var P = Math.min(x, $);
    if (b == M)
      return P;
    for (var S = 0, B = 1; ; ) {
      var W = b.substring(P - B), Z = M.indexOf(W);
      if (Z == -1)
        return S;
      B += Z, (Z == 0 || b.substring(P - B) == M.substring(0, B)) && (S = B, B++);
    }
  }
  function c(b, M) {
    if (!b || !M || b.slice(-1) !== M.slice(-1))
      return 0;
    for (var x = 0, $ = Math.min(b.length, M.length), P = $, S = 0; x < P; )
      b.substring(b.length - P, b.length - S) == M.substring(M.length - P, M.length - S) ? (x = P, S = x) : $ = P, P = Math.floor(($ - x) / 2 + x);
    return q(b.charCodeAt(b.length - P)) && P--, P;
  }
  function d(b, M) {
    var x = b.length > M.length ? b : M, $ = b.length > M.length ? M : b;
    if (x.length < 4 || $.length * 2 < x.length)
      return null;
    function P(z, U, Y) {
      for (var j = z.substring(Y, Y + Math.floor(z.length / 4)), D = -1, H = "", F, J, T, at; (D = U.indexOf(j, D + 1)) !== -1; ) {
        var yt = a(
          z.substring(Y),
          U.substring(D)
        ), At = c(
          z.substring(0, Y),
          U.substring(0, D)
        );
        H.length < At + yt && (H = U.substring(D - At, D) + U.substring(D, D + yt), F = z.substring(0, Y - At), J = z.substring(Y + yt), T = U.substring(0, D - At), at = U.substring(D + yt));
      }
      return H.length * 2 >= z.length ? [
        F,
        J,
        T,
        at,
        H
      ] : null;
    }
    var S = P(
      x,
      $,
      Math.ceil(x.length / 4)
    ), B = P(
      x,
      $,
      Math.ceil(x.length / 2)
    ), W;
    if (!S && !B)
      return null;
    B ? S ? W = S[4].length > B[4].length ? S : B : W = B : W = S;
    var Z, w, L, V;
    b.length > M.length ? (Z = W[0], w = W[1], L = W[2], V = W[3]) : (L = W[0], V = W[1], Z = W[2], w = W[3]);
    var K = W[4];
    return [Z, w, L, V, K];
  }
  function g(b) {
    for (var M = !1, x = [], $ = 0, P = null, S = 0, B = 0, W = 0, Z = 0, w = 0; S < b.length; )
      b[S][0] == e ? (x[$++] = S, B = Z, W = w, Z = 0, w = 0, P = b[S][1]) : (b[S][0] == t ? Z += b[S][1].length : w += b[S][1].length, P && P.length <= Math.max(B, W) && P.length <= Math.max(Z, w) && (b.splice(x[$ - 1], 0, [
        r,
        P
      ]), b[x[$ - 1] + 1][0] = t, $--, $--, S = $ > 0 ? x[$ - 1] : -1, B = 0, W = 0, Z = 0, w = 0, P = null, M = !0)), S++;
    for (M && E(b), _(b), S = 1; S < b.length; ) {
      if (b[S - 1][0] == r && b[S][0] == t) {
        var L = b[S - 1][1], V = b[S][1], K = l(L, V), z = l(V, L);
        K >= z ? (K >= L.length / 2 || K >= V.length / 2) && (b.splice(S, 0, [
          e,
          V.substring(0, K)
        ]), b[S - 1][1] = L.substring(
          0,
          L.length - K
        ), b[S + 1][1] = V.substring(K), S++) : (z >= L.length / 2 || z >= V.length / 2) && (b.splice(S, 0, [
          e,
          L.substring(0, z)
        ]), b[S - 1][0] = t, b[S - 1][1] = V.substring(
          0,
          V.length - z
        ), b[S + 1][0] = r, b[S + 1][1] = L.substring(z), S++), S++;
      }
      S++;
    }
  }
  var h = /[^a-zA-Z0-9]/, f = /\s/, v = /[\r\n]/, m = /\n\r?\n$/, k = /^\r?\n\r?\n/;
  function _(b) {
    function M(z, U) {
      if (!z || !U)
        return 6;
      var Y = z.charAt(z.length - 1), j = U.charAt(0), D = Y.match(h), H = j.match(h), F = D && Y.match(f), J = H && j.match(f), T = F && Y.match(v), at = J && j.match(v), yt = T && z.match(m), At = at && U.match(k);
      return yt || At ? 5 : T || at ? 4 : D && !F && J ? 3 : F || J ? 2 : D || H ? 1 : 0;
    }
    for (var x = 1; x < b.length - 1; ) {
      if (b[x - 1][0] == e && b[x + 1][0] == e) {
        var $ = b[x - 1][1], P = b[x][1], S = b[x + 1][1], B = c($, P);
        if (B) {
          var W = P.substring(P.length - B);
          $ = $.substring(0, $.length - B), P = W + P.substring(0, P.length - B), S = W + S;
        }
        for (var Z = $, w = P, L = S, V = M($, P) + M(P, S); P.charAt(0) === S.charAt(0); ) {
          $ += P.charAt(0), P = P.substring(1) + S.charAt(0), S = S.substring(1);
          var K = M($, P) + M(P, S);
          K >= V && (V = K, Z = $, w = P, L = S);
        }
        b[x - 1][1] != Z && (Z ? b[x - 1][1] = Z : (b.splice(x - 1, 1), x--), b[x][1] = w, L ? b[x + 1][1] = L : (b.splice(x + 1, 1), x--));
      }
      x++;
    }
  }
  function E(b, M) {
    b.push([e, ""]);
    for (var x = 0, $ = 0, P = 0, S = "", B = "", W; x < b.length; ) {
      if (x < b.length - 1 && !b[x][1]) {
        b.splice(x, 1);
        continue;
      }
      switch (b[x][0]) {
        case t:
          P++, B += b[x][1], x++;
          break;
        case r:
          $++, S += b[x][1], x++;
          break;
        case e:
          var Z = x - P - $ - 1;
          if (M) {
            if (Z >= 0 && X(b[Z][1])) {
              var w = b[Z][1].slice(-1);
              if (b[Z][1] = b[Z][1].slice(
                0,
                -1
              ), S = w + S, B = w + B, !b[Z][1]) {
                b.splice(Z, 1), x--;
                var L = Z - 1;
                b[L] && b[L][0] === t && (P++, B = b[L][1] + B, L--), b[L] && b[L][0] === r && ($++, S = b[L][1] + S, L--), Z = L;
              }
            }
            if (A(b[x][1])) {
              var w = b[x][1].charAt(0);
              b[x][1] = b[x][1].slice(1), S += w, B += w;
            }
          }
          if (x < b.length - 1 && !b[x][1]) {
            b.splice(x, 1);
            break;
          }
          if (S.length > 0 || B.length > 0) {
            S.length > 0 && B.length > 0 && (W = a(B, S), W !== 0 && (Z >= 0 ? b[Z][1] += B.substring(
              0,
              W
            ) : (b.splice(0, 0, [
              e,
              B.substring(0, W)
            ]), x++), B = B.substring(W), S = S.substring(W)), W = c(B, S), W !== 0 && (b[x][1] = B.substring(B.length - W) + b[x][1], B = B.substring(
              0,
              B.length - W
            ), S = S.substring(
              0,
              S.length - W
            )));
            var V = P + $;
            S.length === 0 && B.length === 0 ? (b.splice(x - V, V), x = x - V) : S.length === 0 ? (b.splice(x - V, V, [t, B]), x = x - V + 1) : B.length === 0 ? (b.splice(x - V, V, [r, S]), x = x - V + 1) : (b.splice(
              x - V,
              V,
              [r, S],
              [t, B]
            ), x = x - V + 2);
          }
          x !== 0 && b[x - 1][0] === e ? (b[x - 1][1] += b[x][1], b.splice(x, 1)) : x++, P = 0, $ = 0, S = "", B = "";
          break;
      }
    }
    b[b.length - 1][1] === "" && b.pop();
    var K = !1;
    for (x = 1; x < b.length - 1; )
      b[x - 1][0] === e && b[x + 1][0] === e && (b[x][1].substring(
        b[x][1].length - b[x - 1][1].length
      ) === b[x - 1][1] ? (b[x][1] = b[x - 1][1] + b[x][1].substring(
        0,
        b[x][1].length - b[x - 1][1].length
      ), b[x + 1][1] = b[x - 1][1] + b[x + 1][1], b.splice(x - 1, 1), K = !0) : b[x][1].substring(0, b[x + 1][1].length) == b[x + 1][1] && (b[x - 1][1] += b[x + 1][1], b[x][1] = b[x][1].substring(b[x + 1][1].length) + b[x + 1][1], b.splice(x + 1, 1), K = !0)), x++;
    K && E(b, M);
  }
  function N(b) {
    return b >= 55296 && b <= 56319;
  }
  function q(b) {
    return b >= 56320 && b <= 57343;
  }
  function A(b) {
    return q(b.charCodeAt(0));
  }
  function X(b) {
    return N(b.charCodeAt(b.length - 1));
  }
  function G(b) {
    for (var M = [], x = 0; x < b.length; x++)
      b[x][1].length > 0 && M.push(b[x]);
    return M;
  }
  function ct(b, M, x, $) {
    return X(b) || A($) ? null : G([
      [e, b],
      [r, M],
      [t, x],
      [e, $]
    ]);
  }
  function mt(b, M, x) {
    var $ = typeof x == "number" ? { index: x, length: 0 } : x.oldRange, P = typeof x == "number" ? null : x.newRange, S = b.length, B = M.length;
    if ($.length === 0 && (P === null || P.length === 0)) {
      var W = $.index, Z = b.slice(0, W), w = b.slice(W), L = P ? P.index : null;
      t: {
        var V = W + B - S;
        if (L !== null && L !== V || V < 0 || V > B)
          break t;
        var K = M.slice(0, V), z = M.slice(V);
        if (z !== w)
          break t;
        var U = Math.min(W, V), Y = Z.slice(0, U), j = K.slice(0, U);
        if (Y !== j)
          break t;
        var D = Z.slice(U), H = K.slice(U);
        return ct(Y, D, H, w);
      }
      t: {
        if (L !== null && L !== W)
          break t;
        var F = W, K = M.slice(0, F), z = M.slice(F);
        if (K !== Z)
          break t;
        var J = Math.min(S - F, B - F), T = w.slice(w.length - J), at = z.slice(z.length - J);
        if (T !== at)
          break t;
        var D = w.slice(0, w.length - J), H = z.slice(0, z.length - J);
        return ct(Z, D, H, T);
      }
    }
    if ($.length > 0 && P && P.length === 0)
      t: {
        var Y = b.slice(0, $.index), T = b.slice($.index + $.length), U = Y.length, J = T.length;
        if (B < U + J)
          break t;
        var j = M.slice(0, U), at = M.slice(B - J);
        if (Y !== j || T !== at)
          break t;
        var D = b.slice(U, S - J), H = M.slice(U, B - J);
        return ct(Y, D, H, T);
      }
    return null;
  }
  function xt(b, M, x, $) {
    return s(b, M, x, $, !0);
  }
  return xt.INSERT = t, xt.DELETE = r, xt.EQUAL = e, Co = xt, Co;
}
var Mn = { exports: {} };
Mn.exports;
var hu;
function Od() {
  return hu || (hu = 1, function(r, t) {
    var e = 200, s = "__lodash_hash_undefined__", n = 9007199254740991, i = "[object Arguments]", o = "[object Array]", a = "[object Boolean]", l = "[object Date]", c = "[object Error]", d = "[object Function]", g = "[object GeneratorFunction]", h = "[object Map]", f = "[object Number]", v = "[object Object]", m = "[object Promise]", k = "[object RegExp]", _ = "[object Set]", E = "[object String]", N = "[object Symbol]", q = "[object WeakMap]", A = "[object ArrayBuffer]", X = "[object DataView]", G = "[object Float32Array]", ct = "[object Float64Array]", mt = "[object Int8Array]", xt = "[object Int16Array]", b = "[object Int32Array]", M = "[object Uint8Array]", x = "[object Uint8ClampedArray]", $ = "[object Uint16Array]", P = "[object Uint32Array]", S = /[\\^$.*+?()[\]{}|]/g, B = /\w*$/, W = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, w = {};
    w[i] = w[o] = w[A] = w[X] = w[a] = w[l] = w[G] = w[ct] = w[mt] = w[xt] = w[b] = w[h] = w[f] = w[v] = w[k] = w[_] = w[E] = w[N] = w[M] = w[x] = w[$] = w[P] = !0, w[c] = w[d] = w[q] = !1;
    var L = typeof ze == "object" && ze && ze.Object === Object && ze, V = typeof self == "object" && self && self.Object === Object && self, K = L || V || Function("return this")(), z = t && !t.nodeType && t, U = z && !0 && r && !r.nodeType && r, Y = U && U.exports === z;
    function j(u, p) {
      return u.set(p[0], p[1]), u;
    }
    function D(u, p) {
      return u.add(p), u;
    }
    function H(u, p) {
      for (var y = -1, O = u ? u.length : 0; ++y < O && p(u[y], y, u) !== !1; )
        ;
      return u;
    }
    function F(u, p) {
      for (var y = -1, O = p.length, lt = u.length; ++y < O; )
        u[lt + y] = p[y];
      return u;
    }
    function J(u, p, y, O) {
      for (var lt = -1, it = u ? u.length : 0; ++lt < it; )
        y = p(y, u[lt], lt, u);
      return y;
    }
    function T(u, p) {
      for (var y = -1, O = Array(u); ++y < u; )
        O[y] = p(y);
      return O;
    }
    function at(u, p) {
      return u == null ? void 0 : u[p];
    }
    function yt(u) {
      var p = !1;
      if (u != null && typeof u.toString != "function")
        try {
          p = !!(u + "");
        } catch {
        }
      return p;
    }
    function At(u) {
      var p = -1, y = Array(u.size);
      return u.forEach(function(O, lt) {
        y[++p] = [lt, O];
      }), y;
    }
    function _e(u, p) {
      return function(y) {
        return u(p(y));
      };
    }
    function Ys(u) {
      var p = -1, y = Array(u.size);
      return u.forEach(function(O) {
        y[++p] = O;
      }), y;
    }
    var Ti = Array.prototype, Ri = Function.prototype, Cr = Object.prototype, cs = K["__core-js_shared__"], Js = function() {
      var u = /[^.]+$/.exec(cs && cs.keys && cs.keys.IE_PROTO || "");
      return u ? "Symbol(src)_1." + u : "";
    }(), Qs = Ri.toString, fe = Cr.hasOwnProperty, Or = Cr.toString, Li = RegExp(
      "^" + Qs.call(fe).replace(S, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), sr = Y ? K.Buffer : void 0, Tr = K.Symbol, hs = K.Uint8Array, Yt = _e(Object.getPrototypeOf, Object), tn = Object.create, en = Cr.propertyIsEnumerable, Ii = Ti.splice, ds = Object.getOwnPropertySymbols, Rr = sr ? sr.isBuffer : void 0, rn = _e(Object.keys, Object), Lr = ne(K, "DataView"), nr = ne(K, "Map"), se = ne(K, "Promise"), Ir = ne(K, "Set"), ps = ne(K, "WeakMap"), ir = ne(Object, "create"), fs = zt(Lr), or = zt(nr), ms = zt(se), gs = zt(Ir), vs = zt(ps), Fe = Tr ? Tr.prototype : void 0, sn = Fe ? Fe.valueOf : void 0;
    function Ae(u) {
      var p = -1, y = u ? u.length : 0;
      for (this.clear(); ++p < y; ) {
        var O = u[p];
        this.set(O[0], O[1]);
      }
    }
    function qi() {
      this.__data__ = ir ? ir(null) : {};
    }
    function ji(u) {
      return this.has(u) && delete this.__data__[u];
    }
    function Mi(u) {
      var p = this.__data__;
      if (ir) {
        var y = p[u];
        return y === s ? void 0 : y;
      }
      return fe.call(p, u) ? p[u] : void 0;
    }
    function nn(u) {
      var p = this.__data__;
      return ir ? p[u] !== void 0 : fe.call(p, u);
    }
    function bs(u, p) {
      var y = this.__data__;
      return y[u] = ir && p === void 0 ? s : p, this;
    }
    Ae.prototype.clear = qi, Ae.prototype.delete = ji, Ae.prototype.get = Mi, Ae.prototype.has = nn, Ae.prototype.set = bs;
    function It(u) {
      var p = -1, y = u ? u.length : 0;
      for (this.clear(); ++p < y; ) {
        var O = u[p];
        this.set(O[0], O[1]);
      }
    }
    function Bi() {
      this.__data__ = [];
    }
    function Di(u) {
      var p = this.__data__, y = jr(p, u);
      if (y < 0)
        return !1;
      var O = p.length - 1;
      return y == O ? p.pop() : Ii.call(p, y, 1), !0;
    }
    function Fi(u) {
      var p = this.__data__, y = jr(p, u);
      return y < 0 ? void 0 : p[y][1];
    }
    function Pi(u) {
      return jr(this.__data__, u) > -1;
    }
    function Vi(u, p) {
      var y = this.__data__, O = jr(y, u);
      return O < 0 ? y.push([u, p]) : y[O][1] = p, this;
    }
    It.prototype.clear = Bi, It.prototype.delete = Di, It.prototype.get = Fi, It.prototype.has = Pi, It.prototype.set = Vi;
    function Bt(u) {
      var p = -1, y = u ? u.length : 0;
      for (this.clear(); ++p < y; ) {
        var O = u[p];
        this.set(O[0], O[1]);
      }
    }
    function Ui() {
      this.__data__ = {
        hash: new Ae(),
        map: new (nr || It)(),
        string: new Ae()
      };
    }
    function $i(u) {
      return lr(this, u).delete(u);
    }
    function zi(u) {
      return lr(this, u).get(u);
    }
    function Hi(u) {
      return lr(this, u).has(u);
    }
    function Ki(u, p) {
      return lr(this, u).set(u, p), this;
    }
    Bt.prototype.clear = Ui, Bt.prototype.delete = $i, Bt.prototype.get = zi, Bt.prototype.has = Hi, Bt.prototype.set = Ki;
    function Ht(u) {
      this.__data__ = new It(u);
    }
    function Gi() {
      this.__data__ = new It();
    }
    function Wi(u) {
      return this.__data__.delete(u);
    }
    function Zi(u) {
      return this.__data__.get(u);
    }
    function Xi(u) {
      return this.__data__.has(u);
    }
    function Yi(u, p) {
      var y = this.__data__;
      if (y instanceof It) {
        var O = y.__data__;
        if (!nr || O.length < e - 1)
          return O.push([u, p]), this;
        y = this.__data__ = new Bt(O);
      }
      return y.set(u, p), this;
    }
    Ht.prototype.clear = Gi, Ht.prototype.delete = Wi, Ht.prototype.get = Zi, Ht.prototype.has = Xi, Ht.prototype.set = Yi;
    function qr(u, p) {
      var y = ws(u) || Br(u) ? T(u.length, String) : [], O = y.length, lt = !!O;
      for (var it in u)
        fe.call(u, it) && !(lt && (it == "length" || ho(it, O))) && y.push(it);
      return y;
    }
    function on(u, p, y) {
      var O = u[p];
      (!(fe.call(u, p) && hn(O, y)) || y === void 0 && !(p in u)) && (u[p] = y);
    }
    function jr(u, p) {
      for (var y = u.length; y--; )
        if (hn(u[y][0], p))
          return y;
      return -1;
    }
    function me(u, p) {
      return u && xs(p, _s(p), u);
    }
    function ys(u, p, y, O, lt, it, ft) {
      var pt;
      if (O && (pt = it ? O(u, lt, it, ft) : O(u)), pt !== void 0)
        return pt;
      if (!ve(u))
        return u;
      var Ot = ws(u);
      if (Ot) {
        if (pt = uo(u), !p)
          return oo(u, pt);
      } else {
        var gt = Se(u), Dt = gt == d || gt == g;
        if (dn(u))
          return Mr(u, p);
        if (gt == v || gt == i || Dt && !it) {
          if (yt(u))
            return it ? u : {};
          if (pt = ge(Dt ? {} : u), !p)
            return ao(u, me(pt, u));
        } else {
          if (!w[gt])
            return it ? u : {};
          pt = co(u, gt, ys, p);
        }
      }
      ft || (ft = new Ht());
      var Kt = ft.get(u);
      if (Kt)
        return Kt;
      if (ft.set(u, pt), !Ot)
        var Rt = y ? lo(u) : _s(u);
      return H(Rt || u, function(Ft, qt) {
        Rt && (qt = Ft, Ft = u[qt]), on(pt, qt, ys(Ft, p, y, O, qt, u, ft));
      }), pt;
    }
    function Ji(u) {
      return ve(u) ? tn(u) : {};
    }
    function Qi(u, p, y) {
      var O = p(u);
      return ws(u) ? O : F(O, y(u));
    }
    function to(u) {
      return Or.call(u);
    }
    function eo(u) {
      if (!ve(u) || fo(u))
        return !1;
      var p = Es(u) || yt(u) ? Li : W;
      return p.test(zt(u));
    }
    function ro(u) {
      if (!un(u))
        return rn(u);
      var p = [];
      for (var y in Object(u))
        fe.call(u, y) && y != "constructor" && p.push(y);
      return p;
    }
    function Mr(u, p) {
      if (p)
        return u.slice();
      var y = new u.constructor(u.length);
      return u.copy(y), y;
    }
    function ks(u) {
      var p = new u.constructor(u.byteLength);
      return new hs(p).set(new hs(u)), p;
    }
    function ar(u, p) {
      var y = p ? ks(u.buffer) : u.buffer;
      return new u.constructor(y, u.byteOffset, u.byteLength);
    }
    function an(u, p, y) {
      var O = p ? y(At(u), !0) : At(u);
      return J(O, j, new u.constructor());
    }
    function ln(u) {
      var p = new u.constructor(u.source, B.exec(u));
      return p.lastIndex = u.lastIndex, p;
    }
    function so(u, p, y) {
      var O = p ? y(Ys(u), !0) : Ys(u);
      return J(O, D, new u.constructor());
    }
    function no(u) {
      return sn ? Object(sn.call(u)) : {};
    }
    function io(u, p) {
      var y = p ? ks(u.buffer) : u.buffer;
      return new u.constructor(y, u.byteOffset, u.length);
    }
    function oo(u, p) {
      var y = -1, O = u.length;
      for (p || (p = Array(O)); ++y < O; )
        p[y] = u[y];
      return p;
    }
    function xs(u, p, y, O) {
      y || (y = {});
      for (var lt = -1, it = p.length; ++lt < it; ) {
        var ft = p[lt], pt = void 0;
        on(y, ft, pt === void 0 ? u[ft] : pt);
      }
      return y;
    }
    function ao(u, p) {
      return xs(u, Ne(u), p);
    }
    function lo(u) {
      return Qi(u, _s, Ne);
    }
    function lr(u, p) {
      var y = u.__data__;
      return po(p) ? y[typeof p == "string" ? "string" : "hash"] : y.map;
    }
    function ne(u, p) {
      var y = at(u, p);
      return eo(y) ? y : void 0;
    }
    var Ne = ds ? _e(ds, Object) : go, Se = to;
    (Lr && Se(new Lr(new ArrayBuffer(1))) != X || nr && Se(new nr()) != h || se && Se(se.resolve()) != m || Ir && Se(new Ir()) != _ || ps && Se(new ps()) != q) && (Se = function(u) {
      var p = Or.call(u), y = p == v ? u.constructor : void 0, O = y ? zt(y) : void 0;
      if (O)
        switch (O) {
          case fs:
            return X;
          case or:
            return h;
          case ms:
            return m;
          case gs:
            return _;
          case vs:
            return q;
        }
      return p;
    });
    function uo(u) {
      var p = u.length, y = u.constructor(p);
      return p && typeof u[0] == "string" && fe.call(u, "index") && (y.index = u.index, y.input = u.input), y;
    }
    function ge(u) {
      return typeof u.constructor == "function" && !un(u) ? Ji(Yt(u)) : {};
    }
    function co(u, p, y, O) {
      var lt = u.constructor;
      switch (p) {
        case A:
          return ks(u);
        case a:
        case l:
          return new lt(+u);
        case X:
          return ar(u, O);
        case G:
        case ct:
        case mt:
        case xt:
        case b:
        case M:
        case x:
        case $:
        case P:
          return io(u, O);
        case h:
          return an(u, O, y);
        case f:
        case E:
          return new lt(u);
        case k:
          return ln(u);
        case _:
          return so(u, O, y);
        case N:
          return no(u);
      }
    }
    function ho(u, p) {
      return p = p ?? n, !!p && (typeof u == "number" || Z.test(u)) && u > -1 && u % 1 == 0 && u < p;
    }
    function po(u) {
      var p = typeof u;
      return p == "string" || p == "number" || p == "symbol" || p == "boolean" ? u !== "__proto__" : u === null;
    }
    function fo(u) {
      return !!Js && Js in u;
    }
    function un(u) {
      var p = u && u.constructor, y = typeof p == "function" && p.prototype || Cr;
      return u === y;
    }
    function zt(u) {
      if (u != null) {
        try {
          return Qs.call(u);
        } catch {
        }
        try {
          return u + "";
        } catch {
        }
      }
      return "";
    }
    function cn(u) {
      return ys(u, !0, !0);
    }
    function hn(u, p) {
      return u === p || u !== u && p !== p;
    }
    function Br(u) {
      return mo(u) && fe.call(u, "callee") && (!en.call(u, "callee") || Or.call(u) == i);
    }
    var ws = Array.isArray;
    function Dr(u) {
      return u != null && pn(u.length) && !Es(u);
    }
    function mo(u) {
      return fn(u) && Dr(u);
    }
    var dn = Rr || vo;
    function Es(u) {
      var p = ve(u) ? Or.call(u) : "";
      return p == d || p == g;
    }
    function pn(u) {
      return typeof u == "number" && u > -1 && u % 1 == 0 && u <= n;
    }
    function ve(u) {
      var p = typeof u;
      return !!u && (p == "object" || p == "function");
    }
    function fn(u) {
      return !!u && typeof u == "object";
    }
    function _s(u) {
      return Dr(u) ? qr(u) : ro(u);
    }
    function go() {
      return [];
    }
    function vo() {
      return !1;
    }
    r.exports = cn;
  }(Mn, Mn.exports)), Mn.exports;
}
var Bn = { exports: {} };
Bn.exports;
var du;
function Td() {
  return du || (du = 1, function(r, t) {
    var e = 200, s = "__lodash_hash_undefined__", n = 1, i = 2, o = 9007199254740991, a = "[object Arguments]", l = "[object Array]", c = "[object AsyncFunction]", d = "[object Boolean]", g = "[object Date]", h = "[object Error]", f = "[object Function]", v = "[object GeneratorFunction]", m = "[object Map]", k = "[object Number]", _ = "[object Null]", E = "[object Object]", N = "[object Promise]", q = "[object Proxy]", A = "[object RegExp]", X = "[object Set]", G = "[object String]", ct = "[object Symbol]", mt = "[object Undefined]", xt = "[object WeakMap]", b = "[object ArrayBuffer]", M = "[object DataView]", x = "[object Float32Array]", $ = "[object Float64Array]", P = "[object Int8Array]", S = "[object Int16Array]", B = "[object Int32Array]", W = "[object Uint8Array]", Z = "[object Uint8ClampedArray]", w = "[object Uint16Array]", L = "[object Uint32Array]", V = /[\\^$.*+?()[\]{}|]/g, K = /^\[object .+?Constructor\]$/, z = /^(?:0|[1-9]\d*)$/, U = {};
    U[x] = U[$] = U[P] = U[S] = U[B] = U[W] = U[Z] = U[w] = U[L] = !0, U[a] = U[l] = U[b] = U[d] = U[M] = U[g] = U[h] = U[f] = U[m] = U[k] = U[E] = U[A] = U[X] = U[G] = U[xt] = !1;
    var Y = typeof ze == "object" && ze && ze.Object === Object && ze, j = typeof self == "object" && self && self.Object === Object && self, D = Y || j || Function("return this")(), H = t && !t.nodeType && t, F = H && !0 && r && !r.nodeType && r, J = F && F.exports === H, T = J && Y.process, at = function() {
      try {
        return T && T.binding && T.binding("util");
      } catch {
      }
    }(), yt = at && at.isTypedArray;
    function At(u, p) {
      for (var y = -1, O = u == null ? 0 : u.length, lt = 0, it = []; ++y < O; ) {
        var ft = u[y];
        p(ft, y, u) && (it[lt++] = ft);
      }
      return it;
    }
    function _e(u, p) {
      for (var y = -1, O = p.length, lt = u.length; ++y < O; )
        u[lt + y] = p[y];
      return u;
    }
    function Ys(u, p) {
      for (var y = -1, O = u == null ? 0 : u.length; ++y < O; )
        if (p(u[y], y, u))
          return !0;
      return !1;
    }
    function Ti(u, p) {
      for (var y = -1, O = Array(u); ++y < u; )
        O[y] = p(y);
      return O;
    }
    function Ri(u) {
      return function(p) {
        return u(p);
      };
    }
    function Cr(u, p) {
      return u.has(p);
    }
    function cs(u, p) {
      return u == null ? void 0 : u[p];
    }
    function Js(u) {
      var p = -1, y = Array(u.size);
      return u.forEach(function(O, lt) {
        y[++p] = [lt, O];
      }), y;
    }
    function Qs(u, p) {
      return function(y) {
        return u(p(y));
      };
    }
    function fe(u) {
      var p = -1, y = Array(u.size);
      return u.forEach(function(O) {
        y[++p] = O;
      }), y;
    }
    var Or = Array.prototype, Li = Function.prototype, sr = Object.prototype, Tr = D["__core-js_shared__"], hs = Li.toString, Yt = sr.hasOwnProperty, tn = function() {
      var u = /[^.]+$/.exec(Tr && Tr.keys && Tr.keys.IE_PROTO || "");
      return u ? "Symbol(src)_1." + u : "";
    }(), en = sr.toString, Ii = RegExp(
      "^" + hs.call(Yt).replace(V, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), ds = J ? D.Buffer : void 0, Rr = D.Symbol, rn = D.Uint8Array, Lr = sr.propertyIsEnumerable, nr = Or.splice, se = Rr ? Rr.toStringTag : void 0, Ir = Object.getOwnPropertySymbols, ps = ds ? ds.isBuffer : void 0, ir = Qs(Object.keys, Object), fs = Ne(D, "DataView"), or = Ne(D, "Map"), ms = Ne(D, "Promise"), gs = Ne(D, "Set"), vs = Ne(D, "WeakMap"), Fe = Ne(Object, "create"), sn = zt(fs), Ae = zt(or), qi = zt(ms), ji = zt(gs), Mi = zt(vs), nn = Rr ? Rr.prototype : void 0, bs = nn ? nn.valueOf : void 0;
    function It(u) {
      var p = -1, y = u == null ? 0 : u.length;
      for (this.clear(); ++p < y; ) {
        var O = u[p];
        this.set(O[0], O[1]);
      }
    }
    function Bi() {
      this.__data__ = Fe ? Fe(null) : {}, this.size = 0;
    }
    function Di(u) {
      var p = this.has(u) && delete this.__data__[u];
      return this.size -= p ? 1 : 0, p;
    }
    function Fi(u) {
      var p = this.__data__;
      if (Fe) {
        var y = p[u];
        return y === s ? void 0 : y;
      }
      return Yt.call(p, u) ? p[u] : void 0;
    }
    function Pi(u) {
      var p = this.__data__;
      return Fe ? p[u] !== void 0 : Yt.call(p, u);
    }
    function Vi(u, p) {
      var y = this.__data__;
      return this.size += this.has(u) ? 0 : 1, y[u] = Fe && p === void 0 ? s : p, this;
    }
    It.prototype.clear = Bi, It.prototype.delete = Di, It.prototype.get = Fi, It.prototype.has = Pi, It.prototype.set = Vi;
    function Bt(u) {
      var p = -1, y = u == null ? 0 : u.length;
      for (this.clear(); ++p < y; ) {
        var O = u[p];
        this.set(O[0], O[1]);
      }
    }
    function Ui() {
      this.__data__ = [], this.size = 0;
    }
    function $i(u) {
      var p = this.__data__, y = Mr(p, u);
      if (y < 0)
        return !1;
      var O = p.length - 1;
      return y == O ? p.pop() : nr.call(p, y, 1), --this.size, !0;
    }
    function zi(u) {
      var p = this.__data__, y = Mr(p, u);
      return y < 0 ? void 0 : p[y][1];
    }
    function Hi(u) {
      return Mr(this.__data__, u) > -1;
    }
    function Ki(u, p) {
      var y = this.__data__, O = Mr(y, u);
      return O < 0 ? (++this.size, y.push([u, p])) : y[O][1] = p, this;
    }
    Bt.prototype.clear = Ui, Bt.prototype.delete = $i, Bt.prototype.get = zi, Bt.prototype.has = Hi, Bt.prototype.set = Ki;
    function Ht(u) {
      var p = -1, y = u == null ? 0 : u.length;
      for (this.clear(); ++p < y; ) {
        var O = u[p];
        this.set(O[0], O[1]);
      }
    }
    function Gi() {
      this.size = 0, this.__data__ = {
        hash: new It(),
        map: new (or || Bt)(),
        string: new It()
      };
    }
    function Wi(u) {
      var p = ne(this, u).delete(u);
      return this.size -= p ? 1 : 0, p;
    }
    function Zi(u) {
      return ne(this, u).get(u);
    }
    function Xi(u) {
      return ne(this, u).has(u);
    }
    function Yi(u, p) {
      var y = ne(this, u), O = y.size;
      return y.set(u, p), this.size += y.size == O ? 0 : 1, this;
    }
    Ht.prototype.clear = Gi, Ht.prototype.delete = Wi, Ht.prototype.get = Zi, Ht.prototype.has = Xi, Ht.prototype.set = Yi;
    function qr(u) {
      var p = -1, y = u == null ? 0 : u.length;
      for (this.__data__ = new Ht(); ++p < y; )
        this.add(u[p]);
    }
    function on(u) {
      return this.__data__.set(u, s), this;
    }
    function jr(u) {
      return this.__data__.has(u);
    }
    qr.prototype.add = qr.prototype.push = on, qr.prototype.has = jr;
    function me(u) {
      var p = this.__data__ = new Bt(u);
      this.size = p.size;
    }
    function ys() {
      this.__data__ = new Bt(), this.size = 0;
    }
    function Ji(u) {
      var p = this.__data__, y = p.delete(u);
      return this.size = p.size, y;
    }
    function Qi(u) {
      return this.__data__.get(u);
    }
    function to(u) {
      return this.__data__.has(u);
    }
    function eo(u, p) {
      var y = this.__data__;
      if (y instanceof Bt) {
        var O = y.__data__;
        if (!or || O.length < e - 1)
          return O.push([u, p]), this.size = ++y.size, this;
        y = this.__data__ = new Ht(O);
      }
      return y.set(u, p), this.size = y.size, this;
    }
    me.prototype.clear = ys, me.prototype.delete = Ji, me.prototype.get = Qi, me.prototype.has = to, me.prototype.set = eo;
    function ro(u, p) {
      var y = Br(u), O = !y && hn(u), lt = !y && !O && Dr(u), it = !y && !O && !lt && fn(u), ft = y || O || lt || it, pt = ft ? Ti(u.length, String) : [], Ot = pt.length;
      for (var gt in u)
        Yt.call(u, gt) && !(ft && // Safari 9 has enumerable `arguments.length` in strict mode.
        (gt == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        lt && (gt == "offset" || gt == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        it && (gt == "buffer" || gt == "byteLength" || gt == "byteOffset") || // Skip index properties.
        co(gt, Ot))) && pt.push(gt);
      return pt;
    }
    function Mr(u, p) {
      for (var y = u.length; y--; )
        if (cn(u[y][0], p))
          return y;
      return -1;
    }
    function ks(u, p, y) {
      var O = p(u);
      return Br(u) ? O : _e(O, y(u));
    }
    function ar(u) {
      return u == null ? u === void 0 ? mt : _ : se && se in Object(u) ? Se(u) : un(u);
    }
    function an(u) {
      return ve(u) && ar(u) == a;
    }
    function ln(u, p, y, O, lt) {
      return u === p ? !0 : u == null || p == null || !ve(u) && !ve(p) ? u !== u && p !== p : so(u, p, y, O, ln, lt);
    }
    function so(u, p, y, O, lt, it) {
      var ft = Br(u), pt = Br(p), Ot = ft ? l : ge(u), gt = pt ? l : ge(p);
      Ot = Ot == a ? E : Ot, gt = gt == a ? E : gt;
      var Dt = Ot == E, Kt = gt == E, Rt = Ot == gt;
      if (Rt && Dr(u)) {
        if (!Dr(p))
          return !1;
        ft = !0, Dt = !1;
      }
      if (Rt && !Dt)
        return it || (it = new me()), ft || fn(u) ? xs(u, p, y, O, lt, it) : ao(u, p, Ot, y, O, lt, it);
      if (!(y & n)) {
        var Ft = Dt && Yt.call(u, "__wrapped__"), qt = Kt && Yt.call(p, "__wrapped__");
        if (Ft || qt) {
          var Pe = Ft ? u.value() : u, Ce = qt ? p.value() : p;
          return it || (it = new me()), lt(Pe, Ce, y, O, it);
        }
      }
      return Rt ? (it || (it = new me()), lo(u, p, y, O, lt, it)) : !1;
    }
    function no(u) {
      if (!pn(u) || po(u))
        return !1;
      var p = dn(u) ? Ii : K;
      return p.test(zt(u));
    }
    function io(u) {
      return ve(u) && Es(u.length) && !!U[ar(u)];
    }
    function oo(u) {
      if (!fo(u))
        return ir(u);
      var p = [];
      for (var y in Object(u))
        Yt.call(u, y) && y != "constructor" && p.push(y);
      return p;
    }
    function xs(u, p, y, O, lt, it) {
      var ft = y & n, pt = u.length, Ot = p.length;
      if (pt != Ot && !(ft && Ot > pt))
        return !1;
      var gt = it.get(u);
      if (gt && it.get(p))
        return gt == p;
      var Dt = -1, Kt = !0, Rt = y & i ? new qr() : void 0;
      for (it.set(u, p), it.set(p, u); ++Dt < pt; ) {
        var Ft = u[Dt], qt = p[Dt];
        if (O)
          var Pe = ft ? O(qt, Ft, Dt, p, u, it) : O(Ft, qt, Dt, u, p, it);
        if (Pe !== void 0) {
          if (Pe)
            continue;
          Kt = !1;
          break;
        }
        if (Rt) {
          if (!Ys(p, function(Ce, ur) {
            if (!Cr(Rt, ur) && (Ft === Ce || lt(Ft, Ce, y, O, it)))
              return Rt.push(ur);
          })) {
            Kt = !1;
            break;
          }
        } else if (!(Ft === qt || lt(Ft, qt, y, O, it))) {
          Kt = !1;
          break;
        }
      }
      return it.delete(u), it.delete(p), Kt;
    }
    function ao(u, p, y, O, lt, it, ft) {
      switch (y) {
        case M:
          if (u.byteLength != p.byteLength || u.byteOffset != p.byteOffset)
            return !1;
          u = u.buffer, p = p.buffer;
        case b:
          return !(u.byteLength != p.byteLength || !it(new rn(u), new rn(p)));
        case d:
        case g:
        case k:
          return cn(+u, +p);
        case h:
          return u.name == p.name && u.message == p.message;
        case A:
        case G:
          return u == p + "";
        case m:
          var pt = Js;
        case X:
          var Ot = O & n;
          if (pt || (pt = fe), u.size != p.size && !Ot)
            return !1;
          var gt = ft.get(u);
          if (gt)
            return gt == p;
          O |= i, ft.set(u, p);
          var Dt = xs(pt(u), pt(p), O, lt, it, ft);
          return ft.delete(u), Dt;
        case ct:
          if (bs)
            return bs.call(u) == bs.call(p);
      }
      return !1;
    }
    function lo(u, p, y, O, lt, it) {
      var ft = y & n, pt = lr(u), Ot = pt.length, gt = lr(p), Dt = gt.length;
      if (Ot != Dt && !ft)
        return !1;
      for (var Kt = Ot; Kt--; ) {
        var Rt = pt[Kt];
        if (!(ft ? Rt in p : Yt.call(p, Rt)))
          return !1;
      }
      var Ft = it.get(u);
      if (Ft && it.get(p))
        return Ft == p;
      var qt = !0;
      it.set(u, p), it.set(p, u);
      for (var Pe = ft; ++Kt < Ot; ) {
        Rt = pt[Kt];
        var Ce = u[Rt], ur = p[Rt];
        if (O)
          var hl = ft ? O(ur, Ce, Rt, p, u, it) : O(Ce, ur, Rt, u, p, it);
        if (!(hl === void 0 ? Ce === ur || lt(Ce, ur, y, O, it) : hl)) {
          qt = !1;
          break;
        }
        Pe || (Pe = Rt == "constructor");
      }
      if (qt && !Pe) {
        var mn = u.constructor, gn = p.constructor;
        mn != gn && "constructor" in u && "constructor" in p && !(typeof mn == "function" && mn instanceof mn && typeof gn == "function" && gn instanceof gn) && (qt = !1);
      }
      return it.delete(u), it.delete(p), qt;
    }
    function lr(u) {
      return ks(u, _s, uo);
    }
    function ne(u, p) {
      var y = u.__data__;
      return ho(p) ? y[typeof p == "string" ? "string" : "hash"] : y.map;
    }
    function Ne(u, p) {
      var y = cs(u, p);
      return no(y) ? y : void 0;
    }
    function Se(u) {
      var p = Yt.call(u, se), y = u[se];
      try {
        u[se] = void 0;
        var O = !0;
      } catch {
      }
      var lt = en.call(u);
      return O && (p ? u[se] = y : delete u[se]), lt;
    }
    var uo = Ir ? function(u) {
      return u == null ? [] : (u = Object(u), At(Ir(u), function(p) {
        return Lr.call(u, p);
      }));
    } : go, ge = ar;
    (fs && ge(new fs(new ArrayBuffer(1))) != M || or && ge(new or()) != m || ms && ge(ms.resolve()) != N || gs && ge(new gs()) != X || vs && ge(new vs()) != xt) && (ge = function(u) {
      var p = ar(u), y = p == E ? u.constructor : void 0, O = y ? zt(y) : "";
      if (O)
        switch (O) {
          case sn:
            return M;
          case Ae:
            return m;
          case qi:
            return N;
          case ji:
            return X;
          case Mi:
            return xt;
        }
      return p;
    });
    function co(u, p) {
      return p = p ?? o, !!p && (typeof u == "number" || z.test(u)) && u > -1 && u % 1 == 0 && u < p;
    }
    function ho(u) {
      var p = typeof u;
      return p == "string" || p == "number" || p == "symbol" || p == "boolean" ? u !== "__proto__" : u === null;
    }
    function po(u) {
      return !!tn && tn in u;
    }
    function fo(u) {
      var p = u && u.constructor, y = typeof p == "function" && p.prototype || sr;
      return u === y;
    }
    function un(u) {
      return en.call(u);
    }
    function zt(u) {
      if (u != null) {
        try {
          return hs.call(u);
        } catch {
        }
        try {
          return u + "";
        } catch {
        }
      }
      return "";
    }
    function cn(u, p) {
      return u === p || u !== u && p !== p;
    }
    var hn = an(/* @__PURE__ */ function() {
      return arguments;
    }()) ? an : function(u) {
      return ve(u) && Yt.call(u, "callee") && !Lr.call(u, "callee");
    }, Br = Array.isArray;
    function ws(u) {
      return u != null && Es(u.length) && !dn(u);
    }
    var Dr = ps || vo;
    function mo(u, p) {
      return ln(u, p);
    }
    function dn(u) {
      if (!pn(u))
        return !1;
      var p = ar(u);
      return p == f || p == v || p == c || p == q;
    }
    function Es(u) {
      return typeof u == "number" && u > -1 && u % 1 == 0 && u <= o;
    }
    function pn(u) {
      var p = typeof u;
      return u != null && (p == "object" || p == "function");
    }
    function ve(u) {
      return u != null && typeof u == "object";
    }
    var fn = yt ? Ri(yt) : io;
    function _s(u) {
      return ws(u) ? ro(u) : oo(u);
    }
    function go() {
      return [];
    }
    function vo() {
      return !1;
    }
    r.exports = mo;
  }(Bn, Bn.exports)), Bn.exports;
}
var wn = {}, pu;
function gy() {
  if (pu) return wn;
  pu = 1, Object.defineProperty(wn, "__esModule", { value: !0 });
  const r = Od(), t = Td();
  var e;
  return function(s) {
    function n(l = {}, c = {}, d = !1) {
      typeof l != "object" && (l = {}), typeof c != "object" && (c = {});
      let g = r(c);
      d || (g = Object.keys(g).reduce((h, f) => (g[f] != null && (h[f] = g[f]), h), {}));
      for (const h in l)
        l[h] !== void 0 && c[h] === void 0 && (g[h] = l[h]);
      return Object.keys(g).length > 0 ? g : void 0;
    }
    s.compose = n;
    function i(l = {}, c = {}) {
      typeof l != "object" && (l = {}), typeof c != "object" && (c = {});
      const d = Object.keys(l).concat(Object.keys(c)).reduce((g, h) => (t(l[h], c[h]) || (g[h] = c[h] === void 0 ? null : c[h]), g), {});
      return Object.keys(d).length > 0 ? d : void 0;
    }
    s.diff = i;
    function o(l = {}, c = {}) {
      l = l || {};
      const d = Object.keys(c).reduce((g, h) => (c[h] !== l[h] && l[h] !== void 0 && (g[h] = c[h]), g), {});
      return Object.keys(l).reduce((g, h) => (l[h] !== c[h] && c[h] === void 0 && (g[h] = null), g), d);
    }
    s.invert = o;
    function a(l, c, d = !1) {
      if (typeof l != "object")
        return c;
      if (typeof c != "object")
        return;
      if (!d)
        return c;
      const g = Object.keys(c).reduce((h, f) => (l[f] === void 0 && (h[f] = c[f]), h), {});
      return Object.keys(g).length > 0 ? g : void 0;
    }
    s.transform = a;
  }(e || (e = {})), wn.default = e, wn;
}
var En = {}, fu;
function Rd() {
  if (fu) return En;
  fu = 1, Object.defineProperty(En, "__esModule", { value: !0 });
  var r;
  return function(t) {
    function e(s) {
      return typeof s.delete == "number" ? s.delete : typeof s.retain == "number" ? s.retain : typeof s.retain == "object" && s.retain !== null ? 1 : typeof s.insert == "string" ? s.insert.length : 1;
    }
    t.length = e;
  }(r || (r = {})), En.default = r, En;
}
var _n = {}, mu;
function vy() {
  if (mu) return _n;
  mu = 1, Object.defineProperty(_n, "__esModule", { value: !0 });
  const r = Rd();
  class t {
    constructor(s) {
      this.ops = s, this.index = 0, this.offset = 0;
    }
    hasNext() {
      return this.peekLength() < 1 / 0;
    }
    next(s) {
      s || (s = 1 / 0);
      const n = this.ops[this.index];
      if (n) {
        const i = this.offset, o = r.default.length(n);
        if (s >= o - i ? (s = o - i, this.index += 1, this.offset = 0) : this.offset += s, typeof n.delete == "number")
          return { delete: s };
        {
          const a = {};
          return n.attributes && (a.attributes = n.attributes), typeof n.retain == "number" ? a.retain = s : typeof n.retain == "object" && n.retain !== null ? a.retain = n.retain : typeof n.insert == "string" ? a.insert = n.insert.substr(i, s) : a.insert = n.insert, a;
        }
      } else
        return { retain: 1 / 0 };
    }
    peek() {
      return this.ops[this.index];
    }
    peekLength() {
      return this.ops[this.index] ? r.default.length(this.ops[this.index]) - this.offset : 1 / 0;
    }
    peekType() {
      const s = this.ops[this.index];
      return s ? typeof s.delete == "number" ? "delete" : typeof s.retain == "number" || typeof s.retain == "object" && s.retain !== null ? "retain" : "insert" : "retain";
    }
    rest() {
      if (this.hasNext()) {
        if (this.offset === 0)
          return this.ops.slice(this.index);
        {
          const s = this.offset, n = this.index, i = this.next(), o = this.ops.slice(this.index);
          return this.offset = s, this.index = n, [i].concat(o);
        }
      } else return [];
    }
  }
  return _n.default = t, _n;
}
var gu;
function by() {
  return gu || (gu = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AttributeMap = t.OpIterator = t.Op = void 0;
    const e = my(), s = Od(), n = Td(), i = gy();
    t.AttributeMap = i.default;
    const o = Rd();
    t.Op = o.default;
    const a = vy();
    t.OpIterator = a.default;
    const l = "\0", c = (g, h) => {
      if (typeof g != "object" || g === null)
        throw new Error(`cannot retain a ${typeof g}`);
      if (typeof h != "object" || h === null)
        throw new Error(`cannot retain a ${typeof h}`);
      const f = Object.keys(g)[0];
      if (!f || f !== Object.keys(h)[0])
        throw new Error(`embed types not matched: ${f} != ${Object.keys(h)[0]}`);
      return [f, g[f], h[f]];
    };
    class d {
      constructor(h) {
        Array.isArray(h) ? this.ops = h : h != null && Array.isArray(h.ops) ? this.ops = h.ops : this.ops = [];
      }
      static registerEmbed(h, f) {
        this.handlers[h] = f;
      }
      static unregisterEmbed(h) {
        delete this.handlers[h];
      }
      static getHandler(h) {
        const f = this.handlers[h];
        if (!f)
          throw new Error(`no handlers for embed type "${h}"`);
        return f;
      }
      insert(h, f) {
        const v = {};
        return typeof h == "string" && h.length === 0 ? this : (v.insert = h, f != null && typeof f == "object" && Object.keys(f).length > 0 && (v.attributes = f), this.push(v));
      }
      delete(h) {
        return h <= 0 ? this : this.push({ delete: h });
      }
      retain(h, f) {
        if (typeof h == "number" && h <= 0)
          return this;
        const v = { retain: h };
        return f != null && typeof f == "object" && Object.keys(f).length > 0 && (v.attributes = f), this.push(v);
      }
      push(h) {
        let f = this.ops.length, v = this.ops[f - 1];
        if (h = s(h), typeof v == "object") {
          if (typeof h.delete == "number" && typeof v.delete == "number")
            return this.ops[f - 1] = { delete: v.delete + h.delete }, this;
          if (typeof v.delete == "number" && h.insert != null && (f -= 1, v = this.ops[f - 1], typeof v != "object"))
            return this.ops.unshift(h), this;
          if (n(h.attributes, v.attributes)) {
            if (typeof h.insert == "string" && typeof v.insert == "string")
              return this.ops[f - 1] = { insert: v.insert + h.insert }, typeof h.attributes == "object" && (this.ops[f - 1].attributes = h.attributes), this;
            if (typeof h.retain == "number" && typeof v.retain == "number")
              return this.ops[f - 1] = { retain: v.retain + h.retain }, typeof h.attributes == "object" && (this.ops[f - 1].attributes = h.attributes), this;
          }
        }
        return f === this.ops.length ? this.ops.push(h) : this.ops.splice(f, 0, h), this;
      }
      chop() {
        const h = this.ops[this.ops.length - 1];
        return h && typeof h.retain == "number" && !h.attributes && this.ops.pop(), this;
      }
      filter(h) {
        return this.ops.filter(h);
      }
      forEach(h) {
        this.ops.forEach(h);
      }
      map(h) {
        return this.ops.map(h);
      }
      partition(h) {
        const f = [], v = [];
        return this.forEach((m) => {
          (h(m) ? f : v).push(m);
        }), [f, v];
      }
      reduce(h, f) {
        return this.ops.reduce(h, f);
      }
      changeLength() {
        return this.reduce((h, f) => f.insert ? h + o.default.length(f) : f.delete ? h - f.delete : h, 0);
      }
      length() {
        return this.reduce((h, f) => h + o.default.length(f), 0);
      }
      slice(h = 0, f = 1 / 0) {
        const v = [], m = new a.default(this.ops);
        let k = 0;
        for (; k < f && m.hasNext(); ) {
          let _;
          k < h ? _ = m.next(h - k) : (_ = m.next(f - k), v.push(_)), k += o.default.length(_);
        }
        return new d(v);
      }
      compose(h) {
        const f = new a.default(this.ops), v = new a.default(h.ops), m = [], k = v.peek();
        if (k != null && typeof k.retain == "number" && k.attributes == null) {
          let E = k.retain;
          for (; f.peekType() === "insert" && f.peekLength() <= E; )
            E -= f.peekLength(), m.push(f.next());
          k.retain - E > 0 && v.next(k.retain - E);
        }
        const _ = new d(m);
        for (; f.hasNext() || v.hasNext(); )
          if (v.peekType() === "insert")
            _.push(v.next());
          else if (f.peekType() === "delete")
            _.push(f.next());
          else {
            const E = Math.min(f.peekLength(), v.peekLength()), N = f.next(E), q = v.next(E);
            if (q.retain) {
              const A = {};
              if (typeof N.retain == "number")
                A.retain = typeof q.retain == "number" ? E : q.retain;
              else if (typeof q.retain == "number")
                N.retain == null ? A.insert = N.insert : A.retain = N.retain;
              else {
                const G = N.retain == null ? "insert" : "retain", [ct, mt, xt] = c(N[G], q.retain), b = d.getHandler(ct);
                A[G] = {
                  [ct]: b.compose(mt, xt, G === "retain")
                };
              }
              const X = i.default.compose(N.attributes, q.attributes, typeof N.retain == "number");
              if (X && (A.attributes = X), _.push(A), !v.hasNext() && n(_.ops[_.ops.length - 1], A)) {
                const G = new d(f.rest());
                return _.concat(G).chop();
              }
            } else typeof q.delete == "number" && (typeof N.retain == "number" || typeof N.retain == "object" && N.retain !== null) && _.push(q);
          }
        return _.chop();
      }
      concat(h) {
        const f = new d(this.ops.slice());
        return h.ops.length > 0 && (f.push(h.ops[0]), f.ops = f.ops.concat(h.ops.slice(1))), f;
      }
      diff(h, f) {
        if (this.ops === h.ops)
          return new d();
        const v = [this, h].map((N) => N.map((q) => {
          if (q.insert != null)
            return typeof q.insert == "string" ? q.insert : l;
          const A = N === h ? "on" : "with";
          throw new Error("diff() called " + A + " non-document");
        }).join("")), m = new d(), k = e(v[0], v[1], f, !0), _ = new a.default(this.ops), E = new a.default(h.ops);
        return k.forEach((N) => {
          let q = N[1].length;
          for (; q > 0; ) {
            let A = 0;
            switch (N[0]) {
              case e.INSERT:
                A = Math.min(E.peekLength(), q), m.push(E.next(A));
                break;
              case e.DELETE:
                A = Math.min(q, _.peekLength()), _.next(A), m.delete(A);
                break;
              case e.EQUAL:
                A = Math.min(_.peekLength(), E.peekLength(), q);
                const X = _.next(A), G = E.next(A);
                n(X.insert, G.insert) ? m.retain(A, i.default.diff(X.attributes, G.attributes)) : m.push(G).delete(A);
                break;
            }
            q -= A;
          }
        }), m.chop();
      }
      eachLine(h, f = `
`) {
        const v = new a.default(this.ops);
        let m = new d(), k = 0;
        for (; v.hasNext(); ) {
          if (v.peekType() !== "insert")
            return;
          const _ = v.peek(), E = o.default.length(_) - v.peekLength(), N = typeof _.insert == "string" ? _.insert.indexOf(f, E) - E : -1;
          if (N < 0)
            m.push(v.next());
          else if (N > 0)
            m.push(v.next(N));
          else {
            if (h(m, v.next(1).attributes || {}, k) === !1)
              return;
            k += 1, m = new d();
          }
        }
        m.length() > 0 && h(m, {}, k);
      }
      invert(h) {
        const f = new d();
        return this.reduce((v, m) => {
          if (m.insert)
            f.delete(o.default.length(m));
          else {
            if (typeof m.retain == "number" && m.attributes == null)
              return f.retain(m.retain), v + m.retain;
            if (m.delete || typeof m.retain == "number") {
              const k = m.delete || m.retain;
              return h.slice(v, v + k).forEach((_) => {
                m.delete ? f.push(_) : m.retain && m.attributes && f.retain(o.default.length(_), i.default.invert(m.attributes, _.attributes));
              }), v + k;
            } else if (typeof m.retain == "object" && m.retain !== null) {
              const k = h.slice(v, v + 1), _ = new a.default(k.ops).next(), [E, N, q] = c(m.retain, _.insert), A = d.getHandler(E);
              return f.retain({ [E]: A.invert(N, q) }, i.default.invert(m.attributes, _.attributes)), v + 1;
            }
          }
          return v;
        }, 0), f.chop();
      }
      transform(h, f = !1) {
        if (f = !!f, typeof h == "number")
          return this.transformPosition(h, f);
        const v = h, m = new a.default(this.ops), k = new a.default(v.ops), _ = new d();
        for (; m.hasNext() || k.hasNext(); )
          if (m.peekType() === "insert" && (f || k.peekType() !== "insert"))
            _.retain(o.default.length(m.next()));
          else if (k.peekType() === "insert")
            _.push(k.next());
          else {
            const E = Math.min(m.peekLength(), k.peekLength()), N = m.next(E), q = k.next(E);
            if (N.delete)
              continue;
            if (q.delete)
              _.push(q);
            else {
              const A = N.retain, X = q.retain;
              let G = typeof X == "object" && X !== null ? X : E;
              if (typeof A == "object" && A !== null && typeof X == "object" && X !== null) {
                const ct = Object.keys(A)[0];
                if (ct === Object.keys(X)[0]) {
                  const mt = d.getHandler(ct);
                  mt && (G = {
                    [ct]: mt.transform(A[ct], X[ct], f)
                  });
                }
              }
              _.retain(G, i.default.transform(N.attributes, q.attributes, f));
            }
          }
        return _.chop();
      }
      transformPosition(h, f = !1) {
        f = !!f;
        const v = new a.default(this.ops);
        let m = 0;
        for (; v.hasNext() && m <= h; ) {
          const k = v.peekLength(), _ = v.peekType();
          if (v.next(), _ === "delete") {
            h -= Math.min(k, h - m);
            continue;
          } else _ === "insert" && (m < h || !f) && (h += k);
          m += k;
        }
        return h;
      }
    }
    d.Op = o.default, d.OpIterator = a.default, d.AttributeMap = i.default, d.handlers = {}, t.default = d, r.exports = d, r.exports.default = d;
  }(So, So.exports)), So.exports;
}
var te = by();
const et = /* @__PURE__ */ Ra(te);
class de extends Xt {
  static value() {
  }
  optimize() {
    (this.prev || this.next) && this.remove();
  }
  length() {
    return 0;
  }
  value() {
    return "";
  }
}
de.blotName = "break";
de.tagName = "BR";
let ce = class extends Yn {
};
const yy = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function ki(r) {
  return r.replace(/[&<>"']/g, (t) => yy[t]);
}
const Dn = class zr extends Ya {
  static compare(t, e) {
    const s = zr.order.indexOf(t), n = zr.order.indexOf(e);
    return s >= 0 || n >= 0 ? s - n : t === e ? 0 : t < e ? -1 : 1;
  }
  formatAt(t, e, s, n) {
    if (zr.compare(this.statics.blotName, s) < 0 && this.scroll.query(s, rt.BLOT)) {
      const i = this.isolate(t, e);
      n && i.wrap(s, n);
    } else
      super.formatAt(t, e, s, n);
  }
  optimize(t) {
    if (super.optimize(t), this.parent instanceof zr && zr.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
      const e = this.parent.isolate(this.offset(), this.length());
      this.moveChildren(e), e.wrap(this);
    }
  }
};
Q(Dn, "allowedChildren", [Dn, de, Xt, ce]), // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
Q(Dn, "order", [
  "cursor",
  "inline",
  // Must be lower
  "link",
  // Chrome wants <a> to be lower
  "underline",
  "strike",
  "italic",
  "bold",
  "script",
  "code"
  // Must be higher
]);
let rr = Dn;
const vu = 1;
class jt extends Fs {
  constructor() {
    super(...arguments), Q(this, "cache", {});
  }
  delta() {
    return this.cache.delta == null && (this.cache.delta = Ld(this)), this.cache.delta;
  }
  deleteAt(t, e) {
    super.deleteAt(t, e), this.cache = {};
  }
  formatAt(t, e, s, n) {
    e <= 0 || (this.scroll.query(s, rt.BLOCK) ? t + e === this.length() && this.format(s, n) : super.formatAt(t, Math.min(e, this.length() - t - 1), s, n), this.cache = {});
  }
  insertAt(t, e, s) {
    if (s != null) {
      super.insertAt(t, e, s), this.cache = {};
      return;
    }
    if (e.length === 0) return;
    const n = e.split(`
`), i = n.shift();
    i.length > 0 && (t < this.length() - 1 || this.children.tail == null ? super.insertAt(Math.min(t, this.length() - 1), i) : this.children.tail.insertAt(this.children.tail.length(), i), this.cache = {});
    let o = this;
    n.reduce((a, l) => (o = o.split(a, !0), o.insertAt(0, l), l.length), t + i.length);
  }
  insertBefore(t, e) {
    const {
      head: s
    } = this.children;
    super.insertBefore(t, e), s instanceof de && s.remove(), this.cache = {};
  }
  length() {
    return this.cache.length == null && (this.cache.length = super.length() + vu), this.cache.length;
  }
  moveChildren(t, e) {
    super.moveChildren(t, e), this.cache = {};
  }
  optimize(t) {
    super.optimize(t), this.cache = {};
  }
  path(t) {
    return super.path(t, !0);
  }
  removeChild(t) {
    super.removeChild(t), this.cache = {};
  }
  split(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (e && (t === 0 || t >= this.length() - vu)) {
      const n = this.clone();
      return t === 0 ? (this.parent.insertBefore(n, this), this) : (this.parent.insertBefore(n, this.next), n);
    }
    const s = super.split(t, e);
    return this.cache = {}, s;
  }
}
jt.blotName = "block";
jt.tagName = "P";
jt.defaultChild = de;
jt.allowedChildren = [de, rr, Xt, ce];
class ee extends Xt {
  attach() {
    super.attach(), this.attributes = new bi(this.domNode);
  }
  delta() {
    return new et().insert(this.value(), {
      ...this.formats(),
      ...this.attributes.values()
    });
  }
  format(t, e) {
    const s = this.scroll.query(t, rt.BLOCK_ATTRIBUTE);
    s != null && this.attributes.attribute(s, e);
  }
  formatAt(t, e, s, n) {
    this.format(s, n);
  }
  insertAt(t, e, s) {
    if (s != null) {
      super.insertAt(t, e, s);
      return;
    }
    const n = e.split(`
`), i = n.pop(), o = n.map((l) => {
      const c = this.scroll.create(jt.blotName);
      return c.insertAt(0, l), c;
    }), a = this.split(t);
    o.forEach((l) => {
      this.parent.insertBefore(l, a);
    }), i && this.parent.insertBefore(this.scroll.create("text", i), a);
  }
}
ee.scope = rt.BLOCK_BLOT;
function Ld(r) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return r.descendants(Pt).reduce((e, s) => s.length() === 0 ? e : e.insert(s.value(), Jt(s, {}, t)), new et()).insert(`
`, Jt(r));
}
function Jt(r) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return r == null || ("formats" in r && typeof r.formats == "function" && (t = {
    ...t,
    ...r.formats()
  }, e && delete t["code-token"]), r.parent == null || r.parent.statics.blotName === "scroll" || r.parent.statics.scope !== r.statics.scope) ? t : Jt(r.parent, t, e);
}
const Os = class cr extends Xt {
  // Zero width no break space
  static value() {
  }
  constructor(t, e, s) {
    super(t, e), this.selection = s, this.textNode = document.createTextNode(cr.CONTENTS), this.domNode.appendChild(this.textNode), this.savedLength = 0;
  }
  detach() {
    this.parent != null && this.parent.removeChild(this);
  }
  format(t, e) {
    if (this.savedLength !== 0) {
      super.format(t, e);
      return;
    }
    let s = this, n = 0;
    for (; s != null && s.statics.scope !== rt.BLOCK_BLOT; )
      n += s.offset(s.parent), s = s.parent;
    s != null && (this.savedLength = cr.CONTENTS.length, s.optimize(), s.formatAt(n, cr.CONTENTS.length, t, e), this.savedLength = 0);
  }
  index(t, e) {
    return t === this.textNode ? 0 : super.index(t, e);
  }
  length() {
    return this.savedLength;
  }
  position() {
    return [this.textNode, this.textNode.data.length];
  }
  remove() {
    super.remove(), this.parent = null;
  }
  restore() {
    if (this.selection.composing || this.parent == null) return null;
    const t = this.selection.getNativeRange();
    for (; this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode; )
      this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
    const e = this.prev instanceof ce ? this.prev : null, s = e ? e.length() : 0, n = this.next instanceof ce ? this.next : null, i = n ? n.text : "", {
      textNode: o
    } = this, a = o.data.split(cr.CONTENTS).join("");
    o.data = cr.CONTENTS;
    let l;
    if (e)
      l = e, (a || n) && (e.insertAt(e.length(), a + i), n && n.remove());
    else if (n)
      l = n, n.insertAt(0, a);
    else {
      const c = document.createTextNode(a);
      l = this.scroll.create(c), this.parent.insertBefore(l, this);
    }
    if (this.remove(), t) {
      const c = (h, f) => e && h === e.domNode ? f : h === o ? s + f - 1 : n && h === n.domNode ? s + a.length + f : null, d = c(t.start.node, t.start.offset), g = c(t.end.node, t.end.offset);
      if (d !== null && g !== null)
        return {
          startNode: l.domNode,
          startOffset: d,
          endNode: l.domNode,
          endOffset: g
        };
    }
    return null;
  }
  update(t, e) {
    if (t.some((s) => s.type === "characterData" && s.target === this.textNode)) {
      const s = this.restore();
      s && (e.range = s);
    }
  }
  // Avoid .ql-cursor being a descendant of `<a/>`.
  // The reason is Safari pushes down `<a/>` on text insertion.
  // That will cause DOM nodes not sync with the model.
  //
  // For example ({I} is the caret), given the markup:
  //    <a><span class="ql-cursor">\uFEFF{I}</span></a>
  // When typing a char "x", `<a/>` will be pushed down inside the `<span>` first:
  //    <span class="ql-cursor"><a>\uFEFF{I}</a></span>
  // And then "x" will be inserted after `<a/>`:
  //    <span class="ql-cursor"><a>\uFEFF</a>d{I}</span>
  optimize(t) {
    super.optimize(t);
    let {
      parent: e
    } = this;
    for (; e; ) {
      if (e.domNode.tagName === "A") {
        this.savedLength = cr.CONTENTS.length, e.isolate(this.offset(e), this.length()).unwrap(), this.savedLength = 0;
        break;
      }
      e = e.parent;
    }
  }
  value() {
    return "";
  }
};
Q(Os, "blotName", "cursor"), Q(Os, "className", "ql-cursor"), Q(Os, "tagName", "span"), Q(Os, "CONTENTS", "\uFEFF");
let xi = Os;
var bu = { exports: {} }, yu;
function ky() {
  return yu || (yu = 1, function(r) {
    var t = Object.prototype.hasOwnProperty, e = "~";
    function s() {
    }
    Object.create && (s.prototype = /* @__PURE__ */ Object.create(null), new s().__proto__ || (e = !1));
    function n(l, c, d) {
      this.fn = l, this.context = c, this.once = d || !1;
    }
    function i(l, c, d, g, h) {
      if (typeof d != "function")
        throw new TypeError("The listener must be a function");
      var f = new n(d, g || l, h), v = e ? e + c : c;
      return l._events[v] ? l._events[v].fn ? l._events[v] = [l._events[v], f] : l._events[v].push(f) : (l._events[v] = f, l._eventsCount++), l;
    }
    function o(l, c) {
      --l._eventsCount === 0 ? l._events = new s() : delete l._events[c];
    }
    function a() {
      this._events = new s(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
      var l = [], c, d;
      if (this._eventsCount === 0) return l;
      for (d in c = this._events)
        t.call(c, d) && l.push(e ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l;
    }, a.prototype.listeners = function(l) {
      var c = e ? e + l : l, d = this._events[c];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var g = 0, h = d.length, f = new Array(h); g < h; g++)
        f[g] = d[g].fn;
      return f;
    }, a.prototype.listenerCount = function(l) {
      var c = e ? e + l : l, d = this._events[c];
      return d ? d.fn ? 1 : d.length : 0;
    }, a.prototype.emit = function(l, c, d, g, h, f) {
      var v = e ? e + l : l;
      if (!this._events[v]) return !1;
      var m = this._events[v], k = arguments.length, _, E;
      if (m.fn) {
        switch (m.once && this.removeListener(l, m.fn, void 0, !0), k) {
          case 1:
            return m.fn.call(m.context), !0;
          case 2:
            return m.fn.call(m.context, c), !0;
          case 3:
            return m.fn.call(m.context, c, d), !0;
          case 4:
            return m.fn.call(m.context, c, d, g), !0;
          case 5:
            return m.fn.call(m.context, c, d, g, h), !0;
          case 6:
            return m.fn.call(m.context, c, d, g, h, f), !0;
        }
        for (E = 1, _ = new Array(k - 1); E < k; E++)
          _[E - 1] = arguments[E];
        m.fn.apply(m.context, _);
      } else {
        var N = m.length, q;
        for (E = 0; E < N; E++)
          switch (m[E].once && this.removeListener(l, m[E].fn, void 0, !0), k) {
            case 1:
              m[E].fn.call(m[E].context);
              break;
            case 2:
              m[E].fn.call(m[E].context, c);
              break;
            case 3:
              m[E].fn.call(m[E].context, c, d);
              break;
            case 4:
              m[E].fn.call(m[E].context, c, d, g);
              break;
            default:
              if (!_) for (q = 1, _ = new Array(k - 1); q < k; q++)
                _[q - 1] = arguments[q];
              m[E].fn.apply(m[E].context, _);
          }
      }
      return !0;
    }, a.prototype.on = function(l, c, d) {
      return i(this, l, c, d, !1);
    }, a.prototype.once = function(l, c, d) {
      return i(this, l, c, d, !0);
    }, a.prototype.removeListener = function(l, c, d, g) {
      var h = e ? e + l : l;
      if (!this._events[h]) return this;
      if (!c)
        return o(this, h), this;
      var f = this._events[h];
      if (f.fn)
        f.fn === c && (!g || f.once) && (!d || f.context === d) && o(this, h);
      else {
        for (var v = 0, m = [], k = f.length; v < k; v++)
          (f[v].fn !== c || g && !f[v].once || d && f[v].context !== d) && m.push(f[v]);
        m.length ? this._events[h] = m.length === 1 ? m[0] : m : o(this, h);
      }
      return this;
    }, a.prototype.removeAllListeners = function(l) {
      var c;
      return l ? (c = e ? e + l : l, this._events[c] && o(this, c)) : (this._events = new s(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, r.exports = a;
  }(bu)), bu.exports;
}
var xy = ky();
const wy = /* @__PURE__ */ Ra(xy), ga = /* @__PURE__ */ new WeakMap(), va = ["error", "warn", "log", "info"];
let ba = "warn";
function Id(r) {
  if (ba && va.indexOf(r) <= va.indexOf(ba)) {
    for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)
      e[s - 1] = arguments[s];
    console[r](...e);
  }
}
function De(r) {
  return va.reduce((t, e) => (t[e] = Id.bind(console, e, r), t), {});
}
De.level = (r) => {
  ba = r;
};
Id.level = De.level;
const Oo = De("quill:events"), Ey = ["selectionchange", "mousedown", "mouseup", "click"];
Ey.forEach((r) => {
  document.addEventListener(r, function() {
    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++)
      e[s] = arguments[s];
    Array.from(document.querySelectorAll(".ql-container")).forEach((n) => {
      const i = ga.get(n);
      i && i.emitter && i.emitter.handleDOM(...e);
    });
  });
});
class tt extends wy {
  constructor() {
    super(), this.domListeners = {}, this.on("error", Oo.error);
  }
  emit() {
    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++)
      e[s] = arguments[s];
    return Oo.log.call(Oo, ...e), super.emit(...e);
  }
  handleDOM(t) {
    for (var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
      s[n - 1] = arguments[n];
    (this.domListeners[t.type] || []).forEach((i) => {
      let {
        node: o,
        handler: a
      } = i;
      (t.target === o || o.contains(t.target)) && a(t, ...s);
    });
  }
  listenDOM(t, e, s) {
    this.domListeners[t] || (this.domListeners[t] = []), this.domListeners[t].push({
      node: e,
      handler: s
    });
  }
}
Q(tt, "events", {
  EDITOR_CHANGE: "editor-change",
  SCROLL_BEFORE_UPDATE: "scroll-before-update",
  SCROLL_BLOT_MOUNT: "scroll-blot-mount",
  SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount",
  SCROLL_OPTIMIZE: "scroll-optimize",
  SCROLL_UPDATE: "scroll-update",
  SCROLL_EMBED_UPDATE: "scroll-embed-update",
  SELECTION_CHANGE: "selection-change",
  TEXT_CHANGE: "text-change",
  COMPOSITION_BEFORE_START: "composition-before-start",
  COMPOSITION_START: "composition-start",
  COMPOSITION_BEFORE_END: "composition-before-end",
  COMPOSITION_END: "composition-end"
}), Q(tt, "sources", {
  API: "api",
  SILENT: "silent",
  USER: "user"
});
const To = De("quill:selection");
class xr {
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.index = t, this.length = e;
  }
}
class _y {
  constructor(t, e) {
    this.emitter = e, this.scroll = t, this.composing = !1, this.mouseDown = !1, this.root = this.scroll.domNode, this.cursor = this.scroll.create("cursor", this), this.savedRange = new xr(0, 0), this.lastRange = this.savedRange, this.lastNative = null, this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, () => {
      !this.mouseDown && !this.composing && setTimeout(this.update.bind(this, tt.sources.USER), 1);
    }), this.emitter.on(tt.events.SCROLL_BEFORE_UPDATE, () => {
      if (!this.hasFocus()) return;
      const s = this.getNativeRange();
      s != null && s.start.node !== this.cursor.textNode && this.emitter.once(tt.events.SCROLL_UPDATE, (n, i) => {
        try {
          this.root.contains(s.start.node) && this.root.contains(s.end.node) && this.setNativeRange(s.start.node, s.start.offset, s.end.node, s.end.offset);
          const o = i.some((a) => a.type === "characterData" || a.type === "childList" || a.type === "attributes" && a.target === this.root);
          this.update(o ? tt.sources.SILENT : n);
        } catch {
        }
      });
    }), this.emitter.on(tt.events.SCROLL_OPTIMIZE, (s, n) => {
      if (n.range) {
        const {
          startNode: i,
          startOffset: o,
          endNode: a,
          endOffset: l
        } = n.range;
        this.setNativeRange(i, o, a, l), this.update(tt.sources.SILENT);
      }
    }), this.update(tt.sources.SILENT);
  }
  handleComposition() {
    this.emitter.on(tt.events.COMPOSITION_BEFORE_START, () => {
      this.composing = !0;
    }), this.emitter.on(tt.events.COMPOSITION_END, () => {
      if (this.composing = !1, this.cursor.parent) {
        const t = this.cursor.restore();
        if (!t) return;
        setTimeout(() => {
          this.setNativeRange(t.startNode, t.startOffset, t.endNode, t.endOffset);
        }, 1);
      }
    });
  }
  handleDragging() {
    this.emitter.listenDOM("mousedown", document.body, () => {
      this.mouseDown = !0;
    }), this.emitter.listenDOM("mouseup", document.body, () => {
      this.mouseDown = !1, this.update(tt.sources.USER);
    });
  }
  focus() {
    this.hasFocus() || (this.root.focus({
      preventScroll: !0
    }), this.setRange(this.savedRange));
  }
  format(t, e) {
    this.scroll.update();
    const s = this.getNativeRange();
    if (!(s == null || !s.native.collapsed || this.scroll.query(t, rt.BLOCK))) {
      if (s.start.node !== this.cursor.textNode) {
        const n = this.scroll.find(s.start.node, !1);
        if (n == null) return;
        if (n instanceof Pt) {
          const i = n.split(s.start.offset);
          n.parent.insertBefore(this.cursor, i);
        } else
          n.insertBefore(this.cursor, s.start.node);
        this.cursor.attach();
      }
      this.cursor.format(t, e), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
    }
  }
  getBounds(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const s = this.scroll.length();
    t = Math.min(t, s - 1), e = Math.min(t + e, s - 1) - t;
    let n, [i, o] = this.scroll.leaf(t);
    if (i == null) return null;
    if (e > 0 && o === i.length()) {
      const [d] = this.scroll.leaf(t + 1);
      if (d) {
        const [g] = this.scroll.line(t), [h] = this.scroll.line(t + 1);
        g === h && (i = d, o = 0);
      }
    }
    [n, o] = i.position(o, !0);
    const a = document.createRange();
    if (e > 0)
      return a.setStart(n, o), [i, o] = this.scroll.leaf(t + e), i == null ? null : ([n, o] = i.position(o, !0), a.setEnd(n, o), a.getBoundingClientRect());
    let l = "left", c;
    if (n instanceof Text) {
      if (!n.data.length)
        return null;
      o < n.data.length ? (a.setStart(n, o), a.setEnd(n, o + 1)) : (a.setStart(n, o - 1), a.setEnd(n, o), l = "right"), c = a.getBoundingClientRect();
    } else {
      if (!(i.domNode instanceof Element)) return null;
      c = i.domNode.getBoundingClientRect(), o > 0 && (l = "right");
    }
    return {
      bottom: c.top + c.height,
      height: c.height,
      left: c[l],
      right: c[l],
      top: c.top,
      width: 0
    };
  }
  getNativeRange() {
    const t = document.getSelection();
    if (t == null || t.rangeCount <= 0) return null;
    const e = t.getRangeAt(0);
    if (e == null) return null;
    const s = this.normalizeNative(e);
    return To.info("getNativeRange", s), s;
  }
  getRange() {
    const t = this.scroll.domNode;
    if ("isConnected" in t && !t.isConnected)
      return [null, null];
    const e = this.getNativeRange();
    return e == null ? [null, null] : [this.normalizedToRange(e), e];
  }
  hasFocus() {
    return document.activeElement === this.root || document.activeElement != null && Ro(this.root, document.activeElement);
  }
  normalizedToRange(t) {
    const e = [[t.start.node, t.start.offset]];
    t.native.collapsed || e.push([t.end.node, t.end.offset]);
    const s = e.map((o) => {
      const [a, l] = o, c = this.scroll.find(a, !0), d = c.offset(this.scroll);
      return l === 0 ? d : c instanceof Pt ? d + c.index(a, l) : d + c.length();
    }), n = Math.min(Math.max(...s), this.scroll.length() - 1), i = Math.min(n, ...s);
    return new xr(i, n - i);
  }
  normalizeNative(t) {
    if (!Ro(this.root, t.startContainer) || !t.collapsed && !Ro(this.root, t.endContainer))
      return null;
    const e = {
      start: {
        node: t.startContainer,
        offset: t.startOffset
      },
      end: {
        node: t.endContainer,
        offset: t.endOffset
      },
      native: t
    };
    return [e.start, e.end].forEach((s) => {
      let {
        node: n,
        offset: i
      } = s;
      for (; !(n instanceof Text) && n.childNodes.length > 0; )
        if (n.childNodes.length > i)
          n = n.childNodes[i], i = 0;
        else if (n.childNodes.length === i)
          n = n.lastChild, n instanceof Text ? i = n.data.length : n.childNodes.length > 0 ? i = n.childNodes.length : i = n.childNodes.length + 1;
        else
          break;
      s.node = n, s.offset = i;
    }), e;
  }
  rangeToNative(t) {
    const e = this.scroll.length(), s = (n, i) => {
      n = Math.min(e - 1, n);
      const [o, a] = this.scroll.leaf(n);
      return o ? o.position(a, i) : [null, -1];
    };
    return [...s(t.index, !1), ...s(t.index + t.length, !0)];
  }
  setNativeRange(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : t, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : e, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    if (To.info("setNativeRange", t, e, s, n), t != null && (this.root.parentNode == null || t.parentNode == null || // @ts-expect-error Fix me later
    s.parentNode == null))
      return;
    const o = document.getSelection();
    if (o != null)
      if (t != null) {
        this.hasFocus() || this.root.focus({
          preventScroll: !0
        });
        const {
          native: a
        } = this.getNativeRange() || {};
        if (a == null || i || t !== a.startContainer || e !== a.startOffset || s !== a.endContainer || n !== a.endOffset) {
          t instanceof Element && t.tagName === "BR" && (e = Array.from(t.parentNode.childNodes).indexOf(t), t = t.parentNode), s instanceof Element && s.tagName === "BR" && (n = Array.from(s.parentNode.childNodes).indexOf(s), s = s.parentNode);
          const l = document.createRange();
          l.setStart(t, e), l.setEnd(s, n), o.removeAllRanges(), o.addRange(l);
        }
      } else
        o.removeAllRanges(), this.root.blur();
  }
  setRange(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tt.sources.API;
    if (typeof e == "string" && (s = e, e = !1), To.info("setRange", t), t != null) {
      const n = this.rangeToNative(t);
      this.setNativeRange(...n, e);
    } else
      this.setNativeRange(null);
    this.update(s);
  }
  update() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : tt.sources.USER;
    const e = this.lastRange, [s, n] = this.getRange();
    if (this.lastRange = s, this.lastNative = n, this.lastRange != null && (this.savedRange = this.lastRange), !$e(e, this.lastRange)) {
      if (!this.composing && n != null && n.native.collapsed && n.start.node !== this.cursor.textNode) {
        const o = this.cursor.restore();
        o && this.setNativeRange(o.startNode, o.startOffset, o.endNode, o.endOffset);
      }
      const i = [tt.events.SELECTION_CHANGE, Wr(this.lastRange), Wr(e), t];
      this.emitter.emit(tt.events.EDITOR_CHANGE, ...i), t !== tt.sources.SILENT && this.emitter.emit(...i);
    }
  }
}
function Ro(r, t) {
  try {
    t.parentNode;
  } catch {
    return !1;
  }
  return r.contains(t);
}
const Ay = /^[ -~]*$/;
class Ny {
  constructor(t) {
    this.scroll = t, this.delta = this.getDelta();
  }
  applyDelta(t) {
    this.scroll.update();
    let e = this.scroll.length();
    this.scroll.batchStart();
    const s = ku(t), n = new et();
    return Cy(s.ops.slice()).reduce((i, o) => {
      const a = te.Op.length(o);
      let l = o.attributes || {}, c = !1, d = !1;
      if (o.insert != null) {
        if (n.retain(a), typeof o.insert == "string") {
          const f = o.insert;
          d = !f.endsWith(`
`) && (e <= i || !!this.scroll.descendant(ee, i)[0]), this.scroll.insertAt(i, f);
          const [v, m] = this.scroll.line(i);
          let k = We({}, Jt(v));
          if (v instanceof jt) {
            const [_] = v.descendant(Pt, m);
            _ && (k = We(k, Jt(_)));
          }
          l = te.AttributeMap.diff(k, l) || {};
        } else if (typeof o.insert == "object") {
          const f = Object.keys(o.insert)[0];
          if (f == null) return i;
          const v = this.scroll.query(f, rt.INLINE) != null;
          if (v)
            (e <= i || this.scroll.descendant(ee, i)[0]) && (d = !0);
          else if (i > 0) {
            const [m, k] = this.scroll.descendant(Pt, i - 1);
            m instanceof ce ? m.value()[k] !== `
` && (c = !0) : m instanceof Xt && m.statics.scope === rt.INLINE_BLOT && (c = !0);
          }
          if (this.scroll.insertAt(i, f, o.insert[f]), v) {
            const [m] = this.scroll.descendant(Pt, i);
            if (m) {
              const k = We({}, Jt(m));
              l = te.AttributeMap.diff(k, l) || {};
            }
          }
        }
        e += a;
      } else if (n.push(o), o.retain !== null && typeof o.retain == "object") {
        const f = Object.keys(o.retain)[0];
        if (f == null) return i;
        this.scroll.updateEmbedAt(i, f, o.retain[f]);
      }
      Object.keys(l).forEach((f) => {
        this.scroll.formatAt(i, a, f, l[f]);
      });
      const g = c ? 1 : 0, h = d ? 1 : 0;
      return e += g + h, n.retain(g), n.delete(h), i + a + g + h;
    }, 0), n.reduce((i, o) => typeof o.delete == "number" ? (this.scroll.deleteAt(i, o.delete), i) : i + te.Op.length(o), 0), this.scroll.batchEnd(), this.scroll.optimize(), this.update(s);
  }
  deleteText(t, e) {
    return this.scroll.deleteAt(t, e), this.update(new et().retain(t).delete(e));
  }
  formatLine(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.scroll.update(), Object.keys(s).forEach((i) => {
      this.scroll.lines(t, Math.max(e, 1)).forEach((o) => {
        o.format(i, s[i]);
      });
    }), this.scroll.optimize();
    const n = new et().retain(t).retain(e, Wr(s));
    return this.update(n);
  }
  formatText(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Object.keys(s).forEach((i) => {
      this.scroll.formatAt(t, e, i, s[i]);
    });
    const n = new et().retain(t).retain(e, Wr(s));
    return this.update(n);
  }
  getContents(t, e) {
    return this.delta.slice(t, t + e);
  }
  getDelta() {
    return this.scroll.lines().reduce((t, e) => t.concat(e.delta()), new et());
  }
  getFormat(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = [], n = [];
    e === 0 ? this.scroll.path(t).forEach((a) => {
      const [l] = a;
      l instanceof jt ? s.push(l) : l instanceof Pt && n.push(l);
    }) : (s = this.scroll.lines(t, e), n = this.scroll.descendants(Pt, t, e));
    const [i, o] = [s, n].map((a) => {
      const l = a.shift();
      if (l == null) return {};
      let c = Jt(l);
      for (; Object.keys(c).length > 0; ) {
        const d = a.shift();
        if (d == null) return c;
        c = Sy(Jt(d), c);
      }
      return c;
    });
    return {
      ...i,
      ...o
    };
  }
  getHTML(t, e) {
    const [s, n] = this.scroll.line(t);
    if (s) {
      const i = s.length();
      return s.length() >= n + e && !(n === 0 && e === i) ? Ps(s, n, e, !0) : Ps(this.scroll, t, e, !0);
    }
    return "";
  }
  getText(t, e) {
    return this.getContents(t, e).filter((s) => typeof s.insert == "string").map((s) => s.insert).join("");
  }
  insertContents(t, e) {
    const s = ku(e), n = new et().retain(t).concat(s);
    return this.scroll.insertContents(t, s), this.update(n);
  }
  insertEmbed(t, e, s) {
    return this.scroll.insertAt(t, e, s), this.update(new et().retain(t).insert({
      [e]: s
    }));
  }
  insertText(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return e = e.replace(/\r\n/g, `
`).replace(/\r/g, `
`), this.scroll.insertAt(t, e), Object.keys(s).forEach((n) => {
      this.scroll.formatAt(t, e.length, n, s[n]);
    }), this.update(new et().retain(t).insert(e, Wr(s)));
  }
  isBlank() {
    if (this.scroll.children.length === 0) return !0;
    if (this.scroll.children.length > 1) return !1;
    const t = this.scroll.children.head;
    if ((t == null ? void 0 : t.statics.blotName) !== jt.blotName) return !1;
    const e = t;
    return e.children.length > 1 ? !1 : e.children.head instanceof de;
  }
  removeFormat(t, e) {
    const s = this.getText(t, e), [n, i] = this.scroll.line(t + e);
    let o = 0, a = new et();
    n != null && (o = n.length() - i, a = n.delta().slice(i, i + o - 1).insert(`
`));
    const l = this.getContents(t, e + o).diff(new et().insert(s).concat(a)), c = new et().retain(t).concat(l);
    return this.applyDelta(c);
  }
  update(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    const n = this.delta;
    if (e.length === 1 && e[0].type === "characterData" && // @ts-expect-error Fix me later
    e[0].target.data.match(Ay) && this.scroll.find(e[0].target)) {
      const i = this.scroll.find(e[0].target), o = Jt(i), a = i.offset(this.scroll), l = e[0].oldValue.replace(xi.CONTENTS, ""), c = new et().insert(l), d = new et().insert(i.value()), g = s && {
        oldRange: xu(s.oldRange, -a),
        newRange: xu(s.newRange, -a)
      };
      t = new et().retain(a).concat(c.diff(d, g)).reduce((h, f) => f.insert ? h.insert(f.insert, o) : h.push(f), new et()), this.delta = n.compose(t);
    } else
      this.delta = this.getDelta(), (!t || !$e(n.compose(t), this.delta)) && (t = n.diff(this.delta, s));
    return t;
  }
}
function Hr(r, t, e) {
  if (r.length === 0) {
    const [f] = Lo(e.pop());
    return t <= 0 ? `</li></${f}>` : `</li></${f}>${Hr([], t - 1, e)}`;
  }
  const [{
    child: s,
    offset: n,
    length: i,
    indent: o,
    type: a
  }, ...l] = r, [c, d] = Lo(a);
  if (o > t)
    return e.push(a), o === t + 1 ? `<${c}><li${d}>${Ps(s, n, i)}${Hr(l, o, e)}` : `<${c}><li>${Hr(r, t + 1, e)}`;
  const g = e[e.length - 1];
  if (o === t && a === g)
    return `</li><li${d}>${Ps(s, n, i)}${Hr(l, o, e)}`;
  const [h] = Lo(e.pop());
  return `</li></${h}>${Hr(r, t - 1, e)}`;
}
function Ps(r, t, e) {
  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if ("html" in r && typeof r.html == "function")
    return r.html(t, e);
  if (r instanceof ce)
    return ki(r.value().slice(t, t + e)).replaceAll(" ", "&nbsp;");
  if (r instanceof ue) {
    if (r.statics.blotName === "list-container") {
      const c = [];
      return r.children.forEachAt(t, e, (d, g, h) => {
        const f = "formats" in d && typeof d.formats == "function" ? d.formats() : {};
        c.push({
          child: d,
          offset: g,
          length: h,
          indent: f.indent || 0,
          type: f.list
        });
      }), Hr(c, -1, []);
    }
    const n = [];
    if (r.children.forEachAt(t, e, (c, d, g) => {
      n.push(Ps(c, d, g));
    }), s || r.statics.blotName === "list")
      return n.join("");
    const {
      outerHTML: i,
      innerHTML: o
    } = r.domNode, [a, l] = i.split(`>${o}<`);
    return a === "<table" ? `<table style="border: 1px solid #000;">${n.join("")}<${l}` : `${a}>${n.join("")}<${l}`;
  }
  return r.domNode instanceof Element ? r.domNode.outerHTML : "";
}
function Sy(r, t) {
  return Object.keys(t).reduce((e, s) => {
    if (r[s] == null) return e;
    const n = t[s];
    return n === r[s] ? e[s] = n : Array.isArray(n) ? n.indexOf(r[s]) < 0 ? e[s] = n.concat([r[s]]) : e[s] = n : e[s] = [n, r[s]], e;
  }, {});
}
function Lo(r) {
  const t = r === "ordered" ? "ol" : "ul";
  switch (r) {
    case "checked":
      return [t, ' data-list="checked"'];
    case "unchecked":
      return [t, ' data-list="unchecked"'];
    default:
      return [t, ""];
  }
}
function ku(r) {
  return r.reduce((t, e) => {
    if (typeof e.insert == "string") {
      const s = e.insert.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      return t.insert(s, e.attributes);
    }
    return t.push(e);
  }, new et());
}
function xu(r, t) {
  let {
    index: e,
    length: s
  } = r;
  return new xr(e + t, s);
}
function Cy(r) {
  const t = [];
  return r.forEach((e) => {
    typeof e.insert == "string" ? e.insert.split(`
`).forEach((s, n) => {
      n && t.push({
        insert: `
`,
        attributes: e.attributes
      }), s && t.push({
        insert: s,
        attributes: e.attributes
      });
    }) : t.push(e);
  }), t;
}
class pe {
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.quill = t, this.options = e;
  }
}
Q(pe, "DEFAULTS", {});
const An = "\uFEFF";
class Qa extends Xt {
  constructor(t, e) {
    super(t, e), this.contentNode = document.createElement("span"), this.contentNode.setAttribute("contenteditable", "false"), Array.from(this.domNode.childNodes).forEach((s) => {
      this.contentNode.appendChild(s);
    }), this.leftGuard = document.createTextNode(An), this.rightGuard = document.createTextNode(An), this.domNode.appendChild(this.leftGuard), this.domNode.appendChild(this.contentNode), this.domNode.appendChild(this.rightGuard);
  }
  index(t, e) {
    return t === this.leftGuard ? 0 : t === this.rightGuard ? 1 : super.index(t, e);
  }
  restore(t) {
    let e = null, s;
    const n = t.data.split(An).join("");
    if (t === this.leftGuard)
      if (this.prev instanceof ce) {
        const i = this.prev.length();
        this.prev.insertAt(i, n), e = {
          startNode: this.prev.domNode,
          startOffset: i + n.length
        };
      } else
        s = document.createTextNode(n), this.parent.insertBefore(this.scroll.create(s), this), e = {
          startNode: s,
          startOffset: n.length
        };
    else t === this.rightGuard && (this.next instanceof ce ? (this.next.insertAt(0, n), e = {
      startNode: this.next.domNode,
      startOffset: n.length
    }) : (s = document.createTextNode(n), this.parent.insertBefore(this.scroll.create(s), this.next), e = {
      startNode: s,
      startOffset: n.length
    }));
    return t.data = An, e;
  }
  update(t, e) {
    t.forEach((s) => {
      if (s.type === "characterData" && (s.target === this.leftGuard || s.target === this.rightGuard)) {
        const n = this.restore(s.target);
        n && (e.range = n);
      }
    });
  }
}
class Oy {
  constructor(t, e) {
    Q(this, "isComposing", !1), this.scroll = t, this.emitter = e, this.setupListeners();
  }
  setupListeners() {
    this.scroll.domNode.addEventListener("compositionstart", (t) => {
      this.isComposing || this.handleCompositionStart(t);
    }), this.scroll.domNode.addEventListener("compositionend", (t) => {
      this.isComposing && queueMicrotask(() => {
        this.handleCompositionEnd(t);
      });
    });
  }
  handleCompositionStart(t) {
    const e = t.target instanceof Node ? this.scroll.find(t.target, !0) : null;
    e && !(e instanceof Qa) && (this.emitter.emit(tt.events.COMPOSITION_BEFORE_START, t), this.scroll.batchStart(), this.emitter.emit(tt.events.COMPOSITION_START, t), this.isComposing = !0);
  }
  handleCompositionEnd(t) {
    this.emitter.emit(tt.events.COMPOSITION_BEFORE_END, t), this.scroll.batchEnd(), this.emitter.emit(tt.events.COMPOSITION_END, t), this.isComposing = !1;
  }
}
const Fn = class {
  constructor(t, e) {
    Q(this, "modules", {}), this.quill = t, this.options = e;
  }
  init() {
    Object.keys(this.options.modules).forEach((t) => {
      this.modules[t] == null && this.addModule(t);
    });
  }
  addModule(t) {
    const e = this.quill.constructor.import(`modules/${t}`);
    return this.modules[t] = new e(this.quill, this.options.modules[t] || {}), this.modules[t];
  }
};
Q(Fn, "DEFAULTS", {
  modules: {}
}), Q(Fn, "themes", {
  default: Fn
});
let wi = Fn;
const Ty = (r) => r.parentElement || r.getRootNode().host || null, Ry = (r) => {
  const t = r.getBoundingClientRect(), e = "offsetWidth" in r && Math.abs(t.width) / r.offsetWidth || 1, s = "offsetHeight" in r && Math.abs(t.height) / r.offsetHeight || 1;
  return {
    top: t.top,
    right: t.left + r.clientWidth * e,
    bottom: t.top + r.clientHeight * s,
    left: t.left
  };
}, Nn = (r) => {
  const t = parseInt(r, 10);
  return Number.isNaN(t) ? 0 : t;
}, wu = (r, t, e, s, n, i) => r < e && t > s ? 0 : r < e ? -(e - r + n) : t > s ? t - r > s - e ? r + n - e : t - s + i : 0, Ly = (r, t) => {
  var e, s, n;
  const i = r.ownerDocument;
  let o = t, a = r;
  for (; a; ) {
    const l = a === i.body, c = l ? {
      top: 0,
      right: ((e = window.visualViewport) == null ? void 0 : e.width) ?? i.documentElement.clientWidth,
      bottom: ((s = window.visualViewport) == null ? void 0 : s.height) ?? i.documentElement.clientHeight,
      left: 0
    } : Ry(a), d = getComputedStyle(a), g = wu(o.left, o.right, c.left, c.right, Nn(d.scrollPaddingLeft), Nn(d.scrollPaddingRight)), h = wu(o.top, o.bottom, c.top, c.bottom, Nn(d.scrollPaddingTop), Nn(d.scrollPaddingBottom));
    if (g || h)
      if (l)
        (n = i.defaultView) == null || n.scrollBy(g, h);
      else {
        const {
          scrollLeft: f,
          scrollTop: v
        } = a;
        h && (a.scrollTop += h), g && (a.scrollLeft += g);
        const m = a.scrollLeft - f, k = a.scrollTop - v;
        o = {
          left: o.left - m,
          top: o.top - k,
          right: o.right - m,
          bottom: o.bottom - k
        };
      }
    a = l || d.position === "fixed" ? null : Ty(a);
  }
}, Iy = 100, qy = ["block", "break", "cursor", "inline", "scroll", "text"], jy = (r, t, e) => {
  const s = new ns();
  return qy.forEach((n) => {
    const i = t.query(n);
    i && s.register(i);
  }), r.forEach((n) => {
    let i = t.query(n);
    i || e.error(`Cannot register "${n}" specified in "formats" config. Are you sure it was registered?`);
    let o = 0;
    for (; i; )
      if (s.register(i), i = "blotName" in i ? i.requiredContainer ?? null : null, o += 1, o > Iy) {
        e.error(`Cycle detected in registering blot requiredContainer: "${n}"`);
        break;
      }
  }), s;
}, Xr = De("quill"), Pn = new ns();
ue.uiClass = "ql-ui";
const Kr = class Ts {
  static debug(t) {
    t === !0 && (t = "log"), De.level(t);
  }
  static find(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return ga.get(t) || Pn.find(t, e);
  }
  static import(t) {
    return this.imports[t] == null && Xr.error(`Cannot import ${t}. Are you sure it was registered?`), this.imports[t];
  }
  static register() {
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) != "string") {
      const t = arguments.length <= 0 ? void 0 : arguments[0], e = !!(!(arguments.length <= 1) && arguments[1]), s = "attrName" in t ? t.attrName : t.blotName;
      typeof s == "string" ? this.register(`formats/${s}`, t, e) : Object.keys(t).forEach((n) => {
        this.register(n, t[n], e);
      });
    } else {
      const t = arguments.length <= 0 ? void 0 : arguments[0], e = arguments.length <= 1 ? void 0 : arguments[1], s = !!(!(arguments.length <= 2) && arguments[2]);
      this.imports[t] != null && !s && Xr.warn(`Overwriting ${t} with`, e), this.imports[t] = e, (t.startsWith("blots/") || t.startsWith("formats/")) && e && typeof e != "boolean" && e.blotName !== "abstract" && Pn.register(e), typeof e.register == "function" && e.register(Pn);
    }
  }
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.options = My(t, e), this.container = this.options.container, this.container == null) {
      Xr.error("Invalid Quill container", t);
      return;
    }
    this.options.debug && Ts.debug(this.options.debug);
    const s = this.container.innerHTML.trim();
    this.container.classList.add("ql-container"), this.container.innerHTML = "", ga.set(this.container, this), this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.emitter = new tt();
    const n = Ja.blotName, i = this.options.registry.query(n);
    if (!i || !("blotName" in i))
      throw new Error(`Cannot initialize Quill without "${n}" blot`);
    if (this.scroll = new i(this.options.registry, this.root, {
      emitter: this.emitter
    }), this.editor = new Ny(this.scroll), this.selection = new _y(this.scroll, this.emitter), this.composition = new Oy(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.uploader = this.theme.addModule("uploader"), this.theme.addModule("input"), this.theme.addModule("uiNode"), this.theme.init(), this.emitter.on(tt.events.EDITOR_CHANGE, (o) => {
      o === tt.events.TEXT_CHANGE && this.root.classList.toggle("ql-blank", this.editor.isBlank());
    }), this.emitter.on(tt.events.SCROLL_UPDATE, (o, a) => {
      const l = this.selection.lastRange, [c] = this.selection.getRange(), d = l && c ? {
        oldRange: l,
        newRange: c
      } : void 0;
      ie.call(this, () => this.editor.update(null, a, d), o);
    }), this.emitter.on(tt.events.SCROLL_EMBED_UPDATE, (o, a) => {
      const l = this.selection.lastRange, [c] = this.selection.getRange(), d = l && c ? {
        oldRange: l,
        newRange: c
      } : void 0;
      ie.call(this, () => {
        const g = new et().retain(o.offset(this)).retain({
          [o.statics.blotName]: a
        });
        return this.editor.update(g, [], d);
      }, Ts.sources.USER);
    }), s) {
      const o = this.clipboard.convert({
        html: `${s}<p><br></p>`,
        text: `
`
      });
      this.setContents(o);
    }
    this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable(), this.allowReadOnlyEdits = !1;
  }
  addContainer(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (typeof t == "string") {
      const s = t;
      t = document.createElement("div"), t.classList.add(s);
    }
    return this.container.insertBefore(t, e), t;
  }
  blur() {
    this.selection.setRange(null);
  }
  deleteText(t, e, s) {
    return [t, e, , s] = Oe(t, e, s), ie.call(this, () => this.editor.deleteText(t, e), s, t, -1 * e);
  }
  disable() {
    this.enable(!1);
  }
  editReadOnly(t) {
    this.allowReadOnlyEdits = !0;
    const e = t();
    return this.allowReadOnlyEdits = !1, e;
  }
  enable() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.scroll.enable(t), this.container.classList.toggle("ql-disabled", !t);
  }
  focus() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.selection.focus(), t.preventScroll || this.scrollSelectionIntoView();
  }
  format(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tt.sources.API;
    return ie.call(this, () => {
      const n = this.getSelection(!0);
      let i = new et();
      if (n == null) return i;
      if (this.scroll.query(t, rt.BLOCK))
        i = this.editor.formatLine(n.index, n.length, {
          [t]: e
        });
      else {
        if (n.length === 0)
          return this.selection.format(t, e), i;
        i = this.editor.formatText(n.index, n.length, {
          [t]: e
        });
      }
      return this.setSelection(n, tt.sources.SILENT), i;
    }, s);
  }
  formatLine(t, e, s, n, i) {
    let o;
    return [t, e, o, i] = Oe(
      t,
      e,
      // @ts-expect-error
      s,
      n,
      i
    ), ie.call(this, () => this.editor.formatLine(t, e, o), i, t, 0);
  }
  formatText(t, e, s, n, i) {
    let o;
    return [t, e, o, i] = Oe(
      // @ts-expect-error
      t,
      e,
      s,
      n,
      i
    ), ie.call(this, () => this.editor.formatText(t, e, o), i, t, 0);
  }
  getBounds(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = null;
    if (typeof t == "number" ? s = this.selection.getBounds(t, e) : s = this.selection.getBounds(t.index, t.length), !s) return null;
    const n = this.container.getBoundingClientRect();
    return {
      bottom: s.bottom - n.top,
      height: s.height,
      left: s.left - n.left,
      right: s.right - n.left,
      top: s.top - n.top,
      width: s.width
    };
  }
  getContents() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - t;
    return [t, e] = Oe(t, e), this.editor.getContents(t, e);
  }
  getFormat() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(!0), e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return typeof t == "number" ? this.editor.getFormat(t, e) : this.editor.getFormat(t.index, t.length);
  }
  getIndex(t) {
    return t.offset(this.scroll);
  }
  getLength() {
    return this.scroll.length();
  }
  getLeaf(t) {
    return this.scroll.leaf(t);
  }
  getLine(t) {
    return this.scroll.line(t);
  }
  getLines() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
    return typeof t != "number" ? this.scroll.lines(t.index, t.length) : this.scroll.lines(t, e);
  }
  getModule(t) {
    return this.theme.modules[t];
  }
  getSelection() {
    return arguments.length > 0 && arguments[0] !== void 0 && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];
  }
  getSemanticHTML() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 ? arguments[1] : void 0;
    return typeof t == "number" && (e = e ?? this.getLength() - t), [t, e] = Oe(t, e), this.editor.getHTML(t, e);
  }
  getText() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 ? arguments[1] : void 0;
    return typeof t == "number" && (e = e ?? this.getLength() - t), [t, e] = Oe(t, e), this.editor.getText(t, e);
  }
  hasFocus() {
    return this.selection.hasFocus();
  }
  insertEmbed(t, e, s) {
    let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Ts.sources.API;
    return ie.call(this, () => this.editor.insertEmbed(t, e, s), n, t);
  }
  insertText(t, e, s, n, i) {
    let o;
    return [t, , o, i] = Oe(t, 0, s, n, i), ie.call(this, () => this.editor.insertText(t, e, o), i, t, e.length);
  }
  isEnabled() {
    return this.scroll.isEnabled();
  }
  off() {
    return this.emitter.off(...arguments);
  }
  on() {
    return this.emitter.on(...arguments);
  }
  once() {
    return this.emitter.once(...arguments);
  }
  removeFormat(t, e, s) {
    return [t, e, , s] = Oe(t, e, s), ie.call(this, () => this.editor.removeFormat(t, e), s, t);
  }
  scrollRectIntoView(t) {
    Ly(this.root, t);
  }
  /**
   * @deprecated Use Quill#scrollSelectionIntoView() instead.
   */
  scrollIntoView() {
    console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead."), this.scrollSelectionIntoView();
  }
  /**
   * Scroll the current selection into the visible area.
   * If the selection is already visible, no scrolling will occur.
   */
  scrollSelectionIntoView() {
    const t = this.selection.lastRange, e = t && this.selection.getBounds(t.index, t.length);
    e && this.scrollRectIntoView(e);
  }
  setContents(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : tt.sources.API;
    return ie.call(this, () => {
      t = new et(t);
      const s = this.getLength(), n = this.editor.deleteText(0, s), i = this.editor.insertContents(0, t), o = this.editor.deleteText(this.getLength() - 1, 1);
      return n.compose(i).compose(o);
    }, e);
  }
  setSelection(t, e, s) {
    t == null ? this.selection.setRange(null, e || Ts.sources.API) : ([t, e, , s] = Oe(t, e, s), this.selection.setRange(new xr(Math.max(0, t), e), s), s !== tt.sources.SILENT && this.scrollSelectionIntoView());
  }
  setText(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : tt.sources.API;
    const s = new et().insert(t);
    return this.setContents(s, e);
  }
  update() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : tt.sources.USER;
    const e = this.scroll.update(t);
    return this.selection.update(t), e;
  }
  updateContents(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : tt.sources.API;
    return ie.call(this, () => (t = new et(t), this.editor.applyDelta(t)), e, !0);
  }
};
Q(Kr, "DEFAULTS", {
  bounds: null,
  modules: {
    clipboard: !0,
    keyboard: !0,
    history: !0,
    uploader: !0
  },
  placeholder: "",
  readOnly: !1,
  registry: Pn,
  theme: "default"
}), Q(Kr, "events", tt.events), Q(Kr, "sources", tt.sources), Q(Kr, "version", "2.0.3"), Q(Kr, "imports", {
  delta: et,
  parchment: fy,
  "core/module": pe,
  "core/theme": wi
});
let I = Kr;
function Eu(r) {
  return typeof r == "string" ? document.querySelector(r) : r;
}
function Io(r) {
  return Object.entries(r ?? {}).reduce((t, e) => {
    let [s, n] = e;
    return {
      ...t,
      [s]: n === !0 ? {} : n
    };
  }, {});
}
function _u(r) {
  return Object.fromEntries(Object.entries(r).filter((t) => t[1] !== void 0));
}
function My(r, t) {
  const e = Eu(r);
  if (!e)
    throw new Error("Invalid Quill container");
  const s = !t.theme || t.theme === I.DEFAULTS.theme ? wi : I.import(`themes/${t.theme}`);
  if (!s)
    throw new Error(`Invalid theme ${t.theme}. Did you register it?`);
  const {
    modules: n,
    ...i
  } = I.DEFAULTS, {
    modules: o,
    ...a
  } = s.DEFAULTS;
  let l = Io(t.modules);
  l != null && l.toolbar && l.toolbar.constructor !== Object && (l = {
    ...l,
    toolbar: {
      container: l.toolbar
    }
  });
  const c = We({}, Io(n), Io(o), l), d = {
    ...i,
    ..._u(a),
    ..._u(t)
  };
  let g = t.registry;
  return g ? t.formats && Xr.warn('Ignoring "formats" option because "registry" is specified') : g = t.formats ? jy(t.formats, d.registry, Xr) : d.registry, {
    ...d,
    registry: g,
    container: e,
    theme: s,
    modules: Object.entries(c).reduce((h, f) => {
      let [v, m] = f;
      if (!m) return h;
      const k = I.import(`modules/${v}`);
      return k == null ? (Xr.error(`Cannot load ${v} module. Are you sure you registered it?`), h) : {
        ...h,
        // @ts-expect-error
        [v]: We({}, k.DEFAULTS || {}, m)
      };
    }, {}),
    bounds: Eu(d.bounds)
  };
}
function ie(r, t, e, s) {
  if (!this.isEnabled() && t === tt.sources.USER && !this.allowReadOnlyEdits)
    return new et();
  let n = e == null ? null : this.getSelection();
  const i = this.editor.delta, o = r();
  if (n != null && (e === !0 && (e = n.index), s == null ? n = Au(n, o, t) : s !== 0 && (n = Au(n, e, s, t)), this.setSelection(n, tt.sources.SILENT)), o.length() > 0) {
    const a = [tt.events.TEXT_CHANGE, o, i, t];
    this.emitter.emit(tt.events.EDITOR_CHANGE, ...a), t !== tt.sources.SILENT && this.emitter.emit(...a);
  }
  return o;
}
function Oe(r, t, e, s, n) {
  let i = {};
  return typeof r.index == "number" && typeof r.length == "number" ? typeof t != "number" ? (n = s, s = e, e = t, t = r.length, r = r.index) : (t = r.length, r = r.index) : typeof t != "number" && (n = s, s = e, e = t, t = 0), typeof e == "object" ? (i = e, n = s) : typeof e == "string" && (s != null ? i[e] = s : n = e), n = n || tt.sources.API, [r, t, i, n];
}
function Au(r, t, e, s) {
  const n = typeof e == "number" ? e : 0;
  if (r == null) return null;
  let i, o;
  return t && typeof t.transformPosition == "function" ? [i, o] = [r.index, r.index + r.length].map((a) => (
    // @ts-expect-error -- TODO: add a better type guard around `index`
    t.transformPosition(a, s !== tt.sources.USER)
  )) : [i, o] = [r.index, r.index + r.length].map((a) => a < t || a === t && s === tt.sources.USER ? a : n >= 0 ? a + n : Math.max(t, a + n)), new xr(i, o - i);
}
class Ar extends yi {
}
function Nu(r) {
  return r instanceof jt || r instanceof ee;
}
function Su(r) {
  return typeof r.updateContent == "function";
}
class Gr extends Ja {
  constructor(t, e, s) {
    let {
      emitter: n
    } = s;
    super(t, e), this.emitter = n, this.batch = !1, this.optimize(), this.enable(), this.domNode.addEventListener("dragstart", (i) => this.handleDragStart(i));
  }
  batchStart() {
    Array.isArray(this.batch) || (this.batch = []);
  }
  batchEnd() {
    if (!this.batch) return;
    const t = this.batch;
    this.batch = !1, this.update(t);
  }
  emitMount(t) {
    this.emitter.emit(tt.events.SCROLL_BLOT_MOUNT, t);
  }
  emitUnmount(t) {
    this.emitter.emit(tt.events.SCROLL_BLOT_UNMOUNT, t);
  }
  emitEmbedUpdate(t, e) {
    this.emitter.emit(tt.events.SCROLL_EMBED_UPDATE, t, e);
  }
  deleteAt(t, e) {
    const [s, n] = this.line(t), [i] = this.line(t + e);
    if (super.deleteAt(t, e), i != null && s !== i && n > 0) {
      if (s instanceof ee || i instanceof ee) {
        this.optimize();
        return;
      }
      const o = i.children.head instanceof de ? null : i.children.head;
      s.moveChildren(i, o), s.remove();
    }
    this.optimize();
  }
  enable() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.domNode.setAttribute("contenteditable", t ? "true" : "false");
  }
  formatAt(t, e, s, n) {
    super.formatAt(t, e, s, n), this.optimize();
  }
  insertAt(t, e, s) {
    if (t >= this.length())
      if (s == null || this.scroll.query(e, rt.BLOCK) == null) {
        const n = this.scroll.create(this.statics.defaultChild.blotName);
        this.appendChild(n), s == null && e.endsWith(`
`) ? n.insertAt(0, e.slice(0, -1), s) : n.insertAt(0, e, s);
      } else {
        const n = this.scroll.create(e, s);
        this.appendChild(n);
      }
    else
      super.insertAt(t, e, s);
    this.optimize();
  }
  insertBefore(t, e) {
    if (t.statics.scope === rt.INLINE_BLOT) {
      const s = this.scroll.create(this.statics.defaultChild.blotName);
      s.appendChild(t), super.insertBefore(s, e);
    } else
      super.insertBefore(t, e);
  }
  insertContents(t, e) {
    const s = this.deltaToRenderBlocks(e.concat(new et().insert(`
`))), n = s.pop();
    if (n == null) return;
    this.batchStart();
    const i = s.shift();
    if (i) {
      const l = i.type === "block" && (i.delta.length() === 0 || !this.descendant(ee, t)[0] && t < this.length()), c = i.type === "block" ? i.delta : new et().insert({
        [i.key]: i.value
      });
      qo(this, t, c);
      const d = i.type === "block" ? 1 : 0, g = t + c.length() + d;
      l && this.insertAt(g - 1, `
`);
      const h = Jt(this.line(t)[0]), f = te.AttributeMap.diff(h, i.attributes) || {};
      Object.keys(f).forEach((v) => {
        this.formatAt(g - 1, 1, v, f[v]);
      }), t = g;
    }
    let [o, a] = this.children.find(t);
    if (s.length && (o && (o = o.split(a), a = 0), s.forEach((l) => {
      if (l.type === "block") {
        const c = this.createBlock(l.attributes, o || void 0);
        qo(c, 0, l.delta);
      } else {
        const c = this.create(l.key, l.value);
        this.insertBefore(c, o || void 0), Object.keys(l.attributes).forEach((d) => {
          c.format(d, l.attributes[d]);
        });
      }
    })), n.type === "block" && n.delta.length()) {
      const l = o ? o.offset(o.scroll) + a : this.length();
      qo(this, l, n.delta);
    }
    this.batchEnd(), this.optimize();
  }
  isEnabled() {
    return this.domNode.getAttribute("contenteditable") === "true";
  }
  leaf(t) {
    const e = this.path(t).pop();
    if (!e)
      return [null, -1];
    const [s, n] = e;
    return s instanceof Pt ? [s, n] : [null, -1];
  }
  line(t) {
    return t === this.length() ? this.line(t - 1) : this.descendant(Nu, t);
  }
  lines() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
    const s = (n, i, o) => {
      let a = [], l = o;
      return n.children.forEachAt(i, o, (c, d, g) => {
        Nu(c) ? a.push(c) : c instanceof yi && (a = a.concat(s(c, d, l))), l -= g;
      }), a;
    };
    return s(this, t, e);
  }
  optimize() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.batch || (super.optimize(t, e), t.length > 0 && this.emitter.emit(tt.events.SCROLL_OPTIMIZE, t, e));
  }
  path(t) {
    return super.path(t).slice(1);
  }
  remove() {
  }
  update(t) {
    if (this.batch) {
      Array.isArray(t) && (this.batch = this.batch.concat(t));
      return;
    }
    let e = tt.sources.USER;
    typeof t == "string" && (e = t), Array.isArray(t) || (t = this.observer.takeRecords()), t = t.filter((s) => {
      let {
        target: n
      } = s;
      const i = this.find(n, !0);
      return i && !Su(i);
    }), t.length > 0 && this.emitter.emit(tt.events.SCROLL_BEFORE_UPDATE, e, t), super.update(t.concat([])), t.length > 0 && this.emitter.emit(tt.events.SCROLL_UPDATE, e, t);
  }
  updateEmbedAt(t, e, s) {
    const [n] = this.descendant((i) => i instanceof ee, t);
    n && n.statics.blotName === e && Su(n) && n.updateContent(s);
  }
  handleDragStart(t) {
    t.preventDefault();
  }
  deltaToRenderBlocks(t) {
    const e = [];
    let s = new et();
    return t.forEach((n) => {
      const i = n == null ? void 0 : n.insert;
      if (i)
        if (typeof i == "string") {
          const o = i.split(`
`);
          o.slice(0, -1).forEach((l) => {
            s.insert(l, n.attributes), e.push({
              type: "block",
              delta: s,
              attributes: n.attributes ?? {}
            }), s = new et();
          });
          const a = o[o.length - 1];
          a && s.insert(a, n.attributes);
        } else {
          const o = Object.keys(i)[0];
          if (!o) return;
          this.query(o, rt.INLINE) ? s.push(n) : (s.length() && e.push({
            type: "block",
            delta: s,
            attributes: {}
          }), s = new et(), e.push({
            type: "blockEmbed",
            key: o,
            value: i[o],
            attributes: n.attributes ?? {}
          }));
        }
    }), s.length() && e.push({
      type: "block",
      delta: s,
      attributes: {}
    }), e;
  }
  createBlock(t, e) {
    let s;
    const n = {};
    Object.entries(t).forEach((a) => {
      let [l, c] = a;
      this.query(l, rt.BLOCK & rt.BLOT) != null ? s = l : n[l] = c;
    });
    const i = this.create(s || this.statics.defaultChild.blotName, s ? t[s] : void 0);
    this.insertBefore(i, e || void 0);
    const o = i.length();
    return Object.entries(n).forEach((a) => {
      let [l, c] = a;
      i.formatAt(0, o, l, c);
    }), i;
  }
}
Q(Gr, "blotName", "scroll"), Q(Gr, "className", "ql-editor"), Q(Gr, "tagName", "DIV"), Q(Gr, "defaultChild", jt), Q(Gr, "allowedChildren", [jt, ee, Ar]);
function qo(r, t, e) {
  e.reduce((s, n) => {
    const i = te.Op.length(n);
    let o = n.attributes || {};
    if (n.insert != null) {
      if (typeof n.insert == "string") {
        const a = n.insert;
        r.insertAt(s, a);
        const [l] = r.descendant(Pt, s), c = Jt(l);
        o = te.AttributeMap.diff(c, o) || {};
      } else if (typeof n.insert == "object") {
        const a = Object.keys(n.insert)[0];
        if (a == null) return s;
        if (r.insertAt(s, a, n.insert[a]), r.scroll.query(a, rt.INLINE) != null) {
          const [l] = r.descendant(Pt, s), c = Jt(l);
          o = te.AttributeMap.diff(c, o) || {};
        }
      }
    }
    return Object.keys(o).forEach((a) => {
      r.formatAt(s, i, a, o[a]);
    }), s + i;
  }, t);
}
const tl = {
  scope: rt.BLOCK,
  whitelist: ["right", "center", "justify"]
}, By = new we("align", "align", tl), qd = new he("align", "ql-align", tl), jd = new er("align", "text-align", tl);
class Md extends er {
  value(t) {
    let e = super.value(t);
    return e.startsWith("rgb(") ? (e = e.replace(/^[^\d]+/, "").replace(/[^\d]+$/, ""), `#${e.split(",").map((s) => `00${parseInt(s, 10).toString(16)}`.slice(-2)).join("")}`) : e;
  }
}
const Dy = new he("color", "ql-color", {
  scope: rt.INLINE
}), el = new Md("color", "color", {
  scope: rt.INLINE
}), Fy = new he("background", "ql-bg", {
  scope: rt.INLINE
}), rl = new Md("background", "background-color", {
  scope: rt.INLINE
});
class Nr extends Ar {
  static create(t) {
    const e = super.create(t);
    return e.setAttribute("spellcheck", "false"), e;
  }
  code(t, e) {
    return this.children.map((s) => s.length() <= 1 ? "" : s.domNode.innerText).join(`
`).slice(t, t + e);
  }
  html(t, e) {
    return `<pre>
${ki(this.code(t, e))}
</pre>`;
  }
}
class Vt extends jt {
  static register() {
    I.register(Nr);
  }
}
Q(Vt, "TAB", "  ");
class sl extends rr {
}
sl.blotName = "code";
sl.tagName = "CODE";
Vt.blotName = "code-block";
Vt.className = "ql-code-block";
Vt.tagName = "DIV";
Nr.blotName = "code-block-container";
Nr.className = "ql-code-block-container";
Nr.tagName = "DIV";
Nr.allowedChildren = [Vt];
Vt.allowedChildren = [ce, de, xi];
Vt.requiredContainer = Nr;
const nl = {
  scope: rt.BLOCK,
  whitelist: ["rtl"]
}, Bd = new we("direction", "dir", nl), Dd = new he("direction", "ql-direction", nl), Fd = new er("direction", "direction", nl), Pd = {
  scope: rt.INLINE,
  whitelist: ["serif", "monospace"]
}, Vd = new he("font", "ql-font", Pd);
class Py extends er {
  value(t) {
    return super.value(t).replace(/["']/g, "");
  }
}
const Ud = new Py("font", "font-family", Pd), $d = new he("size", "ql-size", {
  scope: rt.INLINE,
  whitelist: ["small", "large", "huge"]
}), zd = new er("size", "font-size", {
  scope: rt.INLINE,
  whitelist: ["10px", "18px", "32px"]
}), Vy = De("quill:keyboard"), Uy = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
class Ei extends pe {
  static match(t, e) {
    return ["altKey", "ctrlKey", "metaKey", "shiftKey"].some((s) => !!e[s] !== t[s] && e[s] !== null) ? !1 : e.key === t.key || e.key === t.which;
  }
  constructor(t, e) {
    super(t, e), this.bindings = {}, Object.keys(this.options.bindings).forEach((s) => {
      this.options.bindings[s] && this.addBinding(this.options.bindings[s]);
    }), this.addBinding({
      key: "Enter",
      shiftKey: null
    }, this.handleEnter), this.addBinding({
      key: "Enter",
      metaKey: null,
      ctrlKey: null,
      altKey: null
    }, () => {
    }), /Firefox/i.test(navigator.userAgent) ? (this.addBinding({
      key: "Backspace"
    }, {
      collapsed: !0
    }, this.handleBackspace), this.addBinding({
      key: "Delete"
    }, {
      collapsed: !0
    }, this.handleDelete)) : (this.addBinding({
      key: "Backspace"
    }, {
      collapsed: !0,
      prefix: /^.?$/
    }, this.handleBackspace), this.addBinding({
      key: "Delete"
    }, {
      collapsed: !0,
      suffix: /^.?$/
    }, this.handleDelete)), this.addBinding({
      key: "Backspace"
    }, {
      collapsed: !1
    }, this.handleDeleteRange), this.addBinding({
      key: "Delete"
    }, {
      collapsed: !1
    }, this.handleDeleteRange), this.addBinding({
      key: "Backspace",
      altKey: null,
      ctrlKey: null,
      metaKey: null,
      shiftKey: null
    }, {
      collapsed: !0,
      offset: 0
    }, this.handleBackspace), this.listen();
  }
  addBinding(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const n = zy(t);
    if (n == null) {
      Vy.warn("Attempted to add invalid keyboard binding", n);
      return;
    }
    typeof e == "function" && (e = {
      handler: e
    }), typeof s == "function" && (s = {
      handler: s
    }), (Array.isArray(n.key) ? n.key : [n.key]).forEach((i) => {
      const o = {
        ...n,
        key: i,
        ...e,
        ...s
      };
      this.bindings[o.key] = this.bindings[o.key] || [], this.bindings[o.key].push(o);
    });
  }
  listen() {
    this.quill.root.addEventListener("keydown", (t) => {
      if (t.defaultPrevented || t.isComposing || t.keyCode === 229 && (t.key === "Enter" || t.key === "Backspace")) return;
      const e = (this.bindings[t.key] || []).concat(this.bindings[t.which] || []).filter((v) => Ei.match(t, v));
      if (e.length === 0) return;
      const s = I.find(t.target, !0);
      if (s && s.scroll !== this.quill.scroll) return;
      const n = this.quill.getSelection();
      if (n == null || !this.quill.hasFocus()) return;
      const [i, o] = this.quill.getLine(n.index), [a, l] = this.quill.getLeaf(n.index), [c, d] = n.length === 0 ? [a, l] : this.quill.getLeaf(n.index + n.length), g = a instanceof Yn ? a.value().slice(0, l) : "", h = c instanceof Yn ? c.value().slice(d) : "", f = {
        collapsed: n.length === 0,
        // @ts-expect-error Fix me later
        empty: n.length === 0 && i.length() <= 1,
        format: this.quill.getFormat(n),
        line: i,
        offset: o,
        prefix: g,
        suffix: h,
        event: t
      };
      e.some((v) => {
        if (v.collapsed != null && v.collapsed !== f.collapsed || v.empty != null && v.empty !== f.empty || v.offset != null && v.offset !== f.offset)
          return !1;
        if (Array.isArray(v.format)) {
          if (v.format.every((m) => f.format[m] == null))
            return !1;
        } else if (typeof v.format == "object" && !Object.keys(v.format).every((m) => v.format[m] === !0 ? f.format[m] != null : v.format[m] === !1 ? f.format[m] == null : $e(v.format[m], f.format[m])))
          return !1;
        return v.prefix != null && !v.prefix.test(f.prefix) || v.suffix != null && !v.suffix.test(f.suffix) ? !1 : v.handler.call(this, n, f, v) !== !0;
      }) && t.preventDefault();
    });
  }
  handleBackspace(t, e) {
    const s = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e.prefix) ? 2 : 1;
    if (t.index === 0 || this.quill.getLength() <= 1) return;
    let n = {};
    const [i] = this.quill.getLine(t.index);
    let o = new et().retain(t.index - s).delete(s);
    if (e.offset === 0) {
      const [a] = this.quill.getLine(t.index - 1);
      if (a && !(a.statics.blotName === "block" && a.length() <= 1)) {
        const l = i.formats(), c = this.quill.getFormat(t.index - 1, 1);
        if (n = te.AttributeMap.diff(l, c) || {}, Object.keys(n).length > 0) {
          const d = new et().retain(t.index + i.length() - 2).retain(1, n);
          o = o.compose(d);
        }
      }
    }
    this.quill.updateContents(o, I.sources.USER), this.quill.focus();
  }
  handleDelete(t, e) {
    const s = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e.suffix) ? 2 : 1;
    if (t.index >= this.quill.getLength() - s) return;
    let n = {};
    const [i] = this.quill.getLine(t.index);
    let o = new et().retain(t.index).delete(s);
    if (e.offset >= i.length() - 1) {
      const [a] = this.quill.getLine(t.index + 1);
      if (a) {
        const l = i.formats(), c = this.quill.getFormat(t.index, 1);
        n = te.AttributeMap.diff(l, c) || {}, Object.keys(n).length > 0 && (o = o.retain(a.length() - 1).retain(1, n));
      }
    }
    this.quill.updateContents(o, I.sources.USER), this.quill.focus();
  }
  handleDeleteRange(t) {
    il({
      range: t,
      quill: this.quill
    }), this.quill.focus();
  }
  handleEnter(t, e) {
    const s = Object.keys(e.format).reduce((i, o) => (this.quill.scroll.query(o, rt.BLOCK) && !Array.isArray(e.format[o]) && (i[o] = e.format[o]), i), {}), n = new et().retain(t.index).delete(t.length).insert(`
`, s);
    this.quill.updateContents(n, I.sources.USER), this.quill.setSelection(t.index + 1, I.sources.SILENT), this.quill.focus();
  }
}
const $y = {
  bindings: {
    bold: jo("bold"),
    italic: jo("italic"),
    underline: jo("underline"),
    indent: {
      // highlight tab or tab at beginning of list, indent or blockquote
      key: "Tab",
      format: ["blockquote", "indent", "list"],
      handler(r, t) {
        return t.collapsed && t.offset !== 0 ? !0 : (this.quill.format("indent", "+1", I.sources.USER), !1);
      }
    },
    outdent: {
      key: "Tab",
      shiftKey: !0,
      format: ["blockquote", "indent", "list"],
      // highlight tab or tab at beginning of list, indent or blockquote
      handler(r, t) {
        return t.collapsed && t.offset !== 0 ? !0 : (this.quill.format("indent", "-1", I.sources.USER), !1);
      }
    },
    "outdent backspace": {
      key: "Backspace",
      collapsed: !0,
      shiftKey: null,
      metaKey: null,
      ctrlKey: null,
      altKey: null,
      format: ["indent", "list"],
      offset: 0,
      handler(r, t) {
        t.format.indent != null ? this.quill.format("indent", "-1", I.sources.USER) : t.format.list != null && this.quill.format("list", !1, I.sources.USER);
      }
    },
    "indent code-block": Cu(!0),
    "outdent code-block": Cu(!1),
    "remove tab": {
      key: "Tab",
      shiftKey: !0,
      collapsed: !0,
      prefix: /\t$/,
      handler(r) {
        this.quill.deleteText(r.index - 1, 1, I.sources.USER);
      }
    },
    tab: {
      key: "Tab",
      handler(r, t) {
        if (t.format.table) return !0;
        this.quill.history.cutoff();
        const e = new et().retain(r.index).delete(r.length).insert("	");
        return this.quill.updateContents(e, I.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(r.index + 1, I.sources.SILENT), !1;
      }
    },
    "blockquote empty enter": {
      key: "Enter",
      collapsed: !0,
      format: ["blockquote"],
      empty: !0,
      handler() {
        this.quill.format("blockquote", !1, I.sources.USER);
      }
    },
    "list empty enter": {
      key: "Enter",
      collapsed: !0,
      format: ["list"],
      empty: !0,
      handler(r, t) {
        const e = {
          list: !1
        };
        t.format.indent && (e.indent = !1), this.quill.formatLine(r.index, r.length, e, I.sources.USER);
      }
    },
    "checklist enter": {
      key: "Enter",
      collapsed: !0,
      format: {
        list: "checked"
      },
      handler(r) {
        const [t, e] = this.quill.getLine(r.index), s = {
          // @ts-expect-error Fix me later
          ...t.formats(),
          list: "checked"
        }, n = new et().retain(r.index).insert(`
`, s).retain(t.length() - e - 1).retain(1, {
          list: "unchecked"
        });
        this.quill.updateContents(n, I.sources.USER), this.quill.setSelection(r.index + 1, I.sources.SILENT), this.quill.scrollSelectionIntoView();
      }
    },
    "header enter": {
      key: "Enter",
      collapsed: !0,
      format: ["header"],
      suffix: /^$/,
      handler(r, t) {
        const [e, s] = this.quill.getLine(r.index), n = new et().retain(r.index).insert(`
`, t.format).retain(e.length() - s - 1).retain(1, {
          header: null
        });
        this.quill.updateContents(n, I.sources.USER), this.quill.setSelection(r.index + 1, I.sources.SILENT), this.quill.scrollSelectionIntoView();
      }
    },
    "table backspace": {
      key: "Backspace",
      format: ["table"],
      collapsed: !0,
      offset: 0,
      handler() {
      }
    },
    "table delete": {
      key: "Delete",
      format: ["table"],
      collapsed: !0,
      suffix: /^$/,
      handler() {
      }
    },
    "table enter": {
      key: "Enter",
      shiftKey: null,
      format: ["table"],
      handler(r) {
        const t = this.quill.getModule("table");
        if (t) {
          const [e, s, n, i] = t.getTable(r), o = Hy(e, s, n, i);
          if (o == null) return;
          let a = e.offset();
          if (o < 0) {
            const l = new et().retain(a).insert(`
`);
            this.quill.updateContents(l, I.sources.USER), this.quill.setSelection(r.index + 1, r.length, I.sources.SILENT);
          } else if (o > 0) {
            a += e.length();
            const l = new et().retain(a).insert(`
`);
            this.quill.updateContents(l, I.sources.USER), this.quill.setSelection(a, I.sources.USER);
          }
        }
      }
    },
    "table tab": {
      key: "Tab",
      shiftKey: null,
      format: ["table"],
      handler(r, t) {
        const {
          event: e,
          line: s
        } = t, n = s.offset(this.quill.scroll);
        e.shiftKey ? this.quill.setSelection(n - 1, I.sources.USER) : this.quill.setSelection(n + s.length(), I.sources.USER);
      }
    },
    "list autofill": {
      key: " ",
      shiftKey: null,
      collapsed: !0,
      format: {
        "code-block": !1,
        blockquote: !1,
        table: !1
      },
      prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
      handler(r, t) {
        if (this.quill.scroll.query("list") == null) return !0;
        const {
          length: e
        } = t.prefix, [s, n] = this.quill.getLine(r.index);
        if (n > e) return !0;
        let i;
        switch (t.prefix.trim()) {
          case "[]":
          case "[ ]":
            i = "unchecked";
            break;
          case "[x]":
            i = "checked";
            break;
          case "-":
          case "*":
            i = "bullet";
            break;
          default:
            i = "ordered";
        }
        this.quill.insertText(r.index, " ", I.sources.USER), this.quill.history.cutoff();
        const o = new et().retain(r.index - n).delete(e + 1).retain(s.length() - 2 - n).retain(1, {
          list: i
        });
        return this.quill.updateContents(o, I.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(r.index - e, I.sources.SILENT), !1;
      }
    },
    "code exit": {
      key: "Enter",
      collapsed: !0,
      format: ["code-block"],
      prefix: /^$/,
      suffix: /^\s*$/,
      handler(r) {
        const [t, e] = this.quill.getLine(r.index);
        let s = 2, n = t;
        for (; n != null && n.length() <= 1 && n.formats()["code-block"]; )
          if (n = n.prev, s -= 1, s <= 0) {
            const i = new et().retain(r.index + t.length() - e - 2).retain(1, {
              "code-block": null
            }).delete(1);
            return this.quill.updateContents(i, I.sources.USER), this.quill.setSelection(r.index - 1, I.sources.SILENT), !1;
          }
        return !0;
      }
    },
    "embed left": Sn("ArrowLeft", !1),
    "embed left shift": Sn("ArrowLeft", !0),
    "embed right": Sn("ArrowRight", !1),
    "embed right shift": Sn("ArrowRight", !0),
    "table down": Ou(!1),
    "table up": Ou(!0)
  }
};
Ei.DEFAULTS = $y;
function Cu(r) {
  return {
    key: "Tab",
    shiftKey: !r,
    format: {
      "code-block": !0
    },
    handler(t, e) {
      let {
        event: s
      } = e;
      const n = this.quill.scroll.query("code-block"), {
        TAB: i
      } = n;
      if (t.length === 0 && !s.shiftKey) {
        this.quill.insertText(t.index, i, I.sources.USER), this.quill.setSelection(t.index + i.length, I.sources.SILENT);
        return;
      }
      const o = t.length === 0 ? this.quill.getLines(t.index, 1) : this.quill.getLines(t);
      let {
        index: a,
        length: l
      } = t;
      o.forEach((c, d) => {
        r ? (c.insertAt(0, i), d === 0 ? a += i.length : l += i.length) : c.domNode.textContent.startsWith(i) && (c.deleteAt(0, i.length), d === 0 ? a -= i.length : l -= i.length);
      }), this.quill.update(I.sources.USER), this.quill.setSelection(a, l, I.sources.SILENT);
    }
  };
}
function Sn(r, t) {
  return {
    key: r,
    shiftKey: t,
    altKey: null,
    [r === "ArrowLeft" ? "prefix" : "suffix"]: /^$/,
    handler(e) {
      let {
        index: s
      } = e;
      r === "ArrowRight" && (s += e.length + 1);
      const [n] = this.quill.getLeaf(s);
      return n instanceof Xt ? (r === "ArrowLeft" ? t ? this.quill.setSelection(e.index - 1, e.length + 1, I.sources.USER) : this.quill.setSelection(e.index - 1, I.sources.USER) : t ? this.quill.setSelection(e.index, e.length + 1, I.sources.USER) : this.quill.setSelection(e.index + e.length + 1, I.sources.USER), !1) : !0;
    }
  };
}
function jo(r) {
  return {
    key: r[0],
    shortKey: !0,
    handler(t, e) {
      this.quill.format(r, !e.format[r], I.sources.USER);
    }
  };
}
function Ou(r) {
  return {
    key: r ? "ArrowUp" : "ArrowDown",
    collapsed: !0,
    format: ["table"],
    handler(t, e) {
      const s = r ? "prev" : "next", n = e.line, i = n.parent[s];
      if (i != null) {
        if (i.statics.blotName === "table-row") {
          let o = i.children.head, a = n;
          for (; a.prev != null; )
            a = a.prev, o = o.next;
          const l = o.offset(this.quill.scroll) + Math.min(e.offset, o.length() - 1);
          this.quill.setSelection(l, 0, I.sources.USER);
        }
      } else {
        const o = n.table()[s];
        o != null && (r ? this.quill.setSelection(o.offset(this.quill.scroll) + o.length() - 1, 0, I.sources.USER) : this.quill.setSelection(o.offset(this.quill.scroll), 0, I.sources.USER));
      }
      return !1;
    }
  };
}
function zy(r) {
  if (typeof r == "string" || typeof r == "number")
    r = {
      key: r
    };
  else if (typeof r == "object")
    r = Wr(r);
  else
    return null;
  return r.shortKey && (r[Uy] = r.shortKey, delete r.shortKey), r;
}
function il(r) {
  let {
    quill: t,
    range: e
  } = r;
  const s = t.getLines(e);
  let n = {};
  if (s.length > 1) {
    const i = s[0].formats(), o = s[s.length - 1].formats();
    n = te.AttributeMap.diff(o, i) || {};
  }
  t.deleteText(e, I.sources.USER), Object.keys(n).length > 0 && t.formatLine(e.index, 1, n, I.sources.USER), t.setSelection(e.index, I.sources.SILENT);
}
function Hy(r, t, e, s) {
  return t.prev == null && t.next == null ? e.prev == null && e.next == null ? s === 0 ? -1 : 1 : e.prev == null ? -1 : 1 : t.prev == null ? -1 : t.next == null ? 1 : null;
}
const Ky = /font-weight:\s*normal/, Gy = ["P", "OL", "UL"], Tu = (r) => r && Gy.includes(r.tagName), Wy = (r) => {
  Array.from(r.querySelectorAll("br")).filter((t) => Tu(t.previousElementSibling) && Tu(t.nextElementSibling)).forEach((t) => {
    var e;
    (e = t.parentNode) == null || e.removeChild(t);
  });
}, Zy = (r) => {
  Array.from(r.querySelectorAll('b[style*="font-weight"]')).filter((t) => {
    var e;
    return (e = t.getAttribute("style")) == null ? void 0 : e.match(Ky);
  }).forEach((t) => {
    var e;
    const s = r.createDocumentFragment();
    s.append(...t.childNodes), (e = t.parentNode) == null || e.replaceChild(s, t);
  });
};
function Xy(r) {
  r.querySelector('[id^="docs-internal-guid-"]') && (Zy(r), Wy(r));
}
const Yy = /\bmso-list:[^;]*ignore/i, Jy = /\bmso-list:[^;]*\bl(\d+)/i, Qy = /\bmso-list:[^;]*\blevel(\d+)/i, tk = (r, t) => {
  const e = r.getAttribute("style"), s = e == null ? void 0 : e.match(Jy);
  if (!s)
    return null;
  const n = Number(s[1]), i = e == null ? void 0 : e.match(Qy), o = i ? Number(i[1]) : 1, a = new RegExp(`@list l${n}:level${o}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i"), l = t.match(a), c = l && l[1] === "bullet" ? "bullet" : "ordered";
  return {
    id: n,
    indent: o,
    type: c,
    element: r
  };
}, ek = (r) => {
  var t, e;
  const s = Array.from(r.querySelectorAll("[style*=mso-list]")), n = [], i = [];
  s.forEach((l) => {
    (l.getAttribute("style") || "").match(Yy) ? n.push(l) : i.push(l);
  }), n.forEach((l) => {
    var c;
    return (c = l.parentNode) == null ? void 0 : c.removeChild(l);
  });
  const o = r.documentElement.innerHTML, a = i.map((l) => tk(l, o)).filter((l) => l);
  for (; a.length; ) {
    const l = [];
    let c = a.shift();
    for (; c; )
      l.push(c), c = a.length && ((t = a[0]) == null ? void 0 : t.element) === c.element.nextElementSibling && // Different id means the next item doesn't belong to this group.
      a[0].id === c.id ? a.shift() : null;
    const d = document.createElement("ul");
    l.forEach((f) => {
      const v = document.createElement("li");
      v.setAttribute("data-list", f.type), f.indent > 1 && v.setAttribute("class", `ql-indent-${f.indent - 1}`), v.innerHTML = f.element.innerHTML, d.appendChild(v);
    });
    const g = (e = l[0]) == null ? void 0 : e.element, {
      parentNode: h
    } = g ?? {};
    g && (h == null || h.replaceChild(d, g)), l.slice(1).forEach((f) => {
      let {
        element: v
      } = f;
      h == null || h.removeChild(v);
    });
  }
};
function rk(r) {
  r.documentElement.getAttribute("xmlns:w") === "urn:schemas-microsoft-com:office:word" && ek(r);
}
const sk = [rk, Xy], nk = (r) => {
  r.documentElement && sk.forEach((t) => {
    t(r);
  });
}, ik = De("quill:clipboard"), ok = [[Node.TEXT_NODE, bk], [Node.TEXT_NODE, Lu], ["br", hk], [Node.ELEMENT_NODE, Lu], [Node.ELEMENT_NODE, ck], [Node.ELEMENT_NODE, uk], [Node.ELEMENT_NODE, gk], ["li", fk], ["ol, ul", mk], ["pre", dk], ["tr", vk], ["b", Mo("bold")], ["i", Mo("italic")], ["strike", Mo("strike")], ["style", pk]], ak = [By, Bd].reduce((r, t) => (r[t.keyName] = t, r), {}), Ru = [jd, rl, el, Fd, Ud, zd].reduce((r, t) => (r[t.keyName] = t, r), {});
class Hd extends pe {
  constructor(t, e) {
    super(t, e), this.quill.root.addEventListener("copy", (s) => this.onCaptureCopy(s, !1)), this.quill.root.addEventListener("cut", (s) => this.onCaptureCopy(s, !0)), this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this)), this.matchers = [], ok.concat(this.options.matchers ?? []).forEach((s) => {
      let [n, i] = s;
      this.addMatcher(n, i);
    });
  }
  addMatcher(t, e) {
    this.matchers.push([t, e]);
  }
  convert(t) {
    let {
      html: e,
      text: s
    } = t, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (n[Vt.blotName])
      return new et().insert(s || "", {
        [Vt.blotName]: n[Vt.blotName]
      });
    if (!e)
      return new et().insert(s || "", n);
    const i = this.convertHTML(e);
    return Gs(i, `
`) && (i.ops[i.ops.length - 1].attributes == null || n.table) ? i.compose(new et().retain(i.length() - 1).delete(1)) : i;
  }
  normalizeHTML(t) {
    nk(t);
  }
  convertHTML(t) {
    const e = new DOMParser().parseFromString(t, "text/html");
    this.normalizeHTML(e);
    const s = e.body, n = /* @__PURE__ */ new WeakMap(), [i, o] = this.prepareMatching(s, n);
    return ol(this.quill.scroll, s, i, o, n);
  }
  dangerouslyPasteHTML(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : I.sources.API;
    if (typeof t == "string") {
      const n = this.convert({
        html: t,
        text: ""
      });
      this.quill.setContents(n, e), this.quill.setSelection(0, I.sources.SILENT);
    } else {
      const n = this.convert({
        html: e,
        text: ""
      });
      this.quill.updateContents(new et().retain(t).concat(n), s), this.quill.setSelection(t + n.length(), I.sources.SILENT);
    }
  }
  onCaptureCopy(t) {
    var e, s;
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (t.defaultPrevented) return;
    t.preventDefault();
    const [i] = this.quill.selection.getRange();
    if (i == null) return;
    const {
      html: o,
      text: a
    } = this.onCopy(i, n);
    (e = t.clipboardData) == null || e.setData("text/plain", a), (s = t.clipboardData) == null || s.setData("text/html", o), n && il({
      range: i,
      quill: this.quill
    });
  }
  /*
   * https://www.iana.org/assignments/media-types/text/uri-list
   */
  normalizeURIList(t) {
    return t.split(/\r?\n/).filter((e) => e[0] !== "#").join(`
`);
  }
  onCapturePaste(t) {
    var e, s, n, i, o;
    if (t.defaultPrevented || !this.quill.isEnabled()) return;
    t.preventDefault();
    const a = this.quill.getSelection(!0);
    if (a == null) return;
    const l = (e = t.clipboardData) == null ? void 0 : e.getData("text/html");
    let c = (s = t.clipboardData) == null ? void 0 : s.getData("text/plain");
    if (!l && !c) {
      const g = (n = t.clipboardData) == null ? void 0 : n.getData("text/uri-list");
      g && (c = this.normalizeURIList(g));
    }
    const d = Array.from(((i = t.clipboardData) == null ? void 0 : i.files) || []);
    if (!l && d.length > 0) {
      this.quill.uploader.upload(a, d);
      return;
    }
    if (l && d.length > 0) {
      const g = new DOMParser().parseFromString(l, "text/html");
      if (g.body.childElementCount === 1 && ((o = g.body.firstElementChild) == null ? void 0 : o.tagName) === "IMG") {
        this.quill.uploader.upload(a, d);
        return;
      }
    }
    this.onPaste(a, {
      html: l,
      text: c
    });
  }
  onCopy(t) {
    const e = this.quill.getText(t);
    return {
      html: this.quill.getSemanticHTML(t),
      text: e
    };
  }
  onPaste(t, e) {
    let {
      text: s,
      html: n
    } = e;
    const i = this.quill.getFormat(t.index), o = this.convert({
      text: s,
      html: n
    }, i);
    ik.log("onPaste", o, {
      text: s,
      html: n
    });
    const a = new et().retain(t.index).delete(t.length).concat(o);
    this.quill.updateContents(a, I.sources.USER), this.quill.setSelection(a.length() - t.length, I.sources.SILENT), this.quill.scrollSelectionIntoView();
  }
  prepareMatching(t, e) {
    const s = [], n = [];
    return this.matchers.forEach((i) => {
      const [o, a] = i;
      switch (o) {
        case Node.TEXT_NODE:
          n.push(a);
          break;
        case Node.ELEMENT_NODE:
          s.push(a);
          break;
        default:
          Array.from(t.querySelectorAll(o)).forEach((l) => {
            if (e.has(l)) {
              const c = e.get(l);
              c == null || c.push(a);
            } else
              e.set(l, [a]);
          });
          break;
      }
    }), [s, n];
  }
}
Q(Hd, "DEFAULTS", {
  matchers: []
});
function Sr(r, t, e, s) {
  return s.query(t) ? r.reduce((n, i) => {
    if (!i.insert) return n;
    if (i.attributes && i.attributes[t])
      return n.push(i);
    const o = e ? {
      [t]: e
    } : {};
    return n.insert(i.insert, {
      ...o,
      ...i.attributes
    });
  }, new et()) : r;
}
function Gs(r, t) {
  let e = "";
  for (let s = r.ops.length - 1; s >= 0 && e.length < t.length; --s) {
    const n = r.ops[s];
    if (typeof n.insert != "string") break;
    e = n.insert + e;
  }
  return e.slice(-1 * t.length) === t;
}
function He(r, t) {
  if (!(r instanceof Element)) return !1;
  const e = t.query(r);
  return e && e.prototype instanceof Xt ? !1 : ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(r.tagName.toLowerCase());
}
function lk(r, t) {
  return r.previousElementSibling && r.nextElementSibling && !He(r.previousElementSibling, t) && !He(r.nextElementSibling, t);
}
const Cn = /* @__PURE__ */ new WeakMap();
function Kd(r) {
  return r == null ? !1 : (Cn.has(r) || (r.tagName === "PRE" ? Cn.set(r, !0) : Cn.set(r, Kd(r.parentNode))), Cn.get(r));
}
function ol(r, t, e, s, n) {
  return t.nodeType === t.TEXT_NODE ? s.reduce((i, o) => o(t, i, r), new et()) : t.nodeType === t.ELEMENT_NODE ? Array.from(t.childNodes || []).reduce((i, o) => {
    let a = ol(r, o, e, s, n);
    return o.nodeType === t.ELEMENT_NODE && (a = e.reduce((l, c) => c(o, l, r), a), a = (n.get(o) || []).reduce((l, c) => c(o, l, r), a)), i.concat(a);
  }, new et()) : new et();
}
function Mo(r) {
  return (t, e, s) => Sr(e, r, !0, s);
}
function uk(r, t, e) {
  const s = we.keys(r), n = he.keys(r), i = er.keys(r), o = {};
  return s.concat(n).concat(i).forEach((a) => {
    let l = e.query(a, rt.ATTRIBUTE);
    l != null && (o[l.attrName] = l.value(r), o[l.attrName]) || (l = ak[a], l != null && (l.attrName === a || l.keyName === a) && (o[l.attrName] = l.value(r) || void 0), l = Ru[a], l != null && (l.attrName === a || l.keyName === a) && (l = Ru[a], o[l.attrName] = l.value(r) || void 0));
  }), Object.entries(o).reduce((a, l) => {
    let [c, d] = l;
    return Sr(a, c, d, e);
  }, t);
}
function ck(r, t, e) {
  const s = e.query(r);
  if (s == null) return t;
  if (s.prototype instanceof Xt) {
    const n = {}, i = s.value(r);
    if (i != null)
      return n[s.blotName] = i, new et().insert(n, s.formats(r, e));
  } else if (s.prototype instanceof Fs && !Gs(t, `
`) && t.insert(`
`), "blotName" in s && "formats" in s && typeof s.formats == "function")
    return Sr(t, s.blotName, s.formats(r, e), e);
  return t;
}
function hk(r, t) {
  return Gs(t, `
`) || t.insert(`
`), t;
}
function dk(r, t, e) {
  const s = e.query("code-block"), n = s && "formats" in s && typeof s.formats == "function" ? s.formats(r, e) : !0;
  return Sr(t, "code-block", n, e);
}
function pk() {
  return new et();
}
function fk(r, t, e) {
  const s = e.query(r);
  if (s == null || // @ts-expect-error
  s.blotName !== "list" || !Gs(t, `
`))
    return t;
  let n = -1, i = r.parentNode;
  for (; i != null; )
    ["OL", "UL"].includes(i.tagName) && (n += 1), i = i.parentNode;
  return n <= 0 ? t : t.reduce((o, a) => a.insert ? a.attributes && typeof a.attributes.indent == "number" ? o.push(a) : o.insert(a.insert, {
    indent: n,
    ...a.attributes || {}
  }) : o, new et());
}
function mk(r, t, e) {
  const s = r;
  let n = s.tagName === "OL" ? "ordered" : "bullet";
  const i = s.getAttribute("data-checked");
  return i && (n = i === "true" ? "checked" : "unchecked"), Sr(t, "list", n, e);
}
function Lu(r, t, e) {
  if (!Gs(t, `
`)) {
    if (He(r, e) && (r.childNodes.length > 0 || r instanceof HTMLParagraphElement))
      return t.insert(`
`);
    if (t.length() > 0 && r.nextSibling) {
      let s = r.nextSibling;
      for (; s != null; ) {
        if (He(s, e))
          return t.insert(`
`);
        const n = e.query(s);
        if (n && n.prototype instanceof ee)
          return t.insert(`
`);
        s = s.firstChild;
      }
    }
  }
  return t;
}
function gk(r, t, e) {
  var s;
  const n = {}, i = r.style || {};
  return i.fontStyle === "italic" && (n.italic = !0), i.textDecoration === "underline" && (n.underline = !0), i.textDecoration === "line-through" && (n.strike = !0), ((s = i.fontWeight) != null && s.startsWith("bold") || // @ts-expect-error Fix me later
  parseInt(i.fontWeight, 10) >= 700) && (n.bold = !0), t = Object.entries(n).reduce((o, a) => {
    let [l, c] = a;
    return Sr(o, l, c, e);
  }, t), parseFloat(i.textIndent || 0) > 0 ? new et().insert("	").concat(t) : t;
}
function vk(r, t, e) {
  var s, n;
  const i = ((s = r.parentElement) == null ? void 0 : s.tagName) === "TABLE" ? r.parentElement : (n = r.parentElement) == null ? void 0 : n.parentElement;
  if (i != null) {
    const o = Array.from(i.querySelectorAll("tr")).indexOf(r) + 1;
    return Sr(t, "table", o, e);
  }
  return t;
}
function bk(r, t, e) {
  var s;
  let n = r.data;
  if (((s = r.parentElement) == null ? void 0 : s.tagName) === "O:P")
    return t.insert(n.trim());
  if (!Kd(r)) {
    if (n.trim().length === 0 && n.includes(`
`) && !lk(r, e))
      return t;
    n = n.replace(/[^\S\u00a0]/g, " "), n = n.replace(/ {2,}/g, " "), (r.previousSibling == null && r.parentElement != null && He(r.parentElement, e) || r.previousSibling instanceof Element && He(r.previousSibling, e)) && (n = n.replace(/^ /, "")), (r.nextSibling == null && r.parentElement != null && He(r.parentElement, e) || r.nextSibling instanceof Element && He(r.nextSibling, e)) && (n = n.replace(/ $/, "")), n = n.replaceAll("", " ");
  }
  return t.insert(n);
}
class Gd extends pe {
  constructor(t, e) {
    super(t, e), Q(this, "lastRecorded", 0), Q(this, "ignoreChange", !1), Q(this, "stack", {
      undo: [],
      redo: []
    }), Q(this, "currentRange", null), this.quill.on(I.events.EDITOR_CHANGE, (s, n, i, o) => {
      s === I.events.SELECTION_CHANGE ? n && o !== I.sources.SILENT && (this.currentRange = n) : s === I.events.TEXT_CHANGE && (this.ignoreChange || (!this.options.userOnly || o === I.sources.USER ? this.record(n, i) : this.transform(n)), this.currentRange = ya(this.currentRange, n));
    }), this.quill.keyboard.addBinding({
      key: "z",
      shortKey: !0
    }, this.undo.bind(this)), this.quill.keyboard.addBinding({
      key: ["z", "Z"],
      shortKey: !0,
      shiftKey: !0
    }, this.redo.bind(this)), /Win/i.test(navigator.platform) && this.quill.keyboard.addBinding({
      key: "y",
      shortKey: !0
    }, this.redo.bind(this)), this.quill.root.addEventListener("beforeinput", (s) => {
      s.inputType === "historyUndo" ? (this.undo(), s.preventDefault()) : s.inputType === "historyRedo" && (this.redo(), s.preventDefault());
    });
  }
  change(t, e) {
    if (this.stack[t].length === 0) return;
    const s = this.stack[t].pop();
    if (!s) return;
    const n = this.quill.getContents(), i = s.delta.invert(n);
    this.stack[e].push({
      delta: i,
      range: ya(s.range, i)
    }), this.lastRecorded = 0, this.ignoreChange = !0, this.quill.updateContents(s.delta, I.sources.USER), this.ignoreChange = !1, this.restoreSelection(s);
  }
  clear() {
    this.stack = {
      undo: [],
      redo: []
    };
  }
  cutoff() {
    this.lastRecorded = 0;
  }
  record(t, e) {
    if (t.ops.length === 0) return;
    this.stack.redo = [];
    let s = t.invert(e), n = this.currentRange;
    const i = Date.now();
    if (
      // @ts-expect-error Fix me later
      this.lastRecorded + this.options.delay > i && this.stack.undo.length > 0
    ) {
      const o = this.stack.undo.pop();
      o && (s = s.compose(o.delta), n = o.range);
    } else
      this.lastRecorded = i;
    s.length() !== 0 && (this.stack.undo.push({
      delta: s,
      range: n
    }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift());
  }
  redo() {
    this.change("redo", "undo");
  }
  transform(t) {
    Iu(this.stack.undo, t), Iu(this.stack.redo, t);
  }
  undo() {
    this.change("undo", "redo");
  }
  restoreSelection(t) {
    if (t.range)
      this.quill.setSelection(t.range, I.sources.USER);
    else {
      const e = kk(this.quill.scroll, t.delta);
      this.quill.setSelection(e, I.sources.USER);
    }
  }
}
Q(Gd, "DEFAULTS", {
  delay: 1e3,
  maxStack: 100,
  userOnly: !1
});
function Iu(r, t) {
  let e = t;
  for (let s = r.length - 1; s >= 0; s -= 1) {
    const n = r[s];
    r[s] = {
      delta: e.transform(n.delta, !0),
      range: n.range && ya(n.range, e)
    }, e = n.delta.transform(e), r[s].delta.length() === 0 && r.splice(s, 1);
  }
}
function yk(r, t) {
  const e = t.ops[t.ops.length - 1];
  return e == null ? !1 : e.insert != null ? typeof e.insert == "string" && e.insert.endsWith(`
`) : e.attributes != null ? Object.keys(e.attributes).some((s) => r.query(s, rt.BLOCK) != null) : !1;
}
function kk(r, t) {
  const e = t.reduce((n, i) => n + (i.delete || 0), 0);
  let s = t.length() - e;
  return yk(r, t) && (s -= 1), s;
}
function ya(r, t) {
  if (!r) return r;
  const e = t.transformPosition(r.index), s = t.transformPosition(r.index + r.length);
  return {
    index: e,
    length: s - e
  };
}
class Wd extends pe {
  constructor(t, e) {
    super(t, e), t.root.addEventListener("drop", (s) => {
      var n;
      s.preventDefault();
      let i = null;
      if (document.caretRangeFromPoint)
        i = document.caretRangeFromPoint(s.clientX, s.clientY);
      else if (document.caretPositionFromPoint) {
        const a = document.caretPositionFromPoint(s.clientX, s.clientY);
        i = document.createRange(), i.setStart(a.offsetNode, a.offset), i.setEnd(a.offsetNode, a.offset);
      }
      const o = i && t.selection.normalizeNative(i);
      if (o) {
        const a = t.selection.normalizedToRange(o);
        (n = s.dataTransfer) != null && n.files && this.upload(a, s.dataTransfer.files);
      }
    });
  }
  upload(t, e) {
    const s = [];
    Array.from(e).forEach((n) => {
      var i;
      n && (i = this.options.mimetypes) != null && i.includes(n.type) && s.push(n);
    }), s.length > 0 && this.options.handler.call(this, t, s);
  }
}
Wd.DEFAULTS = {
  mimetypes: ["image/png", "image/jpeg"],
  handler(r, t) {
    if (!this.quill.scroll.query("image"))
      return;
    const e = t.map((s) => new Promise((n) => {
      const i = new FileReader();
      i.onload = () => {
        n(i.result);
      }, i.readAsDataURL(s);
    }));
    Promise.all(e).then((s) => {
      const n = s.reduce((i, o) => i.insert({
        image: o
      }), new et().retain(r.index).delete(r.length));
      this.quill.updateContents(n, tt.sources.USER), this.quill.setSelection(r.index + s.length, tt.sources.SILENT);
    });
  }
};
const xk = ["insertText", "insertReplacementText"];
class wk extends pe {
  constructor(t, e) {
    super(t, e), t.root.addEventListener("beforeinput", (s) => {
      this.handleBeforeInput(s);
    }), /Android/i.test(navigator.userAgent) || t.on(I.events.COMPOSITION_BEFORE_START, () => {
      this.handleCompositionStart();
    });
  }
  deleteRange(t) {
    il({
      range: t,
      quill: this.quill
    });
  }
  replaceText(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (t.length === 0) return !1;
    if (e) {
      const s = this.quill.getFormat(t.index, 1);
      this.deleteRange(t), this.quill.updateContents(new et().retain(t.index).insert(e, s), I.sources.USER);
    } else
      this.deleteRange(t);
    return this.quill.setSelection(t.index + e.length, 0, I.sources.SILENT), !0;
  }
  handleBeforeInput(t) {
    if (this.quill.composition.isComposing || t.defaultPrevented || !xk.includes(t.inputType))
      return;
    const e = t.getTargetRanges ? t.getTargetRanges()[0] : null;
    if (!e || e.collapsed === !0)
      return;
    const s = Ek(t);
    if (s == null)
      return;
    const n = this.quill.selection.normalizeNative(e), i = n ? this.quill.selection.normalizedToRange(n) : null;
    i && this.replaceText(i, s) && t.preventDefault();
  }
  handleCompositionStart() {
    const t = this.quill.getSelection();
    t && this.replaceText(t);
  }
}
function Ek(r) {
  var t;
  return typeof r.data == "string" ? r.data : (t = r.dataTransfer) != null && t.types.includes("text/plain") ? r.dataTransfer.getData("text/plain") : null;
}
const _k = /Mac/i.test(navigator.platform), Ak = 100, Nk = (r) => !!(r.key === "ArrowLeft" || r.key === "ArrowRight" || // RTL scripts or moving from the end of the previous line
r.key === "ArrowUp" || r.key === "ArrowDown" || r.key === "Home" || _k && r.key === "a" && r.ctrlKey === !0);
class Sk extends pe {
  constructor(t, e) {
    super(t, e), Q(this, "isListening", !1), Q(this, "selectionChangeDeadline", 0), this.handleArrowKeys(), this.handleNavigationShortcuts();
  }
  handleArrowKeys() {
    this.quill.keyboard.addBinding({
      key: ["ArrowLeft", "ArrowRight"],
      offset: 0,
      shiftKey: null,
      handler(t, e) {
        let {
          line: s,
          event: n
        } = e;
        if (!(s instanceof ue) || !s.uiNode)
          return !0;
        const i = getComputedStyle(s.domNode).direction === "rtl";
        return i && n.key !== "ArrowRight" || !i && n.key !== "ArrowLeft" ? !0 : (this.quill.setSelection(t.index - 1, t.length + (n.shiftKey ? 1 : 0), I.sources.USER), !1);
      }
    });
  }
  handleNavigationShortcuts() {
    this.quill.root.addEventListener("keydown", (t) => {
      !t.defaultPrevented && Nk(t) && this.ensureListeningToSelectionChange();
    });
  }
  /**
   * We only listen to the `selectionchange` event when
   * there is an intention of moving the caret to the beginning using shortcuts.
   * This is primarily implemented to prevent infinite loops, as we are changing
   * the selection within the handler of a `selectionchange` event.
   */
  ensureListeningToSelectionChange() {
    if (this.selectionChangeDeadline = Date.now() + Ak, this.isListening) return;
    this.isListening = !0;
    const t = () => {
      this.isListening = !1, Date.now() <= this.selectionChangeDeadline && this.handleSelectionChange();
    };
    document.addEventListener("selectionchange", t, {
      once: !0
    });
  }
  handleSelectionChange() {
    const t = document.getSelection();
    if (!t) return;
    const e = t.getRangeAt(0);
    if (e.collapsed !== !0 || e.startOffset !== 0) return;
    const s = this.quill.scroll.find(e.startContainer);
    if (!(s instanceof ue) || !s.uiNode) return;
    const n = document.createRange();
    n.setStartAfter(s.uiNode), n.setEndAfter(s.uiNode), t.removeAllRanges(), t.addRange(n);
  }
}
I.register({
  "blots/block": jt,
  "blots/block/embed": ee,
  "blots/break": de,
  "blots/container": Ar,
  "blots/cursor": xi,
  "blots/embed": Qa,
  "blots/inline": rr,
  "blots/scroll": Gr,
  "blots/text": ce,
  "modules/clipboard": Hd,
  "modules/history": Gd,
  "modules/keyboard": Ei,
  "modules/uploader": Wd,
  "modules/input": wk,
  "modules/uiNode": Sk
});
class Ck extends he {
  add(t, e) {
    let s = 0;
    if (e === "+1" || e === "-1") {
      const n = this.value(t) || 0;
      s = e === "+1" ? n + 1 : n - 1;
    } else typeof e == "number" && (s = e);
    return s === 0 ? (this.remove(t), !0) : super.add(t, s.toString());
  }
  canAdd(t, e) {
    return super.canAdd(t, e) || super.canAdd(t, parseInt(e, 10));
  }
  value(t) {
    return parseInt(super.value(t), 10) || void 0;
  }
}
const Ok = new Ck("indent", "ql-indent", {
  scope: rt.BLOCK,
  // @ts-expect-error
  whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
});
class ka extends jt {
}
Q(ka, "blotName", "blockquote"), Q(ka, "tagName", "blockquote");
class xa extends jt {
  static formats(t) {
    return this.tagName.indexOf(t.tagName) + 1;
  }
}
Q(xa, "blotName", "header"), Q(xa, "tagName", ["H1", "H2", "H3", "H4", "H5", "H6"]);
class Ws extends Ar {
}
Ws.blotName = "list-container";
Ws.tagName = "OL";
class Zs extends jt {
  static create(t) {
    const e = super.create();
    return e.setAttribute("data-list", t), e;
  }
  static formats(t) {
    return t.getAttribute("data-list") || void 0;
  }
  static register() {
    I.register(Ws);
  }
  constructor(t, e) {
    super(t, e);
    const s = e.ownerDocument.createElement("span"), n = (i) => {
      if (!t.isEnabled()) return;
      const o = this.statics.formats(e, t);
      o === "checked" ? (this.format("list", "unchecked"), i.preventDefault()) : o === "unchecked" && (this.format("list", "checked"), i.preventDefault());
    };
    s.addEventListener("mousedown", n), s.addEventListener("touchstart", n), this.attachUI(s);
  }
  format(t, e) {
    t === this.statics.blotName && e ? this.domNode.setAttribute("data-list", e) : super.format(t, e);
  }
}
Zs.blotName = "list";
Zs.tagName = "LI";
Ws.allowedChildren = [Zs];
Zs.requiredContainer = Ws;
class Vs extends rr {
  static create() {
    return super.create();
  }
  static formats() {
    return !0;
  }
  optimize(t) {
    super.optimize(t), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
  }
}
Q(Vs, "blotName", "bold"), Q(Vs, "tagName", ["STRONG", "B"]);
class wa extends Vs {
}
Q(wa, "blotName", "italic"), Q(wa, "tagName", ["EM", "I"]);
class Ke extends rr {
  static create(t) {
    const e = super.create(t);
    return e.setAttribute("href", this.sanitize(t)), e.setAttribute("rel", "noopener noreferrer"), e.setAttribute("target", "_blank"), e;
  }
  static formats(t) {
    return t.getAttribute("href");
  }
  static sanitize(t) {
    return Zd(t, this.PROTOCOL_WHITELIST) ? t : this.SANITIZED_URL;
  }
  format(t, e) {
    t !== this.statics.blotName || !e ? super.format(t, e) : this.domNode.setAttribute("href", this.constructor.sanitize(e));
  }
}
Q(Ke, "blotName", "link"), Q(Ke, "tagName", "A"), Q(Ke, "SANITIZED_URL", "about:blank"), Q(Ke, "PROTOCOL_WHITELIST", ["http", "https", "mailto", "tel", "sms"]);
function Zd(r, t) {
  const e = document.createElement("a");
  e.href = r;
  const s = e.href.slice(0, e.href.indexOf(":"));
  return t.indexOf(s) > -1;
}
class Ea extends rr {
  static create(t) {
    return t === "super" ? document.createElement("sup") : t === "sub" ? document.createElement("sub") : super.create(t);
  }
  static formats(t) {
    if (t.tagName === "SUB") return "sub";
    if (t.tagName === "SUP") return "super";
  }
}
Q(Ea, "blotName", "script"), Q(Ea, "tagName", ["SUB", "SUP"]);
class _a extends Vs {
}
Q(_a, "blotName", "strike"), Q(_a, "tagName", ["S", "STRIKE"]);
class Aa extends rr {
}
Q(Aa, "blotName", "underline"), Q(Aa, "tagName", "U");
class Vn extends Qa {
  static create(t) {
    if (window.katex == null)
      throw new Error("Formula module requires KaTeX.");
    const e = super.create(t);
    return typeof t == "string" && (window.katex.render(t, e, {
      throwOnError: !1,
      errorColor: "#f00"
    }), e.setAttribute("data-value", t)), e;
  }
  static value(t) {
    return t.getAttribute("data-value");
  }
  html() {
    const {
      formula: t
    } = this.value();
    return `<span>${t}</span>`;
  }
}
Q(Vn, "blotName", "formula"), Q(Vn, "className", "ql-formula"), Q(Vn, "tagName", "SPAN");
const qu = ["alt", "height", "width"];
class Na extends Xt {
  static create(t) {
    const e = super.create(t);
    return typeof t == "string" && e.setAttribute("src", this.sanitize(t)), e;
  }
  static formats(t) {
    return qu.reduce((e, s) => (t.hasAttribute(s) && (e[s] = t.getAttribute(s)), e), {});
  }
  static match(t) {
    return /\.(jpe?g|gif|png)$/.test(t) || /^data:image\/.+;base64/.test(t);
  }
  static sanitize(t) {
    return Zd(t, ["http", "https", "data"]) ? t : "//:0";
  }
  static value(t) {
    return t.getAttribute("src");
  }
  format(t, e) {
    qu.indexOf(t) > -1 ? e ? this.domNode.setAttribute(t, e) : this.domNode.removeAttribute(t) : super.format(t, e);
  }
}
Q(Na, "blotName", "image"), Q(Na, "tagName", "IMG");
const ju = ["height", "width"];
class Un extends ee {
  static create(t) {
    const e = super.create(t);
    return e.setAttribute("frameborder", "0"), e.setAttribute("allowfullscreen", "true"), e.setAttribute("src", this.sanitize(t)), e;
  }
  static formats(t) {
    return ju.reduce((e, s) => (t.hasAttribute(s) && (e[s] = t.getAttribute(s)), e), {});
  }
  static sanitize(t) {
    return Ke.sanitize(t);
  }
  static value(t) {
    return t.getAttribute("src");
  }
  format(t, e) {
    ju.indexOf(t) > -1 ? e ? this.domNode.setAttribute(t, e) : this.domNode.removeAttribute(t) : super.format(t, e);
  }
  html() {
    const {
      video: t
    } = this.value();
    return `<a href="${t}">${t}</a>`;
  }
}
Q(Un, "blotName", "video"), Q(Un, "className", "ql-video"), Q(Un, "tagName", "IFRAME");
const Rs = new he("code-token", "hljs", {
  scope: rt.INLINE
});
class qe extends rr {
  static formats(t, e) {
    for (; t != null && t !== e.domNode; ) {
      if (t.classList && t.classList.contains(Vt.className))
        return super.formats(t, e);
      t = t.parentNode;
    }
  }
  constructor(t, e, s) {
    super(t, e, s), Rs.add(this.domNode, s);
  }
  format(t, e) {
    t !== qe.blotName ? super.format(t, e) : e ? Rs.add(this.domNode, e) : (Rs.remove(this.domNode), this.domNode.classList.remove(this.statics.className));
  }
  optimize() {
    super.optimize(...arguments), Rs.value(this.domNode) || this.unwrap();
  }
}
qe.blotName = "code-token";
qe.className = "ql-token";
class Qt extends Vt {
  static create(t) {
    const e = super.create(t);
    return typeof t == "string" && e.setAttribute("data-language", t), e;
  }
  static formats(t) {
    return t.getAttribute("data-language") || "plain";
  }
  static register() {
  }
  // Syntax module will register
  format(t, e) {
    t === this.statics.blotName && e ? this.domNode.setAttribute("data-language", e) : super.format(t, e);
  }
  replaceWith(t, e) {
    return this.formatAt(0, this.length(), qe.blotName, !1), super.replaceWith(t, e);
  }
}
class qs extends Nr {
  attach() {
    super.attach(), this.forceNext = !1, this.scroll.emitMount(this);
  }
  format(t, e) {
    t === Qt.blotName && (this.forceNext = !0, this.children.forEach((s) => {
      s.format(t, e);
    }));
  }
  formatAt(t, e, s, n) {
    s === Qt.blotName && (this.forceNext = !0), super.formatAt(t, e, s, n);
  }
  highlight(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (this.children.head == null) return;
    const s = `${Array.from(this.domNode.childNodes).filter((i) => i !== this.uiNode).map((i) => i.textContent).join(`
`)}
`, n = Qt.formats(this.children.head.domNode);
    if (e || this.forceNext || this.cachedText !== s) {
      if (s.trim().length > 0 || this.cachedText == null) {
        const i = this.children.reduce((a, l) => a.concat(Ld(l, !1)), new et()), o = t(s, n);
        i.diff(o).reduce((a, l) => {
          let {
            retain: c,
            attributes: d
          } = l;
          return c ? (d && Object.keys(d).forEach((g) => {
            [Qt.blotName, qe.blotName].includes(g) && this.formatAt(a, c, g, d[g]);
          }), a + c) : a;
        }, 0);
      }
      this.cachedText = s, this.forceNext = !1;
    }
  }
  html(t, e) {
    const [s] = this.children.find(t);
    return `<pre data-language="${s ? Qt.formats(s.domNode) : "plain"}">
${ki(this.code(t, e))}
</pre>`;
  }
  optimize(t) {
    if (super.optimize(t), this.parent != null && this.children.head != null && this.uiNode != null) {
      const e = Qt.formats(this.children.head.domNode);
      e !== this.uiNode.value && (this.uiNode.value = e);
    }
  }
}
qs.allowedChildren = [Qt];
Qt.requiredContainer = qs;
Qt.allowedChildren = [qe, xi, ce, de];
const Tk = (r, t, e) => {
  if (typeof r.versionString == "string") {
    const s = r.versionString.split(".")[0];
    if (parseInt(s, 10) >= 11)
      return r.highlight(e, {
        language: t
      }).value;
  }
  return r.highlight(t, e).value;
};
class Xd extends pe {
  static register() {
    I.register(qe, !0), I.register(Qt, !0), I.register(qs, !0);
  }
  constructor(t, e) {
    if (super(t, e), this.options.hljs == null)
      throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
    this.languages = this.options.languages.reduce((s, n) => {
      let {
        key: i
      } = n;
      return s[i] = !0, s;
    }, {}), this.highlightBlot = this.highlightBlot.bind(this), this.initListener(), this.initTimer();
  }
  initListener() {
    this.quill.on(I.events.SCROLL_BLOT_MOUNT, (t) => {
      if (!(t instanceof qs)) return;
      const e = this.quill.root.ownerDocument.createElement("select");
      this.options.languages.forEach((s) => {
        let {
          key: n,
          label: i
        } = s;
        const o = e.ownerDocument.createElement("option");
        o.textContent = i, o.setAttribute("value", n), e.appendChild(o);
      }), e.addEventListener("change", () => {
        t.format(Qt.blotName, e.value), this.quill.root.focus(), this.highlight(t, !0);
      }), t.uiNode == null && (t.attachUI(e), t.children.head && (e.value = Qt.formats(t.children.head.domNode)));
    });
  }
  initTimer() {
    let t = null;
    this.quill.on(I.events.SCROLL_OPTIMIZE, () => {
      t && clearTimeout(t), t = setTimeout(() => {
        this.highlight(), t = null;
      }, this.options.interval);
    });
  }
  highlight() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (this.quill.selection.composing) return;
    this.quill.update(I.sources.USER);
    const s = this.quill.getSelection();
    (t == null ? this.quill.scroll.descendants(qs) : [t]).forEach((n) => {
      n.highlight(this.highlightBlot, e);
    }), this.quill.update(I.sources.SILENT), s != null && this.quill.setSelection(s, I.sources.SILENT);
  }
  highlightBlot(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "plain";
    if (e = this.languages[e] ? e : "plain", e === "plain")
      return ki(t).split(`
`).reduce((n, i, o) => (o !== 0 && n.insert(`
`, {
        [Vt.blotName]: e
      }), n.insert(i)), new et());
    const s = this.quill.root.ownerDocument.createElement("div");
    return s.classList.add(Vt.className), s.innerHTML = Tk(this.options.hljs, e, t), ol(this.quill.scroll, s, [(n, i) => {
      const o = Rs.value(n);
      return o ? i.compose(new et().retain(i.length(), {
        [qe.blotName]: o
      })) : i;
    }], [(n, i) => n.data.split(`
`).reduce((o, a, l) => (l !== 0 && o.insert(`
`, {
      [Vt.blotName]: e
    }), o.insert(a)), i)], /* @__PURE__ */ new WeakMap());
  }
}
Xd.DEFAULTS = {
  hljs: window.hljs,
  interval: 1e3,
  languages: [{
    key: "plain",
    label: "Plain"
  }, {
    key: "bash",
    label: "Bash"
  }, {
    key: "cpp",
    label: "C++"
  }, {
    key: "cs",
    label: "C#"
  }, {
    key: "css",
    label: "CSS"
  }, {
    key: "diff",
    label: "Diff"
  }, {
    key: "xml",
    label: "HTML/XML"
  }, {
    key: "java",
    label: "Java"
  }, {
    key: "javascript",
    label: "JavaScript"
  }, {
    key: "markdown",
    label: "Markdown"
  }, {
    key: "php",
    label: "PHP"
  }, {
    key: "python",
    label: "Python"
  }, {
    key: "ruby",
    label: "Ruby"
  }, {
    key: "sql",
    label: "SQL"
  }]
};
const Sa = class Yd extends jt {
  static create(t) {
    const e = super.create();
    return t ? e.setAttribute("data-row", t) : e.setAttribute("data-row", al()), e;
  }
  static formats(t) {
    if (t.hasAttribute("data-row"))
      return t.getAttribute("data-row");
  }
  cellOffset() {
    return this.parent ? this.parent.children.indexOf(this) : -1;
  }
  format(t, e) {
    t === Yd.blotName && e ? this.domNode.setAttribute("data-row", e) : super.format(t, e);
  }
  row() {
    return this.parent;
  }
  rowOffset() {
    return this.row() ? this.row().rowOffset() : -1;
  }
  table() {
    return this.row() && this.row().table();
  }
};
Q(Sa, "blotName", "table"), Q(Sa, "tagName", "TD");
let Re = Sa;
class je extends Ar {
  checkMerge() {
    if (super.checkMerge() && this.next.children.head != null) {
      const t = this.children.head.formats(), e = this.children.tail.formats(), s = this.next.children.head.formats(), n = this.next.children.tail.formats();
      return t.table === e.table && t.table === s.table && t.table === n.table;
    }
    return !1;
  }
  optimize(t) {
    super.optimize(t), this.children.forEach((e) => {
      if (e.next == null) return;
      const s = e.formats(), n = e.next.formats();
      if (s.table !== n.table) {
        const i = this.splitAfter(e);
        i && i.optimize(), this.prev && this.prev.optimize();
      }
    });
  }
  rowOffset() {
    return this.parent ? this.parent.children.indexOf(this) : -1;
  }
  table() {
    return this.parent && this.parent.parent;
  }
}
Q(je, "blotName", "table-row"), Q(je, "tagName", "TR");
class xe extends Ar {
}
Q(xe, "blotName", "table-body"), Q(xe, "tagName", "TBODY");
class is extends Ar {
  balanceCells() {
    const t = this.descendants(je), e = t.reduce((s, n) => Math.max(n.children.length, s), 0);
    t.forEach((s) => {
      new Array(e - s.children.length).fill(0).forEach(() => {
        let n;
        s.children.head != null && (n = Re.formats(s.children.head.domNode));
        const i = this.scroll.create(Re.blotName, n);
        s.appendChild(i), i.optimize();
      });
    });
  }
  cells(t) {
    return this.rows().map((e) => e.children.at(t));
  }
  deleteColumn(t) {
    const [e] = this.descendant(xe);
    e == null || e.children.head == null || e.children.forEach((s) => {
      const n = s.children.at(t);
      n != null && n.remove();
    });
  }
  insertColumn(t) {
    const [e] = this.descendant(xe);
    e == null || e.children.head == null || e.children.forEach((s) => {
      const n = s.children.at(t), i = Re.formats(s.children.head.domNode), o = this.scroll.create(Re.blotName, i);
      s.insertBefore(o, n);
    });
  }
  insertRow(t) {
    const [e] = this.descendant(xe);
    if (e == null || e.children.head == null) return;
    const s = al(), n = this.scroll.create(je.blotName);
    e.children.head.children.forEach(() => {
      const o = this.scroll.create(Re.blotName, s);
      n.appendChild(o);
    });
    const i = e.children.at(t);
    e.insertBefore(n, i);
  }
  rows() {
    const t = this.children.head;
    return t == null ? [] : t.children.map((e) => e);
  }
}
Q(is, "blotName", "table-container"), Q(is, "tagName", "TABLE");
is.allowedChildren = [xe];
xe.requiredContainer = is;
xe.allowedChildren = [je];
je.requiredContainer = xe;
je.allowedChildren = [Re];
Re.requiredContainer = je;
function al() {
  return `row-${Math.random().toString(36).slice(2, 6)}`;
}
class Rk extends pe {
  static register() {
    I.register(Re), I.register(je), I.register(xe), I.register(is);
  }
  constructor() {
    super(...arguments), this.listenBalanceCells();
  }
  balanceTables() {
    this.quill.scroll.descendants(is).forEach((t) => {
      t.balanceCells();
    });
  }
  deleteColumn() {
    const [t, , e] = this.getTable();
    e != null && (t.deleteColumn(e.cellOffset()), this.quill.update(I.sources.USER));
  }
  deleteRow() {
    const [, t] = this.getTable();
    t != null && (t.remove(), this.quill.update(I.sources.USER));
  }
  deleteTable() {
    const [t] = this.getTable();
    if (t == null) return;
    const e = t.offset();
    t.remove(), this.quill.update(I.sources.USER), this.quill.setSelection(e, I.sources.SILENT);
  }
  getTable() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.quill.getSelection();
    if (t == null) return [null, null, null, -1];
    const [e, s] = this.quill.getLine(t.index);
    if (e == null || e.statics.blotName !== Re.blotName)
      return [null, null, null, -1];
    const n = e.parent;
    return [n.parent.parent, n, e, s];
  }
  insertColumn(t) {
    const e = this.quill.getSelection();
    if (!e) return;
    const [s, n, i] = this.getTable(e);
    if (i == null) return;
    const o = i.cellOffset();
    s.insertColumn(o + t), this.quill.update(I.sources.USER);
    let a = n.rowOffset();
    t === 0 && (a += 1), this.quill.setSelection(e.index + a, e.length, I.sources.SILENT);
  }
  insertColumnLeft() {
    this.insertColumn(0);
  }
  insertColumnRight() {
    this.insertColumn(1);
  }
  insertRow(t) {
    const e = this.quill.getSelection();
    if (!e) return;
    const [s, n, i] = this.getTable(e);
    if (i == null) return;
    const o = n.rowOffset();
    s.insertRow(o + t), this.quill.update(I.sources.USER), t > 0 ? this.quill.setSelection(e, I.sources.SILENT) : this.quill.setSelection(e.index + n.children.length, e.length, I.sources.SILENT);
  }
  insertRowAbove() {
    this.insertRow(0);
  }
  insertRowBelow() {
    this.insertRow(1);
  }
  insertTable(t, e) {
    const s = this.quill.getSelection();
    if (s == null) return;
    const n = new Array(t).fill(0).reduce((i) => {
      const o = new Array(e).fill(`
`).join("");
      return i.insert(o, {
        table: al()
      });
    }, new et().retain(s.index));
    this.quill.updateContents(n, I.sources.USER), this.quill.setSelection(s.index, I.sources.SILENT), this.balanceTables();
  }
  listenBalanceCells() {
    this.quill.on(I.events.SCROLL_OPTIMIZE, (t) => {
      t.some((e) => ["TD", "TR", "TBODY", "TABLE"].includes(e.target.tagName) ? (this.quill.once(I.events.TEXT_CHANGE, (s, n, i) => {
        i === I.sources.USER && this.balanceTables();
      }), !0) : !1);
    });
  }
}
const Mu = De("quill:toolbar");
class ll extends pe {
  constructor(t, e) {
    var s, n;
    if (super(t, e), Array.isArray(this.options.container)) {
      const i = document.createElement("div");
      i.setAttribute("role", "toolbar"), Lk(i, this.options.container), (n = (s = t.container) == null ? void 0 : s.parentNode) == null || n.insertBefore(i, t.container), this.container = i;
    } else typeof this.options.container == "string" ? this.container = document.querySelector(this.options.container) : this.container = this.options.container;
    if (!(this.container instanceof HTMLElement)) {
      Mu.error("Container required for toolbar", this.options);
      return;
    }
    this.container.classList.add("ql-toolbar"), this.controls = [], this.handlers = {}, this.options.handlers && Object.keys(this.options.handlers).forEach((i) => {
      var o;
      const a = (o = this.options.handlers) == null ? void 0 : o[i];
      a && this.addHandler(i, a);
    }), Array.from(this.container.querySelectorAll("button, select")).forEach((i) => {
      this.attach(i);
    }), this.quill.on(I.events.EDITOR_CHANGE, () => {
      const [i] = this.quill.selection.getRange();
      this.update(i);
    });
  }
  addHandler(t, e) {
    this.handlers[t] = e;
  }
  attach(t) {
    let e = Array.from(t.classList).find((n) => n.indexOf("ql-") === 0);
    if (!e) return;
    if (e = e.slice(3), t.tagName === "BUTTON" && t.setAttribute("type", "button"), this.handlers[e] == null && this.quill.scroll.query(e) == null) {
      Mu.warn("ignoring attaching to nonexistent format", e, t);
      return;
    }
    const s = t.tagName === "SELECT" ? "change" : "click";
    t.addEventListener(s, (n) => {
      let i;
      if (t.tagName === "SELECT") {
        if (t.selectedIndex < 0) return;
        const a = t.options[t.selectedIndex];
        a.hasAttribute("selected") ? i = !1 : i = a.value || !1;
      } else
        t.classList.contains("ql-active") ? i = !1 : i = t.value || !t.hasAttribute("value"), n.preventDefault();
      this.quill.focus();
      const [o] = this.quill.selection.getRange();
      if (this.handlers[e] != null)
        this.handlers[e].call(this, i);
      else if (
        // @ts-expect-error
        this.quill.scroll.query(e).prototype instanceof Xt
      ) {
        if (i = prompt(`Enter ${e}`), !i) return;
        this.quill.updateContents(new et().retain(o.index).delete(o.length).insert({
          [e]: i
        }), I.sources.USER);
      } else
        this.quill.format(e, i, I.sources.USER);
      this.update(o);
    }), this.controls.push([e, t]);
  }
  update(t) {
    const e = t == null ? {} : this.quill.getFormat(t);
    this.controls.forEach((s) => {
      const [n, i] = s;
      if (i.tagName === "SELECT") {
        let o = null;
        if (t == null)
          o = null;
        else if (e[n] == null)
          o = i.querySelector("option[selected]");
        else if (!Array.isArray(e[n])) {
          let a = e[n];
          typeof a == "string" && (a = a.replace(/"/g, '\\"')), o = i.querySelector(`option[value="${a}"]`);
        }
        o == null ? (i.value = "", i.selectedIndex = -1) : o.selected = !0;
      } else if (t == null)
        i.classList.remove("ql-active"), i.setAttribute("aria-pressed", "false");
      else if (i.hasAttribute("value")) {
        const o = e[n], a = o === i.getAttribute("value") || o != null && o.toString() === i.getAttribute("value") || o == null && !i.getAttribute("value");
        i.classList.toggle("ql-active", a), i.setAttribute("aria-pressed", a.toString());
      } else {
        const o = e[n] != null;
        i.classList.toggle("ql-active", o), i.setAttribute("aria-pressed", o.toString());
      }
    });
  }
}
ll.DEFAULTS = {};
function Bu(r, t, e) {
  const s = document.createElement("button");
  s.setAttribute("type", "button"), s.classList.add(`ql-${t}`), s.setAttribute("aria-pressed", "false"), e != null ? (s.value = e, s.setAttribute("aria-label", `${t}: ${e}`)) : s.setAttribute("aria-label", t), r.appendChild(s);
}
function Lk(r, t) {
  Array.isArray(t[0]) || (t = [t]), t.forEach((e) => {
    const s = document.createElement("span");
    s.classList.add("ql-formats"), e.forEach((n) => {
      if (typeof n == "string")
        Bu(s, n);
      else {
        const i = Object.keys(n)[0], o = n[i];
        Array.isArray(o) ? Ik(s, i, o) : Bu(s, i, o);
      }
    }), r.appendChild(s);
  });
}
function Ik(r, t, e) {
  const s = document.createElement("select");
  s.classList.add(`ql-${t}`), e.forEach((n) => {
    const i = document.createElement("option");
    n !== !1 ? i.setAttribute("value", String(n)) : i.setAttribute("selected", "selected"), s.appendChild(i);
  }), r.appendChild(s);
}
ll.DEFAULTS = {
  container: null,
  handlers: {
    clean() {
      const r = this.quill.getSelection();
      if (r != null)
        if (r.length === 0) {
          const t = this.quill.getFormat();
          Object.keys(t).forEach((e) => {
            this.quill.scroll.query(e, rt.INLINE) != null && this.quill.format(e, !1, I.sources.USER);
          });
        } else
          this.quill.removeFormat(r.index, r.length, I.sources.USER);
    },
    direction(r) {
      const {
        align: t
      } = this.quill.getFormat();
      r === "rtl" && t == null ? this.quill.format("align", "right", I.sources.USER) : !r && t === "right" && this.quill.format("align", !1, I.sources.USER), this.quill.format("direction", r, I.sources.USER);
    },
    indent(r) {
      const t = this.quill.getSelection(), e = this.quill.getFormat(t), s = parseInt(e.indent || 0, 10);
      if (r === "+1" || r === "-1") {
        let n = r === "+1" ? 1 : -1;
        e.direction === "rtl" && (n *= -1), this.quill.format("indent", s + n, I.sources.USER);
      }
    },
    link(r) {
      r === !0 && (r = prompt("Enter link URL:")), this.quill.format("link", r, I.sources.USER);
    },
    list(r) {
      const t = this.quill.getSelection(), e = this.quill.getFormat(t);
      r === "check" ? e.list === "checked" || e.list === "unchecked" ? this.quill.format("list", !1, I.sources.USER) : this.quill.format("list", "unchecked", I.sources.USER) : this.quill.format("list", r, I.sources.USER);
    }
  }
};
const qk = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>', jk = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>', Mk = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>', Bk = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>', Dk = '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>', Fk = '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>', Pk = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>', Vk = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>', Du = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>', Uk = '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>', $k = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>', zk = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>', Hk = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>', Kk = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>', Gk = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', Wk = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.65186,12.30664a2.6742,2.6742,0,0,1-2.915,2.68457,3.96592,3.96592,0,0,1-2.25537-.6709.56007.56007,0,0,1-.13232-.83594L11.64648,13c.209-.34082.48389-.36328.82471-.1543a2.32654,2.32654,0,0,0,1.12256.33008c.71484,0,1.12207-.35156,1.12207-.78125,0-.61523-.61621-.86816-1.46338-.86816H13.2085a.65159.65159,0,0,1-.68213-.41895l-.05518-.10937a.67114.67114,0,0,1,.14307-.78125l.71533-.86914a8.55289,8.55289,0,0,1,.68213-.7373V8.58887a3.93913,3.93913,0,0,1-.748.05469H11.9873a.54085.54085,0,0,1-.605-.60547V7.59863a.54085.54085,0,0,1,.605-.60547h3.75146a.53773.53773,0,0,1,.60547.59375v.17676a1.03723,1.03723,0,0,1-.27539.748L14.74854,10.0293A2.31132,2.31132,0,0,1,16.65186,12.30664ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', Zk = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm7.05371,7.96582v.38477c0,.39648-.165.60547-.46191.60547h-.47314v1.29785a.54085.54085,0,0,1-.605.60547h-.69336a.54085.54085,0,0,1-.605-.60547V12.95605H11.333a.5412.5412,0,0,1-.60547-.60547v-.15332a1.199,1.199,0,0,1,.22021-.748l2.56348-4.05957a.7819.7819,0,0,1,.72607-.39648h1.27637a.54085.54085,0,0,1,.605.60547v3.7627h.33008A.54055.54055,0,0,1,17.05371,11.96582ZM14.28125,8.7207h-.022a4.18969,4.18969,0,0,1-.38525.81348l-1.188,1.80469v.02246h1.5293V9.60059A7.04058,7.04058,0,0,1,14.28125,8.7207Z"/></svg>', Xk = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.74023,12.18555a2.75131,2.75131,0,0,1-2.91553,2.80566,3.908,3.908,0,0,1-2.25537-.68164.54809.54809,0,0,1-.13184-.8252L11.73438,13c.209-.34082.48389-.36328.8252-.1543a2.23757,2.23757,0,0,0,1.1001.33008,1.01827,1.01827,0,0,0,1.1001-.96777c0-.61621-.53906-.97949-1.25439-.97949a2.15554,2.15554,0,0,0-.64893.09961,1.15209,1.15209,0,0,1-.814.01074l-.12109-.04395a.64116.64116,0,0,1-.45117-.71484l.231-3.00391a.56666.56666,0,0,1,.62744-.583H15.541a.54085.54085,0,0,1,.605.60547v.43945a.54085.54085,0,0,1-.605.60547H13.41748l-.04395.72559a1.29306,1.29306,0,0,1-.04395.30859h.022a2.39776,2.39776,0,0,1,.57227-.07715A2.53266,2.53266,0,0,1,16.74023,12.18555ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', Yk = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M14.51758,9.64453a1.85627,1.85627,0,0,0-1.24316.38477H13.252a1.73532,1.73532,0,0,1,1.72754-1.4082,2.66491,2.66491,0,0,1,.5498.06641c.35254.05469.57227.01074.70508-.40723l.16406-.5166a.53393.53393,0,0,0-.373-.75977,4.83723,4.83723,0,0,0-1.17773-.14258c-2.43164,0-3.7627,2.17773-3.7627,4.43359,0,2.47559,1.60645,3.69629,3.19043,3.69629A2.70585,2.70585,0,0,0,16.96,12.19727,2.43861,2.43861,0,0,0,14.51758,9.64453Zm-.23047,3.58691c-.67187,0-1.22168-.81445-1.22168-1.45215,0-.47363.30762-.583.72559-.583.96875,0,1.27734.59375,1.27734,1.12207A.82182.82182,0,0,1,14.28711,13.23145ZM10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Z"/></svg>', Jk = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>', Qk = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>', tx = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>', ex = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>', rx = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>', sx = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>', nx = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>', ix = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>', ox = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>', ax = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>', lx = '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>', ux = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>', cx = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>', hx = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>', Us = {
  align: {
    "": qk,
    center: jk,
    right: Mk,
    justify: Bk
  },
  background: Dk,
  blockquote: Fk,
  bold: Pk,
  clean: Vk,
  code: Du,
  "code-block": Du,
  color: Uk,
  direction: {
    "": $k,
    rtl: zk
  },
  formula: Hk,
  header: {
    1: Kk,
    2: Gk,
    3: Wk,
    4: Zk,
    5: Xk,
    6: Yk
  },
  italic: Jk,
  image: Qk,
  indent: {
    "+1": tx,
    "-1": ex
  },
  link: rx,
  list: {
    bullet: sx,
    check: nx,
    ordered: ix
  },
  script: {
    sub: ox,
    super: ax
  },
  strike: lx,
  table: ux,
  underline: cx,
  video: hx
}, dx = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>';
let Fu = 0;
function Pu(r, t) {
  r.setAttribute(t, `${r.getAttribute(t) !== "true"}`);
}
class _i {
  constructor(t) {
    this.select = t, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", () => {
      this.togglePicker();
    }), this.label.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "Enter":
          this.togglePicker();
          break;
        case "Escape":
          this.escape(), e.preventDefault();
          break;
      }
    }), this.select.addEventListener("change", this.update.bind(this));
  }
  togglePicker() {
    this.container.classList.toggle("ql-expanded"), Pu(this.label, "aria-expanded"), Pu(this.options, "aria-hidden");
  }
  buildItem(t) {
    const e = document.createElement("span");
    e.tabIndex = "0", e.setAttribute("role", "button"), e.classList.add("ql-picker-item");
    const s = t.getAttribute("value");
    return s && e.setAttribute("data-value", s), t.textContent && e.setAttribute("data-label", t.textContent), e.addEventListener("click", () => {
      this.selectItem(e, !0);
    }), e.addEventListener("keydown", (n) => {
      switch (n.key) {
        case "Enter":
          this.selectItem(e, !0), n.preventDefault();
          break;
        case "Escape":
          this.escape(), n.preventDefault();
          break;
      }
    }), e;
  }
  buildLabel() {
    const t = document.createElement("span");
    return t.classList.add("ql-picker-label"), t.innerHTML = dx, t.tabIndex = "0", t.setAttribute("role", "button"), t.setAttribute("aria-expanded", "false"), this.container.appendChild(t), t;
  }
  buildOptions() {
    const t = document.createElement("span");
    t.classList.add("ql-picker-options"), t.setAttribute("aria-hidden", "true"), t.tabIndex = "-1", t.id = `ql-picker-options-${Fu}`, Fu += 1, this.label.setAttribute("aria-controls", t.id), this.options = t, Array.from(this.select.options).forEach((e) => {
      const s = this.buildItem(e);
      t.appendChild(s), e.selected === !0 && this.selectItem(s);
    }), this.container.appendChild(t);
  }
  buildPicker() {
    Array.from(this.select.attributes).forEach((t) => {
      this.container.setAttribute(t.name, t.value);
    }), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions();
  }
  escape() {
    this.close(), setTimeout(() => this.label.focus(), 1);
  }
  close() {
    this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true");
  }
  selectItem(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const s = this.container.querySelector(".ql-selected");
    t !== s && (s != null && s.classList.remove("ql-selected"), t != null && (t.classList.add("ql-selected"), this.select.selectedIndex = Array.from(t.parentNode.children).indexOf(t), t.hasAttribute("data-value") ? this.label.setAttribute("data-value", t.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t.hasAttribute("data-label") ? this.label.setAttribute("data-label", t.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e && (this.select.dispatchEvent(new Event("change")), this.close())));
  }
  update() {
    let t;
    if (this.select.selectedIndex > -1) {
      const s = (
        // @ts-expect-error Fix me later
        this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex]
      );
      t = this.select.options[this.select.selectedIndex], this.selectItem(s);
    } else
      this.selectItem(null);
    const e = t != null && t !== this.select.querySelector("option[selected]");
    this.label.classList.toggle("ql-active", e);
  }
}
class Jd extends _i {
  constructor(t, e) {
    super(t), this.label.innerHTML = e, this.container.classList.add("ql-color-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((s) => {
      s.classList.add("ql-primary");
    });
  }
  buildItem(t) {
    const e = super.buildItem(t);
    return e.style.backgroundColor = t.getAttribute("value") || "", e;
  }
  selectItem(t, e) {
    super.selectItem(t, e);
    const s = this.label.querySelector(".ql-color-label"), n = t && t.getAttribute("data-value") || "";
    s && (s.tagName === "line" ? s.style.stroke = n : s.style.fill = n);
  }
}
class Qd extends _i {
  constructor(t, e) {
    super(t), this.container.classList.add("ql-icon-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((s) => {
      s.innerHTML = e[s.getAttribute("data-value") || ""];
    }), this.defaultItem = this.container.querySelector(".ql-selected"), this.selectItem(this.defaultItem);
  }
  selectItem(t, e) {
    super.selectItem(t, e);
    const s = t || this.defaultItem;
    if (s != null) {
      if (this.label.innerHTML === s.innerHTML) return;
      this.label.innerHTML = s.innerHTML;
    }
  }
}
const px = (r) => {
  const {
    overflowY: t
  } = getComputedStyle(r, null);
  return t !== "visible" && t !== "clip";
};
class tp {
  constructor(t, e) {
    this.quill = t, this.boundsContainer = e || document.body, this.root = t.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, px(this.quill.root) && this.quill.root.addEventListener("scroll", () => {
      this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;
    }), this.hide();
  }
  hide() {
    this.root.classList.add("ql-hidden");
  }
  position(t) {
    const e = t.left + t.width / 2 - this.root.offsetWidth / 2, s = t.bottom + this.quill.root.scrollTop;
    this.root.style.left = `${e}px`, this.root.style.top = `${s}px`, this.root.classList.remove("ql-flip");
    const n = this.boundsContainer.getBoundingClientRect(), i = this.root.getBoundingClientRect();
    let o = 0;
    if (i.right > n.right && (o = n.right - i.right, this.root.style.left = `${e + o}px`), i.left < n.left && (o = n.left - i.left, this.root.style.left = `${e + o}px`), i.bottom > n.bottom) {
      const a = i.bottom - i.top, l = t.bottom - t.top + a;
      this.root.style.top = `${s - l}px`, this.root.classList.add("ql-flip");
    }
    return o;
  }
  show() {
    this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden");
  }
}
const fx = [!1, "center", "right", "justify"], mx = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"], gx = [!1, "serif", "monospace"], vx = ["1", "2", "3", !1], bx = ["small", !1, "large", "huge"];
class Xs extends wi {
  constructor(t, e) {
    super(t, e);
    const s = (n) => {
      if (!document.body.contains(t.root)) {
        document.body.removeEventListener("click", s);
        return;
      }
      this.tooltip != null && // @ts-expect-error
      !this.tooltip.root.contains(n.target) && // @ts-expect-error
      document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus() && this.tooltip.hide(), this.pickers != null && this.pickers.forEach((i) => {
        i.container.contains(n.target) || i.close();
      });
    };
    t.emitter.listenDOM("click", document.body, s);
  }
  addModule(t) {
    const e = super.addModule(t);
    return t === "toolbar" && this.extendToolbar(e), e;
  }
  buildButtons(t, e) {
    Array.from(t).forEach((s) => {
      (s.getAttribute("class") || "").split(/\s+/).forEach((n) => {
        if (n.startsWith("ql-") && (n = n.slice(3), e[n] != null))
          if (n === "direction")
            s.innerHTML = e[n][""] + e[n].rtl;
          else if (typeof e[n] == "string")
            s.innerHTML = e[n];
          else {
            const i = s.value || "";
            i != null && e[n][i] && (s.innerHTML = e[n][i]);
          }
      });
    });
  }
  buildPickers(t, e) {
    this.pickers = Array.from(t).map((n) => {
      if (n.classList.contains("ql-align") && (n.querySelector("option") == null && Ns(n, fx), typeof e.align == "object"))
        return new Qd(n, e.align);
      if (n.classList.contains("ql-background") || n.classList.contains("ql-color")) {
        const i = n.classList.contains("ql-background") ? "background" : "color";
        return n.querySelector("option") == null && Ns(n, mx, i === "background" ? "#ffffff" : "#000000"), new Jd(n, e[i]);
      }
      return n.querySelector("option") == null && (n.classList.contains("ql-font") ? Ns(n, gx) : n.classList.contains("ql-header") ? Ns(n, vx) : n.classList.contains("ql-size") && Ns(n, bx)), new _i(n);
    });
    const s = () => {
      this.pickers.forEach((n) => {
        n.update();
      });
    };
    this.quill.on(tt.events.EDITOR_CHANGE, s);
  }
}
Xs.DEFAULTS = We({}, wi.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        formula() {
          this.quill.theme.tooltip.edit("formula");
        },
        image() {
          let r = this.container.querySelector("input.ql-image[type=file]");
          r == null && (r = document.createElement("input"), r.setAttribute("type", "file"), r.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", ")), r.classList.add("ql-image"), r.addEventListener("change", () => {
            const t = this.quill.getSelection(!0);
            this.quill.uploader.upload(t, r.files), r.value = "";
          }), this.container.appendChild(r)), r.click();
        },
        video() {
          this.quill.theme.tooltip.edit("video");
        }
      }
    }
  }
});
class ep extends tp {
  constructor(t, e) {
    super(t, e), this.textbox = this.root.querySelector('input[type="text"]'), this.listen();
  }
  listen() {
    this.textbox.addEventListener("keydown", (t) => {
      t.key === "Enter" ? (this.save(), t.preventDefault()) : t.key === "Escape" && (this.cancel(), t.preventDefault());
    });
  }
  cancel() {
    this.hide(), this.restoreFocus();
  }
  edit() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), this.textbox == null) return;
    e != null ? this.textbox.value = e : t !== this.root.getAttribute("data-mode") && (this.textbox.value = "");
    const s = this.quill.getBounds(this.quill.selection.savedRange);
    s != null && this.position(s), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${t}`) || ""), this.root.setAttribute("data-mode", t);
  }
  restoreFocus() {
    this.quill.focus({
      preventScroll: !0
    });
  }
  save() {
    let {
      value: t
    } = this.textbox;
    switch (this.root.getAttribute("data-mode")) {
      case "link": {
        const {
          scrollTop: e
        } = this.quill.root;
        this.linkRange ? (this.quill.formatText(this.linkRange, "link", t, tt.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", t, tt.sources.USER)), this.quill.root.scrollTop = e;
        break;
      }
      case "video":
        t = yx(t);
      // eslint-disable-next-line no-fallthrough
      case "formula": {
        if (!t) break;
        const e = this.quill.getSelection(!0);
        if (e != null) {
          const s = e.index + e.length;
          this.quill.insertEmbed(
            s,
            // @ts-expect-error Fix me later
            this.root.getAttribute("data-mode"),
            t,
            tt.sources.USER
          ), this.root.getAttribute("data-mode") === "formula" && this.quill.insertText(s + 1, " ", tt.sources.USER), this.quill.setSelection(s + 2, tt.sources.USER);
        }
        break;
      }
    }
    this.textbox.value = "", this.hide();
  }
}
function yx(r) {
  let t = r.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || r.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
  return t ? `${t[1] || "https"}://www.youtube.com/embed/${t[2]}?showinfo=0` : (t = r.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) ? `${t[1] || "https"}://player.vimeo.com/video/${t[2]}/` : r;
}
function Ns(r, t) {
  let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  t.forEach((s) => {
    const n = document.createElement("option");
    s === e ? n.setAttribute("selected", "selected") : n.setAttribute("value", String(s)), r.appendChild(n);
  });
}
const kx = [["bold", "italic", "link"], [{
  header: 1
}, {
  header: 2
}, "blockquote"]];
class rp extends ep {
  constructor(t, e) {
    super(t, e), this.quill.on(tt.events.EDITOR_CHANGE, (s, n, i, o) => {
      if (s === tt.events.SELECTION_CHANGE)
        if (n != null && n.length > 0 && o === tt.sources.USER) {
          this.show(), this.root.style.left = "0px", this.root.style.width = "", this.root.style.width = `${this.root.offsetWidth}px`;
          const a = this.quill.getLines(n.index, n.length);
          if (a.length === 1) {
            const l = this.quill.getBounds(n);
            l != null && this.position(l);
          } else {
            const l = a[a.length - 1], c = this.quill.getIndex(l), d = Math.min(l.length() - 1, n.index + n.length - c), g = this.quill.getBounds(new xr(c, d));
            g != null && this.position(g);
          }
        } else document.activeElement !== this.textbox && this.quill.hasFocus() && this.hide();
    });
  }
  listen() {
    super.listen(), this.root.querySelector(".ql-close").addEventListener("click", () => {
      this.root.classList.remove("ql-editing");
    }), this.quill.on(tt.events.SCROLL_OPTIMIZE, () => {
      setTimeout(() => {
        if (this.root.classList.contains("ql-hidden")) return;
        const t = this.quill.getSelection();
        if (t != null) {
          const e = this.quill.getBounds(t);
          e != null && this.position(e);
        }
      }, 1);
    });
  }
  cancel() {
    this.show();
  }
  position(t) {
    const e = super.position(t), s = this.root.querySelector(".ql-tooltip-arrow");
    return s.style.marginLeft = "", e !== 0 && (s.style.marginLeft = `${-1 * e - s.offsetWidth / 2}px`), e;
  }
}
Q(rp, "TEMPLATE", ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join(""));
class sp extends Xs {
  constructor(t, e) {
    e.modules.toolbar != null && e.modules.toolbar.container == null && (e.modules.toolbar.container = kx), super(t, e), this.quill.container.classList.add("ql-bubble");
  }
  extendToolbar(t) {
    this.tooltip = new rp(this.quill, this.options.bounds), t.container != null && (this.tooltip.root.appendChild(t.container), this.buildButtons(t.container.querySelectorAll("button"), Us), this.buildPickers(t.container.querySelectorAll("select"), Us));
  }
}
sp.DEFAULTS = We({}, Xs.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link(r) {
          r ? this.quill.theme.tooltip.edit() : this.quill.format("link", !1, I.sources.USER);
        }
      }
    }
  }
});
const xx = [[{
  header: ["1", "2", "3", !1]
}], ["bold", "italic", "underline", "link"], [{
  list: "ordered"
}, {
  list: "bullet"
}], ["clean"]];
class np extends ep {
  constructor() {
    super(...arguments), Q(this, "preview", this.root.querySelector("a.ql-preview"));
  }
  listen() {
    super.listen(), this.root.querySelector("a.ql-action").addEventListener("click", (t) => {
      this.root.classList.contains("ql-editing") ? this.save() : this.edit("link", this.preview.textContent), t.preventDefault();
    }), this.root.querySelector("a.ql-remove").addEventListener("click", (t) => {
      if (this.linkRange != null) {
        const e = this.linkRange;
        this.restoreFocus(), this.quill.formatText(e, "link", !1, tt.sources.USER), delete this.linkRange;
      }
      t.preventDefault(), this.hide();
    }), this.quill.on(tt.events.SELECTION_CHANGE, (t, e, s) => {
      if (t != null) {
        if (t.length === 0 && s === tt.sources.USER) {
          const [n, i] = this.quill.scroll.descendant(Ke, t.index);
          if (n != null) {
            this.linkRange = new xr(t.index - i, n.length());
            const o = Ke.formats(n.domNode);
            this.preview.textContent = o, this.preview.setAttribute("href", o), this.show();
            const a = this.quill.getBounds(this.linkRange);
            a != null && this.position(a);
            return;
          }
        } else
          delete this.linkRange;
        this.hide();
      }
    });
  }
  show() {
    super.show(), this.root.removeAttribute("data-mode");
  }
}
Q(np, "TEMPLATE", ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join(""));
class ip extends Xs {
  constructor(t, e) {
    e.modules.toolbar != null && e.modules.toolbar.container == null && (e.modules.toolbar.container = xx), super(t, e), this.quill.container.classList.add("ql-snow");
  }
  extendToolbar(t) {
    t.container != null && (t.container.classList.add("ql-snow"), this.buildButtons(t.container.querySelectorAll("button"), Us), this.buildPickers(t.container.querySelectorAll("select"), Us), this.tooltip = new np(this.quill, this.options.bounds), t.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({
      key: "k",
      shortKey: !0
    }, (e, s) => {
      t.handlers.link.call(t, !s.format.link);
    }));
  }
}
ip.DEFAULTS = We({}, Xs.DEFAULTS, {
  modules: {
    toolbar: {
      handlers: {
        link(r) {
          if (r) {
            const t = this.quill.getSelection();
            if (t == null || t.length === 0) return;
            let e = this.quill.getText(t);
            /^\S+@\S+\.\S+$/.test(e) && e.indexOf("mailto:") !== 0 && (e = `mailto:${e}`);
            const {
              tooltip: s
            } = this.quill.theme;
            s.edit("link", e);
          } else
            this.quill.format("link", !1, I.sources.USER);
        }
      }
    }
  }
});
I.register({
  "attributors/attribute/direction": Bd,
  "attributors/class/align": qd,
  "attributors/class/background": Fy,
  "attributors/class/color": Dy,
  "attributors/class/direction": Dd,
  "attributors/class/font": Vd,
  "attributors/class/size": $d,
  "attributors/style/align": jd,
  "attributors/style/background": rl,
  "attributors/style/color": el,
  "attributors/style/direction": Fd,
  "attributors/style/font": Ud,
  "attributors/style/size": zd
}, !0);
I.register({
  "formats/align": qd,
  "formats/direction": Dd,
  "formats/indent": Ok,
  "formats/background": rl,
  "formats/color": el,
  "formats/font": Vd,
  "formats/size": $d,
  "formats/blockquote": ka,
  "formats/code-block": Vt,
  "formats/header": xa,
  "formats/list": Zs,
  "formats/bold": Vs,
  "formats/code": sl,
  "formats/italic": wa,
  "formats/link": Ke,
  "formats/script": Ea,
  "formats/strike": _a,
  "formats/underline": Aa,
  "formats/formula": Vn,
  "formats/image": Na,
  "formats/video": Un,
  "modules/syntax": Xd,
  "modules/table": Rk,
  "modules/toolbar": ll,
  "themes/bubble": sp,
  "themes/snow": ip,
  "ui/icons": Us,
  "ui/picker": _i,
  "ui/icon-picker": Qd,
  "ui/color-picker": Jd,
  "ui/tooltip": tp
}, !0);
class Ai extends ut.Component {
  constructor(t) {
    super(t), this.editingAreaRef = pl(), this.containerRef = pl(), this.dirtyProps = [
      "modules",
      "formats",
      "bounds",
      "theme",
      "children"
    ], this.cleanProps = [
      "id",
      "className",
      "style",
      "placeholder",
      "tabIndex",
      "onChange",
      "onChangeSelection",
      "onFocus",
      "onBlur",
      "onKeyPress",
      "onKeyDown",
      "onKeyUp"
    ], this.state = {
      generation: 0
    }, this.selection = null, this.onEditorChange = (s, n, i, o) => {
      var a, l;
      s === "text-change" ? (a = this.onEditorChangeText) == null || a.call(this, this.editor.root.innerHTML, n, o, this.unprivilegedEditor) : s === "selection-change" && ((l = this.onEditorChangeSelection) == null || l.call(this, n, o, this.unprivilegedEditor));
    };
    const e = this.isControlled() ? t.value : t.defaultValue;
    this.value = e ?? "";
  }
  validateProps(t) {
    if (ut.Children.count(t.children) > 1)
      throw new Error("The Quill editing area can only be composed of a single React element.");
    if (ut.Children.count(t.children)) {
      const e = ut.Children.only(t.children);
      if ((e == null ? void 0 : e.type) === "textarea")
        throw new Error("Quill does not support editing on a <textarea>. Use a <div> instead.");
    }
    if (this.lastDeltaChangeSet && t.value === this.lastDeltaChangeSet)
      throw new Error("You are passing the `delta` object from the `onChange` event back as `value`. You most probably want `editor.getContents()` instead. See: https://github.com/zenoamaro/react-quill#using-deltas");
  }
  shouldComponentUpdate(t, e) {
    if (this.validateProps(t), !this.editor || this.state.generation !== e.generation)
      return !0;
    if ("value" in t) {
      const s = this.getEditorContents(), n = t.value ?? "";
      this.isEqualValue(n, s) || this.setEditorContents(this.editor, n);
    }
    return t.readOnly !== this.props.readOnly && this.setEditorReadOnly(this.editor, t.readOnly), [...this.cleanProps, ...this.dirtyProps].some((s) => !$e(t[s], this.props[s]));
  }
  shouldComponentRegenerate(t) {
    return this.dirtyProps.some((e) => !$e(t[e], this.props[e]));
  }
  componentDidMount() {
    this.instantiateEditor(), this.setEditorContents(this.editor, this.getEditorContents());
  }
  componentWillUnmount() {
    this.destroyEditor();
  }
  componentDidUpdate(t, e) {
    if (this.editor && this.shouldComponentRegenerate(t)) {
      const s = this.editor.getContents(), n = this.editor.getSelection();
      this.regenerationSnapshot = { delta: s, selection: n }, this.setState({ generation: this.state.generation + 1 }), this.destroyEditor();
    }
    if (this.state.generation !== e.generation) {
      const { delta: s, selection: n } = this.regenerationSnapshot;
      delete this.regenerationSnapshot, this.instantiateEditor();
      const i = this.editor;
      i.setContents(s), Vu(() => this.setEditorSelection(i, n));
    }
  }
  instantiateEditor() {
    this.editor ? this.hookEditor(this.editor) : this.editor = this.createEditor(this.getEditingArea(), this.getEditorConfig());
  }
  destroyEditor() {
    var t, e;
    if (!this.editor)
      return;
    this.unhookEditor(this.editor);
    const s = (t = this.props.modules) == null ? void 0 : t.toolbar;
    if (!(typeof s == "object" && s && "container" in s && typeof s.container == "string" || typeof s == "string")) {
      const n = (e = this.containerRef.current) == null ? void 0 : e.querySelector(".ql-toolbar");
      n && n.remove();
    }
    delete this.editor;
  }
  /*
  We consider the component to be controlled if `value` is being sent in props.
  */
  isControlled() {
    return "value" in this.props;
  }
  getEditorConfig() {
    return {
      bounds: this.props.bounds,
      formats: this.props.formats,
      modules: this.props.modules,
      placeholder: this.props.placeholder,
      readOnly: this.props.readOnly,
      tabIndex: this.props.tabIndex,
      theme: this.props.theme
    };
  }
  getEditor() {
    if (!this.editor)
      throw new Error("Accessing non-instantiated editor");
    return this.editor;
  }
  /**
  Creates an editor on the given element. The editor will be passed the
  configuration, have its events bound,
  */
  createEditor(t, e) {
    const s = new I(t, e);
    return e.tabIndex != null && this.setEditorTabIndex(s, e.tabIndex), this.hookEditor(s), s;
  }
  hookEditor(t) {
    this.unprivilegedEditor = this.makeUnprivilegedEditor(t), t.on("editor-change", this.onEditorChange);
  }
  unhookEditor(t) {
    t.off("editor-change", this.onEditorChange);
  }
  getEditorContents() {
    return this.value;
  }
  getEditorSelection() {
    return this.selection;
  }
  /*
  True if the value is a Delta instance or a Delta look-alike.
  */
  isDelta(t) {
    return t && t.ops;
  }
  /*
  Special comparison function that knows how to compare Deltas.
  */
  isEqualValue(t, e) {
    return this.isDelta(t) && this.isDelta(e) ? $e(t.ops, e.ops) : $e(t, e);
  }
  /*
  Replace the contents of the editor, but keep the previous selection hanging
  around so that the cursor won't move.
  */
  setEditorContents(t, e) {
    this.value = e;
    const s = this.getEditorSelection();
    typeof e == "string" ? t.setContents(t.clipboard.convert({ html: e })) : t.setContents(e), Vu(() => this.setEditorSelection(t, s));
  }
  setEditorSelection(t, e) {
    if (this.selection = e, e) {
      const s = t.getLength();
      e.index = Math.max(0, Math.min(e.index, s - 1)), e.length = Math.max(0, Math.min(e.length, s - 1 - e.index)), t.setSelection(e);
    }
  }
  setEditorTabIndex(t, e) {
    var s;
    (s = t == null ? void 0 : t.scroll) != null && s.domNode && (t.scroll.domNode.tabIndex = e);
  }
  setEditorReadOnly(t, e) {
    e ? t.disable() : t.enable();
  }
  /*
  Returns a weaker, unprivileged proxy object that only exposes read-only
  accessors found on the editor instance, without any state-modifying methods.
  */
  makeUnprivilegedEditor(t) {
    const e = t;
    return {
      getHTML: () => e.root.innerHTML,
      getSemanticHTML: e.getSemanticHTML.bind(e),
      getLength: e.getLength.bind(e),
      getText: e.getText.bind(e),
      getContents: e.getContents.bind(e),
      getSelection: e.getSelection.bind(e),
      getBounds: e.getBounds.bind(e)
    };
  }
  getEditingArea() {
    const t = this.editingAreaRef.current;
    if (!t)
      throw new Error("Cannot find element for editing area");
    if (t.nodeType === 3)
      throw new Error("Editing area cannot be a text node");
    return t;
  }
  /*
  Renders an editor area, unless it has been provided one to clone.
  */
  renderEditingArea() {
    const { children: t, preserveWhitespace: e } = this.props, { generation: s } = this.state, n = {
      key: s,
      ref: this.editingAreaRef
    };
    return ut.Children.count(t) ? ut.cloneElement(ut.Children.only(t), n) : e ? ut.createElement("pre", { ...n }) : ut.createElement("div", { ...n });
  }
  render() {
    return ut.createElement("div", { ref: this.containerRef, id: this.props.id, style: this.props.style, key: this.state.generation, className: `quill ${this.props.className ?? ""}`, onKeyPress: this.props.onKeyPress, onKeyDown: this.props.onKeyDown, onKeyUp: this.props.onKeyUp }, this.renderEditingArea());
  }
  onEditorChangeText(t, e, s, n) {
    var i, o;
    if (!this.editor)
      return;
    const a = this.isDelta(this.value) ? n.getContents() : n.getHTML();
    a !== this.getEditorContents() && (this.lastDeltaChangeSet = e, this.value = a, (o = (i = this.props).onChange) == null || o.call(i, t, e, s, n));
  }
  onEditorChangeSelection(t, e, s) {
    var n, i, o, a, l, c;
    if (!this.editor)
      return;
    const d = this.getEditorSelection(), g = !d && t, h = d && !t;
    $e(t, d) || (this.selection = t, (i = (n = this.props).onChangeSelection) == null || i.call(n, t, e, s), g ? (a = (o = this.props).onFocus) == null || a.call(o, t, e, s) : h && ((c = (l = this.props).onBlur) == null || c.call(l, d, e, s)));
  }
  focus() {
    this.editor && this.editor.focus();
  }
  blur() {
    this.editor && (this.selection = null, this.editor.blur());
  }
}
Ai.displayName = "React Quill";
Ai.Quill = I;
Ai.defaultProps = {
  theme: "snow",
  modules: {},
  readOnly: !1
};
function Vu(r) {
  Promise.resolve().then(r);
}
const wx = La(
  "w-full rounded-lg border border-border-alpha-strong dark:bg-transparent file:border-0 placeholder:text-secondary placeholder:text-body-sm-regular focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-bg focus-within:ring-offset-2 focus-within:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "focus-within:ring-item-primary",
        failure: "focus-within:ring-item-destructive bg-item-destructive-focus placeholder:text-item-destructive border-item-destructive text-destructive",
        success: "focus-within:ring-success bg-success/20 placeholder:text-success/80 border-success text-success"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), Ex = Va.div`
  .quill {
    .ql {
      &-toolbar {
        border: none;
      }

      &-editor,
      &-container {
        min-height: 120px;
        border: none;
      }
    }
`;
function _x({
  containerProps: r,
  className: t,
  variant: e,
  ...s
}) {
  return /* @__PURE__ */ R.jsx(
    Ex,
    {
      ...r,
      className: St(wx({ variant: e }), "block h-auto p-0", t),
      children: /* @__PURE__ */ R.jsx(Ai, { theme: "snow", ...s })
    }
  );
}
_x.displayName = "HtmlEditor";
function Ze(r) {
  return typeof r == "string" || r instanceof String;
}
function Uu(r) {
  var t;
  return typeof r == "object" && r != null && (r == null || (t = r.constructor) == null ? void 0 : t.name) === "Object";
}
function op(r, t) {
  return Array.isArray(t) ? op(r, (e, s) => t.includes(s)) : Object.entries(r).reduce((e, s) => {
    let [n, i] = s;
    return t(i, n) && (e[n] = i), e;
  }, {});
}
const nt = {
  NONE: "NONE",
  LEFT: "LEFT",
  FORCE_LEFT: "FORCE_LEFT",
  RIGHT: "RIGHT",
  FORCE_RIGHT: "FORCE_RIGHT"
};
function Ax(r) {
  switch (r) {
    case nt.LEFT:
      return nt.FORCE_LEFT;
    case nt.RIGHT:
      return nt.FORCE_RIGHT;
    default:
      return r;
  }
}
function Bo(r) {
  return r.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
}
function Jn(r, t) {
  if (t === r) return !0;
  const e = Array.isArray(t), s = Array.isArray(r);
  let n;
  if (e && s) {
    if (t.length != r.length) return !1;
    for (n = 0; n < t.length; n++) if (!Jn(t[n], r[n])) return !1;
    return !0;
  }
  if (e != s) return !1;
  if (t && r && typeof t == "object" && typeof r == "object") {
    const i = t instanceof Date, o = r instanceof Date;
    if (i && o) return t.getTime() == r.getTime();
    if (i != o) return !1;
    const a = t instanceof RegExp, l = r instanceof RegExp;
    if (a && l) return t.toString() == r.toString();
    if (a != l) return !1;
    const c = Object.keys(t);
    for (n = 0; n < c.length; n++) if (!Object.prototype.hasOwnProperty.call(r, c[n])) return !1;
    for (n = 0; n < c.length; n++) if (!Jn(r[c[n]], t[c[n]])) return !1;
    return !0;
  } else if (t && r && typeof t == "function" && typeof r == "function")
    return t.toString() === r.toString();
  return !1;
}
class Nx {
  /** Current input value */
  /** Current cursor position */
  /** Old input value */
  /** Old selection */
  constructor(t) {
    for (Object.assign(this, t); this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos); )
      --this.oldSelection.start;
    if (this.insertedCount)
      for (; this.value.slice(this.cursorPos) !== this.oldValue.slice(this.oldSelection.end); )
        this.value.length - this.cursorPos < this.oldValue.length - this.oldSelection.end ? ++this.oldSelection.end : ++this.cursorPos;
  }
  /** Start changing position */
  get startChangePos() {
    return Math.min(this.cursorPos, this.oldSelection.start);
  }
  /** Inserted symbols count */
  get insertedCount() {
    return this.cursorPos - this.startChangePos;
  }
  /** Inserted symbols */
  get inserted() {
    return this.value.substr(this.startChangePos, this.insertedCount);
  }
  /** Removed symbols count */
  get removedCount() {
    return Math.max(this.oldSelection.end - this.startChangePos || // for Delete
    this.oldValue.length - this.value.length, 0);
  }
  /** Removed symbols */
  get removed() {
    return this.oldValue.substr(this.startChangePos, this.removedCount);
  }
  /** Unchanged head symbols */
  get head() {
    return this.value.substring(0, this.startChangePos);
  }
  /** Unchanged tail symbols */
  get tail() {
    return this.value.substring(this.startChangePos + this.insertedCount);
  }
  /** Remove direction */
  get removeDirection() {
    return !this.removedCount || this.insertedCount ? nt.NONE : (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) && // if not range removed (event with backspace)
    this.oldSelection.end === this.oldSelection.start ? nt.RIGHT : nt.LEFT;
  }
}
function ot(r, t) {
  return new ot.InputMask(r, t);
}
function ap(r) {
  if (r == null) throw new Error("mask property should be defined");
  return r instanceof RegExp ? ot.MaskedRegExp : Ze(r) ? ot.MaskedPattern : r === Date ? ot.MaskedDate : r === Number ? ot.MaskedNumber : Array.isArray(r) || r === Array ? ot.MaskedDynamic : ot.Masked && r.prototype instanceof ot.Masked ? r : ot.Masked && r instanceof ot.Masked ? r.constructor : r instanceof Function ? ot.MaskedFunction : (console.warn("Mask not found for mask", r), ot.Masked);
}
function $s(r) {
  if (!r) throw new Error("Options in not defined");
  if (ot.Masked) {
    if (r.prototype instanceof ot.Masked) return {
      mask: r
    };
    const {
      mask: t = void 0,
      ...e
    } = r instanceof ot.Masked ? {
      mask: r
    } : Uu(r) && r.mask instanceof ot.Masked ? r : {};
    if (t) {
      const s = t.mask;
      return {
        ...op(t, (n, i) => !i.startsWith("_")),
        mask: t.constructor,
        _mask: s,
        ...e
      };
    }
  }
  return Uu(r) ? {
    ...r
  } : {
    mask: r
  };
}
function Me(r) {
  if (ot.Masked && r instanceof ot.Masked) return r;
  const t = $s(r), e = ap(t.mask);
  if (!e) throw new Error("Masked class is not found for provided mask " + t.mask + ", appropriate module needs to be imported manually before creating mask.");
  return t.mask === e && delete t.mask, t._mask && (t.mask = t._mask, delete t._mask), new e(t);
}
ot.createMask = Me;
class ul {
  /** */
  /** */
  /** */
  /** Safely returns selection start */
  get selectionStart() {
    let t;
    try {
      t = this._unsafeSelectionStart;
    } catch {
    }
    return t ?? this.value.length;
  }
  /** Safely returns selection end */
  get selectionEnd() {
    let t;
    try {
      t = this._unsafeSelectionEnd;
    } catch {
    }
    return t ?? this.value.length;
  }
  /** Safely sets element selection */
  select(t, e) {
    if (!(t == null || e == null || t === this.selectionStart && e === this.selectionEnd))
      try {
        this._unsafeSelect(t, e);
      } catch {
      }
  }
  /** */
  get isActive() {
    return !1;
  }
  /** */
  /** */
  /** */
}
ot.MaskElement = ul;
const $u = 90, Sx = 89;
class Ni extends ul {
  /** HTMLElement to use mask on */
  constructor(t) {
    super(), this.input = t, this._onKeydown = this._onKeydown.bind(this), this._onInput = this._onInput.bind(this), this._onBeforeinput = this._onBeforeinput.bind(this), this._onCompositionEnd = this._onCompositionEnd.bind(this);
  }
  get rootElement() {
    var t, e, s;
    return (t = (e = (s = this.input).getRootNode) == null ? void 0 : e.call(s)) != null ? t : document;
  }
  /** Is element in focus */
  get isActive() {
    return this.input === this.rootElement.activeElement;
  }
  /** Binds HTMLElement events to mask internal events */
  bindEvents(t) {
    this.input.addEventListener("keydown", this._onKeydown), this.input.addEventListener("input", this._onInput), this.input.addEventListener("beforeinput", this._onBeforeinput), this.input.addEventListener("compositionend", this._onCompositionEnd), this.input.addEventListener("drop", t.drop), this.input.addEventListener("click", t.click), this.input.addEventListener("focus", t.focus), this.input.addEventListener("blur", t.commit), this._handlers = t;
  }
  _onKeydown(t) {
    if (this._handlers.redo && (t.keyCode === $u && t.shiftKey && (t.metaKey || t.ctrlKey) || t.keyCode === Sx && t.ctrlKey))
      return t.preventDefault(), this._handlers.redo(t);
    if (this._handlers.undo && t.keyCode === $u && (t.metaKey || t.ctrlKey))
      return t.preventDefault(), this._handlers.undo(t);
    t.isComposing || this._handlers.selectionChange(t);
  }
  _onBeforeinput(t) {
    if (t.inputType === "historyUndo" && this._handlers.undo)
      return t.preventDefault(), this._handlers.undo(t);
    if (t.inputType === "historyRedo" && this._handlers.redo)
      return t.preventDefault(), this._handlers.redo(t);
  }
  _onCompositionEnd(t) {
    this._handlers.input(t);
  }
  _onInput(t) {
    t.isComposing || this._handlers.input(t);
  }
  /** Unbinds HTMLElement events to mask internal events */
  unbindEvents() {
    this.input.removeEventListener("keydown", this._onKeydown), this.input.removeEventListener("input", this._onInput), this.input.removeEventListener("beforeinput", this._onBeforeinput), this.input.removeEventListener("compositionend", this._onCompositionEnd), this.input.removeEventListener("drop", this._handlers.drop), this.input.removeEventListener("click", this._handlers.click), this.input.removeEventListener("focus", this._handlers.focus), this.input.removeEventListener("blur", this._handlers.commit), this._handlers = {};
  }
}
ot.HTMLMaskElement = Ni;
class Cx extends Ni {
  /** InputElement to use mask on */
  constructor(t) {
    super(t), this.input = t;
  }
  /** Returns InputElement selection start */
  get _unsafeSelectionStart() {
    return this.input.selectionStart != null ? this.input.selectionStart : this.value.length;
  }
  /** Returns InputElement selection end */
  get _unsafeSelectionEnd() {
    return this.input.selectionEnd;
  }
  /** Sets InputElement selection */
  _unsafeSelect(t, e) {
    this.input.setSelectionRange(t, e);
  }
  get value() {
    return this.input.value;
  }
  set value(t) {
    this.input.value = t;
  }
}
ot.HTMLMaskElement = Ni;
class lp extends Ni {
  /** Returns HTMLElement selection start */
  get _unsafeSelectionStart() {
    const t = this.rootElement, e = t.getSelection && t.getSelection(), s = e && e.anchorOffset, n = e && e.focusOffset;
    return n == null || s == null || s < n ? s : n;
  }
  /** Returns HTMLElement selection end */
  get _unsafeSelectionEnd() {
    const t = this.rootElement, e = t.getSelection && t.getSelection(), s = e && e.anchorOffset, n = e && e.focusOffset;
    return n == null || s == null || s > n ? s : n;
  }
  /** Sets HTMLElement selection */
  _unsafeSelect(t, e) {
    if (!this.rootElement.createRange) return;
    const s = this.rootElement.createRange();
    s.setStart(this.input.firstChild || this.input, t), s.setEnd(this.input.lastChild || this.input, e);
    const n = this.rootElement, i = n.getSelection && n.getSelection();
    i && (i.removeAllRanges(), i.addRange(s));
  }
  /** HTMLElement value */
  get value() {
    return this.input.textContent || "";
  }
  set value(t) {
    this.input.textContent = t;
  }
}
ot.HTMLContenteditableMaskElement = lp;
class Si {
  constructor() {
    this.states = [], this.currentIndex = 0;
  }
  get currentState() {
    return this.states[this.currentIndex];
  }
  get isEmpty() {
    return this.states.length === 0;
  }
  push(t) {
    this.currentIndex < this.states.length - 1 && (this.states.length = this.currentIndex + 1), this.states.push(t), this.states.length > Si.MAX_LENGTH && this.states.shift(), this.currentIndex = this.states.length - 1;
  }
  go(t) {
    return this.currentIndex = Math.min(Math.max(this.currentIndex + t, 0), this.states.length - 1), this.currentState;
  }
  undo() {
    return this.go(-1);
  }
  redo() {
    return this.go(1);
  }
  clear() {
    this.states.length = 0, this.currentIndex = 0;
  }
}
Si.MAX_LENGTH = 100;
class Ox {
  /**
    View element
  */
  /** Internal {@link Masked} model */
  constructor(t, e) {
    this.el = t instanceof ul ? t : t.isContentEditable && t.tagName !== "INPUT" && t.tagName !== "TEXTAREA" ? new lp(t) : new Cx(t), this.masked = Me(e), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._rawInputValue = "", this.history = new Si(), this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this._onUndo = this._onUndo.bind(this), this._onRedo = this._onRedo.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange();
  }
  maskEquals(t) {
    var e;
    return t == null || ((e = this.masked) == null ? void 0 : e.maskEquals(t));
  }
  /** Masked */
  get mask() {
    return this.masked.mask;
  }
  set mask(t) {
    if (this.maskEquals(t)) return;
    if (!(t instanceof ot.Masked) && this.masked.constructor === ap(t)) {
      this.masked.updateOptions({
        mask: t
      });
      return;
    }
    const e = t instanceof ot.Masked ? t : Me({
      mask: t
    });
    e.unmaskedValue = this.masked.unmaskedValue, this.masked = e;
  }
  /** Raw value */
  get value() {
    return this._value;
  }
  set value(t) {
    this.value !== t && (this.masked.value = t, this.updateControl("auto"));
  }
  /** Unmasked value */
  get unmaskedValue() {
    return this._unmaskedValue;
  }
  set unmaskedValue(t) {
    this.unmaskedValue !== t && (this.masked.unmaskedValue = t, this.updateControl("auto"));
  }
  /** Raw input value */
  get rawInputValue() {
    return this._rawInputValue;
  }
  set rawInputValue(t) {
    this.rawInputValue !== t && (this.masked.rawInputValue = t, this.updateControl(), this.alignCursor());
  }
  /** Typed unmasked value */
  get typedValue() {
    return this.masked.typedValue;
  }
  set typedValue(t) {
    this.masked.typedValueEquals(t) || (this.masked.typedValue = t, this.updateControl("auto"));
  }
  /** Display value */
  get displayValue() {
    return this.masked.displayValue;
  }
  /** Starts listening to element events */
  _bindEvents() {
    this.el.bindEvents({
      selectionChange: this._saveSelection,
      input: this._onInput,
      drop: this._onDrop,
      click: this._onClick,
      focus: this._onFocus,
      commit: this._onChange,
      undo: this._onUndo,
      redo: this._onRedo
    });
  }
  /** Stops listening to element events */
  _unbindEvents() {
    this.el && this.el.unbindEvents();
  }
  /** Fires custom event */
  _fireEvent(t, e) {
    const s = this._listeners[t];
    s && s.forEach((n) => n(e));
  }
  /** Current selection start */
  get selectionStart() {
    return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
  }
  /** Current cursor position */
  get cursorPos() {
    return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
  }
  set cursorPos(t) {
    !this.el || !this.el.isActive || (this.el.select(t, t), this._saveSelection());
  }
  /** Stores current selection */
  _saveSelection() {
    this.displayValue !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = {
      start: this.selectionStart,
      end: this.cursorPos
    };
  }
  /** Syncronizes model value from view */
  updateValue() {
    this.masked.value = this.el.value, this._value = this.masked.value, this._unmaskedValue = this.masked.unmaskedValue, this._rawInputValue = this.masked.rawInputValue;
  }
  /** Syncronizes view from model value, fires change events */
  updateControl(t) {
    const e = this.masked.unmaskedValue, s = this.masked.value, n = this.masked.rawInputValue, i = this.displayValue, o = this.unmaskedValue !== e || this.value !== s || this._rawInputValue !== n;
    this._unmaskedValue = e, this._value = s, this._rawInputValue = n, this.el.value !== i && (this.el.value = i), t === "auto" ? this.alignCursor() : t != null && (this.cursorPos = t), o && this._fireChangeEvents(), !this._historyChanging && (o || this.history.isEmpty) && this.history.push({
      unmaskedValue: e,
      selection: {
        start: this.selectionStart,
        end: this.cursorPos
      }
    });
  }
  /** Updates options with deep equal check, recreates {@link Masked} model if mask type changes */
  updateOptions(t) {
    const {
      mask: e,
      ...s
    } = t, n = !this.maskEquals(e), i = this.masked.optionsIsChanged(s);
    n && (this.mask = e), i && this.masked.updateOptions(s), (n || i) && this.updateControl();
  }
  /** Updates cursor */
  updateCursor(t) {
    t != null && (this.cursorPos = t, this._delayUpdateCursor(t));
  }
  /** Delays cursor update to support mobile browsers */
  _delayUpdateCursor(t) {
    this._abortUpdateCursor(), this._changingCursorPos = t, this._cursorChanging = setTimeout(() => {
      this.el && (this.cursorPos = this._changingCursorPos, this._abortUpdateCursor());
    }, 10);
  }
  /** Fires custom events */
  _fireChangeEvents() {
    this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent);
  }
  /** Aborts delayed cursor update */
  _abortUpdateCursor() {
    this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging);
  }
  /** Aligns cursor to nearest available position */
  alignCursor() {
    this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, nt.LEFT));
  }
  /** Aligns cursor only if selection is empty */
  alignCursorFriendly() {
    this.selectionStart === this.cursorPos && this.alignCursor();
  }
  /** Adds listener on custom event */
  on(t, e) {
    return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), this;
  }
  /** Removes custom event listener */
  off(t, e) {
    if (!this._listeners[t]) return this;
    if (!e)
      return delete this._listeners[t], this;
    const s = this._listeners[t].indexOf(e);
    return s >= 0 && this._listeners[t].splice(s, 1), this;
  }
  /** Handles view input event */
  _onInput(t) {
    this._inputEvent = t, this._abortUpdateCursor();
    const e = new Nx({
      // new state
      value: this.el.value,
      cursorPos: this.cursorPos,
      // old state
      oldValue: this.displayValue,
      oldSelection: this._selection
    }), s = this.masked.rawInputValue, n = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection, {
      input: !0,
      raw: !0
    }).offset, i = s === this.masked.rawInputValue ? e.removeDirection : nt.NONE;
    let o = this.masked.nearestInputPos(e.startChangePos + n, i);
    i !== nt.NONE && (o = this.masked.nearestInputPos(o, nt.NONE)), this.updateControl(o), delete this._inputEvent;
  }
  /** Handles view change event and commits model value */
  _onChange() {
    this.displayValue !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection();
  }
  /** Handles view drop event, prevents by default */
  _onDrop(t) {
    t.preventDefault(), t.stopPropagation();
  }
  /** Restore last selection on focus */
  _onFocus(t) {
    this.alignCursorFriendly();
  }
  /** Restore last selection on focus */
  _onClick(t) {
    this.alignCursorFriendly();
  }
  _onUndo() {
    this._applyHistoryState(this.history.undo());
  }
  _onRedo() {
    this._applyHistoryState(this.history.redo());
  }
  _applyHistoryState(t) {
    t && (this._historyChanging = !0, this.unmaskedValue = t.unmaskedValue, this.el.select(t.selection.start, t.selection.end), this._saveSelection(), this._historyChanging = !1);
  }
  /** Unbind view events and removes element reference */
  destroy() {
    this._unbindEvents(), this._listeners.length = 0, delete this.el;
  }
}
ot.InputMask = Ox;
class dt {
  /** Inserted symbols */
  /** Additional offset if any changes occurred before tail */
  /** Raw inserted is used by dynamic mask */
  /** Can skip chars */
  static normalize(t) {
    return Array.isArray(t) ? t : [t, new dt()];
  }
  constructor(t) {
    Object.assign(this, {
      inserted: "",
      rawInserted: "",
      tailShift: 0,
      skip: !1
    }, t);
  }
  /** Aggregate changes */
  aggregate(t) {
    return this.inserted += t.inserted, this.rawInserted += t.rawInserted, this.tailShift += t.tailShift, this.skip = this.skip || t.skip, this;
  }
  /** Total offset considering all changes */
  get offset() {
    return this.tailShift + this.inserted.length;
  }
  get consumed() {
    return !!this.rawInserted || this.skip;
  }
  equals(t) {
    return this.inserted === t.inserted && this.tailShift === t.tailShift && this.rawInserted === t.rawInserted && this.skip === t.skip;
  }
}
ot.ChangeDetails = dt;
class ye {
  /** Tail value as string */
  /** Tail start position */
  /** Start position */
  constructor(t, e, s) {
    t === void 0 && (t = ""), e === void 0 && (e = 0), this.value = t, this.from = e, this.stop = s;
  }
  toString() {
    return this.value;
  }
  extend(t) {
    this.value += String(t);
  }
  appendTo(t) {
    return t.append(this.toString(), {
      tail: !0
    }).aggregate(t._appendPlaceholder());
  }
  get state() {
    return {
      value: this.value,
      from: this.from,
      stop: this.stop
    };
  }
  set state(t) {
    Object.assign(this, t);
  }
  unshift(t) {
    if (!this.value.length || t != null && this.from >= t) return "";
    const e = this.value[0];
    return this.value = this.value.slice(1), e;
  }
  shift() {
    if (!this.value.length) return "";
    const t = this.value[this.value.length - 1];
    return this.value = this.value.slice(0, -1), t;
  }
}
class Ut {
  /** */
  /** */
  /** Transforms value before mask processing */
  /** Transforms each char before mask processing */
  /** Validates if value is acceptable */
  /** Does additional processing at the end of editing */
  /** Format typed value to string */
  /** Parse string to get typed value */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  /** */
  constructor(t) {
    this._value = "", this._update({
      ...Ut.DEFAULTS,
      ...t
    }), this._initialized = !0;
  }
  /** Sets and applies new options */
  updateOptions(t) {
    this.optionsIsChanged(t) && this.withValueRefresh(this._update.bind(this, t));
  }
  /** Sets new options */
  _update(t) {
    Object.assign(this, t);
  }
  /** Mask state */
  get state() {
    return {
      _value: this.value,
      _rawInputValue: this.rawInputValue
    };
  }
  set state(t) {
    this._value = t._value;
  }
  /** Resets value */
  reset() {
    this._value = "";
  }
  get value() {
    return this._value;
  }
  set value(t) {
    this.resolve(t, {
      input: !0
    });
  }
  /** Resolve new value */
  resolve(t, e) {
    e === void 0 && (e = {
      input: !0
    }), this.reset(), this.append(t, e, ""), this.doCommit();
  }
  get unmaskedValue() {
    return this.value;
  }
  set unmaskedValue(t) {
    this.resolve(t, {});
  }
  get typedValue() {
    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;
  }
  set typedValue(t) {
    this.format ? this.value = this.format(t, this) : this.unmaskedValue = String(t);
  }
  /** Value that includes raw user input */
  get rawInputValue() {
    return this.extractInput(0, this.displayValue.length, {
      raw: !0
    });
  }
  set rawInputValue(t) {
    this.resolve(t, {
      raw: !0
    });
  }
  get displayValue() {
    return this.value;
  }
  get isComplete() {
    return !0;
  }
  get isFilled() {
    return this.isComplete;
  }
  /** Finds nearest input position in direction */
  nearestInputPos(t, e) {
    return t;
  }
  totalInputPositions(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), Math.min(this.displayValue.length, e - t);
  }
  /** Extracts value in range considering flags */
  extractInput(t, e, s) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), this.displayValue.slice(t, e);
  }
  /** Extracts tail in range */
  extractTail(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), new ye(this.extractInput(t, e), t);
  }
  /** Appends tail */
  appendTail(t) {
    return Ze(t) && (t = new ye(String(t))), t.appendTo(this);
  }
  /** Appends char */
  _appendCharRaw(t, e) {
    return t ? (this._value += t, new dt({
      inserted: t,
      rawInserted: t
    })) : new dt();
  }
  /** Appends char */
  _appendChar(t, e, s) {
    e === void 0 && (e = {});
    const n = this.state;
    let i;
    if ([t, i] = this.doPrepareChar(t, e), t && (i = i.aggregate(this._appendCharRaw(t, e)), !i.rawInserted && this.autofix === "pad")) {
      const o = this.state;
      this.state = n;
      let a = this.pad(e);
      const l = this._appendCharRaw(t, e);
      a = a.aggregate(l), l.rawInserted || a.equals(i) ? i = a : this.state = o;
    }
    if (i.inserted) {
      let o, a = this.doValidate(e) !== !1;
      if (a && s != null) {
        const l = this.state;
        if (this.overwrite === !0) {
          o = s.state;
          for (let d = 0; d < i.rawInserted.length; ++d)
            s.unshift(this.displayValue.length - i.tailShift);
        }
        let c = this.appendTail(s);
        if (a = c.rawInserted.length === s.toString().length, !(a && c.inserted) && this.overwrite === "shift") {
          this.state = l, o = s.state;
          for (let d = 0; d < i.rawInserted.length; ++d)
            s.shift();
          c = this.appendTail(s), a = c.rawInserted.length === s.toString().length;
        }
        a && c.inserted && (this.state = l);
      }
      a || (i = new dt(), this.state = n, s && o && (s.state = o));
    }
    return i;
  }
  /** Appends optional placeholder at the end */
  _appendPlaceholder() {
    return new dt();
  }
  /** Appends optional eager placeholder at the end */
  _appendEager() {
    return new dt();
  }
  /** Appends symbols considering flags */
  append(t, e, s) {
    if (!Ze(t)) throw new Error("value should be string");
    const n = Ze(s) ? new ye(String(s)) : s;
    e != null && e.tail && (e._beforeTailState = this.state);
    let i;
    [t, i] = this.doPrepare(t, e);
    for (let o = 0; o < t.length; ++o) {
      const a = this._appendChar(t[o], e, n);
      if (!a.rawInserted && !this.doSkipInvalid(t[o], e, n)) break;
      i.aggregate(a);
    }
    return (this.eager === !0 || this.eager === "append") && e != null && e.input && t && i.aggregate(this._appendEager()), n != null && (i.tailShift += this.appendTail(n).tailShift), i;
  }
  remove(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), this._value = this.displayValue.slice(0, t) + this.displayValue.slice(e), new dt();
  }
  /** Calls function and reapplies current value */
  withValueRefresh(t) {
    if (this._refreshing || !this._initialized) return t();
    this._refreshing = !0;
    const e = this.rawInputValue, s = this.value, n = t();
    return this.rawInputValue = e, this.value && this.value !== s && s.indexOf(this.value) === 0 && (this.append(s.slice(this.displayValue.length), {}, ""), this.doCommit()), delete this._refreshing, n;
  }
  runIsolated(t) {
    if (this._isolated || !this._initialized) return t(this);
    this._isolated = !0;
    const e = this.state, s = t(this);
    return this.state = e, delete this._isolated, s;
  }
  doSkipInvalid(t, e, s) {
    return !!this.skipInvalid;
  }
  /** Prepares string before mask processing */
  doPrepare(t, e) {
    return e === void 0 && (e = {}), dt.normalize(this.prepare ? this.prepare(t, this, e) : t);
  }
  /** Prepares each char before mask processing */
  doPrepareChar(t, e) {
    return e === void 0 && (e = {}), dt.normalize(this.prepareChar ? this.prepareChar(t, this, e) : t);
  }
  /** Validates if value is acceptable */
  doValidate(t) {
    return (!this.validate || this.validate(this.value, this, t)) && (!this.parent || this.parent.doValidate(t));
  }
  /** Does additional processing at the end of editing */
  doCommit() {
    this.commit && this.commit(this.value, this);
  }
  splice(t, e, s, n, i) {
    s === void 0 && (s = ""), n === void 0 && (n = nt.NONE), i === void 0 && (i = {
      input: !0
    });
    const o = t + e, a = this.extractTail(o), l = this.eager === !0 || this.eager === "remove";
    let c;
    l && (n = Ax(n), c = this.extractInput(0, o, {
      raw: !0
    }));
    let d = t;
    const g = new dt();
    if (n !== nt.NONE && (d = this.nearestInputPos(t, e > 1 && t !== 0 && !l ? nt.NONE : n), g.tailShift = d - t), g.aggregate(this.remove(d)), l && n !== nt.NONE && c === this.rawInputValue)
      if (n === nt.FORCE_LEFT) {
        let h;
        for (; c === this.rawInputValue && (h = this.displayValue.length); )
          g.aggregate(new dt({
            tailShift: -1
          })).aggregate(this.remove(h - 1));
      } else n === nt.FORCE_RIGHT && a.unshift();
    return g.aggregate(this.append(s, i, a));
  }
  maskEquals(t) {
    return this.mask === t;
  }
  optionsIsChanged(t) {
    return !Jn(this, t);
  }
  typedValueEquals(t) {
    const e = this.typedValue;
    return t === e || Ut.EMPTY_VALUES.includes(t) && Ut.EMPTY_VALUES.includes(e) || (this.format ? this.format(t, this) === this.format(this.typedValue, this) : !1);
  }
  pad(t) {
    return new dt();
  }
}
Ut.DEFAULTS = {
  skipInvalid: !0
};
Ut.EMPTY_VALUES = [void 0, null, ""];
ot.Masked = Ut;
class pr {
  /** */
  constructor(t, e) {
    t === void 0 && (t = []), e === void 0 && (e = 0), this.chunks = t, this.from = e;
  }
  toString() {
    return this.chunks.map(String).join("");
  }
  extend(t) {
    if (!String(t)) return;
    t = Ze(t) ? new ye(String(t)) : t;
    const e = this.chunks[this.chunks.length - 1], s = e && // if stops are same or tail has no stop
    (e.stop === t.stop || t.stop == null) && // if tail chunk goes just after last chunk
    t.from === e.from + e.toString().length;
    if (t instanceof ye)
      s ? e.extend(t.toString()) : this.chunks.push(t);
    else if (t instanceof pr) {
      if (t.stop == null) {
        let n;
        for (; t.chunks.length && t.chunks[0].stop == null; )
          n = t.chunks.shift(), n.from += t.from, this.extend(n);
      }
      t.toString() && (t.stop = t.blockIndex, this.chunks.push(t));
    }
  }
  appendTo(t) {
    if (!(t instanceof ot.MaskedPattern))
      return new ye(this.toString()).appendTo(t);
    const e = new dt();
    for (let s = 0; s < this.chunks.length; ++s) {
      const n = this.chunks[s], i = t._mapPosToBlock(t.displayValue.length), o = n.stop;
      let a;
      if (o != null && // if block not found or stop is behind lastBlock
      (!i || i.index <= o) && ((n instanceof pr || // for continuous block also check if stop is exist
      t._stops.indexOf(o) >= 0) && e.aggregate(t._appendPlaceholder(o)), a = n instanceof pr && t._blocks[o]), a) {
        const l = a.appendTail(n);
        e.aggregate(l);
        const c = n.toString().slice(l.rawInserted.length);
        c && e.aggregate(t.append(c, {
          tail: !0
        }));
      } else
        e.aggregate(t.append(n.toString(), {
          tail: !0
        }));
    }
    return e;
  }
  get state() {
    return {
      chunks: this.chunks.map((t) => t.state),
      from: this.from,
      stop: this.stop,
      blockIndex: this.blockIndex
    };
  }
  set state(t) {
    const {
      chunks: e,
      ...s
    } = t;
    Object.assign(this, s), this.chunks = e.map((n) => {
      const i = "chunks" in n ? new pr() : new ye();
      return i.state = n, i;
    });
  }
  unshift(t) {
    if (!this.chunks.length || t != null && this.from >= t) return "";
    const e = t != null ? t - this.from : t;
    let s = 0;
    for (; s < this.chunks.length; ) {
      const n = this.chunks[s], i = n.unshift(e);
      if (n.toString()) {
        if (!i) break;
        ++s;
      } else
        this.chunks.splice(s, 1);
      if (i) return i;
    }
    return "";
  }
  shift() {
    if (!this.chunks.length) return "";
    let t = this.chunks.length - 1;
    for (; 0 <= t; ) {
      const e = this.chunks[t], s = e.shift();
      if (e.toString()) {
        if (!s) break;
        --t;
      } else
        this.chunks.splice(t, 1);
      if (s) return s;
    }
    return "";
  }
}
class Tx {
  constructor(t, e) {
    this.masked = t, this._log = [];
    const {
      offset: s,
      index: n
    } = t._mapPosToBlock(e) || (e < 0 ? (
      // first
      {
        index: 0,
        offset: 0
      }
    ) : (
      // last
      {
        index: this.masked._blocks.length,
        offset: 0
      }
    ));
    this.offset = s, this.index = n, this.ok = !1;
  }
  get block() {
    return this.masked._blocks[this.index];
  }
  get pos() {
    return this.masked._blockStartPos(this.index) + this.offset;
  }
  get state() {
    return {
      index: this.index,
      offset: this.offset,
      ok: this.ok
    };
  }
  set state(t) {
    Object.assign(this, t);
  }
  pushState() {
    this._log.push(this.state);
  }
  popState() {
    const t = this._log.pop();
    return t && (this.state = t), t;
  }
  bindBlock() {
    this.block || (this.index < 0 && (this.index = 0, this.offset = 0), this.index >= this.masked._blocks.length && (this.index = this.masked._blocks.length - 1, this.offset = this.block.displayValue.length));
  }
  _pushLeft(t) {
    for (this.pushState(), this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((e = this.block) == null ? void 0 : e.displayValue.length) || 0) {
      var e;
      if (t()) return this.ok = !0;
    }
    return this.ok = !1;
  }
  _pushRight(t) {
    for (this.pushState(), this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0)
      if (t()) return this.ok = !0;
    return this.ok = !1;
  }
  pushLeftBeforeFilled() {
    return this._pushLeft(() => {
      if (!(this.block.isFixed || !this.block.value) && (this.offset = this.block.nearestInputPos(this.offset, nt.FORCE_LEFT), this.offset !== 0))
        return !0;
    });
  }
  pushLeftBeforeInput() {
    return this._pushLeft(() => {
      if (!this.block.isFixed)
        return this.offset = this.block.nearestInputPos(this.offset, nt.LEFT), !0;
    });
  }
  pushLeftBeforeRequired() {
    return this._pushLeft(() => {
      if (!(this.block.isFixed || this.block.isOptional && !this.block.value))
        return this.offset = this.block.nearestInputPos(this.offset, nt.LEFT), !0;
    });
  }
  pushRightBeforeFilled() {
    return this._pushRight(() => {
      if (!(this.block.isFixed || !this.block.value) && (this.offset = this.block.nearestInputPos(this.offset, nt.FORCE_RIGHT), this.offset !== this.block.value.length))
        return !0;
    });
  }
  pushRightBeforeInput() {
    return this._pushRight(() => {
      if (!this.block.isFixed)
        return this.offset = this.block.nearestInputPos(this.offset, nt.NONE), !0;
    });
  }
  pushRightBeforeRequired() {
    return this._pushRight(() => {
      if (!(this.block.isFixed || this.block.isOptional && !this.block.value))
        return this.offset = this.block.nearestInputPos(this.offset, nt.NONE), !0;
    });
  }
}
class up {
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  constructor(t) {
    Object.assign(this, t), this._value = "", this.isFixed = !0;
  }
  get value() {
    return this._value;
  }
  get unmaskedValue() {
    return this.isUnmasking ? this.value : "";
  }
  get rawInputValue() {
    return this._isRawInput ? this.value : "";
  }
  get displayValue() {
    return this.value;
  }
  reset() {
    this._isRawInput = !1, this._value = "";
  }
  remove(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this._value.length), this._value = this._value.slice(0, t) + this._value.slice(e), this._value || (this._isRawInput = !1), new dt();
  }
  nearestInputPos(t, e) {
    e === void 0 && (e = nt.NONE);
    const s = 0, n = this._value.length;
    switch (e) {
      case nt.LEFT:
      case nt.FORCE_LEFT:
        return s;
      case nt.NONE:
      case nt.RIGHT:
      case nt.FORCE_RIGHT:
      default:
        return n;
    }
  }
  totalInputPositions(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this._value.length), this._isRawInput ? e - t : 0;
  }
  extractInput(t, e, s) {
    return t === void 0 && (t = 0), e === void 0 && (e = this._value.length), s === void 0 && (s = {}), s.raw && this._isRawInput && this._value.slice(t, e) || "";
  }
  get isComplete() {
    return !0;
  }
  get isFilled() {
    return !!this._value;
  }
  _appendChar(t, e) {
    if (e === void 0 && (e = {}), this.isFilled) return new dt();
    const s = this.eager === !0 || this.eager === "append", n = this.char === t && (this.isUnmasking || e.input || e.raw) && (!e.raw || !s) && !e.tail, i = new dt({
      inserted: this.char,
      rawInserted: n ? this.char : ""
    });
    return this._value = this.char, this._isRawInput = n && (e.raw || e.input), i;
  }
  _appendEager() {
    return this._appendChar(this.char, {
      tail: !0
    });
  }
  _appendPlaceholder() {
    const t = new dt();
    return this.isFilled || (this._value = t.inserted = this.char), t;
  }
  extractTail() {
    return new ye("");
  }
  appendTail(t) {
    return Ze(t) && (t = new ye(String(t))), t.appendTo(this);
  }
  append(t, e, s) {
    const n = this._appendChar(t[0], e);
    return s != null && (n.tailShift += this.appendTail(s).tailShift), n;
  }
  doCommit() {
  }
  get state() {
    return {
      _value: this._value,
      _rawInputValue: this.rawInputValue
    };
  }
  set state(t) {
    this._value = t._value, this._isRawInput = !!t._rawInputValue;
  }
  pad(t) {
    return this._appendPlaceholder();
  }
}
class Qn {
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  constructor(t) {
    const {
      parent: e,
      isOptional: s,
      placeholderChar: n,
      displayChar: i,
      lazy: o,
      eager: a,
      ...l
    } = t;
    this.masked = Me(l), Object.assign(this, {
      parent: e,
      isOptional: s,
      placeholderChar: n,
      displayChar: i,
      lazy: o,
      eager: a
    });
  }
  reset() {
    this.isFilled = !1, this.masked.reset();
  }
  remove(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.value.length), t === 0 && e >= 1 ? (this.isFilled = !1, this.masked.remove(t, e)) : new dt();
  }
  get value() {
    return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
  }
  get unmaskedValue() {
    return this.masked.unmaskedValue;
  }
  get rawInputValue() {
    return this.masked.rawInputValue;
  }
  get displayValue() {
    return this.masked.value && this.displayChar || this.value;
  }
  get isComplete() {
    return !!this.masked.value || this.isOptional;
  }
  _appendChar(t, e) {
    if (e === void 0 && (e = {}), this.isFilled) return new dt();
    const s = this.masked.state;
    let n = this.masked._appendChar(t, this.currentMaskFlags(e));
    return n.inserted && this.doValidate(e) === !1 && (n = new dt(), this.masked.state = s), !n.inserted && !this.isOptional && !this.lazy && !e.input && (n.inserted = this.placeholderChar), n.skip = !n.inserted && !this.isOptional, this.isFilled = !!n.inserted, n;
  }
  append(t, e, s) {
    return this.masked.append(t, this.currentMaskFlags(e), s);
  }
  _appendPlaceholder() {
    return this.isFilled || this.isOptional ? new dt() : (this.isFilled = !0, new dt({
      inserted: this.placeholderChar
    }));
  }
  _appendEager() {
    return new dt();
  }
  extractTail(t, e) {
    return this.masked.extractTail(t, e);
  }
  appendTail(t) {
    return this.masked.appendTail(t);
  }
  extractInput(t, e, s) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.value.length), this.masked.extractInput(t, e, s);
  }
  nearestInputPos(t, e) {
    e === void 0 && (e = nt.NONE);
    const s = 0, n = this.value.length, i = Math.min(Math.max(t, s), n);
    switch (e) {
      case nt.LEFT:
      case nt.FORCE_LEFT:
        return this.isComplete ? i : s;
      case nt.RIGHT:
      case nt.FORCE_RIGHT:
        return this.isComplete ? i : n;
      case nt.NONE:
      default:
        return i;
    }
  }
  totalInputPositions(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.value.length), this.value.slice(t, e).length;
  }
  doValidate(t) {
    return this.masked.doValidate(this.currentMaskFlags(t)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(t)));
  }
  doCommit() {
    this.masked.doCommit();
  }
  get state() {
    return {
      _value: this.value,
      _rawInputValue: this.rawInputValue,
      masked: this.masked.state,
      isFilled: this.isFilled
    };
  }
  set state(t) {
    this.masked.state = t.masked, this.isFilled = t.isFilled;
  }
  currentMaskFlags(t) {
    var e;
    return {
      ...t,
      _beforeTailState: (t == null || (e = t._beforeTailState) == null ? void 0 : e.masked) || (t == null ? void 0 : t._beforeTailState)
    };
  }
  pad(t) {
    return new dt();
  }
}
Qn.DEFAULT_DEFINITIONS = {
  0: /\d/,
  a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
  // http://stackoverflow.com/a/22075070
  "*": /./
};
class Rx extends Ut {
  /** */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    const e = t.mask;
    e && (t.validate = (s) => s.search(e) >= 0), super._update(t);
  }
}
ot.MaskedRegExp = Rx;
class $t extends Ut {
  /** */
  /** */
  /** Single char for empty input */
  /** Single char for filled input */
  /** Show placeholder only when needed */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  constructor(t) {
    super({
      ...$t.DEFAULTS,
      ...t,
      definitions: Object.assign({}, Qn.DEFAULT_DEFINITIONS, t == null ? void 0 : t.definitions)
    });
  }
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    t.definitions = Object.assign({}, this.definitions, t.definitions), super._update(t), this._rebuildMask();
  }
  _rebuildMask() {
    const t = this.definitions;
    this._blocks = [], this.exposeBlock = void 0, this._stops = [], this._maskedBlocks = {};
    const e = this.mask;
    if (!e || !t) return;
    let s = !1, n = !1;
    for (let i = 0; i < e.length; ++i) {
      if (this.blocks) {
        const c = e.slice(i), d = Object.keys(this.blocks).filter((h) => c.indexOf(h) === 0);
        d.sort((h, f) => f.length - h.length);
        const g = d[0];
        if (g) {
          const {
            expose: h,
            repeat: f,
            ...v
          } = $s(this.blocks[g]), m = {
            lazy: this.lazy,
            eager: this.eager,
            placeholderChar: this.placeholderChar,
            displayChar: this.displayChar,
            overwrite: this.overwrite,
            autofix: this.autofix,
            ...v,
            repeat: f,
            parent: this
          }, k = f != null ? new ot.RepeatBlock(
            m
            /* TODO */
          ) : Me(m);
          k && (this._blocks.push(k), h && (this.exposeBlock = k), this._maskedBlocks[g] || (this._maskedBlocks[g] = []), this._maskedBlocks[g].push(this._blocks.length - 1)), i += g.length - 1;
          continue;
        }
      }
      let o = e[i], a = o in t;
      if (o === $t.STOP_CHAR) {
        this._stops.push(this._blocks.length);
        continue;
      }
      if (o === "{" || o === "}") {
        s = !s;
        continue;
      }
      if (o === "[" || o === "]") {
        n = !n;
        continue;
      }
      if (o === $t.ESCAPE_CHAR) {
        if (++i, o = e[i], !o) break;
        a = !1;
      }
      const l = a ? new Qn({
        isOptional: n,
        lazy: this.lazy,
        eager: this.eager,
        placeholderChar: this.placeholderChar,
        displayChar: this.displayChar,
        ...$s(t[o]),
        parent: this
      }) : new up({
        char: o,
        eager: this.eager,
        isUnmasking: s
      });
      this._blocks.push(l);
    }
  }
  get state() {
    return {
      ...super.state,
      _blocks: this._blocks.map((t) => t.state)
    };
  }
  set state(t) {
    if (!t) {
      this.reset();
      return;
    }
    const {
      _blocks: e,
      ...s
    } = t;
    this._blocks.forEach((n, i) => n.state = e[i]), super.state = s;
  }
  reset() {
    super.reset(), this._blocks.forEach((t) => t.reset());
  }
  get isComplete() {
    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every((t) => t.isComplete);
  }
  get isFilled() {
    return this._blocks.every((t) => t.isFilled);
  }
  get isFixed() {
    return this._blocks.every((t) => t.isFixed);
  }
  get isOptional() {
    return this._blocks.every((t) => t.isOptional);
  }
  doCommit() {
    this._blocks.forEach((t) => t.doCommit()), super.doCommit();
  }
  get unmaskedValue() {
    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((t, e) => t += e.unmaskedValue, "");
  }
  set unmaskedValue(t) {
    if (this.exposeBlock) {
      const e = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.unmaskedValue = t, this.appendTail(e), this.doCommit();
    } else super.unmaskedValue = t;
  }
  get value() {
    return this.exposeBlock ? this.exposeBlock.value : (
      // TODO return _value when not in change?
      this._blocks.reduce((t, e) => t += e.value, "")
    );
  }
  set value(t) {
    if (this.exposeBlock) {
      const e = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.value = t, this.appendTail(e), this.doCommit();
    } else super.value = t;
  }
  get typedValue() {
    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;
  }
  set typedValue(t) {
    if (this.exposeBlock) {
      const e = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.typedValue = t, this.appendTail(e), this.doCommit();
    } else super.typedValue = t;
  }
  get displayValue() {
    return this._blocks.reduce((t, e) => t += e.displayValue, "");
  }
  appendTail(t) {
    return super.appendTail(t).aggregate(this._appendPlaceholder());
  }
  _appendEager() {
    var t;
    const e = new dt();
    let s = (t = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : t.index;
    if (s == null) return e;
    this._blocks[s].isFilled && ++s;
    for (let n = s; n < this._blocks.length; ++n) {
      const i = this._blocks[n]._appendEager();
      if (!i.inserted) break;
      e.aggregate(i);
    }
    return e;
  }
  _appendCharRaw(t, e) {
    e === void 0 && (e = {});
    const s = this._mapPosToBlock(this.displayValue.length), n = new dt();
    if (!s) return n;
    for (let o = s.index, a; a = this._blocks[o]; ++o) {
      var i;
      const l = a._appendChar(t, {
        ...e,
        _beforeTailState: (i = e._beforeTailState) == null || (i = i._blocks) == null ? void 0 : i[o]
      });
      if (n.aggregate(l), l.consumed) break;
    }
    return n;
  }
  extractTail(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length);
    const s = new pr();
    return t === e || this._forEachBlocksInRange(t, e, (n, i, o, a) => {
      const l = n.extractTail(o, a);
      l.stop = this._findStopBefore(i), l.from = this._blockStartPos(i), l instanceof pr && (l.blockIndex = i), s.extend(l);
    }), s;
  }
  extractInput(t, e, s) {
    if (t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), s === void 0 && (s = {}), t === e) return "";
    let n = "";
    return this._forEachBlocksInRange(t, e, (i, o, a, l) => {
      n += i.extractInput(a, l, s);
    }), n;
  }
  _findStopBefore(t) {
    let e;
    for (let s = 0; s < this._stops.length; ++s) {
      const n = this._stops[s];
      if (n <= t) e = n;
      else break;
    }
    return e;
  }
  /** Appends placeholder depending on laziness */
  _appendPlaceholder(t) {
    const e = new dt();
    if (this.lazy && t == null) return e;
    const s = this._mapPosToBlock(this.displayValue.length);
    if (!s) return e;
    const n = s.index, i = t ?? this._blocks.length;
    return this._blocks.slice(n, i).forEach((o) => {
      if (!o.lazy || t != null) {
        var a;
        e.aggregate(o._appendPlaceholder((a = o._blocks) == null ? void 0 : a.length));
      }
    }), e;
  }
  /** Finds block in pos */
  _mapPosToBlock(t) {
    let e = "";
    for (let s = 0; s < this._blocks.length; ++s) {
      const n = this._blocks[s], i = e.length;
      if (e += n.displayValue, t <= e.length)
        return {
          index: s,
          offset: t - i
        };
    }
  }
  _blockStartPos(t) {
    return this._blocks.slice(0, t).reduce((e, s) => e += s.displayValue.length, 0);
  }
  _forEachBlocksInRange(t, e, s) {
    e === void 0 && (e = this.displayValue.length);
    const n = this._mapPosToBlock(t);
    if (n) {
      const i = this._mapPosToBlock(e), o = i && n.index === i.index, a = n.offset, l = i && o ? i.offset : this._blocks[n.index].displayValue.length;
      if (s(this._blocks[n.index], n.index, a, l), i && !o) {
        for (let c = n.index + 1; c < i.index; ++c)
          s(this._blocks[c], c, 0, this._blocks[c].displayValue.length);
        s(this._blocks[i.index], i.index, 0, i.offset);
      }
    }
  }
  remove(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length);
    const s = super.remove(t, e);
    return this._forEachBlocksInRange(t, e, (n, i, o, a) => {
      s.aggregate(n.remove(o, a));
    }), s;
  }
  nearestInputPos(t, e) {
    if (e === void 0 && (e = nt.NONE), !this._blocks.length) return 0;
    const s = new Tx(this, t);
    if (e === nt.NONE)
      return s.pushRightBeforeInput() || (s.popState(), s.pushLeftBeforeInput()) ? s.pos : this.displayValue.length;
    if (e === nt.LEFT || e === nt.FORCE_LEFT) {
      if (e === nt.LEFT) {
        if (s.pushRightBeforeFilled(), s.ok && s.pos === t) return t;
        s.popState();
      }
      if (s.pushLeftBeforeInput(), s.pushLeftBeforeRequired(), s.pushLeftBeforeFilled(), e === nt.LEFT) {
        if (s.pushRightBeforeInput(), s.pushRightBeforeRequired(), s.ok && s.pos <= t || (s.popState(), s.ok && s.pos <= t)) return s.pos;
        s.popState();
      }
      return s.ok ? s.pos : e === nt.FORCE_LEFT ? 0 : (s.popState(), s.ok || (s.popState(), s.ok) ? s.pos : 0);
    }
    return e === nt.RIGHT || e === nt.FORCE_RIGHT ? (s.pushRightBeforeInput(), s.pushRightBeforeRequired(), s.pushRightBeforeFilled() ? s.pos : e === nt.FORCE_RIGHT ? this.displayValue.length : (s.popState(), s.ok || (s.popState(), s.ok) ? s.pos : this.nearestInputPos(t, nt.LEFT))) : t;
  }
  totalInputPositions(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length);
    let s = 0;
    return this._forEachBlocksInRange(t, e, (n, i, o, a) => {
      s += n.totalInputPositions(o, a);
    }), s;
  }
  /** Get block by name */
  maskedBlock(t) {
    return this.maskedBlocks(t)[0];
  }
  /** Get all blocks by name */
  maskedBlocks(t) {
    const e = this._maskedBlocks[t];
    return e ? e.map((s) => this._blocks[s]) : [];
  }
  pad(t) {
    const e = new dt();
    return this._forEachBlocksInRange(0, this.displayValue.length, (s) => e.aggregate(s.pad(t))), e;
  }
}
$t.DEFAULTS = {
  ...Ut.DEFAULTS,
  lazy: !0,
  placeholderChar: "_"
};
$t.STOP_CHAR = "`";
$t.ESCAPE_CHAR = "\\";
$t.InputDefinition = Qn;
$t.FixedDefinition = up;
ot.MaskedPattern = $t;
class $n extends $t {
  /**
    Optionally sets max length of pattern.
    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.
  */
  /** Min bound */
  /** Max bound */
  get _matchFrom() {
    return this.maxLength - String(this.from).length;
  }
  constructor(t) {
    super(t);
  }
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    const {
      to: e = this.to || 0,
      from: s = this.from || 0,
      maxLength: n = this.maxLength || 0,
      autofix: i = this.autofix,
      ...o
    } = t;
    this.to = e, this.from = s, this.maxLength = Math.max(String(e).length, n), this.autofix = i;
    const a = String(this.from).padStart(this.maxLength, "0"), l = String(this.to).padStart(this.maxLength, "0");
    let c = 0;
    for (; c < l.length && l[c] === a[c]; ) ++c;
    o.mask = l.slice(0, c).replace(/0/g, "\\0") + "0".repeat(this.maxLength - c), super._update(o);
  }
  get isComplete() {
    return super.isComplete && !!this.value;
  }
  boundaries(t) {
    let e = "", s = "";
    const [, n, i] = t.match(/^(\D*)(\d*)(\D*)/) || [];
    return i && (e = "0".repeat(n.length) + i, s = "9".repeat(n.length) + i), e = e.padEnd(this.maxLength, "0"), s = s.padEnd(this.maxLength, "9"), [e, s];
  }
  doPrepareChar(t, e) {
    e === void 0 && (e = {});
    let s;
    return [t, s] = super.doPrepareChar(t.replace(/\D/g, ""), e), t || (s.skip = !this.isComplete), [t, s];
  }
  _appendCharRaw(t, e) {
    if (e === void 0 && (e = {}), !this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(t, e);
    const s = String(this.from).padStart(this.maxLength, "0"), n = String(this.to).padStart(this.maxLength, "0"), [i, o] = this.boundaries(this.value + t);
    return Number(o) < this.from ? super._appendCharRaw(s[this.value.length], e) : Number(i) > this.to ? !e.tail && this.autofix === "pad" && this.value.length + 1 < this.maxLength ? super._appendCharRaw(s[this.value.length], e).aggregate(this._appendCharRaw(t, e)) : super._appendCharRaw(n[this.value.length], e) : super._appendCharRaw(t, e);
  }
  doValidate(t) {
    const e = this.value;
    if (e.search(/[^0]/) === -1 && e.length <= this._matchFrom) return !0;
    const [s, n] = this.boundaries(e);
    return this.from <= Number(n) && Number(s) <= this.to && super.doValidate(t);
  }
  pad(t) {
    const e = new dt();
    if (this.value.length === this.maxLength) return e;
    const s = this.value, n = this.maxLength - this.value.length;
    if (n) {
      this.reset();
      for (let i = 0; i < n; ++i)
        e.aggregate(super._appendCharRaw("0", t));
      s.split("").forEach((i) => this._appendCharRaw(i));
    }
    return e;
  }
}
ot.MaskedRange = $n;
const Lx = "d{.}`m{.}`Y";
class Le extends $t {
  static extractPatternOptions(t) {
    const {
      mask: e,
      pattern: s,
      ...n
    } = t;
    return {
      ...n,
      mask: Ze(e) ? e : s
    };
  }
  /** Pattern mask for date according to {@link MaskedDate#format} */
  /** Start date */
  /** End date */
  /** Format typed value to string */
  /** Parse string to get typed value */
  constructor(t) {
    super(Le.extractPatternOptions({
      ...Le.DEFAULTS,
      ...t
    }));
  }
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    const {
      mask: e,
      pattern: s,
      blocks: n,
      ...i
    } = {
      ...Le.DEFAULTS,
      ...t
    }, o = Object.assign({}, Le.GET_DEFAULT_BLOCKS());
    t.min && (o.Y.from = t.min.getFullYear()), t.max && (o.Y.to = t.max.getFullYear()), t.min && t.max && o.Y.from === o.Y.to && (o.m.from = t.min.getMonth() + 1, o.m.to = t.max.getMonth() + 1, o.m.from === o.m.to && (o.d.from = t.min.getDate(), o.d.to = t.max.getDate())), Object.assign(o, this.blocks, n), super._update({
      ...i,
      mask: Ze(e) ? e : s,
      blocks: o
    });
  }
  doValidate(t) {
    const e = this.date;
    return super.doValidate(t) && (!this.isComplete || this.isDateExist(this.value) && e != null && (this.min == null || this.min <= e) && (this.max == null || e <= this.max));
  }
  /** Checks if date is exists */
  isDateExist(t) {
    return this.format(this.parse(t, this), this).indexOf(t) >= 0;
  }
  /** Parsed Date */
  get date() {
    return this.typedValue;
  }
  set date(t) {
    this.typedValue = t;
  }
  get typedValue() {
    return this.isComplete ? super.typedValue : null;
  }
  set typedValue(t) {
    super.typedValue = t;
  }
  maskEquals(t) {
    return t === Date || super.maskEquals(t);
  }
  optionsIsChanged(t) {
    return super.optionsIsChanged(Le.extractPatternOptions(t));
  }
}
Le.GET_DEFAULT_BLOCKS = () => ({
  d: {
    mask: $n,
    from: 1,
    to: 31,
    maxLength: 2
  },
  m: {
    mask: $n,
    from: 1,
    to: 12,
    maxLength: 2
  },
  Y: {
    mask: $n,
    from: 1900,
    to: 9999
  }
});
Le.DEFAULTS = {
  ...$t.DEFAULTS,
  mask: Date,
  pattern: Lx,
  format: (r, t) => {
    if (!r) return "";
    const e = String(r.getDate()).padStart(2, "0"), s = String(r.getMonth() + 1).padStart(2, "0"), n = r.getFullYear();
    return [e, s, n].join(".");
  },
  parse: (r, t) => {
    const [e, s, n] = r.split(".").map(Number);
    return new Date(n, s - 1, e);
  }
};
ot.MaskedDate = Le;
class Ci extends Ut {
  constructor(t) {
    super({
      ...Ci.DEFAULTS,
      ...t
    }), this.currentMask = void 0;
  }
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    super._update(t), "mask" in t && (this.exposeMask = void 0, this.compiledMasks = Array.isArray(t.mask) ? t.mask.map((e) => {
      const {
        expose: s,
        ...n
      } = $s(e), i = Me({
        overwrite: this._overwrite,
        eager: this._eager,
        skipInvalid: this._skipInvalid,
        ...n
      });
      return s && (this.exposeMask = i), i;
    }) : []);
  }
  _appendCharRaw(t, e) {
    e === void 0 && (e = {});
    const s = this._applyDispatch(t, e);
    return this.currentMask && s.aggregate(this.currentMask._appendChar(t, this.currentMaskFlags(e))), s;
  }
  _applyDispatch(t, e, s) {
    t === void 0 && (t = ""), e === void 0 && (e = {}), s === void 0 && (s = "");
    const n = e.tail && e._beforeTailState != null ? e._beforeTailState._value : this.value, i = this.rawInputValue, o = e.tail && e._beforeTailState != null ? e._beforeTailState._rawInputValue : i, a = i.slice(o.length), l = this.currentMask, c = new dt(), d = l == null ? void 0 : l.state;
    return this.currentMask = this.doDispatch(t, {
      ...e
    }, s), this.currentMask && (this.currentMask !== l ? (this.currentMask.reset(), o && (this.currentMask.append(o, {
      raw: !0
    }), c.tailShift = this.currentMask.value.length - n.length), a && (c.tailShift += this.currentMask.append(a, {
      raw: !0,
      tail: !0
    }).tailShift)) : d && (this.currentMask.state = d)), c;
  }
  _appendPlaceholder() {
    const t = this._applyDispatch();
    return this.currentMask && t.aggregate(this.currentMask._appendPlaceholder()), t;
  }
  _appendEager() {
    const t = this._applyDispatch();
    return this.currentMask && t.aggregate(this.currentMask._appendEager()), t;
  }
  appendTail(t) {
    const e = new dt();
    return t && e.aggregate(this._applyDispatch("", {}, t)), e.aggregate(this.currentMask ? this.currentMask.appendTail(t) : super.appendTail(t));
  }
  currentMaskFlags(t) {
    var e, s;
    return {
      ...t,
      _beforeTailState: ((e = t._beforeTailState) == null ? void 0 : e.currentMaskRef) === this.currentMask && ((s = t._beforeTailState) == null ? void 0 : s.currentMask) || t._beforeTailState
    };
  }
  doDispatch(t, e, s) {
    return e === void 0 && (e = {}), s === void 0 && (s = ""), this.dispatch(t, this, e, s);
  }
  doValidate(t) {
    return super.doValidate(t) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(t)));
  }
  doPrepare(t, e) {
    e === void 0 && (e = {});
    let [s, n] = super.doPrepare(t, e);
    if (this.currentMask) {
      let i;
      [s, i] = super.doPrepare(s, this.currentMaskFlags(e)), n = n.aggregate(i);
    }
    return [s, n];
  }
  doPrepareChar(t, e) {
    e === void 0 && (e = {});
    let [s, n] = super.doPrepareChar(t, e);
    if (this.currentMask) {
      let i;
      [s, i] = super.doPrepareChar(s, this.currentMaskFlags(e)), n = n.aggregate(i);
    }
    return [s, n];
  }
  reset() {
    var t;
    (t = this.currentMask) == null || t.reset(), this.compiledMasks.forEach((e) => e.reset());
  }
  get value() {
    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : "";
  }
  set value(t) {
    this.exposeMask ? (this.exposeMask.value = t, this.currentMask = this.exposeMask, this._applyDispatch()) : super.value = t;
  }
  get unmaskedValue() {
    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : "";
  }
  set unmaskedValue(t) {
    this.exposeMask ? (this.exposeMask.unmaskedValue = t, this.currentMask = this.exposeMask, this._applyDispatch()) : super.unmaskedValue = t;
  }
  get typedValue() {
    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : "";
  }
  set typedValue(t) {
    if (this.exposeMask) {
      this.exposeMask.typedValue = t, this.currentMask = this.exposeMask, this._applyDispatch();
      return;
    }
    let e = String(t);
    this.currentMask && (this.currentMask.typedValue = t, e = this.currentMask.unmaskedValue), this.unmaskedValue = e;
  }
  get displayValue() {
    return this.currentMask ? this.currentMask.displayValue : "";
  }
  get isComplete() {
    var t;
    return !!((t = this.currentMask) != null && t.isComplete);
  }
  get isFilled() {
    var t;
    return !!((t = this.currentMask) != null && t.isFilled);
  }
  remove(t, e) {
    const s = new dt();
    return this.currentMask && s.aggregate(this.currentMask.remove(t, e)).aggregate(this._applyDispatch()), s;
  }
  get state() {
    var t;
    return {
      ...super.state,
      _rawInputValue: this.rawInputValue,
      compiledMasks: this.compiledMasks.map((e) => e.state),
      currentMaskRef: this.currentMask,
      currentMask: (t = this.currentMask) == null ? void 0 : t.state
    };
  }
  set state(t) {
    const {
      compiledMasks: e,
      currentMaskRef: s,
      currentMask: n,
      ...i
    } = t;
    e && this.compiledMasks.forEach((o, a) => o.state = e[a]), s != null && (this.currentMask = s, this.currentMask.state = n), super.state = i;
  }
  extractInput(t, e, s) {
    return this.currentMask ? this.currentMask.extractInput(t, e, s) : "";
  }
  extractTail(t, e) {
    return this.currentMask ? this.currentMask.extractTail(t, e) : super.extractTail(t, e);
  }
  doCommit() {
    this.currentMask && this.currentMask.doCommit(), super.doCommit();
  }
  nearestInputPos(t, e) {
    return this.currentMask ? this.currentMask.nearestInputPos(t, e) : super.nearestInputPos(t, e);
  }
  get overwrite() {
    return this.currentMask ? this.currentMask.overwrite : this._overwrite;
  }
  set overwrite(t) {
    this._overwrite = t;
  }
  get eager() {
    return this.currentMask ? this.currentMask.eager : this._eager;
  }
  set eager(t) {
    this._eager = t;
  }
  get skipInvalid() {
    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;
  }
  set skipInvalid(t) {
    this._skipInvalid = t;
  }
  get autofix() {
    return this.currentMask ? this.currentMask.autofix : this._autofix;
  }
  set autofix(t) {
    this._autofix = t;
  }
  maskEquals(t) {
    return Array.isArray(t) ? this.compiledMasks.every((e, s) => {
      if (!t[s]) return;
      const {
        mask: n,
        ...i
      } = t[s];
      return Jn(e, i) && e.maskEquals(n);
    }) : super.maskEquals(t);
  }
  typedValueEquals(t) {
    var e;
    return !!((e = this.currentMask) != null && e.typedValueEquals(t));
  }
}
Ci.DEFAULTS = {
  ...Ut.DEFAULTS,
  dispatch: (r, t, e, s) => {
    if (!t.compiledMasks.length) return;
    const n = t.rawInputValue, i = t.compiledMasks.map((o, a) => {
      const l = t.currentMask === o, c = l ? o.displayValue.length : o.nearestInputPos(o.displayValue.length, nt.FORCE_LEFT);
      return o.rawInputValue !== n ? (o.reset(), o.append(n, {
        raw: !0
      })) : l || o.remove(c), o.append(r, t.currentMaskFlags(e)), o.appendTail(s), {
        index: a,
        weight: o.rawInputValue.length,
        totalInputPositions: o.totalInputPositions(0, Math.max(c, o.nearestInputPos(o.displayValue.length, nt.FORCE_LEFT)))
      };
    });
    return i.sort((o, a) => a.weight - o.weight || a.totalInputPositions - o.totalInputPositions), t.compiledMasks[i[0].index];
  }
};
ot.MaskedDynamic = Ci;
class Oi extends $t {
  constructor(t) {
    super({
      ...Oi.DEFAULTS,
      ...t
    });
  }
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    const {
      enum: e,
      ...s
    } = t;
    if (e) {
      const n = e.map((a) => a.length), i = Math.min(...n), o = Math.max(...n) - i;
      s.mask = "*".repeat(i), o && (s.mask += "[" + "*".repeat(o) + "]"), this.enum = e;
    }
    super._update(s);
  }
  _appendCharRaw(t, e) {
    e === void 0 && (e = {});
    const s = Math.min(this.nearestInputPos(0, nt.FORCE_RIGHT), this.value.length), n = this.enum.filter((i) => this.matchValue(i, this.unmaskedValue + t, s));
    if (n.length) {
      n.length === 1 && this._forEachBlocksInRange(0, this.value.length, (o, a) => {
        const l = n[0][a];
        a >= this.value.length || l === o.value || (o.reset(), o._appendChar(l, e));
      });
      const i = super._appendCharRaw(n[0][this.value.length], e);
      return n.length === 1 && n[0].slice(this.unmaskedValue.length).split("").forEach((o) => i.aggregate(super._appendCharRaw(o))), i;
    }
    return new dt({
      skip: !this.isComplete
    });
  }
  extractTail(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), new ye("", t);
  }
  remove(t, e) {
    if (t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), t === e) return new dt();
    const s = Math.min(super.nearestInputPos(0, nt.FORCE_RIGHT), this.value.length);
    let n;
    for (n = t; n >= 0 && !(this.enum.filter((o) => this.matchValue(o, this.value.slice(s, n), s)).length > 1); --n)
      ;
    const i = super.remove(n, e);
    return i.tailShift += n - t, i;
  }
  get isComplete() {
    return this.enum.indexOf(this.value) >= 0;
  }
}
Oi.DEFAULTS = {
  ...$t.DEFAULTS,
  matchValue: (r, t, e) => r.indexOf(t, e) === e
};
ot.MaskedEnum = Oi;
class Ix extends Ut {
  /** */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    super._update({
      ...t,
      validate: t.mask
    });
  }
}
ot.MaskedFunction = Ix;
var cp;
class Zt extends Ut {
  /** Single char */
  /** Single char */
  /** Array of single chars */
  /** */
  /** */
  /** Digits after point */
  /** Flag to remove leading and trailing zeros in the end of editing */
  /** Flag to pad trailing zeros after point in the end of editing */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  /** Format typed value to string */
  /** Parse string to get typed value */
  constructor(t) {
    super({
      ...Zt.DEFAULTS,
      ...t
    });
  }
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    super._update(t), this._updateRegExps();
  }
  _updateRegExps() {
    const t = "^" + (this.allowNegative ? "[+|\\-]?" : ""), e = "\\d*", s = (this.scale ? "(" + Bo(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
    this._numberRegExp = new RegExp(t + e + s), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(Bo).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp(Bo(this.thousandsSeparator), "g");
  }
  _removeThousandsSeparators(t) {
    return t.replace(this._thousandsSeparatorRegExp, "");
  }
  _insertThousandsSeparators(t) {
    const e = t.split(this.radix);
    return e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), e.join(this.radix);
  }
  doPrepareChar(t, e) {
    e === void 0 && (e = {});
    const [s, n] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && /*
      radix should be mapped when
      1) input is done from keyboard = flags.input && flags.raw
      2) unmasked value is set = !flags.input && !flags.raw
      and should not be mapped when
      1) value is set = flags.input && !flags.raw
      2) raw value is set = !flags.input && flags.raw
    */
    (e.input && e.raw || !e.input && !e.raw) ? t.replace(this._mapToRadixRegExp, this.radix) : t), e);
    return t && !s && (n.skip = !0), s && !this.allowPositive && !this.value && s !== "-" && n.aggregate(this._appendChar("-")), [s, n];
  }
  _separatorsCount(t, e) {
    e === void 0 && (e = !1);
    let s = 0;
    for (let n = 0; n < t; ++n)
      this._value.indexOf(this.thousandsSeparator, n) === n && (++s, e && (t += this.thousandsSeparator.length));
    return s;
  }
  _separatorsCountFromSlice(t) {
    return t === void 0 && (t = this._value), this._separatorsCount(this._removeThousandsSeparators(t).length, !0);
  }
  extractInput(t, e, s) {
    return t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), [t, e] = this._adjustRangeWithSeparators(t, e), this._removeThousandsSeparators(super.extractInput(t, e, s));
  }
  _appendCharRaw(t, e) {
    e === void 0 && (e = {});
    const s = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value, n = this._separatorsCountFromSlice(s);
    this._value = this._removeThousandsSeparators(this.value);
    const i = this._value;
    this._value += t;
    const o = this.number;
    let a = !isNaN(o), l = !1;
    if (a) {
      let h;
      this.min != null && this.min < 0 && this.number < this.min && (h = this.min), this.max != null && this.max > 0 && this.number > this.max && (h = this.max), h != null && (this.autofix ? (this._value = this.format(h, this).replace(Zt.UNMASKED_RADIX, this.radix), l || (l = i === this._value && !e.tail)) : a = !1), a && (a = !!this._value.match(this._numberRegExp));
    }
    let c;
    a ? c = new dt({
      inserted: this._value.slice(i.length),
      rawInserted: l ? "" : t,
      skip: l
    }) : (this._value = i, c = new dt()), this._value = this._insertThousandsSeparators(this._value);
    const d = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value, g = this._separatorsCountFromSlice(d);
    return c.tailShift += (g - n) * this.thousandsSeparator.length, c;
  }
  _findSeparatorAround(t) {
    if (this.thousandsSeparator) {
      const e = t - this.thousandsSeparator.length + 1, s = this.value.indexOf(this.thousandsSeparator, e);
      if (s <= t) return s;
    }
    return -1;
  }
  _adjustRangeWithSeparators(t, e) {
    const s = this._findSeparatorAround(t);
    s >= 0 && (t = s);
    const n = this._findSeparatorAround(e);
    return n >= 0 && (e = n + this.thousandsSeparator.length), [t, e];
  }
  remove(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length), [t, e] = this._adjustRangeWithSeparators(t, e);
    const s = this.value.slice(0, t), n = this.value.slice(e), i = this._separatorsCount(s.length);
    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(s + n));
    const o = this._separatorsCountFromSlice(s);
    return new dt({
      tailShift: (o - i) * this.thousandsSeparator.length
    });
  }
  nearestInputPos(t, e) {
    if (!this.thousandsSeparator) return t;
    switch (e) {
      case nt.NONE:
      case nt.LEFT:
      case nt.FORCE_LEFT: {
        const s = this._findSeparatorAround(t - 1);
        if (s >= 0) {
          const n = s + this.thousandsSeparator.length;
          if (t < n || this.value.length <= n || e === nt.FORCE_LEFT)
            return s;
        }
        break;
      }
      case nt.RIGHT:
      case nt.FORCE_RIGHT: {
        const s = this._findSeparatorAround(t);
        if (s >= 0)
          return s + this.thousandsSeparator.length;
      }
    }
    return t;
  }
  doCommit() {
    if (this.value) {
      const t = this.number;
      let e = t;
      this.min != null && (e = Math.max(e, this.min)), this.max != null && (e = Math.min(e, this.max)), e !== t && (this.unmaskedValue = this.format(e, this));
      let s = this.value;
      this.normalizeZeros && (s = this._normalizeZeros(s)), this.padFractionalZeros && this.scale > 0 && (s = this._padFractionalZeros(s)), this._value = s;
    }
    super.doCommit();
  }
  _normalizeZeros(t) {
    const e = this._removeThousandsSeparators(t).split(this.radix);
    return e[0] = e[0].replace(/^(\D*)(0*)(\d*)/, (s, n, i, o) => n + o), t.length && !/\d$/.test(e[0]) && (e[0] = e[0] + "0"), e.length > 1 && (e[1] = e[1].replace(/0*$/, ""), e[1].length || (e.length = 1)), this._insertThousandsSeparators(e.join(this.radix));
  }
  _padFractionalZeros(t) {
    if (!t) return t;
    const e = t.split(this.radix);
    return e.length < 2 && e.push(""), e[1] = e[1].padEnd(this.scale, "0"), e.join(this.radix);
  }
  doSkipInvalid(t, e, s) {
    e === void 0 && (e = {});
    const n = this.scale === 0 && t !== this.thousandsSeparator && (t === this.radix || t === Zt.UNMASKED_RADIX || this.mapToRadix.includes(t));
    return super.doSkipInvalid(t, e, s) && !n;
  }
  get unmaskedValue() {
    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, Zt.UNMASKED_RADIX);
  }
  set unmaskedValue(t) {
    super.unmaskedValue = t;
  }
  get typedValue() {
    return this.parse(this.unmaskedValue, this);
  }
  set typedValue(t) {
    this.rawInputValue = this.format(t, this).replace(Zt.UNMASKED_RADIX, this.radix);
  }
  /** Parsed Number */
  get number() {
    return this.typedValue;
  }
  set number(t) {
    this.typedValue = t;
  }
  get allowNegative() {
    return this.min != null && this.min < 0 || this.max != null && this.max < 0;
  }
  get allowPositive() {
    return this.min != null && this.min > 0 || this.max != null && this.max > 0;
  }
  typedValueEquals(t) {
    return (super.typedValueEquals(t) || Zt.EMPTY_VALUES.includes(t) && Zt.EMPTY_VALUES.includes(this.typedValue)) && !(t === 0 && this.value === "");
  }
}
cp = Zt;
Zt.UNMASKED_RADIX = ".";
Zt.EMPTY_VALUES = [...Ut.EMPTY_VALUES, 0];
Zt.DEFAULTS = {
  ...Ut.DEFAULTS,
  mask: Number,
  radix: ",",
  thousandsSeparator: "",
  mapToRadix: [cp.UNMASKED_RADIX],
  min: Number.MIN_SAFE_INTEGER,
  max: Number.MAX_SAFE_INTEGER,
  scale: 2,
  normalizeZeros: !0,
  padFractionalZeros: !1,
  parse: Number,
  format: (r) => r.toLocaleString("en-US", {
    useGrouping: !1,
    maximumFractionDigits: 20
  })
};
ot.MaskedNumber = Zt;
const Ca = {
  MASKED: "value",
  UNMASKED: "unmaskedValue",
  TYPED: "typedValue"
};
function hp(r, t, e) {
  t === void 0 && (t = Ca.MASKED), e === void 0 && (e = Ca.MASKED);
  const s = Me(r);
  return (n) => s.runIsolated((i) => (i[t] = n, i[e]));
}
function qx(r, t, e, s) {
  return hp(t, e, s)(r);
}
ot.PIPE_TYPE = Ca;
ot.createPipe = hp;
ot.pipe = qx;
class jx extends $t {
  get repeatFrom() {
    var t;
    return (t = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === 1 / 0 ? 0 : this.repeat) != null ? t : 0;
  }
  get repeatTo() {
    var t;
    return (t = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) != null ? t : 1 / 0;
  }
  constructor(t) {
    super(t);
  }
  updateOptions(t) {
    super.updateOptions(t);
  }
  _update(t) {
    var e, s, n;
    const {
      repeat: i,
      ...o
    } = $s(t);
    this._blockOpts = Object.assign({}, this._blockOpts, o);
    const a = Me(this._blockOpts);
    this.repeat = (e = (s = i ?? a.repeat) != null ? s : this.repeat) != null ? e : 1 / 0, super._update({
      mask: "m".repeat(Math.max(this.repeatTo === 1 / 0 && ((n = this._blocks) == null ? void 0 : n.length) || 0, this.repeatFrom)),
      blocks: {
        m: a
      },
      eager: a.eager,
      overwrite: a.overwrite,
      skipInvalid: a.skipInvalid,
      lazy: a.lazy,
      placeholderChar: a.placeholderChar,
      displayChar: a.displayChar
    });
  }
  _allocateBlock(t) {
    if (t < this._blocks.length) return this._blocks[t];
    if (this.repeatTo === 1 / 0 || this._blocks.length < this.repeatTo)
      return this._blocks.push(Me(this._blockOpts)), this.mask += "m", this._blocks[this._blocks.length - 1];
  }
  _appendCharRaw(t, e) {
    e === void 0 && (e = {});
    const s = new dt();
    for (
      let l = (n = (i = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : i.index) != null ? n : Math.max(this._blocks.length - 1, 0), c, d;
      // try to get a block or
      // try to allocate a new block if not allocated already
      c = (o = this._blocks[l]) != null ? o : d = !d && this._allocateBlock(l);
      ++l
    ) {
      var n, i, o, a;
      const g = c._appendChar(t, {
        ...e,
        _beforeTailState: (a = e._beforeTailState) == null || (a = a._blocks) == null ? void 0 : a[l]
      });
      if (g.skip && d) {
        this._blocks.pop(), this.mask = this.mask.slice(1);
        break;
      }
      if (s.aggregate(g), g.consumed) break;
    }
    return s;
  }
  _trimEmptyTail(t, e) {
    var s, n;
    t === void 0 && (t = 0);
    const i = Math.max(((s = this._mapPosToBlock(t)) == null ? void 0 : s.index) || 0, this.repeatFrom, 0);
    let o;
    e != null && (o = (n = this._mapPosToBlock(e)) == null ? void 0 : n.index), o == null && (o = this._blocks.length - 1);
    let a = 0;
    for (let l = o; i <= l && !this._blocks[l].unmaskedValue; --l, ++a)
      ;
    a && (this._blocks.splice(o - a + 1, a), this.mask = this.mask.slice(a));
  }
  reset() {
    super.reset(), this._trimEmptyTail();
  }
  remove(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = this.displayValue.length);
    const s = super.remove(t, e);
    return this._trimEmptyTail(t, e), s;
  }
  totalInputPositions(t, e) {
    return t === void 0 && (t = 0), e == null && this.repeatTo === 1 / 0 ? 1 / 0 : super.totalInputPositions(t, e);
  }
  get state() {
    return super.state;
  }
  set state(t) {
    this._blocks.length = t._blocks.length, this.mask = this.mask.slice(0, this._blocks.length), super.state = t;
  }
}
ot.RepeatBlock = jx;
try {
  globalThis.IMask = ot;
} catch {
}
var On = { exports: {} }, Do = { exports: {} }, vt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zu;
function Mx() {
  if (zu) return vt;
  zu = 1;
  var r = typeof Symbol == "function" && Symbol.for, t = r ? Symbol.for("react.element") : 60103, e = r ? Symbol.for("react.portal") : 60106, s = r ? Symbol.for("react.fragment") : 60107, n = r ? Symbol.for("react.strict_mode") : 60108, i = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, a = r ? Symbol.for("react.context") : 60110, l = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, d = r ? Symbol.for("react.forward_ref") : 60112, g = r ? Symbol.for("react.suspense") : 60113, h = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, v = r ? Symbol.for("react.lazy") : 60116, m = r ? Symbol.for("react.block") : 60121, k = r ? Symbol.for("react.fundamental") : 60117, _ = r ? Symbol.for("react.responder") : 60118, E = r ? Symbol.for("react.scope") : 60119;
  function N(A) {
    if (typeof A == "object" && A !== null) {
      var X = A.$$typeof;
      switch (X) {
        case t:
          switch (A = A.type, A) {
            case l:
            case c:
            case s:
            case i:
            case n:
            case g:
              return A;
            default:
              switch (A = A && A.$$typeof, A) {
                case a:
                case d:
                case v:
                case f:
                case o:
                  return A;
                default:
                  return X;
              }
          }
        case e:
          return X;
      }
    }
  }
  function q(A) {
    return N(A) === c;
  }
  return vt.AsyncMode = l, vt.ConcurrentMode = c, vt.ContextConsumer = a, vt.ContextProvider = o, vt.Element = t, vt.ForwardRef = d, vt.Fragment = s, vt.Lazy = v, vt.Memo = f, vt.Portal = e, vt.Profiler = i, vt.StrictMode = n, vt.Suspense = g, vt.isAsyncMode = function(A) {
    return q(A) || N(A) === l;
  }, vt.isConcurrentMode = q, vt.isContextConsumer = function(A) {
    return N(A) === a;
  }, vt.isContextProvider = function(A) {
    return N(A) === o;
  }, vt.isElement = function(A) {
    return typeof A == "object" && A !== null && A.$$typeof === t;
  }, vt.isForwardRef = function(A) {
    return N(A) === d;
  }, vt.isFragment = function(A) {
    return N(A) === s;
  }, vt.isLazy = function(A) {
    return N(A) === v;
  }, vt.isMemo = function(A) {
    return N(A) === f;
  }, vt.isPortal = function(A) {
    return N(A) === e;
  }, vt.isProfiler = function(A) {
    return N(A) === i;
  }, vt.isStrictMode = function(A) {
    return N(A) === n;
  }, vt.isSuspense = function(A) {
    return N(A) === g;
  }, vt.isValidElementType = function(A) {
    return typeof A == "string" || typeof A == "function" || A === s || A === c || A === i || A === n || A === g || A === h || typeof A == "object" && A !== null && (A.$$typeof === v || A.$$typeof === f || A.$$typeof === o || A.$$typeof === a || A.$$typeof === d || A.$$typeof === k || A.$$typeof === _ || A.$$typeof === E || A.$$typeof === m);
  }, vt.typeOf = N, vt;
}
var kt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hu;
function Bx() {
  return Hu || (Hu = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, t = r ? Symbol.for("react.element") : 60103, e = r ? Symbol.for("react.portal") : 60106, s = r ? Symbol.for("react.fragment") : 60107, n = r ? Symbol.for("react.strict_mode") : 60108, i = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, a = r ? Symbol.for("react.context") : 60110, l = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, d = r ? Symbol.for("react.forward_ref") : 60112, g = r ? Symbol.for("react.suspense") : 60113, h = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, v = r ? Symbol.for("react.lazy") : 60116, m = r ? Symbol.for("react.block") : 60121, k = r ? Symbol.for("react.fundamental") : 60117, _ = r ? Symbol.for("react.responder") : 60118, E = r ? Symbol.for("react.scope") : 60119;
    function N(T) {
      return typeof T == "string" || typeof T == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      T === s || T === c || T === i || T === n || T === g || T === h || typeof T == "object" && T !== null && (T.$$typeof === v || T.$$typeof === f || T.$$typeof === o || T.$$typeof === a || T.$$typeof === d || T.$$typeof === k || T.$$typeof === _ || T.$$typeof === E || T.$$typeof === m);
    }
    function q(T) {
      if (typeof T == "object" && T !== null) {
        var at = T.$$typeof;
        switch (at) {
          case t:
            var yt = T.type;
            switch (yt) {
              case l:
              case c:
              case s:
              case i:
              case n:
              case g:
                return yt;
              default:
                var At = yt && yt.$$typeof;
                switch (At) {
                  case a:
                  case d:
                  case v:
                  case f:
                  case o:
                    return At;
                  default:
                    return at;
                }
            }
          case e:
            return at;
        }
      }
    }
    var A = l, X = c, G = a, ct = o, mt = t, xt = d, b = s, M = v, x = f, $ = e, P = i, S = n, B = g, W = !1;
    function Z(T) {
      return W || (W = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), w(T) || q(T) === l;
    }
    function w(T) {
      return q(T) === c;
    }
    function L(T) {
      return q(T) === a;
    }
    function V(T) {
      return q(T) === o;
    }
    function K(T) {
      return typeof T == "object" && T !== null && T.$$typeof === t;
    }
    function z(T) {
      return q(T) === d;
    }
    function U(T) {
      return q(T) === s;
    }
    function Y(T) {
      return q(T) === v;
    }
    function j(T) {
      return q(T) === f;
    }
    function D(T) {
      return q(T) === e;
    }
    function H(T) {
      return q(T) === i;
    }
    function F(T) {
      return q(T) === n;
    }
    function J(T) {
      return q(T) === g;
    }
    kt.AsyncMode = A, kt.ConcurrentMode = X, kt.ContextConsumer = G, kt.ContextProvider = ct, kt.Element = mt, kt.ForwardRef = xt, kt.Fragment = b, kt.Lazy = M, kt.Memo = x, kt.Portal = $, kt.Profiler = P, kt.StrictMode = S, kt.Suspense = B, kt.isAsyncMode = Z, kt.isConcurrentMode = w, kt.isContextConsumer = L, kt.isContextProvider = V, kt.isElement = K, kt.isForwardRef = z, kt.isFragment = U, kt.isLazy = Y, kt.isMemo = j, kt.isPortal = D, kt.isProfiler = H, kt.isStrictMode = F, kt.isSuspense = J, kt.isValidElementType = N, kt.typeOf = q;
  }()), kt;
}
var Ku;
function dp() {
  return Ku || (Ku = 1, process.env.NODE_ENV === "production" ? Do.exports = Mx() : Do.exports = Bx()), Do.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Fo, Gu;
function Dx() {
  if (Gu) return Fo;
  Gu = 1;
  var r = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  function s(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function n() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(o).map(function(d) {
        return o[d];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        c[d] = d;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Fo = n() ? Object.assign : function(i, o) {
    for (var a, l = s(i), c, d = 1; d < arguments.length; d++) {
      a = Object(arguments[d]);
      for (var g in a)
        t.call(a, g) && (l[g] = a[g]);
      if (r) {
        c = r(a);
        for (var h = 0; h < c.length; h++)
          e.call(a, c[h]) && (l[c[h]] = a[c[h]]);
      }
    }
    return l;
  }, Fo;
}
var Po, Wu;
function cl() {
  if (Wu) return Po;
  Wu = 1;
  var r = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Po = r, Po;
}
var Zu, Xu;
function pp() {
  return Xu || (Xu = 1, Zu = Function.call.bind(Object.prototype.hasOwnProperty)), Zu;
}
var Vo, Yu;
function Fx() {
  if (Yu) return Vo;
  Yu = 1;
  var r = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = /* @__PURE__ */ cl(), e = {}, s = /* @__PURE__ */ pp();
    r = function(i) {
      var o = "Warning: " + i;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function n(i, o, a, l, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var d in i)
        if (s(i, d)) {
          var g;
          try {
            if (typeof i[d] != "function") {
              var h = Error(
                (l || "React class") + ": " + a + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw h.name = "Invariant Violation", h;
            }
            g = i[d](o, d, l, a, null, t);
          } catch (v) {
            g = v;
          }
          if (g && !(g instanceof Error) && r(
            (l || "React class") + ": type specification of " + a + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof g + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), g instanceof Error && !(g.message in e)) {
            e[g.message] = !0;
            var f = c ? c() : "";
            r(
              "Failed " + a + " type: " + g.message + (f ?? "")
            );
          }
        }
    }
  }
  return n.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (e = {});
  }, Vo = n, Vo;
}
var Uo, Ju;
function Px() {
  if (Ju) return Uo;
  Ju = 1;
  var r = dp(), t = Dx(), e = /* @__PURE__ */ cl(), s = /* @__PURE__ */ pp(), n = /* @__PURE__ */ Fx(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return Uo = function(a, l) {
    var c = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function g(w) {
      var L = w && (c && w[c] || w[d]);
      if (typeof L == "function")
        return L;
    }
    var h = "<<anonymous>>", f = {
      array: _("array"),
      bigint: _("bigint"),
      bool: _("boolean"),
      func: _("function"),
      number: _("number"),
      object: _("object"),
      string: _("string"),
      symbol: _("symbol"),
      any: E(),
      arrayOf: N,
      element: q(),
      elementType: A(),
      instanceOf: X,
      node: xt(),
      objectOf: ct,
      oneOf: G,
      oneOfType: mt,
      shape: M,
      exact: x
    };
    function v(w, L) {
      return w === L ? w !== 0 || 1 / w === 1 / L : w !== w && L !== L;
    }
    function m(w, L) {
      this.message = w, this.data = L && typeof L == "object" ? L : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function k(w) {
      if (process.env.NODE_ENV !== "production")
        var L = {}, V = 0;
      function K(U, Y, j, D, H, F, J) {
        if (D = D || h, F = F || j, J !== e) {
          if (l) {
            var T = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw T.name = "Invariant Violation", T;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var at = D + ":" + j;
            !L[at] && // Avoid spamming the console because they are often not actionable except for lib authors
            V < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + F + "` prop on `" + D + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), L[at] = !0, V++);
          }
        }
        return Y[j] == null ? U ? Y[j] === null ? new m("The " + H + " `" + F + "` is marked as required " + ("in `" + D + "`, but its value is `null`.")) : new m("The " + H + " `" + F + "` is marked as required in " + ("`" + D + "`, but its value is `undefined`.")) : null : w(Y, j, D, H, F);
      }
      var z = K.bind(null, !1);
      return z.isRequired = K.bind(null, !0), z;
    }
    function _(w) {
      function L(V, K, z, U, Y, j) {
        var D = V[K], H = S(D);
        if (H !== w) {
          var F = B(D);
          return new m(
            "Invalid " + U + " `" + Y + "` of type " + ("`" + F + "` supplied to `" + z + "`, expected ") + ("`" + w + "`."),
            { expectedType: w }
          );
        }
        return null;
      }
      return k(L);
    }
    function E() {
      return k(o);
    }
    function N(w) {
      function L(V, K, z, U, Y) {
        if (typeof w != "function")
          return new m("Property `" + Y + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var j = V[K];
        if (!Array.isArray(j)) {
          var D = S(j);
          return new m("Invalid " + U + " `" + Y + "` of type " + ("`" + D + "` supplied to `" + z + "`, expected an array."));
        }
        for (var H = 0; H < j.length; H++) {
          var F = w(j, H, z, U, Y + "[" + H + "]", e);
          if (F instanceof Error)
            return F;
        }
        return null;
      }
      return k(L);
    }
    function q() {
      function w(L, V, K, z, U) {
        var Y = L[V];
        if (!a(Y)) {
          var j = S(Y);
          return new m("Invalid " + z + " `" + U + "` of type " + ("`" + j + "` supplied to `" + K + "`, expected a single ReactElement."));
        }
        return null;
      }
      return k(w);
    }
    function A() {
      function w(L, V, K, z, U) {
        var Y = L[V];
        if (!r.isValidElementType(Y)) {
          var j = S(Y);
          return new m("Invalid " + z + " `" + U + "` of type " + ("`" + j + "` supplied to `" + K + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return k(w);
    }
    function X(w) {
      function L(V, K, z, U, Y) {
        if (!(V[K] instanceof w)) {
          var j = w.name || h, D = Z(V[K]);
          return new m("Invalid " + U + " `" + Y + "` of type " + ("`" + D + "` supplied to `" + z + "`, expected ") + ("instance of `" + j + "`."));
        }
        return null;
      }
      return k(L);
    }
    function G(w) {
      if (!Array.isArray(w))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), o;
      function L(V, K, z, U, Y) {
        for (var j = V[K], D = 0; D < w.length; D++)
          if (v(j, w[D]))
            return null;
        var H = JSON.stringify(w, function(F, J) {
          var T = B(J);
          return T === "symbol" ? String(J) : J;
        });
        return new m("Invalid " + U + " `" + Y + "` of value `" + String(j) + "` " + ("supplied to `" + z + "`, expected one of " + H + "."));
      }
      return k(L);
    }
    function ct(w) {
      function L(V, K, z, U, Y) {
        if (typeof w != "function")
          return new m("Property `" + Y + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var j = V[K], D = S(j);
        if (D !== "object")
          return new m("Invalid " + U + " `" + Y + "` of type " + ("`" + D + "` supplied to `" + z + "`, expected an object."));
        for (var H in j)
          if (s(j, H)) {
            var F = w(j, H, z, U, Y + "." + H, e);
            if (F instanceof Error)
              return F;
          }
        return null;
      }
      return k(L);
    }
    function mt(w) {
      if (!Array.isArray(w))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var L = 0; L < w.length; L++) {
        var V = w[L];
        if (typeof V != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + W(V) + " at index " + L + "."
          ), o;
      }
      function K(z, U, Y, j, D) {
        for (var H = [], F = 0; F < w.length; F++) {
          var J = w[F], T = J(z, U, Y, j, D, e);
          if (T == null)
            return null;
          T.data && s(T.data, "expectedType") && H.push(T.data.expectedType);
        }
        var at = H.length > 0 ? ", expected one of type [" + H.join(", ") + "]" : "";
        return new m("Invalid " + j + " `" + D + "` supplied to " + ("`" + Y + "`" + at + "."));
      }
      return k(K);
    }
    function xt() {
      function w(L, V, K, z, U) {
        return $(L[V]) ? null : new m("Invalid " + z + " `" + U + "` supplied to " + ("`" + K + "`, expected a ReactNode."));
      }
      return k(w);
    }
    function b(w, L, V, K, z) {
      return new m(
        (w || "React class") + ": " + L + " type `" + V + "." + K + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function M(w) {
      function L(V, K, z, U, Y) {
        var j = V[K], D = S(j);
        if (D !== "object")
          return new m("Invalid " + U + " `" + Y + "` of type `" + D + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var H in w) {
          var F = w[H];
          if (typeof F != "function")
            return b(z, U, Y, H, B(F));
          var J = F(j, H, z, U, Y + "." + H, e);
          if (J)
            return J;
        }
        return null;
      }
      return k(L);
    }
    function x(w) {
      function L(V, K, z, U, Y) {
        var j = V[K], D = S(j);
        if (D !== "object")
          return new m("Invalid " + U + " `" + Y + "` of type `" + D + "` " + ("supplied to `" + z + "`, expected `object`."));
        var H = t({}, V[K], w);
        for (var F in H) {
          var J = w[F];
          if (s(w, F) && typeof J != "function")
            return b(z, U, Y, F, B(J));
          if (!J)
            return new m(
              "Invalid " + U + " `" + Y + "` key `" + F + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(V[K], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(w), null, "  ")
            );
          var T = J(j, F, z, U, Y + "." + F, e);
          if (T)
            return T;
        }
        return null;
      }
      return k(L);
    }
    function $(w) {
      switch (typeof w) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !w;
        case "object":
          if (Array.isArray(w))
            return w.every($);
          if (w === null || a(w))
            return !0;
          var L = g(w);
          if (L) {
            var V = L.call(w), K;
            if (L !== w.entries) {
              for (; !(K = V.next()).done; )
                if (!$(K.value))
                  return !1;
            } else
              for (; !(K = V.next()).done; ) {
                var z = K.value;
                if (z && !$(z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function P(w, L) {
      return w === "symbol" ? !0 : L ? L["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && L instanceof Symbol : !1;
    }
    function S(w) {
      var L = typeof w;
      return Array.isArray(w) ? "array" : w instanceof RegExp ? "object" : P(L, w) ? "symbol" : L;
    }
    function B(w) {
      if (typeof w > "u" || w === null)
        return "" + w;
      var L = S(w);
      if (L === "object") {
        if (w instanceof Date)
          return "date";
        if (w instanceof RegExp)
          return "regexp";
      }
      return L;
    }
    function W(w) {
      var L = B(w);
      switch (L) {
        case "array":
        case "object":
          return "an " + L;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + L;
        default:
          return L;
      }
    }
    function Z(w) {
      return !w.constructor || !w.constructor.name ? h : w.constructor.name;
    }
    return f.checkPropTypes = n, f.resetWarningCache = n.resetWarningCache, f.PropTypes = f, f;
  }, Uo;
}
var $o, Qu;
function Vx() {
  if (Qu) return $o;
  Qu = 1;
  var r = /* @__PURE__ */ cl();
  function t() {
  }
  function e() {
  }
  return e.resetWarningCache = t, $o = function() {
    function s(o, a, l, c, d, g) {
      if (g !== r) {
        var h = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw h.name = "Invariant Violation", h;
      }
    }
    s.isRequired = s;
    function n() {
      return s;
    }
    var i = {
      array: s,
      bigint: s,
      bool: s,
      func: s,
      number: s,
      object: s,
      string: s,
      symbol: s,
      any: s,
      arrayOf: n,
      element: s,
      elementType: s,
      instanceOf: n,
      node: s,
      objectOf: n,
      oneOf: n,
      oneOfType: n,
      shape: n,
      exact: n,
      checkPropTypes: e,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, $o;
}
var tc;
function Ux() {
  if (tc) return On.exports;
  if (tc = 1, process.env.NODE_ENV !== "production") {
    var r = dp(), t = !0;
    On.exports = /* @__PURE__ */ Px()(r.isElement, t);
  } else
    On.exports = /* @__PURE__ */ Vx()();
  return On.exports;
}
var $x = /* @__PURE__ */ Ux();
const st = /* @__PURE__ */ Ra($x), fp = {
  // common
  mask: st.oneOfType([st.array, st.func, st.string, st.instanceOf(RegExp), st.oneOf([Date, Number, ot.Masked]), st.instanceOf(ot.Masked)]),
  value: st.any,
  unmask: st.oneOfType([st.bool, st.oneOf(["typed"])]),
  prepare: st.func,
  prepareChar: st.func,
  validate: st.func,
  commit: st.func,
  overwrite: st.oneOfType([st.bool, st.oneOf(["shift"])]),
  eager: st.oneOfType([st.bool, st.oneOf(["append", "remove"])]),
  skipInvalid: st.bool,
  // events
  onAccept: st.func,
  onComplete: st.func,
  // pattern
  placeholderChar: st.string,
  displayChar: st.string,
  lazy: st.bool,
  definitions: st.object,
  blocks: st.object,
  // enum
  enum: st.arrayOf(st.string),
  // range
  maxLength: st.number,
  from: st.number,
  to: st.number,
  // date
  pattern: st.string,
  format: st.func,
  parse: st.func,
  autofix: st.oneOfType([st.bool, st.oneOf(["pad"])]),
  // number
  radix: st.string,
  thousandsSeparator: st.string,
  mapToRadix: st.arrayOf(st.string),
  scale: st.number,
  normalizeZeros: st.bool,
  padFractionalZeros: st.bool,
  min: st.oneOfType([st.number, st.instanceOf(Date)]),
  max: st.oneOfType([st.number, st.instanceOf(Date)]),
  // dynamic
  dispatch: st.func,
  // ref
  inputRef: st.oneOfType([st.func, st.shape({
    current: st.object
  })])
}, mp = Object.keys(fp).filter((r) => r !== "value"), zx = ["value", "unmask", "onAccept", "onComplete", "inputRef"], Hx = mp.filter((r) => zx.indexOf(r) < 0);
function Kx(r) {
  var t;
  const e = (t = class extends ut.Component {
    constructor(n) {
      super(n), this._inputRef = this._inputRef.bind(this);
    }
    componentDidMount() {
      this.props.mask && this.initMask();
    }
    componentDidUpdate() {
      const n = this.props, i = this._extractMaskOptionsFromProps(n);
      if (i.mask)
        this.maskRef ? (this.maskRef.updateOptions(i), "value" in n && n.value !== void 0 && (this.maskValue = n.value)) : this.initMask(i);
      else if (this.destroyMask(), "value" in n && n.value !== void 0) {
        var o;
        (o = this.element) != null && o.isContentEditable && this.element.tagName !== "INPUT" && this.element.tagName !== "TEXTAREA" ? this.element.textContent = n.value : this.element.value = n.value;
      }
    }
    componentWillUnmount() {
      this.destroyMask();
    }
    _inputRef(n) {
      this.element = n, this.props.inputRef && (Object.prototype.hasOwnProperty.call(this.props.inputRef, "current") ? this.props.inputRef.current = n : this.props.inputRef(n));
    }
    initMask(n) {
      n === void 0 && (n = this._extractMaskOptionsFromProps(this.props)), this.maskRef = ot(this.element, n).on("accept", this._onAccept.bind(this)).on("complete", this._onComplete.bind(this)), "value" in this.props && this.props.value !== void 0 && (this.maskValue = this.props.value);
    }
    destroyMask() {
      this.maskRef && (this.maskRef.destroy(), delete this.maskRef);
    }
    _extractMaskOptionsFromProps(n) {
      const {
        ...i
      } = n;
      return Object.keys(i).filter((o) => Hx.indexOf(o) < 0).forEach((o) => {
        delete i[o];
      }), i;
    }
    _extractNonMaskProps(n) {
      const {
        ...i
      } = n;
      return mp.forEach((o) => {
        o !== "maxLength" && delete i[o];
      }), "defaultValue" in i || (i.defaultValue = n.mask ? "" : i.value), delete i.value, i;
    }
    get maskValue() {
      return this.maskRef ? this.props.unmask === "typed" ? this.maskRef.typedValue : this.props.unmask ? this.maskRef.unmaskedValue : this.maskRef.value : "";
    }
    set maskValue(n) {
      this.maskRef && (n = n == null && this.props.unmask !== "typed" ? "" : n, this.props.unmask === "typed" ? this.maskRef.typedValue = n : this.props.unmask ? this.maskRef.unmaskedValue = n : this.maskRef.value = n);
    }
    _onAccept(n) {
      this.props.onAccept && this.maskRef && this.props.onAccept(this.maskValue, this.maskRef, n);
    }
    _onComplete(n) {
      this.props.onComplete && this.maskRef && this.props.onComplete(this.maskValue, this.maskRef, n);
    }
    render() {
      return ut.createElement(r, {
        ...this._extractNonMaskProps(this.props),
        inputRef: this._inputRef
      });
    }
  }, t.displayName = void 0, t.propTypes = void 0, t), s = r.displayName || r.name || "Component";
  return e.displayName = "IMask(" + s + ")", e.propTypes = fp, ut.forwardRef((n, i) => ut.createElement(e, {
    ...n,
    ref: i
  }));
}
const Gx = Kx((r) => {
  let {
    inputRef: t,
    ...e
  } = r;
  return ut.createElement("input", {
    ...e,
    ref: t
  });
}), Wx = (r, t) => ut.createElement(Gx, {
  ...r,
  ref: t
}), Zx = ut.forwardRef(Wx), Xx = kp(
  ({ className: r, type: t, variant: e, ...s }, n) => /* @__PURE__ */ R.jsx(
    Zx,
    {
      className: St(ja({ variant: e }), r),
      ref: n,
      ...s
    }
  )
);
Xx.displayName = "MaskInput";
export {
  Dh as B,
  _x as E,
  Xx as G,
  qm as I,
  Bh as M,
  Im as N,
  Vm as P,
  ef as Q,
  jm as R,
  Lm as T,
  Kc as U,
  tf as X,
  pw as _,
  Ig as a,
  hm as b,
  Lg as c,
  xg as d,
  ja as e,
  vg as f,
  yg as g,
  ui as h,
  Rm as k,
  kg as m,
  bg as p,
  Um as q,
  lw as v,
  hw as w,
  dw as x,
  aw as y
};
