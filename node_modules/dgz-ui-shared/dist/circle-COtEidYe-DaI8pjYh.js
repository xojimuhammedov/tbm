import * as l from "react";
import w from "react";
import { j as G, x as _, a as p, c as K, g as Y, h as P, b as F, y as Z, n as J } from "./index-DqTIeHVj-CeLMF2B2.js";
import { k as L } from "./createLucideIcon-B950nf2d-C2YhAyqE.js";
var Q = l.createContext(void 0);
function W(e) {
  const r = l.useContext(Q);
  return e || r || "ltr";
}
function ee(e) {
  const r = e + "CollectionProvider", [i, n] = G(r), [S, b] = i(
    r,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), v = (f) => {
    const { scope: t, children: a } = f, o = w.useRef(null), c = w.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ p.jsx(S, { scope: t, itemMap: c, collectionRef: o, children: a });
  };
  v.displayName = r;
  const h = e + "CollectionSlot", C = K(h), m = w.forwardRef(
    (f, t) => {
      const { scope: a, children: o } = f, c = b(h, a), d = _(t, c.collectionRef);
      return /* @__PURE__ */ p.jsx(C, { ref: d, children: o });
    }
  );
  m.displayName = h;
  const s = e + "CollectionItemSlot", y = "data-radix-collection-item", x = K(s), R = w.forwardRef(
    (f, t) => {
      const { scope: a, children: o, ...c } = f, d = w.useRef(null), A = _(t, d), E = b(s, a);
      return w.useEffect(() => (E.itemMap.set(d, { ref: d, ...c }), () => void E.itemMap.delete(d))), /* @__PURE__ */ p.jsx(x, { [y]: "", ref: A, children: o });
    }
  );
  R.displayName = s;
  function I(f) {
    const t = b(e + "CollectionConsumer", f);
    return w.useCallback(() => {
      const a = t.collectionRef.current;
      if (!a) return [];
      const o = Array.from(a.querySelectorAll(`[${y}]`));
      return Array.from(t.itemMap.values()).sort(
        (c, d) => o.indexOf(c.ref.current) - o.indexOf(d.ref.current)
      );
    }, [t.collectionRef, t.itemMap]);
  }
  return [
    { Provider: v, Slot: m, ItemSlot: R },
    I,
    n
  ];
}
var k = "rovingFocusGroup.onEntryFocus", te = { bubbles: !1, cancelable: !0 }, T = "RovingFocusGroup", [$, N, re] = ee(T), [oe, be] = G(
  T,
  [re]
), [ne, ce] = oe(T), O = l.forwardRef(
  (e, r) => /* @__PURE__ */ p.jsx($.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ p.jsx($.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ p.jsx(ae, { ...e, ref: r }) }) })
);
O.displayName = T;
var ae = l.forwardRef((e, r) => {
  const {
    __scopeRovingFocusGroup: i,
    orientation: n,
    loop: S = !1,
    dir: b,
    currentTabStopId: v,
    defaultCurrentTabStopId: h,
    onCurrentTabStopIdChange: C,
    onEntryFocus: m,
    preventScrollOnEntryFocus: s = !1,
    ...y
  } = e, x = l.useRef(null), R = _(r, x), I = W(b), [f, t] = Z({
    prop: v,
    defaultProp: h ?? null,
    onChange: C,
    caller: T
  }), [a, o] = l.useState(!1), c = J(m), d = N(i), A = l.useRef(!1), [E, D] = l.useState(0);
  return l.useEffect(() => {
    const u = x.current;
    if (u)
      return u.addEventListener(k, c), () => u.removeEventListener(k, c);
  }, [c]), /* @__PURE__ */ p.jsx(
    ne,
    {
      scope: i,
      orientation: n,
      dir: I,
      loop: S,
      currentTabStopId: f,
      onItemFocus: l.useCallback(
        (u) => t(u),
        [t]
      ),
      onItemShiftTab: l.useCallback(() => o(!0), []),
      onFocusableItemAdd: l.useCallback(
        () => D((u) => u + 1),
        []
      ),
      onFocusableItemRemove: l.useCallback(
        () => D((u) => u - 1),
        []
      ),
      children: /* @__PURE__ */ p.jsx(
        P.div,
        {
          tabIndex: a || E === 0 ? -1 : 0,
          "data-orientation": n,
          ...y,
          ref: R,
          style: { outline: "none", ...e.style },
          onMouseDown: F(e.onMouseDown, () => {
            A.current = !0;
          }),
          onFocus: F(e.onFocus, (u) => {
            const z = !A.current;
            if (u.target === u.currentTarget && z && !a) {
              const j = new CustomEvent(k, te);
              if (u.currentTarget.dispatchEvent(j), !j.defaultPrevented) {
                const M = d().filter((g) => g.focusable), H = M.find((g) => g.active), V = M.find((g) => g.id === f), X = [H, V, ...M].filter(
                  Boolean
                ).map((g) => g.ref.current);
                q(X, s);
              }
            }
            A.current = !1;
          }),
          onBlur: F(e.onBlur, () => o(!1))
        }
      )
    }
  );
}), B = "RovingFocusGroupItem", U = l.forwardRef(
  (e, r) => {
    const {
      __scopeRovingFocusGroup: i,
      focusable: n = !0,
      active: S = !1,
      tabStopId: b,
      children: v,
      ...h
    } = e, C = Y(), m = b || C, s = ce(B, i), y = s.currentTabStopId === m, x = N(i), { onFocusableItemAdd: R, onFocusableItemRemove: I, currentTabStopId: f } = s;
    return l.useEffect(() => {
      if (n)
        return R(), () => I();
    }, [n, R, I]), /* @__PURE__ */ p.jsx(
      $.ItemSlot,
      {
        scope: i,
        id: m,
        focusable: n,
        active: S,
        children: /* @__PURE__ */ p.jsx(
          P.span,
          {
            tabIndex: y ? 0 : -1,
            "data-orientation": s.orientation,
            ...h,
            ref: r,
            onMouseDown: F(e.onMouseDown, (t) => {
              n ? s.onItemFocus(m) : t.preventDefault();
            }),
            onFocus: F(e.onFocus, () => s.onItemFocus(m)),
            onKeyDown: F(e.onKeyDown, (t) => {
              if (t.key === "Tab" && t.shiftKey) {
                s.onItemShiftTab();
                return;
              }
              if (t.target !== t.currentTarget) return;
              const a = ie(t, s.orientation, s.dir);
              if (a !== void 0) {
                if (t.metaKey || t.ctrlKey || t.altKey || t.shiftKey) return;
                t.preventDefault();
                let o = x().filter((c) => c.focusable).map((c) => c.ref.current);
                if (a === "last") o.reverse();
                else if (a === "prev" || a === "next") {
                  a === "prev" && o.reverse();
                  const c = o.indexOf(t.currentTarget);
                  o = s.loop ? ue(o, c + 1) : o.slice(c + 1);
                }
                setTimeout(() => q(o));
              }
            }),
            children: typeof v == "function" ? v({ isCurrentTabStop: y, hasTabStop: f != null }) : v
          }
        )
      }
    );
  }
);
U.displayName = B;
var se = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function le(e, r) {
  return r !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function ie(e, r, i) {
  const n = le(e.key, i);
  if (!(r === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(r === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return se[n];
}
function q(e, r = !1) {
  const i = document.activeElement;
  for (const n of e)
    if (n === i || (n.focus({ preventScroll: r }), document.activeElement !== i)) return;
}
function ue(e, r) {
  return e.map((i, n) => e[(r + n) % e.length]);
}
var he = O, ye = U;
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fe = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Re = L("check", fe);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const de = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]], ge = L("circle", de);
export {
  he as S,
  ee as X,
  ge as a,
  be as b,
  ye as g,
  W as n,
  Re as t
};
