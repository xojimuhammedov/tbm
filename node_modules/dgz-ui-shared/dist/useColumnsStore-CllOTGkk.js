import _ from "react";
function w(t, s) {
  let e;
  try {
    e = t();
  } catch {
    return;
  }
  return {
    getItem: (a) => {
      var r;
      const f = (d) => d === null ? null : JSON.parse(d, void 0), u = (r = e.getItem(a)) != null ? r : null;
      return u instanceof Promise ? u.then(f) : f(u);
    },
    setItem: (a, r) => e.setItem(a, JSON.stringify(r, void 0)),
    removeItem: (a) => e.removeItem(a)
  };
}
const b = (t) => (s) => {
  try {
    const e = t(s);
    return e instanceof Promise ? e : {
      then(o) {
        return b(o)(e);
      },
      catch(o) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(o) {
        return this;
      },
      catch(o) {
        return b(o)(e);
      }
    };
  }
}, C = (t, s) => (e, o, a) => {
  let r = {
    storage: w(() => localStorage),
    partialize: (n) => n,
    version: 0,
    merge: (n, h) => ({
      ...h,
      ...n
    }),
    ...s
  }, f = !1;
  const u = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
  let i = r.storage;
  if (!i)
    return t(
      (...n) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`
        ), e(...n);
      },
      o,
      a
    );
  const g = () => {
    const n = r.partialize({ ...o() });
    return i.setItem(r.name, {
      state: n,
      version: r.version
    });
  }, v = a.setState;
  a.setState = (n, h) => {
    v(n, h), g();
  };
  const S = t(
    (...n) => {
      e(...n), g();
    },
    o,
    a
  );
  a.getInitialState = () => S;
  let m;
  const I = () => {
    var n, h;
    if (!i) return;
    f = !1, u.forEach((c) => {
      var l;
      return c((l = o()) != null ? l : S);
    });
    const y = ((h = r.onRehydrateStorage) == null ? void 0 : h.call(r, (n = o()) != null ? n : S)) || void 0;
    return b(i.getItem.bind(i))(r.name).then((c) => {
      if (c)
        if (typeof c.version == "number" && c.version !== r.version) {
          if (r.migrate) {
            const l = r.migrate(
              c.state,
              c.version
            );
            return l instanceof Promise ? l.then((p) => [!0, p]) : [!0, l];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, c.state];
      return [!1, void 0];
    }).then((c) => {
      var l;
      const [p, j] = c;
      if (m = r.merge(
        j,
        (l = o()) != null ? l : S
      ), e(m, !0), p)
        return g();
    }).then(() => {
      y == null || y(m, void 0), m = o(), f = !0, d.forEach((c) => c(m));
    }).catch((c) => {
      y == null || y(void 0, c);
    });
  };
  return a.persist = {
    setOptions: (n) => {
      r = {
        ...r,
        ...n
      }, n.storage && (i = n.storage);
    },
    clearStorage: () => {
      i == null || i.removeItem(r.name);
    },
    getOptions: () => r,
    rehydrate: () => I(),
    hasHydrated: () => f,
    onHydrate: (n) => (u.add(n), () => {
      u.delete(n);
    }),
    onFinishHydration: (n) => (d.add(n), () => {
      d.delete(n);
    })
  }, r.skipHydration || I(), m || S;
}, E = C, H = (t) => {
  let s;
  const e = /* @__PURE__ */ new Set(), o = (i, g) => {
    const v = typeof i == "function" ? i(s) : i;
    if (!Object.is(v, s)) {
      const S = s;
      s = g ?? (typeof v != "object" || v === null) ? v : Object.assign({}, s, v), e.forEach((m) => m(s, S));
    }
  }, a = () => s, u = { setState: o, getState: a, getInitialState: () => d, subscribe: (i) => (e.add(i), () => e.delete(i)) }, d = s = t(o, a, u);
  return u;
}, R = (t) => t ? H(t) : H, x = (t) => t;
function F(t, s = x) {
  const e = _.useSyncExternalStore(
    t.subscribe,
    () => s(t.getState()),
    () => s(t.getInitialState())
  );
  return _.useDebugValue(e), e;
}
const O = (t) => {
  const s = R(t), e = (o) => F(s, o);
  return Object.assign(e, s), e;
}, J = (t) => t ? O(t) : O, P = J()(
  E(
    (t) => ({
      setColumns: (s) => {
        t({ storedColumns: s });
      },
      storedColumns: {}
    }),
    {
      name: "columnsStore"
    }
  )
);
export {
  w as a,
  J as c,
  E as p,
  P as u
};
