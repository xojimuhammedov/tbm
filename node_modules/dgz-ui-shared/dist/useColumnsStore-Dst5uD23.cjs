"use strict";const O=require("react");function j(t,s){let e;try{e=t()}catch{return}return{getItem:a=>{var r;const f=d=>d===null?null:JSON.parse(d,void 0),u=(r=e.getItem(a))!=null?r:null;return u instanceof Promise?u.then(f):f(u)},setItem:(a,r)=>e.setItem(a,JSON.stringify(r,void 0)),removeItem:a=>e.removeItem(a)}}const I=t=>s=>{try{const e=t(s);return e instanceof Promise?e:{then(o){return I(o)(e)},catch(o){return this}}}catch(e){return{then(o){return this},catch(o){return I(o)(e)}}}},J=(t,s)=>(e,o,a)=>{let r={storage:j(()=>localStorage),partialize:n=>n,version:0,merge:(n,h)=>({...h,...n}),...s},f=!1;const u=new Set,d=new Set;let i=r.storage;if(!i)return t((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),e(...n)},o,a);const g=()=>{const n=r.partialize({...o()});return i.setItem(r.name,{state:n,version:r.version})},S=a.setState;a.setState=(n,h)=>{S(n,h),g()};const v=t((...n)=>{e(...n),g()},o,a);a.getInitialState=()=>v;let m;const p=()=>{var n,h;if(!i)return;f=!1,u.forEach(c=>{var l;return c((l=o())!=null?l:v)});const y=((h=r.onRehydrateStorage)==null?void 0:h.call(r,(n=o())!=null?n:v))||void 0;return I(i.getItem.bind(i))(r.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==r.version){if(r.migrate){const l=r.migrate(c.state,c.version);return l instanceof Promise?l.then(b=>[!0,b]):[!0,l]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,c.state];return[!1,void 0]}).then(c=>{var l;const[b,E]=c;if(m=r.merge(E,(l=o())!=null?l:v),e(m,!0),b)return g()}).then(()=>{y==null||y(m,void 0),m=o(),f=!0,d.forEach(c=>c(m))}).catch(c=>{y==null||y(void 0,c)})};return a.persist={setOptions:n=>{r={...r,...n},n.storage&&(i=n.storage)},clearStorage:()=>{i==null||i.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>p(),hasHydrated:()=>f,onHydrate:n=>(u.add(n),()=>{u.delete(n)}),onFinishHydration:n=>(d.add(n),()=>{d.delete(n)})},r.skipHydration||p(),m||v},C=J,_=t=>{let s;const e=new Set,o=(i,g)=>{const S=typeof i=="function"?i(s):i;if(!Object.is(S,s)){const v=s;s=g??(typeof S!="object"||S===null)?S:Object.assign({},s,S),e.forEach(m=>m(s,v))}},a=()=>s,u={setState:o,getState:a,getInitialState:()=>d,subscribe:i=>(e.add(i),()=>e.delete(i))},d=s=t(o,a,u);return u},N=t=>t?_(t):_,R=t=>t;function F(t,s=R){const e=O.useSyncExternalStore(t.subscribe,()=>s(t.getState()),()=>s(t.getInitialState()));return O.useDebugValue(e),e}const H=t=>{const s=N(t),e=o=>F(s,o);return Object.assign(e,s),e},w=t=>t?H(t):H,P=w()(C(t=>({setColumns:s=>{t({storedColumns:s})},storedColumns:{}}),{name:"columnsStore"}));exports.create=w;exports.createJSONStorage=j;exports.persist=C;exports.useColumnsStore=P;
