import { createContext as H, useContext as M, useCallback as U, useState as _, useRef as A, useEffect as x } from "react";
const G = (e, s, n, a) => {
  var t, d, N, m;
  const r = [n, {
    code: s,
    ...a || {}
  }];
  if ((d = (t = e == null ? void 0 : e.services) == null ? void 0 : t.logger) != null && d.forward)
    return e.services.logger.forward(r, "warn", "react-i18next::", !0);
  p(r[0]) && (r[0] = `react-i18next:: ${r[0]}`), (m = (N = e == null ? void 0 : e.services) == null ? void 0 : N.logger) != null && m.warn ? e.services.logger.warn(...r) : console != null && console.warn && console.warn(...r);
}, L = {}, S = (e, s, n, a) => {
  p(n) && L[n] || (p(n) && (L[n] = /* @__PURE__ */ new Date()), G(e, s, n, a));
}, P = (e, s) => () => {
  if (e.isInitialized)
    s();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n);
      }, 0), s();
    };
    e.on("initialized", n);
  }
}, b = (e, s, n) => {
  e.loadNamespaces(s, P(e, n));
}, R = (e, s, n, a) => {
  if (p(n) && (n = [n]), e.options.preload && e.options.preload.indexOf(s) > -1) return b(e, n, a);
  n.forEach((r) => {
    e.options.ns.indexOf(r) < 0 && e.options.ns.push(r);
  }), e.loadLanguages(s, P(e, a));
}, $ = (e, s, n = {}) => !s.languages || !s.languages.length ? (S(s, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
  languages: s.languages
}), !0) : s.hasLoadedNamespace(e, {
  lng: n.lng,
  precheck: (a, r) => {
    var t;
    if (((t = n.bindI18n) == null ? void 0 : t.indexOf("languageChanging")) > -1 && a.services.backendConnector.backend && a.isLanguageChangingTo && !r(a.isLanguageChangingTo, e)) return !1;
  }
}), p = (e) => typeof e == "string", q = (e) => typeof e == "object" && e !== null, B = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, W = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
}, J = (e) => W[e], K = (e) => e.replace(B, J);
let X = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: K
};
const Y = () => X;
let D;
const Q = () => D, Z = H();
class V {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(s) {
    s.forEach((n) => {
      this.usedNamespaces[n] || (this.usedNamespaces[n] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const ee = (e, s) => {
  const n = A();
  return x(() => {
    n.current = e;
  }, [e, s]), n.current;
}, j = (e, s, n, a) => e.getFixedT(s, n, a), te = (e, s, n, a) => U(j(e, s, n, a), [e, s, n, a]), ne = (e, s = {}) => {
  var O, v, z, F;
  const {
    i18n: n
  } = s, {
    i18n: a,
    defaultNS: r
  } = M(Z) || {}, t = n || a || Q();
  if (t && !t.reportNamespaces && (t.reportNamespaces = new V()), !t) {
    S(t, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
    const i = (l, u) => p(u) ? u : q(u) && p(u.defaultValue) ? u.defaultValue : Array.isArray(l) ? l[l.length - 1] : l, c = [i, {}, !1];
    return c.t = i, c.i18n = {}, c.ready = !1, c;
  }
  (O = t.options.react) != null && O.wait && S(t, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const d = {
    ...Y(),
    ...t.options.react,
    ...s
  }, {
    useSuspense: N,
    keyPrefix: m
  } = d;
  let o = r || ((v = t.options) == null ? void 0 : v.defaultNS);
  o = p(o) ? [o] : o || ["translation"], (F = (z = t.reportNamespaces).addUsedNamespaces) == null || F.call(z, o);
  const f = (t.isInitialized || t.initializedStoreOnce) && o.every((i) => $(i, t, d)), k = te(t, s.lng || null, d.nsMode === "fallback" ? o : o[0], m), E = () => k, T = () => j(t, s.lng || null, d.nsMode === "fallback" ? o : o[0], m), [C, h] = _(E);
  let y = o.join();
  s.lng && (y = `${s.lng}${y}`);
  const I = ee(y), g = A(!0);
  x(() => {
    const {
      bindI18n: i,
      bindI18nStore: c
    } = d;
    g.current = !0, !f && !N && (s.lng ? R(t, s.lng, o, () => {
      g.current && h(T);
    }) : b(t, o, () => {
      g.current && h(T);
    })), f && I && I !== y && g.current && h(T);
    const l = () => {
      g.current && h(T);
    };
    return i && (t == null || t.on(i, l)), c && (t == null || t.store.on(c, l)), () => {
      g.current = !1, t && (i == null || i.split(" ").forEach((u) => t.off(u, l))), c && t && c.split(" ").forEach((u) => t.store.off(u, l));
    };
  }, [t, y]), x(() => {
    g.current && f && h(E);
  }, [t, m, f]);
  const w = [C, t, f];
  if (w.t = C, w.i18n = t, w.ready = f, f || !f && !N) return w;
  throw new Promise((i) => {
    s.lng ? R(t, s.lng, o, () => i()) : b(t, o, () => i());
  });
};
export {
  ne as u
};
