"use strict";const b=require("react"),d=require("./index-DcWZbXs6.cjs");function S(t){const o=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t){for(const e in t)if(e!=="default"){const r=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(o,e,r.get?r:{enumerable:!0,get:()=>t[e]})}}return o.default=t,Object.freeze(o)}const n=S(b);var g=n[" useId ".trim().toString()]||(()=>{}),y=0;function E(t){const[o,e]=n.useState(g());return d.useLayoutEffect2(()=>{e(r=>r??String(y++))},[t]),t||(o?`radix-${o}`:"")}var I=n[" useInsertionEffect ".trim().toString()]||d.useLayoutEffect2;function w({prop:t,defaultProp:o,onChange:e=()=>{},caller:r}){const[i,c,u]=O({defaultProp:o,onChange:e}),s=t!==void 0,v=s?t:i;{const l=n.useRef(t!==void 0);n.useEffect(()=>{const f=l.current;f!==s&&console.warn(`${r} is changing from ${f?"controlled":"uncontrolled"} to ${s?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),l.current=s},[s,r])}const m=n.useCallback(l=>{var f;if(s){const a=j(l)?l(t):l;a!==t&&((f=u.current)==null||f.call(u,a))}else c(l)},[s,t,c,u]);return[v,m]}function O({defaultProp:t,onChange:o}){const[e,r]=n.useState(t),i=n.useRef(e),c=n.useRef(o);return I(()=>{c.current=o},[o]),n.useEffect(()=>{var u;i.current!==e&&((u=c.current)==null||u.call(c,e),i.current=e)},[e,i]),[e,r,c]}function j(t){return typeof t=="function"}exports.useControllableState=w;exports.useId=E;
