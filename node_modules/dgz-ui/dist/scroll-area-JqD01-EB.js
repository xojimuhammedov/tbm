import { j as h } from "./jsx-runtime-C5mzlN2N.js";
import * as s from "react";
import { P as L } from "./index-Do92jweN.js";
import { P as O, c as C } from "./index-D_OzDH1f.js";
import { c as ae, u as ie } from "./index-Dmh__Tgi.js";
import { u as A } from "./index-l1ZGtt0d.js";
import { u as P } from "./index-DwYXX2sM.js";
import { u as de } from "./index-Dz-GVg5i.js";
import { c as ue } from "./index-rKs9bXHr.js";
import { c as $ } from "./utils-B6fNqzRf.js";
function fe(e, o) {
  return s.useReducer((r, n) => o[r][n] ?? r, e);
}
var U = "ScrollArea", [q, ze] = ae(U), [he, v] = q(U), G = s.forwardRef(
  (e, o) => {
    const {
      __scopeScrollArea: r,
      type: n = "hover",
      dir: t,
      scrollHideDelay: l = 600,
      ...c
    } = e, [a, i] = s.useState(null), [f, d] = s.useState(null), [b, u] = s.useState(null), [m, p] = s.useState(null), [T, Y] = s.useState(null), [x, _] = s.useState(0), [M, D] = s.useState(0), [j, y] = s.useState(!1), [N, W] = s.useState(!1), S = A(o, (R) => i(R)), w = de(t);
    return /* @__PURE__ */ h.jsx(
      he,
      {
        scope: r,
        type: n,
        dir: w,
        scrollHideDelay: l,
        scrollArea: a,
        viewport: f,
        onViewportChange: d,
        content: b,
        onContentChange: u,
        scrollbarX: m,
        onScrollbarXChange: p,
        scrollbarXEnabled: j,
        onScrollbarXEnabledChange: y,
        scrollbarY: T,
        onScrollbarYChange: Y,
        scrollbarYEnabled: N,
        onScrollbarYEnabledChange: W,
        onCornerWidthChange: _,
        onCornerHeightChange: D,
        children: /* @__PURE__ */ h.jsx(
          L.div,
          {
            dir: w,
            ...c,
            ref: S,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": x + "px",
              "--radix-scroll-area-corner-height": M + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
G.displayName = U;
var J = "ScrollAreaViewport", K = s.forwardRef(
  (e, o) => {
    const { __scopeScrollArea: r, children: n, nonce: t, ...l } = e, c = v(J, r), a = s.useRef(null), i = A(o, a, c.onViewportChange);
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: t
        }
      ),
      /* @__PURE__ */ h.jsx(
        L.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...l,
          ref: i,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: c.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: c.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ h.jsx("div", { ref: c.onContentChange, style: { minWidth: "100%", display: "table" }, children: n })
        }
      )
    ] });
  }
);
K.displayName = J;
var g = "ScrollAreaScrollbar", V = s.forwardRef(
  (e, o) => {
    const { forceMount: r, ...n } = e, t = v(g, e.__scopeScrollArea), { onScrollbarXEnabledChange: l, onScrollbarYEnabledChange: c } = t, a = e.orientation === "horizontal";
    return s.useEffect(() => (a ? l(!0) : c(!0), () => {
      a ? l(!1) : c(!1);
    }), [a, l, c]), t.type === "hover" ? /* @__PURE__ */ h.jsx(be, { ...n, ref: o, forceMount: r }) : t.type === "scroll" ? /* @__PURE__ */ h.jsx(me, { ...n, ref: o, forceMount: r }) : t.type === "auto" ? /* @__PURE__ */ h.jsx(Q, { ...n, ref: o, forceMount: r }) : t.type === "always" ? /* @__PURE__ */ h.jsx(B, { ...n, ref: o }) : null;
  }
);
V.displayName = g;
var be = s.forwardRef((e, o) => {
  const { forceMount: r, ...n } = e, t = v(g, e.__scopeScrollArea), [l, c] = s.useState(!1);
  return s.useEffect(() => {
    const a = t.scrollArea;
    let i = 0;
    if (a) {
      const f = () => {
        window.clearTimeout(i), c(!0);
      }, d = () => {
        i = window.setTimeout(() => c(!1), t.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", f), a.addEventListener("pointerleave", d), () => {
        window.clearTimeout(i), a.removeEventListener("pointerenter", f), a.removeEventListener("pointerleave", d);
      };
    }
  }, [t.scrollArea, t.scrollHideDelay]), /* @__PURE__ */ h.jsx(O, { present: r || l, children: /* @__PURE__ */ h.jsx(
    Q,
    {
      "data-state": l ? "visible" : "hidden",
      ...n,
      ref: o
    }
  ) });
}), me = s.forwardRef((e, o) => {
  const { forceMount: r, ...n } = e, t = v(g, e.__scopeScrollArea), l = e.orientation === "horizontal", c = X(() => i("SCROLL_END"), 100), [a, i] = fe("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return s.useEffect(() => {
    if (a === "idle") {
      const f = window.setTimeout(() => i("HIDE"), t.scrollHideDelay);
      return () => window.clearTimeout(f);
    }
  }, [a, t.scrollHideDelay, i]), s.useEffect(() => {
    const f = t.viewport, d = l ? "scrollLeft" : "scrollTop";
    if (f) {
      let b = f[d];
      const u = () => {
        const m = f[d];
        b !== m && (i("SCROLL"), c()), b = m;
      };
      return f.addEventListener("scroll", u), () => f.removeEventListener("scroll", u);
    }
  }, [t.viewport, l, i, c]), /* @__PURE__ */ h.jsx(O, { present: r || a !== "hidden", children: /* @__PURE__ */ h.jsx(
    B,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...n,
      ref: o,
      onPointerEnter: C(e.onPointerEnter, () => i("POINTER_ENTER")),
      onPointerLeave: C(e.onPointerLeave, () => i("POINTER_LEAVE"))
    }
  ) });
}), Q = s.forwardRef((e, o) => {
  const r = v(g, e.__scopeScrollArea), { forceMount: n, ...t } = e, [l, c] = s.useState(!1), a = e.orientation === "horizontal", i = X(() => {
    if (r.viewport) {
      const f = r.viewport.offsetWidth < r.viewport.scrollWidth, d = r.viewport.offsetHeight < r.viewport.scrollHeight;
      c(a ? f : d);
    }
  }, 10);
  return E(r.viewport, i), E(r.content, i), /* @__PURE__ */ h.jsx(O, { present: n || l, children: /* @__PURE__ */ h.jsx(
    B,
    {
      "data-state": l ? "visible" : "hidden",
      ...t,
      ref: o
    }
  ) });
}), B = s.forwardRef((e, o) => {
  const { orientation: r = "vertical", ...n } = e, t = v(g, e.__scopeScrollArea), l = s.useRef(null), c = s.useRef(0), [a, i] = s.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), f = te(a.viewport, a.content), d = {
    ...n,
    sizes: a,
    onSizesChange: i,
    hasThumb: f > 0 && f < 1,
    onThumbChange: (u) => l.current = u,
    onThumbPointerUp: () => c.current = 0,
    onThumbPointerDown: (u) => c.current = u
  };
  function b(u, m) {
    return xe(u, c.current, a, m);
  }
  return r === "horizontal" ? /* @__PURE__ */ h.jsx(
    Se,
    {
      ...d,
      ref: o,
      onThumbPositionChange: () => {
        if (t.viewport && l.current) {
          const u = t.viewport.scrollLeft, m = F(u, a, t.dir);
          l.current.style.transform = `translate3d(${m}px, 0, 0)`;
        }
      },
      onWheelScroll: (u) => {
        t.viewport && (t.viewport.scrollLeft = u);
      },
      onDragScroll: (u) => {
        t.viewport && (t.viewport.scrollLeft = b(u, t.dir));
      }
    }
  ) : r === "vertical" ? /* @__PURE__ */ h.jsx(
    pe,
    {
      ...d,
      ref: o,
      onThumbPositionChange: () => {
        if (t.viewport && l.current) {
          const u = t.viewport.scrollTop, m = F(u, a);
          l.current.style.transform = `translate3d(0, ${m}px, 0)`;
        }
      },
      onWheelScroll: (u) => {
        t.viewport && (t.viewport.scrollTop = u);
      },
      onDragScroll: (u) => {
        t.viewport && (t.viewport.scrollTop = b(u));
      }
    }
  ) : null;
}), Se = s.forwardRef((e, o) => {
  const { sizes: r, onSizesChange: n, ...t } = e, l = v(g, e.__scopeScrollArea), [c, a] = s.useState(), i = s.useRef(null), f = A(o, i, l.onScrollbarXChange);
  return s.useEffect(() => {
    i.current && a(getComputedStyle(i.current));
  }, [i]), /* @__PURE__ */ h.jsx(
    ee,
    {
      "data-orientation": "horizontal",
      ...t,
      ref: f,
      sizes: r,
      style: {
        bottom: 0,
        left: l.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: l.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": I(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (d) => e.onThumbPointerDown(d.x),
      onDragScroll: (d) => e.onDragScroll(d.x),
      onWheelScroll: (d, b) => {
        if (l.viewport) {
          const u = l.viewport.scrollLeft + d.deltaX;
          e.onWheelScroll(u), le(u, b) && d.preventDefault();
        }
      },
      onResize: () => {
        i.current && l.viewport && c && n({
          content: l.viewport.scrollWidth,
          viewport: l.viewport.offsetWidth,
          scrollbar: {
            size: i.current.clientWidth,
            paddingStart: z(c.paddingLeft),
            paddingEnd: z(c.paddingRight)
          }
        });
      }
    }
  );
}), pe = s.forwardRef((e, o) => {
  const { sizes: r, onSizesChange: n, ...t } = e, l = v(g, e.__scopeScrollArea), [c, a] = s.useState(), i = s.useRef(null), f = A(o, i, l.onScrollbarYChange);
  return s.useEffect(() => {
    i.current && a(getComputedStyle(i.current));
  }, [i]), /* @__PURE__ */ h.jsx(
    ee,
    {
      "data-orientation": "vertical",
      ...t,
      ref: f,
      sizes: r,
      style: {
        top: 0,
        right: l.dir === "ltr" ? 0 : void 0,
        left: l.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": I(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (d) => e.onThumbPointerDown(d.y),
      onDragScroll: (d) => e.onDragScroll(d.y),
      onWheelScroll: (d, b) => {
        if (l.viewport) {
          const u = l.viewport.scrollTop + d.deltaY;
          e.onWheelScroll(u), le(u, b) && d.preventDefault();
        }
      },
      onResize: () => {
        i.current && l.viewport && c && n({
          content: l.viewport.scrollHeight,
          viewport: l.viewport.offsetHeight,
          scrollbar: {
            size: i.current.clientHeight,
            paddingStart: z(c.paddingTop),
            paddingEnd: z(c.paddingBottom)
          }
        });
      }
    }
  );
}), [ve, Z] = q(g), ee = s.forwardRef((e, o) => {
  const {
    __scopeScrollArea: r,
    sizes: n,
    hasThumb: t,
    onThumbChange: l,
    onThumbPointerUp: c,
    onThumbPointerDown: a,
    onThumbPositionChange: i,
    onDragScroll: f,
    onWheelScroll: d,
    onResize: b,
    ...u
  } = e, m = v(g, r), [p, T] = s.useState(null), Y = A(o, (S) => T(S)), x = s.useRef(null), _ = s.useRef(""), M = m.viewport, D = n.content - n.viewport, j = P(d), y = P(i), N = X(b, 10);
  function W(S) {
    if (x.current) {
      const w = S.clientX - x.current.left, R = S.clientY - x.current.top;
      f({ x: w, y: R });
    }
  }
  return s.useEffect(() => {
    const S = (w) => {
      const R = w.target;
      (p == null ? void 0 : p.contains(R)) && j(w, D);
    };
    return document.addEventListener("wheel", S, { passive: !1 }), () => document.removeEventListener("wheel", S, { passive: !1 });
  }, [M, p, D, j]), s.useEffect(y, [n, y]), E(p, N), E(m.content, N), /* @__PURE__ */ h.jsx(
    ve,
    {
      scope: r,
      scrollbar: p,
      hasThumb: t,
      onThumbChange: P(l),
      onThumbPointerUp: P(c),
      onThumbPositionChange: y,
      onThumbPointerDown: P(a),
      children: /* @__PURE__ */ h.jsx(
        L.div,
        {
          ...u,
          ref: Y,
          style: { position: "absolute", ...u.style },
          onPointerDown: C(e.onPointerDown, (S) => {
            S.button === 0 && (S.target.setPointerCapture(S.pointerId), x.current = p.getBoundingClientRect(), _.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", m.viewport && (m.viewport.style.scrollBehavior = "auto"), W(S));
          }),
          onPointerMove: C(e.onPointerMove, W),
          onPointerUp: C(e.onPointerUp, (S) => {
            const w = S.target;
            w.hasPointerCapture(S.pointerId) && w.releasePointerCapture(S.pointerId), document.body.style.webkitUserSelect = _.current, m.viewport && (m.viewport.style.scrollBehavior = ""), x.current = null;
          })
        }
      )
    }
  );
}), H = "ScrollAreaThumb", re = s.forwardRef(
  (e, o) => {
    const { forceMount: r, ...n } = e, t = Z(H, e.__scopeScrollArea);
    return /* @__PURE__ */ h.jsx(O, { present: r || t.hasThumb, children: /* @__PURE__ */ h.jsx(we, { ref: o, ...n }) });
  }
), we = s.forwardRef(
  (e, o) => {
    const { __scopeScrollArea: r, style: n, ...t } = e, l = v(H, r), c = Z(H, r), { onThumbPositionChange: a } = c, i = A(
      o,
      (b) => c.onThumbChange(b)
    ), f = s.useRef(void 0), d = X(() => {
      f.current && (f.current(), f.current = void 0);
    }, 100);
    return s.useEffect(() => {
      const b = l.viewport;
      if (b) {
        const u = () => {
          if (d(), !f.current) {
            const m = Pe(b, a);
            f.current = m, a();
          }
        };
        return a(), b.addEventListener("scroll", u), () => b.removeEventListener("scroll", u);
      }
    }, [l.viewport, d, a]), /* @__PURE__ */ h.jsx(
      L.div,
      {
        "data-state": c.hasThumb ? "visible" : "hidden",
        ...t,
        ref: i,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n
        },
        onPointerDownCapture: C(e.onPointerDownCapture, (b) => {
          const m = b.target.getBoundingClientRect(), p = b.clientX - m.left, T = b.clientY - m.top;
          c.onThumbPointerDown({ x: p, y: T });
        }),
        onPointerUp: C(e.onPointerUp, c.onThumbPointerUp)
      }
    );
  }
);
re.displayName = H;
var k = "ScrollAreaCorner", oe = s.forwardRef(
  (e, o) => {
    const r = v(k, e.__scopeScrollArea), n = !!(r.scrollbarX && r.scrollbarY);
    return r.type !== "scroll" && n ? /* @__PURE__ */ h.jsx(ge, { ...e, ref: o }) : null;
  }
);
oe.displayName = k;
var ge = s.forwardRef((e, o) => {
  const { __scopeScrollArea: r, ...n } = e, t = v(k, r), [l, c] = s.useState(0), [a, i] = s.useState(0), f = !!(l && a);
  return E(t.scrollbarX, () => {
    var b;
    const d = ((b = t.scrollbarX) == null ? void 0 : b.offsetHeight) || 0;
    t.onCornerHeightChange(d), i(d);
  }), E(t.scrollbarY, () => {
    var b;
    const d = ((b = t.scrollbarY) == null ? void 0 : b.offsetWidth) || 0;
    t.onCornerWidthChange(d), c(d);
  }), f ? /* @__PURE__ */ h.jsx(
    L.div,
    {
      ...n,
      ref: o,
      style: {
        width: l,
        height: a,
        position: "absolute",
        right: t.dir === "ltr" ? 0 : void 0,
        left: t.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function z(e) {
  return e ? parseInt(e, 10) : 0;
}
function te(e, o) {
  const r = e / o;
  return isNaN(r) ? 0 : r;
}
function I(e) {
  const o = te(e.viewport, e.content), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, n = (e.scrollbar.size - r) * o;
  return Math.max(n, 18);
}
function xe(e, o, r, n = "ltr") {
  const t = I(r), l = t / 2, c = o || l, a = t - c, i = r.scrollbar.paddingStart + c, f = r.scrollbar.size - r.scrollbar.paddingEnd - a, d = r.content - r.viewport, b = n === "ltr" ? [0, d] : [d * -1, 0];
  return ne([i, f], b)(e);
}
function F(e, o, r = "ltr") {
  const n = I(o), t = o.scrollbar.paddingStart + o.scrollbar.paddingEnd, l = o.scrollbar.size - t, c = o.content - o.viewport, a = l - n, i = r === "ltr" ? [0, c] : [c * -1, 0], f = ue(e, i);
  return ne([0, c], [0, a])(f);
}
function ne(e, o) {
  return (r) => {
    if (e[0] === e[1] || o[0] === o[1]) return o[0];
    const n = (o[1] - o[0]) / (e[1] - e[0]);
    return o[0] + n * (r - e[0]);
  };
}
function le(e, o) {
  return e > 0 && e < o;
}
var Pe = (e, o = () => {
}) => {
  let r = { left: e.scrollLeft, top: e.scrollTop }, n = 0;
  return function t() {
    const l = { left: e.scrollLeft, top: e.scrollTop }, c = r.left !== l.left, a = r.top !== l.top;
    (c || a) && o(), r = l, n = window.requestAnimationFrame(t);
  }(), () => window.cancelAnimationFrame(n);
};
function X(e, o) {
  const r = P(e), n = s.useRef(0);
  return s.useEffect(() => () => window.clearTimeout(n.current), []), s.useCallback(() => {
    window.clearTimeout(n.current), n.current = window.setTimeout(r, o);
  }, [r, o]);
}
function E(e, o) {
  const r = P(o);
  ie(() => {
    let n = 0;
    if (e) {
      const t = new ResizeObserver(() => {
        cancelAnimationFrame(n), n = window.requestAnimationFrame(r);
      });
      return t.observe(e), () => {
        window.cancelAnimationFrame(n), t.unobserve(e);
      };
    }
  }, [e, r]);
}
var se = G, Ce = K, Re = oe;
const Ee = s.forwardRef(({ className: e, children: o, ...r }, n) => /* @__PURE__ */ h.jsxs(
  se,
  {
    ref: n,
    className: $("relative overflow-auto", e),
    ...r,
    children: [
      /* @__PURE__ */ h.jsx(Ce, { className: "h-full w-full rounded-[inherit]", children: o }),
      /* @__PURE__ */ h.jsx(ce, {}),
      /* @__PURE__ */ h.jsx(Re, {})
    ]
  }
));
Ee.displayName = se.displayName;
const ce = s.forwardRef(({ className: e, orientation: o = "vertical", ...r }, n) => /* @__PURE__ */ h.jsx(
  V,
  {
    ref: n,
    orientation: o,
    className: $(
      "flex touch-none transition-colors select-none",
      o === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      o === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      e
    ),
    ...r,
    children: /* @__PURE__ */ h.jsx(re, { className: "bg-border relative flex-1 rounded-full" })
  }
));
ce.displayName = V.displayName;
export {
  Ee as S,
  ce as a
};
