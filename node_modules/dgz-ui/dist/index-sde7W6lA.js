import * as i from "react";
import { P as R, c as p } from "./index-D_OzDH1f.js";
import { u as _, c as B } from "./index-l1ZGtt0d.js";
import { c as H, a as V } from "./index-Dmh__Tgi.js";
import { u as q, a as C } from "./index-rSIGk0ww.js";
import { D as K } from "./index-DqTIeHVj.js";
import { P as U, R as Y, h as Z, u as z, F as J } from "./index-By7yjsdy.js";
import { P as D } from "./index-Do92jweN.js";
import { j as s } from "./jsx-runtime-C5mzlN2N.js";
var v = "Dialog", [y, De] = H(v), [Q, u] = y(v), N = (e) => {
  const {
    __scopeDialog: o,
    children: r,
    open: a,
    defaultOpen: n,
    onOpenChange: t,
    modal: c = !0
  } = e, l = i.useRef(null), d = i.useRef(null), [g, x] = q({
    prop: a,
    defaultProp: n ?? !1,
    onChange: t,
    caller: v
  });
  return /* @__PURE__ */ s.jsx(
    Q,
    {
      scope: o,
      triggerRef: l,
      contentRef: d,
      contentId: C(),
      titleId: C(),
      descriptionId: C(),
      open: g,
      onOpenChange: x,
      onOpenToggle: i.useCallback(() => x(($) => !$), [x]),
      modal: c,
      children: r
    }
  );
};
N.displayName = v;
var O = "DialogTrigger", I = i.forwardRef(
  (e, o) => {
    const { __scopeDialog: r, ...a } = e, n = u(O, r), t = _(o, n.triggerRef);
    return /* @__PURE__ */ s.jsx(
      D.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": n.open,
        "aria-controls": n.contentId,
        "data-state": P(n.open),
        ...a,
        ref: t,
        onClick: p(e.onClick, n.onOpenToggle)
      }
    );
  }
);
I.displayName = O;
var h = "DialogPortal", [X, A] = y(h, {
  forceMount: void 0
}), T = (e) => {
  const { __scopeDialog: o, forceMount: r, children: a, container: n } = e, t = u(h, o);
  return /* @__PURE__ */ s.jsx(X, { scope: o, forceMount: r, children: i.Children.map(a, (c) => /* @__PURE__ */ s.jsx(R, { present: r || t.open, children: /* @__PURE__ */ s.jsx(U, { asChild: !0, container: n, children: c }) })) });
};
T.displayName = h;
var m = "DialogOverlay", j = i.forwardRef(
  (e, o) => {
    const r = A(m, e.__scopeDialog), { forceMount: a = r.forceMount, ...n } = e, t = u(m, e.__scopeDialog);
    return t.modal ? /* @__PURE__ */ s.jsx(R, { present: a || t.open, children: /* @__PURE__ */ s.jsx(te, { ...n, ref: o }) }) : null;
  }
);
j.displayName = m;
var ee = B("DialogOverlay.RemoveScroll"), te = i.forwardRef(
  (e, o) => {
    const { __scopeDialog: r, ...a } = e, n = u(m, r);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ s.jsx(Y, { as: ee, allowPinchZoom: !0, shards: [n.contentRef], children: /* @__PURE__ */ s.jsx(
        D.div,
        {
          "data-state": P(n.open),
          ...a,
          ref: o,
          style: { pointerEvents: "auto", ...a.style }
        }
      ) })
    );
  }
), f = "DialogContent", b = i.forwardRef(
  (e, o) => {
    const r = A(f, e.__scopeDialog), { forceMount: a = r.forceMount, ...n } = e, t = u(f, e.__scopeDialog);
    return /* @__PURE__ */ s.jsx(R, { present: a || t.open, children: t.modal ? /* @__PURE__ */ s.jsx(oe, { ...n, ref: o }) : /* @__PURE__ */ s.jsx(ne, { ...n, ref: o }) });
  }
);
b.displayName = f;
var oe = i.forwardRef(
  (e, o) => {
    const r = u(f, e.__scopeDialog), a = i.useRef(null), n = _(o, r.contentRef, a);
    return i.useEffect(() => {
      const t = a.current;
      if (t) return Z(t);
    }, []), /* @__PURE__ */ s.jsx(
      M,
      {
        ...e,
        ref: n,
        trapFocus: r.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: p(e.onCloseAutoFocus, (t) => {
          var c;
          t.preventDefault(), (c = r.triggerRef.current) == null || c.focus();
        }),
        onPointerDownOutside: p(e.onPointerDownOutside, (t) => {
          const c = t.detail.originalEvent, l = c.button === 0 && c.ctrlKey === !0;
          (c.button === 2 || l) && t.preventDefault();
        }),
        onFocusOutside: p(
          e.onFocusOutside,
          (t) => t.preventDefault()
        )
      }
    );
  }
), ne = i.forwardRef(
  (e, o) => {
    const r = u(f, e.__scopeDialog), a = i.useRef(!1), n = i.useRef(!1);
    return /* @__PURE__ */ s.jsx(
      M,
      {
        ...e,
        ref: o,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (t) => {
          var c, l;
          (c = e.onCloseAutoFocus) == null || c.call(e, t), t.defaultPrevented || (a.current || (l = r.triggerRef.current) == null || l.focus(), t.preventDefault()), a.current = !1, n.current = !1;
        },
        onInteractOutside: (t) => {
          var d, g;
          (d = e.onInteractOutside) == null || d.call(e, t), t.defaultPrevented || (a.current = !0, t.detail.originalEvent.type === "pointerdown" && (n.current = !0));
          const c = t.target;
          ((g = r.triggerRef.current) == null ? void 0 : g.contains(c)) && t.preventDefault(), t.detail.originalEvent.type === "focusin" && n.current && t.preventDefault();
        }
      }
    );
  }
), M = i.forwardRef(
  (e, o) => {
    const { __scopeDialog: r, trapFocus: a, onOpenAutoFocus: n, onCloseAutoFocus: t, ...c } = e, l = u(f, r), d = i.useRef(null), g = _(o, d);
    return z(), /* @__PURE__ */ s.jsxs(s.Fragment, { children: [
      /* @__PURE__ */ s.jsx(
        J,
        {
          asChild: !0,
          loop: !0,
          trapped: a,
          onMountAutoFocus: n,
          onUnmountAutoFocus: t,
          children: /* @__PURE__ */ s.jsx(
            K,
            {
              role: "dialog",
              id: l.contentId,
              "aria-describedby": l.descriptionId,
              "aria-labelledby": l.titleId,
              "data-state": P(l.open),
              ...c,
              ref: g,
              onDismiss: () => l.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ s.jsxs(s.Fragment, { children: [
        /* @__PURE__ */ s.jsx(re, { titleId: l.titleId }),
        /* @__PURE__ */ s.jsx(se, { contentRef: d, descriptionId: l.descriptionId })
      ] })
    ] });
  }
), E = "DialogTitle", F = i.forwardRef(
  (e, o) => {
    const { __scopeDialog: r, ...a } = e, n = u(E, r);
    return /* @__PURE__ */ s.jsx(D.h2, { id: n.titleId, ...a, ref: o });
  }
);
F.displayName = E;
var w = "DialogDescription", S = i.forwardRef(
  (e, o) => {
    const { __scopeDialog: r, ...a } = e, n = u(w, r);
    return /* @__PURE__ */ s.jsx(D.p, { id: n.descriptionId, ...a, ref: o });
  }
);
S.displayName = w;
var W = "DialogClose", k = i.forwardRef(
  (e, o) => {
    const { __scopeDialog: r, ...a } = e, n = u(W, r);
    return /* @__PURE__ */ s.jsx(
      D.button,
      {
        type: "button",
        ...a,
        ref: o,
        onClick: p(e.onClick, () => n.onOpenChange(!1))
      }
    );
  }
);
k.displayName = W;
function P(e) {
  return e ? "open" : "closed";
}
var G = "DialogTitleWarning", [me, L] = V(G, {
  contentName: f,
  titleName: E,
  docsSlug: "dialog"
}), re = ({ titleId: e }) => {
  const o = L(G), r = `\`${o.contentName}\` requires a \`${o.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${o.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${o.docsSlug}`;
  return i.useEffect(() => {
    e && (document.getElementById(e) || console.error(r));
  }, [r, e]), null;
}, ae = "DialogDescriptionWarning", se = ({ contentRef: e, descriptionId: o }) => {
  const a = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${L(ae).contentName}}.`;
  return i.useEffect(() => {
    var t;
    const n = (t = e.current) == null ? void 0 : t.getAttribute("aria-describedby");
    o && n && (document.getElementById(o) || console.warn(a));
  }, [a, e, o]), null;
}, ve = N, xe = I, Ce = T, Re = j, _e = b, he = F, Ee = S, Pe = k;
export {
  Pe as C,
  Ee as D,
  Re as O,
  Ce as P,
  ve as R,
  xe as T,
  me as W,
  _e as a,
  he as b,
  De as c
};
