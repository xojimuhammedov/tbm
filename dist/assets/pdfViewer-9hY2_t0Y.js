var Ya = Object.defineProperty;
var Mi = (t) => {
  throw TypeError(t);
};
var Za = (t, A, n) =>
  A in t
    ? Ya(t, A, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (t[A] = n);
var $t = (t, A, n) => Za(t, typeof A != "symbol" ? A + "" : A, n),
  Tr = (t, A, n) => A.has(t) || Mi("Cannot " + n);
var l = (t, A, n) => (
    Tr(t, A, "read from private field"),
    n ? n.call(t) : A.get(t)
  ),
  ye = (t, A, n) =>
    A.has(t)
      ? Mi("Cannot add the same private member more than once")
      : A instanceof WeakSet
        ? A.add(t)
        : A.set(t, n),
  Se = (t, A, n, w) => (
    Tr(t, A, "write to private field"),
    w ? w.call(t, n) : A.set(t, n),
    n
  ),
  le = (t, A, n) => (Tr(t, A, "access private method"), n);
var Hn = (t, A, n, w) => ({
  set _(S) {
    Se(t, A, S, n);
  },
  get _() {
    return l(t, A, w);
  },
});
import {
  Z as getAugmentedNamespace,
  _ as requireReact,
  $ as requireReactDom,
  j as jsxRuntimeExports,
} from "./index-ADhmmBpU.js";
var lib$h = { exports: {} },
  core_min = {};
function commonjsRequire(t) {
  throw new Error(
    'Could not dynamically require "' +
      t +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.',
  );
}
var pdf = { exports: {} };
const __viteBrowserExternal = {},
  __viteBrowserExternal$1 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: __viteBrowserExternal },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  require$$5 = getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredPdf;
function requirePdf() {
  return (
    hasRequiredPdf ||
      ((hasRequiredPdf = 1),
      (function (module, exports) {
        (function (A, n) {
          module.exports = A.pdfjsLib = n();
        })(globalThis, () =>
          (() => {
            var __webpack_modules__ = [
                ,
                (t, A) => {
                  var kt;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.VerbosityLevel =
                      A.Util =
                      A.UnknownErrorException =
                      A.UnexpectedResponseException =
                      A.TextRenderingMode =
                      A.RenderingIntentFlag =
                      A.PromiseCapability =
                      A.PermissionFlag =
                      A.PasswordResponses =
                      A.PasswordException =
                      A.PageActionEventType =
                      A.OPS =
                      A.MissingPDFException =
                      A.MAX_IMAGE_SIZE_TO_CACHE =
                      A.LINE_FACTOR =
                      A.LINE_DESCENT_FACTOR =
                      A.InvalidPDFException =
                      A.ImageKind =
                      A.IDENTITY_MATRIX =
                      A.FormatError =
                      A.FeatureTest =
                      A.FONT_IDENTITY_MATRIX =
                      A.DocumentActionEventType =
                      A.CMapCompressionType =
                      A.BaseException =
                      A.BASELINE_FACTOR =
                      A.AnnotationType =
                      A.AnnotationReplyType =
                      A.AnnotationPrefix =
                      A.AnnotationMode =
                      A.AnnotationFlag =
                      A.AnnotationFieldFlag =
                      A.AnnotationEditorType =
                      A.AnnotationEditorPrefix =
                      A.AnnotationEditorParamsType =
                      A.AnnotationBorderStyleType =
                      A.AnnotationActionEventType =
                      A.AbortException =
                        void 0),
                    (A.assert = L),
                    (A.bytesToString = we),
                    (A.createValidAbsoluteUrl = Y),
                    (A.getModificationDate = Ie),
                    (A.getUuid = Je),
                    (A.getVerbosityLevel = M),
                    (A.info = D),
                    (A.isArrayBuffer = se),
                    (A.isArrayEqual = je),
                    (A.isNodeJS = void 0),
                    (A.normalizeUnicode = ze),
                    (A.objectFromMap = Re),
                    (A.objectSize = xe),
                    (A.setVerbosityLevel = B),
                    (A.shadow = T),
                    (A.string32 = Ce),
                    (A.stringToBytes = Ee),
                    (A.stringToPDFString = he),
                    (A.stringToUTF8String = Pe),
                    (A.unreachable = z),
                    (A.utf8StringToString = Me),
                    (A.warn = x));
                  const n =
                    typeof process == "object" &&
                    process + "" == "[object process]" &&
                    !process.versions.nw &&
                    !(
                      process.versions.electron &&
                      process.type &&
                      process.type !== "browser"
                    );
                  A.isNodeJS = n;
                  const w = [1, 0, 0, 1, 0, 0];
                  A.IDENTITY_MATRIX = w;
                  const S = [0.001, 0, 0, 0.001, 0, 0];
                  A.FONT_IDENTITY_MATRIX = S;
                  const i = 1e7;
                  A.MAX_IMAGE_SIZE_TO_CACHE = i;
                  const H = 1.35;
                  A.LINE_FACTOR = H;
                  const ee = 0.35;
                  A.LINE_DESCENT_FACTOR = ee;
                  const X = ee / H;
                  A.BASELINE_FACTOR = X;
                  const W = {
                    ANY: 1,
                    DISPLAY: 2,
                    PRINT: 4,
                    SAVE: 8,
                    ANNOTATIONS_FORMS: 16,
                    ANNOTATIONS_STORAGE: 32,
                    ANNOTATIONS_DISABLE: 64,
                    OPLIST: 256,
                  };
                  A.RenderingIntentFlag = W;
                  const k = {
                    DISABLE: 0,
                    ENABLE: 1,
                    ENABLE_FORMS: 2,
                    ENABLE_STORAGE: 3,
                  };
                  A.AnnotationMode = k;
                  const N = "pdfjs_internal_editor_";
                  A.AnnotationEditorPrefix = N;
                  const P = {
                    DISABLE: -1,
                    NONE: 0,
                    FREETEXT: 3,
                    STAMP: 13,
                    INK: 15,
                  };
                  A.AnnotationEditorType = P;
                  const _ = {
                    RESIZE: 1,
                    CREATE: 2,
                    FREETEXT_SIZE: 11,
                    FREETEXT_COLOR: 12,
                    FREETEXT_OPACITY: 13,
                    INK_COLOR: 21,
                    INK_THICKNESS: 22,
                    INK_OPACITY: 23,
                  };
                  A.AnnotationEditorParamsType = _;
                  const h = {
                    PRINT: 4,
                    MODIFY_CONTENTS: 8,
                    COPY: 16,
                    MODIFY_ANNOTATIONS: 32,
                    FILL_INTERACTIVE_FORMS: 256,
                    COPY_FOR_ACCESSIBILITY: 512,
                    ASSEMBLE: 1024,
                    PRINT_HIGH_QUALITY: 2048,
                  };
                  A.PermissionFlag = h;
                  const r = {
                    FILL: 0,
                    STROKE: 1,
                    FILL_STROKE: 2,
                    INVISIBLE: 3,
                    FILL_ADD_TO_PATH: 4,
                    STROKE_ADD_TO_PATH: 5,
                    FILL_STROKE_ADD_TO_PATH: 6,
                    ADD_TO_PATH: 7,
                    FILL_STROKE_MASK: 3,
                    ADD_TO_PATH_FLAG: 4,
                  };
                  A.TextRenderingMode = r;
                  const d = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 };
                  A.ImageKind = d;
                  const p = {
                    TEXT: 1,
                    LINK: 2,
                    FREETEXT: 3,
                    LINE: 4,
                    SQUARE: 5,
                    CIRCLE: 6,
                    POLYGON: 7,
                    POLYLINE: 8,
                    HIGHLIGHT: 9,
                    UNDERLINE: 10,
                    SQUIGGLY: 11,
                    STRIKEOUT: 12,
                    STAMP: 13,
                    CARET: 14,
                    INK: 15,
                    POPUP: 16,
                    FILEATTACHMENT: 17,
                    SOUND: 18,
                    MOVIE: 19,
                    WIDGET: 20,
                    SCREEN: 21,
                    PRINTERMARK: 22,
                    TRAPNET: 23,
                    WATERMARK: 24,
                    THREED: 25,
                    REDACT: 26,
                  };
                  A.AnnotationType = p;
                  const u = { GROUP: "Group", REPLY: "R" };
                  A.AnnotationReplyType = u;
                  const F = {
                    INVISIBLE: 1,
                    HIDDEN: 2,
                    PRINT: 4,
                    NOZOOM: 8,
                    NOROTATE: 16,
                    NOVIEW: 32,
                    READONLY: 64,
                    LOCKED: 128,
                    TOGGLENOVIEW: 256,
                    LOCKEDCONTENTS: 512,
                  };
                  A.AnnotationFlag = F;
                  const v = {
                    READONLY: 1,
                    REQUIRED: 2,
                    NOEXPORT: 4,
                    MULTILINE: 4096,
                    PASSWORD: 8192,
                    NOTOGGLETOOFF: 16384,
                    RADIO: 32768,
                    PUSHBUTTON: 65536,
                    COMBO: 131072,
                    EDIT: 262144,
                    SORT: 524288,
                    FILESELECT: 1048576,
                    MULTISELECT: 2097152,
                    DONOTSPELLCHECK: 4194304,
                    DONOTSCROLL: 8388608,
                    COMB: 16777216,
                    RICHTEXT: 33554432,
                    RADIOSINUNISON: 33554432,
                    COMMITONSELCHANGE: 67108864,
                  };
                  A.AnnotationFieldFlag = v;
                  const f = {
                    SOLID: 1,
                    DASHED: 2,
                    BEVELED: 3,
                    INSET: 4,
                    UNDERLINE: 5,
                  };
                  A.AnnotationBorderStyleType = f;
                  const b = {
                    E: "Mouse Enter",
                    X: "Mouse Exit",
                    D: "Mouse Down",
                    U: "Mouse Up",
                    Fo: "Focus",
                    Bl: "Blur",
                    PO: "PageOpen",
                    PC: "PageClose",
                    PV: "PageVisible",
                    PI: "PageInvisible",
                    K: "Keystroke",
                    F: "Format",
                    V: "Validate",
                    C: "Calculate",
                  };
                  A.AnnotationActionEventType = b;
                  const c = {
                    WC: "WillClose",
                    WS: "WillSave",
                    DS: "DidSave",
                    WP: "WillPrint",
                    DP: "DidPrint",
                  };
                  A.DocumentActionEventType = c;
                  const a = { O: "PageOpen", C: "PageClose" };
                  A.PageActionEventType = a;
                  const m = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
                  A.VerbosityLevel = m;
                  const C = { NONE: 0, BINARY: 1 };
                  A.CMapCompressionType = C;
                  const e = {
                    dependency: 1,
                    setLineWidth: 2,
                    setLineCap: 3,
                    setLineJoin: 4,
                    setMiterLimit: 5,
                    setDash: 6,
                    setRenderingIntent: 7,
                    setFlatness: 8,
                    setGState: 9,
                    save: 10,
                    restore: 11,
                    transform: 12,
                    moveTo: 13,
                    lineTo: 14,
                    curveTo: 15,
                    curveTo2: 16,
                    curveTo3: 17,
                    closePath: 18,
                    rectangle: 19,
                    stroke: 20,
                    closeStroke: 21,
                    fill: 22,
                    eoFill: 23,
                    fillStroke: 24,
                    eoFillStroke: 25,
                    closeFillStroke: 26,
                    closeEOFillStroke: 27,
                    endPath: 28,
                    clip: 29,
                    eoClip: 30,
                    beginText: 31,
                    endText: 32,
                    setCharSpacing: 33,
                    setWordSpacing: 34,
                    setHScale: 35,
                    setLeading: 36,
                    setFont: 37,
                    setTextRenderingMode: 38,
                    setTextRise: 39,
                    moveText: 40,
                    setLeadingMoveText: 41,
                    setTextMatrix: 42,
                    nextLine: 43,
                    showText: 44,
                    showSpacedText: 45,
                    nextLineShowText: 46,
                    nextLineSetSpacingShowText: 47,
                    setCharWidth: 48,
                    setCharWidthAndBounds: 49,
                    setStrokeColorSpace: 50,
                    setFillColorSpace: 51,
                    setStrokeColor: 52,
                    setStrokeColorN: 53,
                    setFillColor: 54,
                    setFillColorN: 55,
                    setStrokeGray: 56,
                    setFillGray: 57,
                    setStrokeRGBColor: 58,
                    setFillRGBColor: 59,
                    setStrokeCMYKColor: 60,
                    setFillCMYKColor: 61,
                    shadingFill: 62,
                    beginInlineImage: 63,
                    beginImageData: 64,
                    endInlineImage: 65,
                    paintXObject: 66,
                    markPoint: 67,
                    markPointProps: 68,
                    beginMarkedContent: 69,
                    beginMarkedContentProps: 70,
                    endMarkedContent: 71,
                    beginCompat: 72,
                    endCompat: 73,
                    paintFormXObjectBegin: 74,
                    paintFormXObjectEnd: 75,
                    beginGroup: 76,
                    endGroup: 77,
                    beginAnnotation: 80,
                    endAnnotation: 81,
                    paintImageMaskXObject: 83,
                    paintImageMaskXObjectGroup: 84,
                    paintImageXObject: 85,
                    paintInlineImageXObject: 86,
                    paintInlineImageXObjectGroup: 87,
                    paintImageXObjectRepeat: 88,
                    paintImageMaskXObjectRepeat: 89,
                    paintSolidColorImageMask: 90,
                    constructPath: 91,
                  };
                  A.OPS = e;
                  const o = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
                  A.PasswordResponses = o;
                  let y = m.WARNINGS;
                  function B(Le) {
                    Number.isInteger(Le) && (y = Le);
                  }
                  function M() {
                    return y;
                  }
                  function D(Le) {
                    y >= m.INFOS && console.log(`Info: ${Le}`);
                  }
                  function x(Le) {
                    y >= m.WARNINGS && console.log(`Warning: ${Le}`);
                  }
                  function z(Le) {
                    throw new Error(Le);
                  }
                  function L(Le, pe) {
                    Le || z(pe);
                  }
                  function V(Le) {
                    switch (Le == null ? void 0 : Le.protocol) {
                      case "http:":
                      case "https:":
                      case "ftp:":
                      case "mailto:":
                      case "tel:":
                        return !0;
                      default:
                        return !1;
                    }
                  }
                  function Y(Le, pe = null, me = null) {
                    if (!Le) return null;
                    try {
                      if (me && typeof Le == "string") {
                        if (me.addDefaultProtocol && Le.startsWith("www.")) {
                          const Ye = Le.match(/\./g);
                          (Ye == null ? void 0 : Ye.length) >= 2 &&
                            (Le = `http://${Le}`);
                        }
                        if (me.tryConvertEncoding)
                          try {
                            Le = Pe(Le);
                          } catch {}
                      }
                      const Xe = pe ? new URL(Le, pe) : new URL(Le);
                      if (V(Xe)) return Xe;
                    } catch {}
                    return null;
                  }
                  function T(Le, pe, me, Xe = !1) {
                    return (
                      Object.defineProperty(Le, pe, {
                        value: me,
                        enumerable: !Xe,
                        configurable: !0,
                        writable: !1,
                      }),
                      me
                    );
                  }
                  const s = (function () {
                    function pe(me, Xe) {
                      (this.constructor === pe &&
                        z("Cannot initialize BaseException."),
                        (this.message = me),
                        (this.name = Xe));
                    }
                    return (
                      (pe.prototype = new Error()),
                      (pe.constructor = pe),
                      pe
                    );
                  })();
                  A.BaseException = s;
                  class g extends s {
                    constructor(pe, me) {
                      (super(pe, "PasswordException"), (this.code = me));
                    }
                  }
                  A.PasswordException = g;
                  class R extends s {
                    constructor(pe, me) {
                      (super(pe, "UnknownErrorException"), (this.details = me));
                    }
                  }
                  A.UnknownErrorException = R;
                  class $ extends s {
                    constructor(pe) {
                      super(pe, "InvalidPDFException");
                    }
                  }
                  A.InvalidPDFException = $;
                  class j extends s {
                    constructor(pe) {
                      super(pe, "MissingPDFException");
                    }
                  }
                  A.MissingPDFException = j;
                  class U extends s {
                    constructor(pe, me) {
                      (super(pe, "UnexpectedResponseException"),
                        (this.status = me));
                    }
                  }
                  A.UnexpectedResponseException = U;
                  class Q extends s {
                    constructor(pe) {
                      super(pe, "FormatError");
                    }
                  }
                  A.FormatError = Q;
                  class fe extends s {
                    constructor(pe) {
                      super(pe, "AbortException");
                    }
                  }
                  A.AbortException = fe;
                  function we(Le) {
                    (typeof Le != "object" ||
                      (Le == null ? void 0 : Le.length) === void 0) &&
                      z("Invalid argument for bytesToString");
                    const pe = Le.length,
                      me = 8192;
                    if (pe < me) return String.fromCharCode.apply(null, Le);
                    const Xe = [];
                    for (let Ye = 0; Ye < pe; Ye += me) {
                      const ot = Math.min(Ye + me, pe),
                        Z = Le.subarray(Ye, ot);
                      Xe.push(String.fromCharCode.apply(null, Z));
                    }
                    return Xe.join("");
                  }
                  function Ee(Le) {
                    typeof Le != "string" &&
                      z("Invalid argument for stringToBytes");
                    const pe = Le.length,
                      me = new Uint8Array(pe);
                    for (let Xe = 0; Xe < pe; ++Xe)
                      me[Xe] = Le.charCodeAt(Xe) & 255;
                    return me;
                  }
                  function Ce(Le) {
                    return String.fromCharCode(
                      (Le >> 24) & 255,
                      (Le >> 16) & 255,
                      (Le >> 8) & 255,
                      Le & 255,
                    );
                  }
                  function xe(Le) {
                    return Object.keys(Le).length;
                  }
                  function Re(Le) {
                    const pe = Object.create(null);
                    for (const [me, Xe] of Le) pe[me] = Xe;
                    return pe;
                  }
                  function ue() {
                    const Le = new Uint8Array(4);
                    return (
                      (Le[0] = 1),
                      new Uint32Array(Le.buffer, 0, 1)[0] === 1
                    );
                  }
                  function de() {
                    try {
                      return (new Function(""), !0);
                    } catch {
                      return !1;
                    }
                  }
                  class I {
                    static get isLittleEndian() {
                      return T(this, "isLittleEndian", ue());
                    }
                    static get isEvalSupported() {
                      return T(this, "isEvalSupported", de());
                    }
                    static get isOffscreenCanvasSupported() {
                      return T(
                        this,
                        "isOffscreenCanvasSupported",
                        typeof OffscreenCanvas < "u",
                      );
                    }
                    static get platform() {
                      return typeof navigator > "u"
                        ? T(this, "platform", { isWin: !1, isMac: !1 })
                        : T(this, "platform", {
                            isWin: navigator.platform.includes("Win"),
                            isMac: navigator.platform.includes("Mac"),
                          });
                    }
                    static get isCSSRoundSupported() {
                      var pe, me;
                      return T(
                        this,
                        "isCSSRoundSupported",
                        (me =
                          (pe = globalThis.CSS) == null
                            ? void 0
                            : pe.supports) == null
                          ? void 0
                          : me.call(pe, "width: round(1.5px, 1px)"),
                      );
                    }
                  }
                  A.FeatureTest = I;
                  const q = [...Array(256).keys()].map((Le) =>
                    Le.toString(16).padStart(2, "0"),
                  );
                  class ie {
                    static makeHexColor(pe, me, Xe) {
                      return `#${q[pe]}${q[me]}${q[Xe]}`;
                    }
                    static scaleMinMax(pe, me) {
                      let Xe;
                      (pe[0]
                        ? (pe[0] < 0 &&
                            ((Xe = me[0]), (me[0] = me[1]), (me[1] = Xe)),
                          (me[0] *= pe[0]),
                          (me[1] *= pe[0]),
                          pe[3] < 0 &&
                            ((Xe = me[2]), (me[2] = me[3]), (me[3] = Xe)),
                          (me[2] *= pe[3]),
                          (me[3] *= pe[3]))
                        : ((Xe = me[0]),
                          (me[0] = me[2]),
                          (me[2] = Xe),
                          (Xe = me[1]),
                          (me[1] = me[3]),
                          (me[3] = Xe),
                          pe[1] < 0 &&
                            ((Xe = me[2]), (me[2] = me[3]), (me[3] = Xe)),
                          (me[2] *= pe[1]),
                          (me[3] *= pe[1]),
                          pe[2] < 0 &&
                            ((Xe = me[0]), (me[0] = me[1]), (me[1] = Xe)),
                          (me[0] *= pe[2]),
                          (me[1] *= pe[2])),
                        (me[0] += pe[4]),
                        (me[1] += pe[4]),
                        (me[2] += pe[5]),
                        (me[3] += pe[5]));
                    }
                    static transform(pe, me) {
                      return [
                        pe[0] * me[0] + pe[2] * me[1],
                        pe[1] * me[0] + pe[3] * me[1],
                        pe[0] * me[2] + pe[2] * me[3],
                        pe[1] * me[2] + pe[3] * me[3],
                        pe[0] * me[4] + pe[2] * me[5] + pe[4],
                        pe[1] * me[4] + pe[3] * me[5] + pe[5],
                      ];
                    }
                    static applyTransform(pe, me) {
                      const Xe = pe[0] * me[0] + pe[1] * me[2] + me[4],
                        Ye = pe[0] * me[1] + pe[1] * me[3] + me[5];
                      return [Xe, Ye];
                    }
                    static applyInverseTransform(pe, me) {
                      const Xe = me[0] * me[3] - me[1] * me[2],
                        Ye =
                          (pe[0] * me[3] -
                            pe[1] * me[2] +
                            me[2] * me[5] -
                            me[4] * me[3]) /
                          Xe,
                        ot =
                          (-pe[0] * me[1] +
                            pe[1] * me[0] +
                            me[4] * me[1] -
                            me[5] * me[0]) /
                          Xe;
                      return [Ye, ot];
                    }
                    static getAxialAlignedBoundingBox(pe, me) {
                      const Xe = this.applyTransform(pe, me),
                        Ye = this.applyTransform(pe.slice(2, 4), me),
                        ot = this.applyTransform([pe[0], pe[3]], me),
                        Z = this.applyTransform([pe[2], pe[1]], me);
                      return [
                        Math.min(Xe[0], Ye[0], ot[0], Z[0]),
                        Math.min(Xe[1], Ye[1], ot[1], Z[1]),
                        Math.max(Xe[0], Ye[0], ot[0], Z[0]),
                        Math.max(Xe[1], Ye[1], ot[1], Z[1]),
                      ];
                    }
                    static inverseTransform(pe) {
                      const me = pe[0] * pe[3] - pe[1] * pe[2];
                      return [
                        pe[3] / me,
                        -pe[1] / me,
                        -pe[2] / me,
                        pe[0] / me,
                        (pe[2] * pe[5] - pe[4] * pe[3]) / me,
                        (pe[4] * pe[1] - pe[5] * pe[0]) / me,
                      ];
                    }
                    static singularValueDecompose2dScale(pe) {
                      const me = [pe[0], pe[2], pe[1], pe[3]],
                        Xe = pe[0] * me[0] + pe[1] * me[2],
                        Ye = pe[0] * me[1] + pe[1] * me[3],
                        ot = pe[2] * me[0] + pe[3] * me[2],
                        Z = pe[2] * me[1] + pe[3] * me[3],
                        Te = (Xe + Z) / 2,
                        He =
                          Math.sqrt((Xe + Z) ** 2 - 4 * (Xe * Z - ot * Ye)) / 2,
                        Ze = Te + He || 1,
                        tt = Te - He || 1;
                      return [Math.sqrt(Ze), Math.sqrt(tt)];
                    }
                    static normalizeRect(pe) {
                      const me = pe.slice(0);
                      return (
                        pe[0] > pe[2] && ((me[0] = pe[2]), (me[2] = pe[0])),
                        pe[1] > pe[3] && ((me[1] = pe[3]), (me[3] = pe[1])),
                        me
                      );
                    }
                    static intersect(pe, me) {
                      const Xe = Math.max(
                          Math.min(pe[0], pe[2]),
                          Math.min(me[0], me[2]),
                        ),
                        Ye = Math.min(
                          Math.max(pe[0], pe[2]),
                          Math.max(me[0], me[2]),
                        );
                      if (Xe > Ye) return null;
                      const ot = Math.max(
                          Math.min(pe[1], pe[3]),
                          Math.min(me[1], me[3]),
                        ),
                        Z = Math.min(
                          Math.max(pe[1], pe[3]),
                          Math.max(me[1], me[3]),
                        );
                      return ot > Z ? null : [Xe, ot, Ye, Z];
                    }
                    static bezierBoundingBox(pe, me, Xe, Ye, ot, Z, Te, He) {
                      const Ze = [],
                        tt = [[], []];
                      let Ge, K, G, ae, Ae, ke, Fe, Ne;
                      for (let Et = 0; Et < 2; ++Et) {
                        if (
                          (Et === 0
                            ? ((K = 6 * pe - 12 * Xe + 6 * ot),
                              (Ge = -3 * pe + 9 * Xe - 9 * ot + 3 * Te),
                              (G = 3 * Xe - 3 * pe))
                            : ((K = 6 * me - 12 * Ye + 6 * Z),
                              (Ge = -3 * me + 9 * Ye - 9 * Z + 3 * He),
                              (G = 3 * Ye - 3 * me)),
                          Math.abs(Ge) < 1e-12)
                        ) {
                          if (Math.abs(K) < 1e-12) continue;
                          ((ae = -G / K), 0 < ae && ae < 1 && Ze.push(ae));
                          continue;
                        }
                        ((Fe = K * K - 4 * G * Ge),
                          (Ne = Math.sqrt(Fe)),
                          !(Fe < 0) &&
                            ((Ae = (-K + Ne) / (2 * Ge)),
                            0 < Ae && Ae < 1 && Ze.push(Ae),
                            (ke = (-K - Ne) / (2 * Ge)),
                            0 < ke && ke < 1 && Ze.push(ke)));
                      }
                      let Qe = Ze.length,
                        et;
                      const Ue = Qe;
                      for (; Qe--; )
                        ((ae = Ze[Qe]),
                          (et = 1 - ae),
                          (tt[0][Qe] =
                            et * et * et * pe +
                            3 * et * et * ae * Xe +
                            3 * et * ae * ae * ot +
                            ae * ae * ae * Te),
                          (tt[1][Qe] =
                            et * et * et * me +
                            3 * et * et * ae * Ye +
                            3 * et * ae * ae * Z +
                            ae * ae * ae * He));
                      return (
                        (tt[0][Ue] = pe),
                        (tt[1][Ue] = me),
                        (tt[0][Ue + 1] = Te),
                        (tt[1][Ue + 1] = He),
                        (tt[0].length = tt[1].length = Ue + 2),
                        [
                          Math.min(...tt[0]),
                          Math.min(...tt[1]),
                          Math.max(...tt[0]),
                          Math.max(...tt[1]),
                        ]
                      );
                    }
                  }
                  A.Util = ie;
                  const re = [
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225,
                    8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222,
                    8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338,
                    352, 376, 381, 305, 322, 339, 353, 382, 0, 8364,
                  ];
                  function he(Le) {
                    if (Le[0] >= "ï") {
                      let me;
                      if (
                        (Le[0] === "þ" && Le[1] === "ÿ"
                          ? (me = "utf-16be")
                          : Le[0] === "ÿ" && Le[1] === "þ"
                            ? (me = "utf-16le")
                            : Le[0] === "ï" &&
                              Le[1] === "»" &&
                              Le[2] === "¿" &&
                              (me = "utf-8"),
                        me)
                      )
                        try {
                          const Xe = new TextDecoder(me, { fatal: !0 }),
                            Ye = Ee(Le);
                          return Xe.decode(Ye);
                        } catch (Xe) {
                          x(`stringToPDFString: "${Xe}".`);
                        }
                    }
                    const pe = [];
                    for (let me = 0, Xe = Le.length; me < Xe; me++) {
                      const Ye = re[Le.charCodeAt(me)];
                      pe.push(Ye ? String.fromCharCode(Ye) : Le.charAt(me));
                    }
                    return pe.join("");
                  }
                  function Pe(Le) {
                    return decodeURIComponent(escape(Le));
                  }
                  function Me(Le) {
                    return unescape(encodeURIComponent(Le));
                  }
                  function se(Le) {
                    return (
                      typeof Le == "object" &&
                      (Le == null ? void 0 : Le.byteLength) !== void 0
                    );
                  }
                  function je(Le, pe) {
                    if (Le.length !== pe.length) return !1;
                    for (let me = 0, Xe = Le.length; me < Xe; me++)
                      if (Le[me] !== pe[me]) return !1;
                    return !0;
                  }
                  function Ie(Le = new Date()) {
                    return [
                      Le.getUTCFullYear().toString(),
                      (Le.getUTCMonth() + 1).toString().padStart(2, "0"),
                      Le.getUTCDate().toString().padStart(2, "0"),
                      Le.getUTCHours().toString().padStart(2, "0"),
                      Le.getUTCMinutes().toString().padStart(2, "0"),
                      Le.getUTCSeconds().toString().padStart(2, "0"),
                    ].join("");
                  }
                  class it {
                    constructor() {
                      ye(this, kt, !1);
                      this.promise = new Promise((pe, me) => {
                        ((this.resolve = (Xe) => {
                          (Se(this, kt, !0), pe(Xe));
                        }),
                          (this.reject = (Xe) => {
                            (Se(this, kt, !0), me(Xe));
                          }));
                      });
                    }
                    get settled() {
                      return l(this, kt);
                    }
                  }
                  ((kt = new WeakMap()), (A.PromiseCapability = it));
                  let Ke = null,
                    dt = null;
                  function ze(Le) {
                    return (
                      Ke ||
                        ((Ke =
                          /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu),
                        (dt = new Map([["ﬅ", "ſt"]]))),
                      Le.replaceAll(Ke, (pe, me, Xe) =>
                        me ? me.normalize("NFKC") : dt.get(Xe),
                      )
                    );
                  }
                  function Je() {
                    if (
                      typeof crypto < "u" &&
                      typeof (crypto == null ? void 0 : crypto.randomUUID) ==
                        "function"
                    )
                      return crypto.randomUUID();
                    const Le = new Uint8Array(32);
                    if (
                      typeof crypto < "u" &&
                      typeof (crypto == null
                        ? void 0
                        : crypto.getRandomValues) == "function"
                    )
                      crypto.getRandomValues(Le);
                    else
                      for (let pe = 0; pe < 32; pe++)
                        Le[pe] = Math.floor(Math.random() * 255);
                    return we(Le);
                  }
                  const st = "pdfjs_internal_id_";
                  A.AnnotationPrefix = st;
                },
                (__unused_webpack_module, exports, __w_pdfjs_require__) => {
                  var t,
                    n,
                    w,
                    S,
                    In,
                    rr,
                    ee,
                    X,
                    W,
                    k,
                    N,
                    P,
                    _,
                    h,
                    r,
                    ir,
                    p,
                    u,
                    xr,
                    v,
                    f;
                  (Object.defineProperty(exports, "__esModule", { value: !0 }),
                    (exports.RenderTask =
                      exports.PDFWorkerUtil =
                      exports.PDFWorker =
                      exports.PDFPageProxy =
                      exports.PDFDocumentProxy =
                      exports.PDFDocumentLoadingTask =
                      exports.PDFDataRangeTransport =
                      exports.LoopbackPort =
                      exports.DefaultStandardFontDataFactory =
                      exports.DefaultFilterFactory =
                      exports.DefaultCanvasFactory =
                      exports.DefaultCMapReaderFactory =
                        void 0),
                    Object.defineProperty(exports, "SVGGraphics", {
                      enumerable: !0,
                      get: function () {
                        return _displaySvg.SVGGraphics;
                      },
                    }),
                    (exports.build = void 0),
                    (exports.getDocument = getDocument),
                    (exports.version = void 0));
                  var _util = __w_pdfjs_require__(1),
                    _annotation_storage = __w_pdfjs_require__(3),
                    _display_utils = __w_pdfjs_require__(6),
                    _font_loader = __w_pdfjs_require__(9),
                    _displayNode_utils = __w_pdfjs_require__(10),
                    _canvas = __w_pdfjs_require__(11),
                    _worker_options = __w_pdfjs_require__(14),
                    _message_handler = __w_pdfjs_require__(15),
                    _metadata = __w_pdfjs_require__(16),
                    _optional_content_config = __w_pdfjs_require__(17),
                    _transport_stream = __w_pdfjs_require__(18),
                    _displayFetch_stream = __w_pdfjs_require__(19),
                    _displayNetwork = __w_pdfjs_require__(22),
                    _displayNode_stream = __w_pdfjs_require__(23),
                    _displaySvg = __w_pdfjs_require__(24),
                    _xfa_text = __w_pdfjs_require__(25);
                  const DEFAULT_RANGE_CHUNK_SIZE = 65536,
                    RENDERING_CANCELLED_TIMEOUT = 100,
                    DELAYED_CLEANUP_TIMEOUT = 5e3,
                    DefaultCanvasFactory = _util.isNodeJS
                      ? _displayNode_utils.NodeCanvasFactory
                      : _display_utils.DOMCanvasFactory;
                  exports.DefaultCanvasFactory = DefaultCanvasFactory;
                  const DefaultCMapReaderFactory = _util.isNodeJS
                    ? _displayNode_utils.NodeCMapReaderFactory
                    : _display_utils.DOMCMapReaderFactory;
                  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
                  const DefaultFilterFactory = _util.isNodeJS
                    ? _displayNode_utils.NodeFilterFactory
                    : _display_utils.DOMFilterFactory;
                  exports.DefaultFilterFactory = DefaultFilterFactory;
                  const DefaultStandardFontDataFactory = _util.isNodeJS
                    ? _displayNode_utils.NodeStandardFontDataFactory
                    : _display_utils.DOMStandardFontDataFactory;
                  exports.DefaultStandardFontDataFactory =
                    DefaultStandardFontDataFactory;
                  function getDocument(c) {
                    if (
                      (typeof c == "string" || c instanceof URL
                        ? (c = { url: c })
                        : (0, _util.isArrayBuffer)(c) && (c = { data: c }),
                      typeof c != "object")
                    )
                      throw new Error(
                        "Invalid parameter in getDocument, need parameter object.",
                      );
                    if (!c.url && !c.data && !c.range)
                      throw new Error(
                        "Invalid parameter object: need either .data, .range or .url",
                      );
                    const a = new PDFDocumentLoadingTask(),
                      { docId: m } = a,
                      C = c.url ? getUrlProp(c.url) : null,
                      e = c.data ? getDataProp(c.data) : null,
                      o = c.httpHeaders || null,
                      y = c.withCredentials === !0,
                      B = c.password ?? null,
                      M =
                        c.range instanceof PDFDataRangeTransport
                          ? c.range
                          : null,
                      D =
                        Number.isInteger(c.rangeChunkSize) &&
                        c.rangeChunkSize > 0
                          ? c.rangeChunkSize
                          : DEFAULT_RANGE_CHUNK_SIZE;
                    let x = c.worker instanceof PDFWorker ? c.worker : null;
                    const z = c.verbosity,
                      L =
                        typeof c.docBaseUrl == "string" &&
                        !(0, _display_utils.isDataScheme)(c.docBaseUrl)
                          ? c.docBaseUrl
                          : null,
                      V = typeof c.cMapUrl == "string" ? c.cMapUrl : null,
                      Y = c.cMapPacked !== !1,
                      T = c.CMapReaderFactory || DefaultCMapReaderFactory,
                      s =
                        typeof c.standardFontDataUrl == "string"
                          ? c.standardFontDataUrl
                          : null,
                      g =
                        c.StandardFontDataFactory ||
                        DefaultStandardFontDataFactory,
                      R = c.stopAtErrors !== !0,
                      $ =
                        Number.isInteger(c.maxImageSize) && c.maxImageSize > -1
                          ? c.maxImageSize
                          : -1,
                      j = c.isEvalSupported !== !1,
                      U =
                        typeof c.isOffscreenCanvasSupported == "boolean"
                          ? c.isOffscreenCanvasSupported
                          : !_util.isNodeJS,
                      Q = Number.isInteger(c.canvasMaxAreaInBytes)
                        ? c.canvasMaxAreaInBytes
                        : -1,
                      fe =
                        typeof c.disableFontFace == "boolean"
                          ? c.disableFontFace
                          : _util.isNodeJS,
                      we = c.fontExtraProperties === !0,
                      Ee = c.enableXfa === !0,
                      Ce = c.ownerDocument || globalThis.document,
                      xe = c.disableRange === !0,
                      Re = c.disableStream === !0,
                      ue = c.disableAutoFetch === !0,
                      de = c.pdfBug === !0,
                      I = M ? M.length : (c.length ?? NaN),
                      q =
                        typeof c.useSystemFonts == "boolean"
                          ? c.useSystemFonts
                          : !_util.isNodeJS && !fe,
                      ie =
                        typeof c.useWorkerFetch == "boolean"
                          ? c.useWorkerFetch
                          : T === _display_utils.DOMCMapReaderFactory &&
                            g === _display_utils.DOMStandardFontDataFactory &&
                            V &&
                            s &&
                            (0, _display_utils.isValidFetchUrl)(
                              V,
                              document.baseURI,
                            ) &&
                            (0, _display_utils.isValidFetchUrl)(
                              s,
                              document.baseURI,
                            ),
                      re =
                        c.canvasFactory ||
                        new DefaultCanvasFactory({ ownerDocument: Ce }),
                      he =
                        c.filterFactory ||
                        new DefaultFilterFactory({
                          docId: m,
                          ownerDocument: Ce,
                        }),
                      Pe = null;
                    (0, _util.setVerbosityLevel)(z);
                    const Me = { canvasFactory: re, filterFactory: he };
                    if (
                      (ie ||
                        ((Me.cMapReaderFactory = new T({
                          baseUrl: V,
                          isCompressed: Y,
                        })),
                        (Me.standardFontDataFactory = new g({ baseUrl: s }))),
                      !x)
                    ) {
                      const Ie = {
                        verbosity: z,
                        port: _worker_options.GlobalWorkerOptions.workerPort,
                      };
                      ((x = Ie.port
                        ? PDFWorker.fromPort(Ie)
                        : new PDFWorker(Ie)),
                        (a._worker = x));
                    }
                    const se = {
                        docId: m,
                        apiVersion: "3.11.174",
                        data: e,
                        password: B,
                        disableAutoFetch: ue,
                        rangeChunkSize: D,
                        length: I,
                        docBaseUrl: L,
                        enableXfa: Ee,
                        evaluatorOptions: {
                          maxImageSize: $,
                          disableFontFace: fe,
                          ignoreErrors: R,
                          isEvalSupported: j,
                          isOffscreenCanvasSupported: U,
                          canvasMaxAreaInBytes: Q,
                          fontExtraProperties: we,
                          useSystemFonts: q,
                          cMapUrl: ie ? V : null,
                          standardFontDataUrl: ie ? s : null,
                        },
                      },
                      je = {
                        ignoreErrors: R,
                        isEvalSupported: j,
                        disableFontFace: fe,
                        fontExtraProperties: we,
                        enableXfa: Ee,
                        ownerDocument: Ce,
                        disableAutoFetch: ue,
                        pdfBug: de,
                        styleElement: Pe,
                      };
                    return (
                      x.promise
                        .then(function () {
                          if (a.destroyed) throw new Error("Loading aborted");
                          const Ie = _fetchDocument(x, se),
                            it = new Promise(function (Ke) {
                              let dt;
                              (M
                                ? (dt =
                                    new _transport_stream.PDFDataTransportStream(
                                      {
                                        length: I,
                                        initialData: M.initialData,
                                        progressiveDone: M.progressiveDone,
                                        contentDispositionFilename:
                                          M.contentDispositionFilename,
                                        disableRange: xe,
                                        disableStream: Re,
                                      },
                                      M,
                                    ))
                                : e ||
                                  (dt = ((Je) =>
                                    _util.isNodeJS
                                      ? new _displayNode_stream.PDFNodeStream(
                                          Je,
                                        )
                                      : (0, _display_utils.isValidFetchUrl)(
                                            Je.url,
                                          )
                                        ? new _displayFetch_stream.PDFFetchStream(
                                            Je,
                                          )
                                        : new _displayNetwork.PDFNetworkStream(
                                            Je,
                                          ))({
                                    url: C,
                                    length: I,
                                    httpHeaders: o,
                                    withCredentials: y,
                                    rangeChunkSize: D,
                                    disableRange: xe,
                                    disableStream: Re,
                                  })),
                                Ke(dt));
                            });
                          return Promise.all([Ie, it]).then(function ([
                            Ke,
                            dt,
                          ]) {
                            if (a.destroyed) throw new Error("Loading aborted");
                            const ze = new _message_handler.MessageHandler(
                                m,
                                Ke,
                                x.port,
                              ),
                              Je = new WorkerTransport(ze, a, dt, je, Me);
                            ((a._transport = Je), ze.send("Ready", null));
                          });
                        })
                        .catch(a._capability.reject),
                      a
                    );
                  }
                  async function _fetchDocument(c, a) {
                    if (c.destroyed) throw new Error("Worker was destroyed");
                    const m = await c.messageHandler.sendWithPromise(
                      "GetDocRequest",
                      a,
                      a.data ? [a.data.buffer] : null,
                    );
                    if (c.destroyed) throw new Error("Worker was destroyed");
                    return m;
                  }
                  function getUrlProp(c) {
                    if (c instanceof URL) return c.href;
                    try {
                      return new URL(c, window.location).href;
                    } catch {
                      if (_util.isNodeJS && typeof c == "string") return c;
                    }
                    throw new Error(
                      "Invalid PDF url data: either string or URL-object is expected in the url property.",
                    );
                  }
                  function getDataProp(c) {
                    if (
                      _util.isNodeJS &&
                      typeof Buffer < "u" &&
                      c instanceof Buffer
                    )
                      throw new Error(
                        "Please provide binary data as `Uint8Array`, rather than `Buffer`.",
                      );
                    if (
                      c instanceof Uint8Array &&
                      c.byteLength === c.buffer.byteLength
                    )
                      return c;
                    if (typeof c == "string")
                      return (0, _util.stringToBytes)(c);
                    if (
                      (typeof c == "object" &&
                        !isNaN(c == null ? void 0 : c.length)) ||
                      (0, _util.isArrayBuffer)(c)
                    )
                      return new Uint8Array(c);
                    throw new Error(
                      "Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.",
                    );
                  }
                  const A = class A {
                    constructor() {
                      ((this._capability = new _util.PromiseCapability()),
                        (this._transport = null),
                        (this._worker = null),
                        (this.docId = `d${Hn(A, t)._++}`),
                        (this.destroyed = !1),
                        (this.onPassword = null),
                        (this.onProgress = null));
                    }
                    get promise() {
                      return this._capability.promise;
                    }
                    async destroy() {
                      var a, m, C;
                      this.destroyed = !0;
                      try {
                        ((a = this._worker) != null &&
                          a.port &&
                          (this._worker._pendingDestroy = !0),
                          await ((m = this._transport) == null
                            ? void 0
                            : m.destroy()));
                      } catch (e) {
                        throw (
                          (C = this._worker) != null &&
                            C.port &&
                            delete this._worker._pendingDestroy,
                          e
                        );
                      }
                      ((this._transport = null),
                        this._worker &&
                          (this._worker.destroy(), (this._worker = null)));
                    }
                  };
                  ((t = new WeakMap()), ye(A, t, 0));
                  let PDFDocumentLoadingTask = A;
                  exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
                  class PDFDataRangeTransport {
                    constructor(a, m, C = !1, e = null) {
                      ((this.length = a),
                        (this.initialData = m),
                        (this.progressiveDone = C),
                        (this.contentDispositionFilename = e),
                        (this._rangeListeners = []),
                        (this._progressListeners = []),
                        (this._progressiveReadListeners = []),
                        (this._progressiveDoneListeners = []),
                        (this._readyCapability =
                          new _util.PromiseCapability()));
                    }
                    addRangeListener(a) {
                      this._rangeListeners.push(a);
                    }
                    addProgressListener(a) {
                      this._progressListeners.push(a);
                    }
                    addProgressiveReadListener(a) {
                      this._progressiveReadListeners.push(a);
                    }
                    addProgressiveDoneListener(a) {
                      this._progressiveDoneListeners.push(a);
                    }
                    onDataRange(a, m) {
                      for (const C of this._rangeListeners) C(a, m);
                    }
                    onDataProgress(a, m) {
                      this._readyCapability.promise.then(() => {
                        for (const C of this._progressListeners) C(a, m);
                      });
                    }
                    onDataProgressiveRead(a) {
                      this._readyCapability.promise.then(() => {
                        for (const m of this._progressiveReadListeners) m(a);
                      });
                    }
                    onDataProgressiveDone() {
                      this._readyCapability.promise.then(() => {
                        for (const a of this._progressiveDoneListeners) a();
                      });
                    }
                    transportReady() {
                      this._readyCapability.resolve();
                    }
                    requestDataRange(a, m) {
                      (0, _util.unreachable)(
                        "Abstract method PDFDataRangeTransport.requestDataRange",
                      );
                    }
                    abort() {}
                  }
                  exports.PDFDataRangeTransport = PDFDataRangeTransport;
                  class PDFDocumentProxy {
                    constructor(a, m) {
                      ((this._pdfInfo = a),
                        (this._transport = m),
                        Object.defineProperty(this, "getJavaScript", {
                          value: () => (
                            (0, _display_utils.deprecated)(
                              "`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead.",
                            ),
                            this.getJSActions().then((C) => {
                              if (!C) return C;
                              const e = [];
                              for (const o in C) e.push(...C[o]);
                              return e;
                            })
                          ),
                        }));
                    }
                    get annotationStorage() {
                      return this._transport.annotationStorage;
                    }
                    get filterFactory() {
                      return this._transport.filterFactory;
                    }
                    get numPages() {
                      return this._pdfInfo.numPages;
                    }
                    get fingerprints() {
                      return this._pdfInfo.fingerprints;
                    }
                    get isPureXfa() {
                      return (0, _util.shadow)(
                        this,
                        "isPureXfa",
                        !!this._transport._htmlForXfa,
                      );
                    }
                    get allXfaHtml() {
                      return this._transport._htmlForXfa;
                    }
                    getPage(a) {
                      return this._transport.getPage(a);
                    }
                    getPageIndex(a) {
                      return this._transport.getPageIndex(a);
                    }
                    getDestinations() {
                      return this._transport.getDestinations();
                    }
                    getDestination(a) {
                      return this._transport.getDestination(a);
                    }
                    getPageLabels() {
                      return this._transport.getPageLabels();
                    }
                    getPageLayout() {
                      return this._transport.getPageLayout();
                    }
                    getPageMode() {
                      return this._transport.getPageMode();
                    }
                    getViewerPreferences() {
                      return this._transport.getViewerPreferences();
                    }
                    getOpenAction() {
                      return this._transport.getOpenAction();
                    }
                    getAttachments() {
                      return this._transport.getAttachments();
                    }
                    getJSActions() {
                      return this._transport.getDocJSActions();
                    }
                    getOutline() {
                      return this._transport.getOutline();
                    }
                    getOptionalContentConfig() {
                      return this._transport.getOptionalContentConfig();
                    }
                    getPermissions() {
                      return this._transport.getPermissions();
                    }
                    getMetadata() {
                      return this._transport.getMetadata();
                    }
                    getMarkInfo() {
                      return this._transport.getMarkInfo();
                    }
                    getData() {
                      return this._transport.getData();
                    }
                    saveDocument() {
                      return this._transport.saveDocument();
                    }
                    getDownloadInfo() {
                      return this._transport.downloadInfoCapability.promise;
                    }
                    cleanup(a = !1) {
                      return this._transport.startCleanup(a || this.isPureXfa);
                    }
                    destroy() {
                      return this.loadingTask.destroy();
                    }
                    get loadingParams() {
                      return this._transport.loadingParams;
                    }
                    get loadingTask() {
                      return this._transport.loadingTask;
                    }
                    getFieldObjects() {
                      return this._transport.getFieldObjects();
                    }
                    hasJSActions() {
                      return this._transport.hasJSActions();
                    }
                    getCalculationOrderIds() {
                      return this._transport.getCalculationOrderIds();
                    }
                  }
                  exports.PDFDocumentProxy = PDFDocumentProxy;
                  class PDFPageProxy {
                    constructor(a, m, C, e = !1) {
                      ye(this, S);
                      ye(this, n, null);
                      ye(this, w, !1);
                      ((this._pageIndex = a),
                        (this._pageInfo = m),
                        (this._transport = C),
                        (this._stats = e
                          ? new _display_utils.StatTimer()
                          : null),
                        (this._pdfBug = e),
                        (this.commonObjs = C.commonObjs),
                        (this.objs = new PDFObjects()),
                        (this._maybeCleanupAfterRender = !1),
                        (this._intentStates = new Map()),
                        (this.destroyed = !1));
                    }
                    get pageNumber() {
                      return this._pageIndex + 1;
                    }
                    get rotate() {
                      return this._pageInfo.rotate;
                    }
                    get ref() {
                      return this._pageInfo.ref;
                    }
                    get userUnit() {
                      return this._pageInfo.userUnit;
                    }
                    get view() {
                      return this._pageInfo.view;
                    }
                    getViewport({
                      scale: a,
                      rotation: m = this.rotate,
                      offsetX: C = 0,
                      offsetY: e = 0,
                      dontFlip: o = !1,
                    } = {}) {
                      return new _display_utils.PageViewport({
                        viewBox: this.view,
                        scale: a,
                        rotation: m,
                        offsetX: C,
                        offsetY: e,
                        dontFlip: o,
                      });
                    }
                    getAnnotations({ intent: a = "display" } = {}) {
                      const m = this._transport.getRenderingIntent(a);
                      return this._transport.getAnnotations(
                        this._pageIndex,
                        m.renderingIntent,
                      );
                    }
                    getJSActions() {
                      return this._transport.getPageJSActions(this._pageIndex);
                    }
                    get filterFactory() {
                      return this._transport.filterFactory;
                    }
                    get isPureXfa() {
                      return (0, _util.shadow)(
                        this,
                        "isPureXfa",
                        !!this._transport._htmlForXfa,
                      );
                    }
                    async getXfa() {
                      var a;
                      return (
                        ((a = this._transport._htmlForXfa) == null
                          ? void 0
                          : a.children[this._pageIndex]) || null
                      );
                    }
                    render({
                      canvasContext: a,
                      viewport: m,
                      intent: C = "display",
                      annotationMode: e = _util.AnnotationMode.ENABLE,
                      transform: o = null,
                      background: y = null,
                      optionalContentConfigPromise: B = null,
                      annotationCanvasMap: M = null,
                      pageColors: D = null,
                      printAnnotationStorage: x = null,
                    }) {
                      var g, R;
                      (g = this._stats) == null || g.time("Overall");
                      const z = this._transport.getRenderingIntent(C, e, x);
                      (Se(this, w, !1),
                        le(this, S, rr).call(this),
                        B || (B = this._transport.getOptionalContentConfig()));
                      let L = this._intentStates.get(z.cacheKey);
                      (L ||
                        ((L = Object.create(null)),
                        this._intentStates.set(z.cacheKey, L)),
                        L.streamReaderCancelTimeout &&
                          (clearTimeout(L.streamReaderCancelTimeout),
                          (L.streamReaderCancelTimeout = null)));
                      const V = !!(
                        z.renderingIntent & _util.RenderingIntentFlag.PRINT
                      );
                      L.displayReadyCapability ||
                        ((L.displayReadyCapability =
                          new _util.PromiseCapability()),
                        (L.operatorList = {
                          fnArray: [],
                          argsArray: [],
                          lastChunk: !1,
                          separateAnnots: null,
                        }),
                        (R = this._stats) == null || R.time("Page Request"),
                        this._pumpOperatorList(z));
                      const Y = ($) => {
                          var j, U;
                          (L.renderTasks.delete(T),
                            (this._maybeCleanupAfterRender || V) &&
                              Se(this, w, !0),
                            le(this, S, In).call(this, !V),
                            $
                              ? (T.capability.reject($),
                                this._abortOperatorList({
                                  intentState: L,
                                  reason: $ instanceof Error ? $ : new Error($),
                                }))
                              : T.capability.resolve(),
                            (j = this._stats) == null || j.timeEnd("Rendering"),
                            (U = this._stats) == null || U.timeEnd("Overall"));
                        },
                        T = new InternalRenderTask({
                          callback: Y,
                          params: {
                            canvasContext: a,
                            viewport: m,
                            transform: o,
                            background: y,
                          },
                          objs: this.objs,
                          commonObjs: this.commonObjs,
                          annotationCanvasMap: M,
                          operatorList: L.operatorList,
                          pageIndex: this._pageIndex,
                          canvasFactory: this._transport.canvasFactory,
                          filterFactory: this._transport.filterFactory,
                          useRequestAnimationFrame: !V,
                          pdfBug: this._pdfBug,
                          pageColors: D,
                        });
                      (L.renderTasks || (L.renderTasks = new Set())).add(T);
                      const s = T.task;
                      return (
                        Promise.all([L.displayReadyCapability.promise, B])
                          .then(([$, j]) => {
                            var U;
                            if (this.destroyed) {
                              Y();
                              return;
                            }
                            ((U = this._stats) == null || U.time("Rendering"),
                              T.initializeGraphics({
                                transparency: $,
                                optionalContentConfig: j,
                              }),
                              T.operatorListChanged());
                          })
                          .catch(Y),
                        s
                      );
                    }
                    getOperatorList({
                      intent: a = "display",
                      annotationMode: m = _util.AnnotationMode.ENABLE,
                      printAnnotationStorage: C = null,
                    } = {}) {
                      var M;
                      function e() {
                        y.operatorList.lastChunk &&
                          (y.opListReadCapability.resolve(y.operatorList),
                          y.renderTasks.delete(B));
                      }
                      const o = this._transport.getRenderingIntent(a, m, C, !0);
                      let y = this._intentStates.get(o.cacheKey);
                      y ||
                        ((y = Object.create(null)),
                        this._intentStates.set(o.cacheKey, y));
                      let B;
                      return (
                        y.opListReadCapability ||
                          ((B = Object.create(null)),
                          (B.operatorListChanged = e),
                          (y.opListReadCapability =
                            new _util.PromiseCapability()),
                          (y.renderTasks || (y.renderTasks = new Set())).add(B),
                          (y.operatorList = {
                            fnArray: [],
                            argsArray: [],
                            lastChunk: !1,
                            separateAnnots: null,
                          }),
                          (M = this._stats) == null || M.time("Page Request"),
                          this._pumpOperatorList(o)),
                        y.opListReadCapability.promise
                      );
                    }
                    streamTextContent({
                      includeMarkedContent: a = !1,
                      disableNormalization: m = !1,
                    } = {}) {
                      return this._transport.messageHandler.sendWithStream(
                        "GetTextContent",
                        {
                          pageIndex: this._pageIndex,
                          includeMarkedContent: a === !0,
                          disableNormalization: m === !0,
                        },
                        {
                          highWaterMark: 100,
                          size(e) {
                            return e.items.length;
                          },
                        },
                      );
                    }
                    getTextContent(a = {}) {
                      if (this._transport._htmlForXfa)
                        return this.getXfa().then((C) =>
                          _xfa_text.XfaText.textContent(C),
                        );
                      const m = this.streamTextContent(a);
                      return new Promise(function (C, e) {
                        function o() {
                          y.read().then(function ({ value: M, done: D }) {
                            if (D) {
                              C(B);
                              return;
                            }
                            (Object.assign(B.styles, M.styles),
                              B.items.push(...M.items),
                              o());
                          }, e);
                        }
                        const y = m.getReader(),
                          B = { items: [], styles: Object.create(null) };
                        o();
                      });
                    }
                    getStructTree() {
                      return this._transport.getStructTree(this._pageIndex);
                    }
                    _destroy() {
                      this.destroyed = !0;
                      const a = [];
                      for (const m of this._intentStates.values())
                        if (
                          (this._abortOperatorList({
                            intentState: m,
                            reason: new Error("Page was destroyed."),
                            force: !0,
                          }),
                          !m.opListReadCapability)
                        )
                          for (const C of m.renderTasks)
                            (a.push(C.completed), C.cancel());
                      return (
                        this.objs.clear(),
                        Se(this, w, !1),
                        le(this, S, rr).call(this),
                        Promise.all(a)
                      );
                    }
                    cleanup(a = !1) {
                      Se(this, w, !0);
                      const m = le(this, S, In).call(this, !1);
                      return (
                        a &&
                          m &&
                          this._stats &&
                          (this._stats = new _display_utils.StatTimer()),
                        m
                      );
                    }
                    _startRenderPage(a, m) {
                      var e, o;
                      const C = this._intentStates.get(m);
                      C &&
                        ((e = this._stats) == null || e.timeEnd("Page Request"),
                        (o = C.displayReadyCapability) == null || o.resolve(a));
                    }
                    _renderPageChunk(a, m) {
                      for (let C = 0, e = a.length; C < e; C++)
                        (m.operatorList.fnArray.push(a.fnArray[C]),
                          m.operatorList.argsArray.push(a.argsArray[C]));
                      ((m.operatorList.lastChunk = a.lastChunk),
                        (m.operatorList.separateAnnots = a.separateAnnots));
                      for (const C of m.renderTasks) C.operatorListChanged();
                      a.lastChunk && le(this, S, In).call(this, !0);
                    }
                    _pumpOperatorList({
                      renderingIntent: a,
                      cacheKey: m,
                      annotationStorageSerializable: C,
                    }) {
                      const { map: e, transfers: o } = C,
                        B = this._transport.messageHandler
                          .sendWithStream(
                            "GetOperatorList",
                            {
                              pageIndex: this._pageIndex,
                              intent: a,
                              cacheKey: m,
                              annotationStorage: e,
                            },
                            o,
                          )
                          .getReader(),
                        M = this._intentStates.get(m);
                      M.streamReader = B;
                      const D = () => {
                        B.read().then(
                          ({ value: x, done: z }) => {
                            if (z) {
                              M.streamReader = null;
                              return;
                            }
                            this._transport.destroyed ||
                              (this._renderPageChunk(x, M), D());
                          },
                          (x) => {
                            if (
                              ((M.streamReader = null),
                              !this._transport.destroyed)
                            ) {
                              if (M.operatorList) {
                                M.operatorList.lastChunk = !0;
                                for (const z of M.renderTasks)
                                  z.operatorListChanged();
                                le(this, S, In).call(this, !0);
                              }
                              if (M.displayReadyCapability)
                                M.displayReadyCapability.reject(x);
                              else if (M.opListReadCapability)
                                M.opListReadCapability.reject(x);
                              else throw x;
                            }
                          },
                        );
                      };
                      D();
                    }
                    _abortOperatorList({
                      intentState: a,
                      reason: m,
                      force: C = !1,
                    }) {
                      if (a.streamReader) {
                        if (
                          (a.streamReaderCancelTimeout &&
                            (clearTimeout(a.streamReaderCancelTimeout),
                            (a.streamReaderCancelTimeout = null)),
                          !C)
                        ) {
                          if (a.renderTasks.size > 0) return;
                          if (
                            m instanceof
                            _display_utils.RenderingCancelledException
                          ) {
                            let e = RENDERING_CANCELLED_TIMEOUT;
                            (m.extraDelay > 0 &&
                              m.extraDelay < 1e3 &&
                              (e += m.extraDelay),
                              (a.streamReaderCancelTimeout = setTimeout(() => {
                                ((a.streamReaderCancelTimeout = null),
                                  this._abortOperatorList({
                                    intentState: a,
                                    reason: m,
                                    force: !0,
                                  }));
                              }, e)));
                            return;
                          }
                        }
                        if (
                          (a.streamReader
                            .cancel(new _util.AbortException(m.message))
                            .catch(() => {}),
                          (a.streamReader = null),
                          !this._transport.destroyed)
                        ) {
                          for (const [e, o] of this._intentStates)
                            if (o === a) {
                              this._intentStates.delete(e);
                              break;
                            }
                          this.cleanup();
                        }
                      }
                    }
                    get stats() {
                      return this._stats;
                    }
                  }
                  ((n = new WeakMap()),
                    (w = new WeakMap()),
                    (S = new WeakSet()),
                    (In = function (a = !1) {
                      if (
                        (le(this, S, rr).call(this),
                        !l(this, w) || this.destroyed)
                      )
                        return !1;
                      if (a)
                        return (
                          Se(
                            this,
                            n,
                            setTimeout(() => {
                              (Se(this, n, null),
                                le(this, S, In).call(this, !1));
                            }, DELAYED_CLEANUP_TIMEOUT),
                          ),
                          !1
                        );
                      for (const {
                        renderTasks: m,
                        operatorList: C,
                      } of this._intentStates.values())
                        if (m.size > 0 || !C.lastChunk) return !1;
                      return (
                        this._intentStates.clear(),
                        this.objs.clear(),
                        Se(this, w, !1),
                        !0
                      );
                    }),
                    (rr = function () {
                      l(this, n) &&
                        (clearTimeout(l(this, n)), Se(this, n, null));
                    }),
                    (exports.PDFPageProxy = PDFPageProxy));
                  class LoopbackPort {
                    constructor() {
                      ye(this, ee, new Set());
                      ye(this, X, Promise.resolve());
                    }
                    postMessage(a, m) {
                      const C = {
                        data: structuredClone(a, m ? { transfer: m } : null),
                      };
                      l(this, X).then(() => {
                        for (const e of l(this, ee)) e.call(this, C);
                      });
                    }
                    addEventListener(a, m) {
                      l(this, ee).add(m);
                    }
                    removeEventListener(a, m) {
                      l(this, ee).delete(m);
                    }
                    terminate() {
                      l(this, ee).clear();
                    }
                  }
                  ((ee = new WeakMap()),
                    (X = new WeakMap()),
                    (exports.LoopbackPort = LoopbackPort));
                  const PDFWorkerUtil = {
                    isWorkerDisabled: !1,
                    fallbackWorkerSrc: null,
                    fakeWorkerId: 0,
                  };
                  exports.PDFWorkerUtil = PDFWorkerUtil;
                  {
                    if (_util.isNodeJS && typeof commonjsRequire == "function")
                      ((PDFWorkerUtil.isWorkerDisabled = !0),
                        (PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js"));
                    else if (typeof document == "object") {
                      const c =
                        (W =
                          document == null ? void 0 : document.currentScript) ==
                        null
                          ? void 0
                          : W.src;
                      c &&
                        (PDFWorkerUtil.fallbackWorkerSrc = c.replace(
                          /(\.(?:min\.)?js)(\?.*)?$/i,
                          ".worker$1$2",
                        ));
                    }
                    ((PDFWorkerUtil.isSameOrigin = function (c, a) {
                      let m;
                      try {
                        if (
                          ((m = new URL(c)), !m.origin || m.origin === "null")
                        )
                          return !1;
                      } catch {
                        return !1;
                      }
                      const C = new URL(a, m);
                      return m.origin === C.origin;
                    }),
                      (PDFWorkerUtil.createCDNWrapper = function (c) {
                        const a = `importScripts("${c}");`;
                        return URL.createObjectURL(new Blob([a]));
                      }));
                  }
                  const _PDFWorker = class _PDFWorker {
                    constructor({
                      name: c = null,
                      port: a = null,
                      verbosity: m = (0, _util.getVerbosityLevel)(),
                    } = {}) {
                      var C;
                      if (
                        ((this.name = c),
                        (this.destroyed = !1),
                        (this.verbosity = m),
                        (this._readyCapability = new _util.PromiseCapability()),
                        (this._port = null),
                        (this._webWorker = null),
                        (this._messageHandler = null),
                        a)
                      ) {
                        if ((C = l(_PDFWorker, k)) != null && C.has(a))
                          throw new Error(
                            "Cannot use more than one PDFWorker per port.",
                          );
                        ((
                          l(_PDFWorker, k) || Se(_PDFWorker, k, new WeakMap())
                        ).set(a, this),
                          this._initializeFromPort(a));
                        return;
                      }
                      this._initialize();
                    }
                    get promise() {
                      return this._readyCapability.promise;
                    }
                    get port() {
                      return this._port;
                    }
                    get messageHandler() {
                      return this._messageHandler;
                    }
                    _initializeFromPort(c) {
                      ((this._port = c),
                        (this._messageHandler =
                          new _message_handler.MessageHandler(
                            "main",
                            "worker",
                            c,
                          )),
                        this._messageHandler.on("ready", function () {}),
                        this._readyCapability.resolve(),
                        this._messageHandler.send("configure", {
                          verbosity: this.verbosity,
                        }));
                    }
                    _initialize() {
                      if (
                        !PDFWorkerUtil.isWorkerDisabled &&
                        !_PDFWorker._mainThreadWorkerMessageHandler
                      ) {
                        let { workerSrc: c } = _PDFWorker;
                        try {
                          PDFWorkerUtil.isSameOrigin(window.location.href, c) ||
                            (c = PDFWorkerUtil.createCDNWrapper(
                              new URL(c, window.location).href,
                            ));
                          const a = new Worker(c),
                            m = new _message_handler.MessageHandler(
                              "main",
                              "worker",
                              a,
                            ),
                            C = () => {
                              (a.removeEventListener("error", e),
                                m.destroy(),
                                a.terminate(),
                                this.destroyed
                                  ? this._readyCapability.reject(
                                      new Error("Worker was destroyed"),
                                    )
                                  : this._setupFakeWorker());
                            },
                            e = () => {
                              this._webWorker || C();
                            };
                          (a.addEventListener("error", e),
                            m.on("test", (y) => {
                              if (
                                (a.removeEventListener("error", e),
                                this.destroyed)
                              ) {
                                C();
                                return;
                              }
                              y
                                ? ((this._messageHandler = m),
                                  (this._port = a),
                                  (this._webWorker = a),
                                  this._readyCapability.resolve(),
                                  m.send("configure", {
                                    verbosity: this.verbosity,
                                  }))
                                : (this._setupFakeWorker(),
                                  m.destroy(),
                                  a.terminate());
                            }),
                            m.on("ready", (y) => {
                              if (
                                (a.removeEventListener("error", e),
                                this.destroyed)
                              ) {
                                C();
                                return;
                              }
                              try {
                                o();
                              } catch {
                                this._setupFakeWorker();
                              }
                            }));
                          const o = () => {
                            const y = new Uint8Array();
                            m.send("test", y, [y.buffer]);
                          };
                          o();
                          return;
                        } catch {
                          (0, _util.info)("The worker has been disabled.");
                        }
                      }
                      this._setupFakeWorker();
                    }
                    _setupFakeWorker() {
                      (PDFWorkerUtil.isWorkerDisabled ||
                        ((0, _util.warn)("Setting up fake worker."),
                        (PDFWorkerUtil.isWorkerDisabled = !0)),
                        _PDFWorker._setupFakeWorkerGlobal
                          .then((c) => {
                            if (this.destroyed) {
                              this._readyCapability.reject(
                                new Error("Worker was destroyed"),
                              );
                              return;
                            }
                            const a = new LoopbackPort();
                            this._port = a;
                            const m = `fake${PDFWorkerUtil.fakeWorkerId++}`,
                              C = new _message_handler.MessageHandler(
                                m + "_worker",
                                m,
                                a,
                              );
                            c.setup(C, a);
                            const e = new _message_handler.MessageHandler(
                              m,
                              m + "_worker",
                              a,
                            );
                            ((this._messageHandler = e),
                              this._readyCapability.resolve(),
                              e.send("configure", {
                                verbosity: this.verbosity,
                              }));
                          })
                          .catch((c) => {
                            this._readyCapability.reject(
                              new Error(
                                `Setting up fake worker failed: "${c.message}".`,
                              ),
                            );
                          }));
                    }
                    destroy() {
                      var c;
                      ((this.destroyed = !0),
                        this._webWorker &&
                          (this._webWorker.terminate(),
                          (this._webWorker = null)),
                        (c = l(_PDFWorker, k)) == null || c.delete(this._port),
                        (this._port = null),
                        this._messageHandler &&
                          (this._messageHandler.destroy(),
                          (this._messageHandler = null)));
                    }
                    static fromPort(c) {
                      var m;
                      if (!(c != null && c.port))
                        throw new Error(
                          "PDFWorker.fromPort - invalid method signature.",
                        );
                      const a =
                        (m = l(this, k)) == null ? void 0 : m.get(c.port);
                      if (a) {
                        if (a._pendingDestroy)
                          throw new Error(
                            "PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.",
                          );
                        return a;
                      }
                      return new _PDFWorker(c);
                    }
                    static get workerSrc() {
                      if (_worker_options.GlobalWorkerOptions.workerSrc)
                        return _worker_options.GlobalWorkerOptions.workerSrc;
                      if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                        return (
                          _util.isNodeJS ||
                            (0, _display_utils.deprecated)(
                              'No "GlobalWorkerOptions.workerSrc" specified.',
                            ),
                          PDFWorkerUtil.fallbackWorkerSrc
                        );
                      throw new Error(
                        'No "GlobalWorkerOptions.workerSrc" specified.',
                      );
                    }
                    static get _mainThreadWorkerMessageHandler() {
                      var c;
                      try {
                        return (
                          ((c = globalThis.pdfjsWorker) == null
                            ? void 0
                            : c.WorkerMessageHandler) || null
                        );
                      } catch {
                        return null;
                      }
                    }
                    static get _setupFakeWorkerGlobal() {
                      const loader = async () => {
                        const mainWorkerMessageHandler =
                          this._mainThreadWorkerMessageHandler;
                        if (mainWorkerMessageHandler)
                          return mainWorkerMessageHandler;
                        if (
                          _util.isNodeJS &&
                          typeof commonjsRequire == "function"
                        ) {
                          const worker = eval("require")(this.workerSrc);
                          return worker.WorkerMessageHandler;
                        }
                        return (
                          await (0, _display_utils.loadScript)(this.workerSrc),
                          window.pdfjsWorker.WorkerMessageHandler
                        );
                      };
                      return (0, _util.shadow)(
                        this,
                        "_setupFakeWorkerGlobal",
                        loader(),
                      );
                    }
                  };
                  ((k = new WeakMap()), ye(_PDFWorker, k));
                  let PDFWorker = _PDFWorker;
                  exports.PDFWorker = PDFWorker;
                  class WorkerTransport {
                    constructor(a, m, C, e, o) {
                      ye(this, r);
                      ye(this, N, new Map());
                      ye(this, P, new Map());
                      ye(this, _, new Map());
                      ye(this, h, null);
                      ((this.messageHandler = a),
                        (this.loadingTask = m),
                        (this.commonObjs = new PDFObjects()),
                        (this.fontLoader = new _font_loader.FontLoader({
                          ownerDocument: e.ownerDocument,
                          styleElement: e.styleElement,
                        })),
                        (this._params = e),
                        (this.canvasFactory = o.canvasFactory),
                        (this.filterFactory = o.filterFactory),
                        (this.cMapReaderFactory = o.cMapReaderFactory),
                        (this.standardFontDataFactory =
                          o.standardFontDataFactory),
                        (this.destroyed = !1),
                        (this.destroyCapability = null),
                        (this._networkStream = C),
                        (this._fullReader = null),
                        (this._lastProgress = null),
                        (this.downloadInfoCapability =
                          new _util.PromiseCapability()),
                        this.setupMessageHandler());
                    }
                    get annotationStorage() {
                      return (0, _util.shadow)(
                        this,
                        "annotationStorage",
                        new _annotation_storage.AnnotationStorage(),
                      );
                    }
                    getRenderingIntent(
                      a,
                      m = _util.AnnotationMode.ENABLE,
                      C = null,
                      e = !1,
                    ) {
                      let o = _util.RenderingIntentFlag.DISPLAY,
                        y = _annotation_storage.SerializableEmpty;
                      switch (a) {
                        case "any":
                          o = _util.RenderingIntentFlag.ANY;
                          break;
                        case "display":
                          break;
                        case "print":
                          o = _util.RenderingIntentFlag.PRINT;
                          break;
                        default:
                          (0, _util.warn)(
                            `getRenderingIntent - invalid intent: ${a}`,
                          );
                      }
                      switch (m) {
                        case _util.AnnotationMode.DISABLE:
                          o += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                          break;
                        case _util.AnnotationMode.ENABLE:
                          break;
                        case _util.AnnotationMode.ENABLE_FORMS:
                          o += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                          break;
                        case _util.AnnotationMode.ENABLE_STORAGE:
                          ((o += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE),
                            (y = (
                              o & _util.RenderingIntentFlag.PRINT &&
                              C instanceof
                                _annotation_storage.PrintAnnotationStorage
                                ? C
                                : this.annotationStorage
                            ).serializable));
                          break;
                        default:
                          (0, _util.warn)(
                            `getRenderingIntent - invalid annotationMode: ${m}`,
                          );
                      }
                      return (
                        e && (o += _util.RenderingIntentFlag.OPLIST),
                        {
                          renderingIntent: o,
                          cacheKey: `${o}_${y.hash}`,
                          annotationStorageSerializable: y,
                        }
                      );
                    }
                    destroy() {
                      var C;
                      if (this.destroyCapability)
                        return this.destroyCapability.promise;
                      ((this.destroyed = !0),
                        (this.destroyCapability =
                          new _util.PromiseCapability()),
                        (C = l(this, h)) == null ||
                          C.reject(
                            new Error(
                              "Worker was destroyed during onPassword callback",
                            ),
                          ));
                      const a = [];
                      for (const e of l(this, P).values()) a.push(e._destroy());
                      (l(this, P).clear(),
                        l(this, _).clear(),
                        this.hasOwnProperty("annotationStorage") &&
                          this.annotationStorage.resetModified());
                      const m = this.messageHandler.sendWithPromise(
                        "Terminate",
                        null,
                      );
                      return (
                        a.push(m),
                        Promise.all(a).then(() => {
                          var e;
                          (this.commonObjs.clear(),
                            this.fontLoader.clear(),
                            l(this, N).clear(),
                            this.filterFactory.destroy(),
                            (e = this._networkStream) == null ||
                              e.cancelAllRequests(
                                new _util.AbortException(
                                  "Worker was terminated.",
                                ),
                              ),
                            this.messageHandler &&
                              (this.messageHandler.destroy(),
                              (this.messageHandler = null)),
                            this.destroyCapability.resolve());
                        }, this.destroyCapability.reject),
                        this.destroyCapability.promise
                      );
                    }
                    setupMessageHandler() {
                      const { messageHandler: a, loadingTask: m } = this;
                      (a.on("GetReader", (C, e) => {
                        ((0, _util.assert)(
                          this._networkStream,
                          "GetReader - no `IPDFStream` instance available.",
                        ),
                          (this._fullReader =
                            this._networkStream.getFullReader()),
                          (this._fullReader.onProgress = (o) => {
                            this._lastProgress = {
                              loaded: o.loaded,
                              total: o.total,
                            };
                          }),
                          (e.onPull = () => {
                            this._fullReader
                              .read()
                              .then(function ({ value: o, done: y }) {
                                if (y) {
                                  e.close();
                                  return;
                                }
                                ((0, _util.assert)(
                                  o instanceof ArrayBuffer,
                                  "GetReader - expected an ArrayBuffer.",
                                ),
                                  e.enqueue(new Uint8Array(o), 1, [o]));
                              })
                              .catch((o) => {
                                e.error(o);
                              });
                          }),
                          (e.onCancel = (o) => {
                            (this._fullReader.cancel(o),
                              e.ready.catch((y) => {
                                if (!this.destroyed) throw y;
                              }));
                          }));
                      }),
                        a.on("ReaderHeadersReady", (C) => {
                          const e = new _util.PromiseCapability(),
                            o = this._fullReader;
                          return (
                            o.headersReady.then(() => {
                              var y;
                              ((!o.isStreamingSupported ||
                                !o.isRangeSupported) &&
                                (this._lastProgress &&
                                  ((y = m.onProgress) == null ||
                                    y.call(m, this._lastProgress)),
                                (o.onProgress = (B) => {
                                  var M;
                                  (M = m.onProgress) == null ||
                                    M.call(m, {
                                      loaded: B.loaded,
                                      total: B.total,
                                    });
                                })),
                                e.resolve({
                                  isStreamingSupported: o.isStreamingSupported,
                                  isRangeSupported: o.isRangeSupported,
                                  contentLength: o.contentLength,
                                }));
                            }, e.reject),
                            e.promise
                          );
                        }),
                        a.on("GetRangeReader", (C, e) => {
                          (0, _util.assert)(
                            this._networkStream,
                            "GetRangeReader - no `IPDFStream` instance available.",
                          );
                          const o = this._networkStream.getRangeReader(
                            C.begin,
                            C.end,
                          );
                          if (!o) {
                            e.close();
                            return;
                          }
                          ((e.onPull = () => {
                            o.read()
                              .then(function ({ value: y, done: B }) {
                                if (B) {
                                  e.close();
                                  return;
                                }
                                ((0, _util.assert)(
                                  y instanceof ArrayBuffer,
                                  "GetRangeReader - expected an ArrayBuffer.",
                                ),
                                  e.enqueue(new Uint8Array(y), 1, [y]));
                              })
                              .catch((y) => {
                                e.error(y);
                              });
                          }),
                            (e.onCancel = (y) => {
                              (o.cancel(y),
                                e.ready.catch((B) => {
                                  if (!this.destroyed) throw B;
                                }));
                            }));
                        }),
                        a.on("GetDoc", ({ pdfInfo: C }) => {
                          ((this._numPages = C.numPages),
                            (this._htmlForXfa = C.htmlForXfa),
                            delete C.htmlForXfa,
                            m._capability.resolve(
                              new PDFDocumentProxy(C, this),
                            ));
                        }),
                        a.on("DocException", function (C) {
                          let e;
                          switch (C.name) {
                            case "PasswordException":
                              e = new _util.PasswordException(
                                C.message,
                                C.code,
                              );
                              break;
                            case "InvalidPDFException":
                              e = new _util.InvalidPDFException(C.message);
                              break;
                            case "MissingPDFException":
                              e = new _util.MissingPDFException(C.message);
                              break;
                            case "UnexpectedResponseException":
                              e = new _util.UnexpectedResponseException(
                                C.message,
                                C.status,
                              );
                              break;
                            case "UnknownErrorException":
                              e = new _util.UnknownErrorException(
                                C.message,
                                C.details,
                              );
                              break;
                            default:
                              (0, _util.unreachable)(
                                "DocException - expected a valid Error.",
                              );
                          }
                          m._capability.reject(e);
                        }),
                        a.on("PasswordRequest", (C) => {
                          if (
                            (Se(this, h, new _util.PromiseCapability()),
                            m.onPassword)
                          ) {
                            const e = (o) => {
                              o instanceof Error
                                ? l(this, h).reject(o)
                                : l(this, h).resolve({ password: o });
                            };
                            try {
                              m.onPassword(e, C.code);
                            } catch (o) {
                              l(this, h).reject(o);
                            }
                          } else
                            l(this, h).reject(
                              new _util.PasswordException(C.message, C.code),
                            );
                          return l(this, h).promise;
                        }),
                        a.on("DataLoaded", (C) => {
                          var e;
                          ((e = m.onProgress) == null ||
                            e.call(m, { loaded: C.length, total: C.length }),
                            this.downloadInfoCapability.resolve(C));
                        }),
                        a.on("StartRenderPage", (C) => {
                          if (this.destroyed) return;
                          l(this, P)
                            .get(C.pageIndex)
                            ._startRenderPage(C.transparency, C.cacheKey);
                        }),
                        a.on("commonobj", ([C, e, o]) => {
                          var y;
                          if (!this.destroyed && !this.commonObjs.has(C))
                            switch (e) {
                              case "Font":
                                const B = this._params;
                                if ("error" in o) {
                                  const x = o.error;
                                  ((0, _util.warn)(
                                    `Error during font loading: ${x}`,
                                  ),
                                    this.commonObjs.resolve(C, x));
                                  break;
                                }
                                const M =
                                    B.pdfBug &&
                                    (y = globalThis.FontInspector) != null &&
                                    y.enabled
                                      ? (x, z) =>
                                          globalThis.FontInspector.fontAdded(
                                            x,
                                            z,
                                          )
                                      : null,
                                  D = new _font_loader.FontFaceObject(o, {
                                    isEvalSupported: B.isEvalSupported,
                                    disableFontFace: B.disableFontFace,
                                    ignoreErrors: B.ignoreErrors,
                                    inspectFont: M,
                                  });
                                this.fontLoader
                                  .bind(D)
                                  .catch((x) =>
                                    a.sendWithPromise("FontFallback", {
                                      id: C,
                                    }),
                                  )
                                  .finally(() => {
                                    (!B.fontExtraProperties &&
                                      D.data &&
                                      (D.data = null),
                                      this.commonObjs.resolve(C, D));
                                  });
                                break;
                              case "FontPath":
                              case "Image":
                              case "Pattern":
                                this.commonObjs.resolve(C, o);
                                break;
                              default:
                                throw new Error(
                                  `Got unknown common object type ${e}`,
                                );
                            }
                        }),
                        a.on("obj", ([C, e, o, y]) => {
                          var M;
                          if (this.destroyed) return;
                          const B = l(this, P).get(e);
                          if (!B.objs.has(C))
                            switch (o) {
                              case "Image":
                                if ((B.objs.resolve(C, y), y)) {
                                  let D;
                                  if (y.bitmap) {
                                    const { width: x, height: z } = y;
                                    D = x * z * 4;
                                  } else
                                    D =
                                      ((M = y.data) == null
                                        ? void 0
                                        : M.length) || 0;
                                  D > _util.MAX_IMAGE_SIZE_TO_CACHE &&
                                    (B._maybeCleanupAfterRender = !0);
                                }
                                break;
                              case "Pattern":
                                B.objs.resolve(C, y);
                                break;
                              default:
                                throw new Error(`Got unknown object type ${o}`);
                            }
                        }),
                        a.on("DocProgress", (C) => {
                          var e;
                          this.destroyed ||
                            (e = m.onProgress) == null ||
                            e.call(m, { loaded: C.loaded, total: C.total });
                        }),
                        a.on("FetchBuiltInCMap", (C) =>
                          this.destroyed
                            ? Promise.reject(new Error("Worker was destroyed."))
                            : this.cMapReaderFactory
                              ? this.cMapReaderFactory.fetch(C)
                              : Promise.reject(
                                  new Error(
                                    "CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.",
                                  ),
                                ),
                        ),
                        a.on("FetchStandardFontData", (C) =>
                          this.destroyed
                            ? Promise.reject(new Error("Worker was destroyed."))
                            : this.standardFontDataFactory
                              ? this.standardFontDataFactory.fetch(C)
                              : Promise.reject(
                                  new Error(
                                    "StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.",
                                  ),
                                ),
                        ));
                    }
                    getData() {
                      return this.messageHandler.sendWithPromise(
                        "GetData",
                        null,
                      );
                    }
                    saveDocument() {
                      var C;
                      this.annotationStorage.size <= 0 &&
                        (0, _util.warn)(
                          "saveDocument called while `annotationStorage` is empty, please use the getData-method instead.",
                        );
                      const { map: a, transfers: m } =
                        this.annotationStorage.serializable;
                      return this.messageHandler
                        .sendWithPromise(
                          "SaveDocument",
                          {
                            isPureXfa: !!this._htmlForXfa,
                            numPages: this._numPages,
                            annotationStorage: a,
                            filename:
                              ((C = this._fullReader) == null
                                ? void 0
                                : C.filename) ?? null,
                          },
                          m,
                        )
                        .finally(() => {
                          this.annotationStorage.resetModified();
                        });
                    }
                    getPage(a) {
                      if (!Number.isInteger(a) || a <= 0 || a > this._numPages)
                        return Promise.reject(
                          new Error("Invalid page request."),
                        );
                      const m = a - 1,
                        C = l(this, _).get(m);
                      if (C) return C;
                      const e = this.messageHandler
                        .sendWithPromise("GetPage", { pageIndex: m })
                        .then((o) => {
                          if (this.destroyed)
                            throw new Error("Transport destroyed");
                          const y = new PDFPageProxy(
                            m,
                            o,
                            this,
                            this._params.pdfBug,
                          );
                          return (l(this, P).set(m, y), y);
                        });
                      return (l(this, _).set(m, e), e);
                    }
                    getPageIndex(a) {
                      return typeof a != "object" ||
                        a === null ||
                        !Number.isInteger(a.num) ||
                        a.num < 0 ||
                        !Number.isInteger(a.gen) ||
                        a.gen < 0
                        ? Promise.reject(
                            new Error("Invalid pageIndex request."),
                          )
                        : this.messageHandler.sendWithPromise("GetPageIndex", {
                            num: a.num,
                            gen: a.gen,
                          });
                    }
                    getAnnotations(a, m) {
                      return this.messageHandler.sendWithPromise(
                        "GetAnnotations",
                        { pageIndex: a, intent: m },
                      );
                    }
                    getFieldObjects() {
                      return le(this, r, ir).call(this, "GetFieldObjects");
                    }
                    hasJSActions() {
                      return le(this, r, ir).call(this, "HasJSActions");
                    }
                    getCalculationOrderIds() {
                      return this.messageHandler.sendWithPromise(
                        "GetCalculationOrderIds",
                        null,
                      );
                    }
                    getDestinations() {
                      return this.messageHandler.sendWithPromise(
                        "GetDestinations",
                        null,
                      );
                    }
                    getDestination(a) {
                      return typeof a != "string"
                        ? Promise.reject(
                            new Error("Invalid destination request."),
                          )
                        : this.messageHandler.sendWithPromise(
                            "GetDestination",
                            { id: a },
                          );
                    }
                    getPageLabels() {
                      return this.messageHandler.sendWithPromise(
                        "GetPageLabels",
                        null,
                      );
                    }
                    getPageLayout() {
                      return this.messageHandler.sendWithPromise(
                        "GetPageLayout",
                        null,
                      );
                    }
                    getPageMode() {
                      return this.messageHandler.sendWithPromise(
                        "GetPageMode",
                        null,
                      );
                    }
                    getViewerPreferences() {
                      return this.messageHandler.sendWithPromise(
                        "GetViewerPreferences",
                        null,
                      );
                    }
                    getOpenAction() {
                      return this.messageHandler.sendWithPromise(
                        "GetOpenAction",
                        null,
                      );
                    }
                    getAttachments() {
                      return this.messageHandler.sendWithPromise(
                        "GetAttachments",
                        null,
                      );
                    }
                    getDocJSActions() {
                      return le(this, r, ir).call(this, "GetDocJSActions");
                    }
                    getPageJSActions(a) {
                      return this.messageHandler.sendWithPromise(
                        "GetPageJSActions",
                        { pageIndex: a },
                      );
                    }
                    getStructTree(a) {
                      return this.messageHandler.sendWithPromise(
                        "GetStructTree",
                        { pageIndex: a },
                      );
                    }
                    getOutline() {
                      return this.messageHandler.sendWithPromise(
                        "GetOutline",
                        null,
                      );
                    }
                    getOptionalContentConfig() {
                      return this.messageHandler
                        .sendWithPromise("GetOptionalContentConfig", null)
                        .then(
                          (a) =>
                            new _optional_content_config.OptionalContentConfig(
                              a,
                            ),
                        );
                    }
                    getPermissions() {
                      return this.messageHandler.sendWithPromise(
                        "GetPermissions",
                        null,
                      );
                    }
                    getMetadata() {
                      const a = "GetMetadata",
                        m = l(this, N).get(a);
                      if (m) return m;
                      const C = this.messageHandler
                        .sendWithPromise(a, null)
                        .then((e) => {
                          var o, y;
                          return {
                            info: e[0],
                            metadata: e[1]
                              ? new _metadata.Metadata(e[1])
                              : null,
                            contentDispositionFilename:
                              ((o = this._fullReader) == null
                                ? void 0
                                : o.filename) ?? null,
                            contentLength:
                              ((y = this._fullReader) == null
                                ? void 0
                                : y.contentLength) ?? null,
                          };
                        });
                      return (l(this, N).set(a, C), C);
                    }
                    getMarkInfo() {
                      return this.messageHandler.sendWithPromise(
                        "GetMarkInfo",
                        null,
                      );
                    }
                    async startCleanup(a = !1) {
                      if (!this.destroyed) {
                        await this.messageHandler.sendWithPromise(
                          "Cleanup",
                          null,
                        );
                        for (const m of l(this, P).values())
                          if (!m.cleanup())
                            throw new Error(
                              `startCleanup: Page ${m.pageNumber} is currently rendering.`,
                            );
                        (this.commonObjs.clear(),
                          a || this.fontLoader.clear(),
                          l(this, N).clear(),
                          this.filterFactory.destroy(!0));
                      }
                    }
                    get loadingParams() {
                      const { disableAutoFetch: a, enableXfa: m } =
                        this._params;
                      return (0, _util.shadow)(this, "loadingParams", {
                        disableAutoFetch: a,
                        enableXfa: m,
                      });
                    }
                  }
                  ((N = new WeakMap()),
                    (P = new WeakMap()),
                    (_ = new WeakMap()),
                    (h = new WeakMap()),
                    (r = new WeakSet()),
                    (ir = function (a, m = null) {
                      const C = l(this, N).get(a);
                      if (C) return C;
                      const e = this.messageHandler.sendWithPromise(a, m);
                      return (l(this, N).set(a, e), e);
                    }));
                  class PDFObjects {
                    constructor() {
                      ye(this, u);
                      ye(this, p, Object.create(null));
                    }
                    get(a, m = null) {
                      if (m) {
                        const e = le(this, u, xr).call(this, a);
                        return (
                          e.capability.promise.then(() => m(e.data)),
                          null
                        );
                      }
                      const C = l(this, p)[a];
                      if (!(C != null && C.capability.settled))
                        throw new Error(
                          `Requesting object that isn't resolved yet ${a}.`,
                        );
                      return C.data;
                    }
                    has(a) {
                      const m = l(this, p)[a];
                      return (m == null ? void 0 : m.capability.settled) || !1;
                    }
                    resolve(a, m = null) {
                      const C = le(this, u, xr).call(this, a);
                      ((C.data = m), C.capability.resolve());
                    }
                    clear() {
                      var a;
                      for (const m in l(this, p)) {
                        const { data: C } = l(this, p)[m];
                        (a = C == null ? void 0 : C.bitmap) == null ||
                          a.close();
                      }
                      Se(this, p, Object.create(null));
                    }
                  }
                  ((p = new WeakMap()),
                    (u = new WeakSet()),
                    (xr = function (a) {
                      var m;
                      return (
                        (m = l(this, p))[a] ||
                        (m[a] = {
                          capability: new _util.PromiseCapability(),
                          data: null,
                        })
                      );
                    }));
                  class RenderTask {
                    constructor(a) {
                      ye(this, v, null);
                      (Se(this, v, a), (this.onContinue = null));
                    }
                    get promise() {
                      return l(this, v).capability.promise;
                    }
                    cancel(a = 0) {
                      l(this, v).cancel(null, a);
                    }
                    get separateAnnots() {
                      const { separateAnnots: a } = l(this, v).operatorList;
                      if (!a) return !1;
                      const { annotationCanvasMap: m } = l(this, v);
                      return (
                        a.form ||
                        (a.canvas && (m == null ? void 0 : m.size) > 0)
                      );
                    }
                  }
                  ((v = new WeakMap()), (exports.RenderTask = RenderTask));
                  const b = class b {
                    constructor({
                      callback: a,
                      params: m,
                      objs: C,
                      commonObjs: e,
                      annotationCanvasMap: o,
                      operatorList: y,
                      pageIndex: B,
                      canvasFactory: M,
                      filterFactory: D,
                      useRequestAnimationFrame: x = !1,
                      pdfBug: z = !1,
                      pageColors: L = null,
                    }) {
                      ((this.callback = a),
                        (this.params = m),
                        (this.objs = C),
                        (this.commonObjs = e),
                        (this.annotationCanvasMap = o),
                        (this.operatorListIdx = null),
                        (this.operatorList = y),
                        (this._pageIndex = B),
                        (this.canvasFactory = M),
                        (this.filterFactory = D),
                        (this._pdfBug = z),
                        (this.pageColors = L),
                        (this.running = !1),
                        (this.graphicsReadyCallback = null),
                        (this.graphicsReady = !1),
                        (this._useRequestAnimationFrame =
                          x === !0 && typeof window < "u"),
                        (this.cancelled = !1),
                        (this.capability = new _util.PromiseCapability()),
                        (this.task = new RenderTask(this)),
                        (this._cancelBound = this.cancel.bind(this)),
                        (this._continueBound = this._continue.bind(this)),
                        (this._scheduleNextBound =
                          this._scheduleNext.bind(this)),
                        (this._nextBound = this._next.bind(this)),
                        (this._canvas = m.canvasContext.canvas));
                    }
                    get completed() {
                      return this.capability.promise.catch(function () {});
                    }
                    initializeGraphics({
                      transparency: a = !1,
                      optionalContentConfig: m,
                    }) {
                      var B, M;
                      if (this.cancelled) return;
                      if (this._canvas) {
                        if (l(b, f).has(this._canvas))
                          throw new Error(
                            "Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.",
                          );
                        l(b, f).add(this._canvas);
                      }
                      this._pdfBug &&
                        (B = globalThis.StepperManager) != null &&
                        B.enabled &&
                        ((this.stepper = globalThis.StepperManager.create(
                          this._pageIndex,
                        )),
                        this.stepper.init(this.operatorList),
                        (this.stepper.nextBreakPoint =
                          this.stepper.getNextBreakPoint()));
                      const {
                        canvasContext: C,
                        viewport: e,
                        transform: o,
                        background: y,
                      } = this.params;
                      ((this.gfx = new _canvas.CanvasGraphics(
                        C,
                        this.commonObjs,
                        this.objs,
                        this.canvasFactory,
                        this.filterFactory,
                        { optionalContentConfig: m },
                        this.annotationCanvasMap,
                        this.pageColors,
                      )),
                        this.gfx.beginDrawing({
                          transform: o,
                          viewport: e,
                          transparency: a,
                          background: y,
                        }),
                        (this.operatorListIdx = 0),
                        (this.graphicsReady = !0),
                        (M = this.graphicsReadyCallback) == null ||
                          M.call(this));
                    }
                    cancel(a = null, m = 0) {
                      var C;
                      ((this.running = !1),
                        (this.cancelled = !0),
                        (C = this.gfx) == null || C.endDrawing(),
                        l(b, f).delete(this._canvas),
                        this.callback(
                          a ||
                            new _display_utils.RenderingCancelledException(
                              `Rendering cancelled, page ${this._pageIndex + 1}`,
                              m,
                            ),
                        ));
                    }
                    operatorListChanged() {
                      var a;
                      if (!this.graphicsReady) {
                        this.graphicsReadyCallback ||
                          (this.graphicsReadyCallback = this._continueBound);
                        return;
                      }
                      ((a = this.stepper) == null ||
                        a.updateOperatorList(this.operatorList),
                        !this.running && this._continue());
                    }
                    _continue() {
                      ((this.running = !0),
                        !this.cancelled &&
                          (this.task.onContinue
                            ? this.task.onContinue(this._scheduleNextBound)
                            : this._scheduleNext()));
                    }
                    _scheduleNext() {
                      this._useRequestAnimationFrame
                        ? window.requestAnimationFrame(() => {
                            this._nextBound().catch(this._cancelBound);
                          })
                        : Promise.resolve()
                            .then(this._nextBound)
                            .catch(this._cancelBound);
                    }
                    async _next() {
                      this.cancelled ||
                        ((this.operatorListIdx = this.gfx.executeOperatorList(
                          this.operatorList,
                          this.operatorListIdx,
                          this._continueBound,
                          this.stepper,
                        )),
                        this.operatorListIdx ===
                          this.operatorList.argsArray.length &&
                          ((this.running = !1),
                          this.operatorList.lastChunk &&
                            (this.gfx.endDrawing(),
                            l(b, f).delete(this._canvas),
                            this.callback())));
                    }
                  };
                  ((f = new WeakMap()), ye(b, f, new WeakSet()));
                  let InternalRenderTask = b;
                  const version = "3.11.174";
                  exports.version = version;
                  const build = "ce8716743";
                  exports.build = build;
                },
                (t, A, n) => {
                  var W, k, N, Ti, _;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.SerializableEmpty =
                      A.PrintAnnotationStorage =
                      A.AnnotationStorage =
                        void 0));
                  var w = n(1),
                    S = n(4),
                    i = n(8);
                  const H = Object.freeze({
                    map: null,
                    hash: "",
                    transfers: void 0,
                  });
                  A.SerializableEmpty = H;
                  class ee {
                    constructor() {
                      ye(this, N);
                      ye(this, W, !1);
                      ye(this, k, new Map());
                      ((this.onSetModified = null),
                        (this.onResetModified = null),
                        (this.onAnnotationEditor = null));
                    }
                    getValue(r, d) {
                      const p = l(this, k).get(r);
                      return p === void 0 ? d : Object.assign(d, p);
                    }
                    getRawValue(r) {
                      return l(this, k).get(r);
                    }
                    remove(r) {
                      if (
                        (l(this, k).delete(r),
                        l(this, k).size === 0 && this.resetModified(),
                        typeof this.onAnnotationEditor == "function")
                      ) {
                        for (const d of l(this, k).values())
                          if (d instanceof S.AnnotationEditor) return;
                        this.onAnnotationEditor(null);
                      }
                    }
                    setValue(r, d) {
                      const p = l(this, k).get(r);
                      let u = !1;
                      if (p !== void 0)
                        for (const [F, v] of Object.entries(d))
                          p[F] !== v && ((u = !0), (p[F] = v));
                      else ((u = !0), l(this, k).set(r, d));
                      (u && le(this, N, Ti).call(this),
                        d instanceof S.AnnotationEditor &&
                          typeof this.onAnnotationEditor == "function" &&
                          this.onAnnotationEditor(d.constructor._type));
                    }
                    has(r) {
                      return l(this, k).has(r);
                    }
                    getAll() {
                      return l(this, k).size > 0
                        ? (0, w.objectFromMap)(l(this, k))
                        : null;
                    }
                    setAll(r) {
                      for (const [d, p] of Object.entries(r))
                        this.setValue(d, p);
                    }
                    get size() {
                      return l(this, k).size;
                    }
                    resetModified() {
                      l(this, W) &&
                        (Se(this, W, !1),
                        typeof this.onResetModified == "function" &&
                          this.onResetModified());
                    }
                    get print() {
                      return new X(this);
                    }
                    get serializable() {
                      if (l(this, k).size === 0) return H;
                      const r = new Map(),
                        d = new i.MurmurHash3_64(),
                        p = [],
                        u = Object.create(null);
                      let F = !1;
                      for (const [v, f] of l(this, k)) {
                        const b =
                          f instanceof S.AnnotationEditor
                            ? f.serialize(!1, u)
                            : f;
                        b &&
                          (r.set(v, b),
                          d.update(`${v}:${JSON.stringify(b)}`),
                          F || (F = !!b.bitmap));
                      }
                      if (F)
                        for (const v of r.values())
                          v.bitmap && p.push(v.bitmap);
                      return r.size > 0
                        ? { map: r, hash: d.hexdigest(), transfers: p }
                        : H;
                    }
                  }
                  ((W = new WeakMap()),
                    (k = new WeakMap()),
                    (N = new WeakSet()),
                    (Ti = function () {
                      l(this, W) ||
                        (Se(this, W, !0),
                        typeof this.onSetModified == "function" &&
                          this.onSetModified());
                    }),
                    (A.AnnotationStorage = ee));
                  class X extends ee {
                    constructor(d) {
                      super();
                      ye(this, _);
                      const { map: p, hash: u, transfers: F } = d.serializable,
                        v = structuredClone(p, F ? { transfer: F } : null);
                      Se(this, _, { map: v, hash: u, transfers: F });
                    }
                    get print() {
                      (0, w.unreachable)(
                        "Should not call PrintAnnotationStorage.print",
                      );
                    }
                    get serializable() {
                      return l(this, _);
                    }
                  }
                  ((_ = new WeakMap()), (A.PrintAnnotationStorage = X));
                },
                (t, A, n) => {
                  var X,
                    W,
                    k,
                    N,
                    P,
                    _,
                    h,
                    r,
                    d,
                    p,
                    u,
                    F,
                    v,
                    f,
                    b,
                    Rr,
                    Lr,
                    m,
                    Fr,
                    Ir,
                    xi,
                    Ri,
                    Li,
                    Dr,
                    Fi;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.AnnotationEditor = void 0));
                  var w = n(5),
                    S = n(1),
                    i = n(6);
                  const x = class x {
                    constructor(L) {
                      ye(this, b);
                      ye(this, X, "");
                      ye(this, W, !1);
                      ye(this, k, null);
                      ye(this, N, null);
                      ye(this, P, null);
                      ye(this, _, !1);
                      ye(this, h, null);
                      ye(this, r, this.focusin.bind(this));
                      ye(this, d, this.focusout.bind(this));
                      ye(this, p, !1);
                      ye(this, u, !1);
                      ye(this, F, !1);
                      $t(this, "_initialOptions", Object.create(null));
                      $t(this, "_uiManager", null);
                      $t(this, "_focusEventsAllowed", !0);
                      $t(this, "_l10nPromise", null);
                      ye(this, v, !1);
                      ye(this, f, x._zIndex++);
                      (this.constructor === x &&
                        (0, S.unreachable)(
                          "Cannot initialize AnnotationEditor.",
                        ),
                        (this.parent = L.parent),
                        (this.id = L.id),
                        (this.width = this.height = null),
                        (this.pageIndex = L.parent.pageIndex),
                        (this.name = L.name),
                        (this.div = null),
                        (this._uiManager = L.uiManager),
                        (this.annotationElementId = null),
                        (this._willKeepAspectRatio = !1),
                        (this._initialOptions.isCentered = L.isCentered),
                        (this._structTreeParentId = null));
                      const {
                        rotation: V,
                        rawDims: {
                          pageWidth: Y,
                          pageHeight: T,
                          pageX: s,
                          pageY: g,
                        },
                      } = this.parent.viewport;
                      ((this.rotation = V),
                        (this.pageRotation =
                          (360 + V - this._uiManager.viewParameters.rotation) %
                          360),
                        (this.pageDimensions = [Y, T]),
                        (this.pageTranslation = [s, g]));
                      const [R, $] = this.parentDimensions;
                      ((this.x = L.x / R),
                        (this.y = L.y / $),
                        (this.isAttachedToDOM = !1),
                        (this.deleted = !1));
                    }
                    get editorType() {
                      return Object.getPrototypeOf(this).constructor._type;
                    }
                    static get _defaultLineColor() {
                      return (0, S.shadow)(
                        this,
                        "_defaultLineColor",
                        this._colorManager.getHexCode("CanvasText"),
                      );
                    }
                    static deleteAnnotationElement(L) {
                      const V = new ee({
                        id: L.parent.getNextId(),
                        parent: L.parent,
                        uiManager: L._uiManager,
                      });
                      ((V.annotationElementId = L.annotationElementId),
                        (V.deleted = !0),
                        V._uiManager.addToAnnotationStorage(V));
                    }
                    static initialize(L, V = null) {
                      if (
                        (x._l10nPromise ||
                          (x._l10nPromise = new Map(
                            [
                              "editor_alt_text_button_label",
                              "editor_alt_text_edit_button_label",
                              "editor_alt_text_decorative_tooltip",
                            ].map((T) => [T, L.get(T)]),
                          )),
                        V != null && V.strings)
                      )
                        for (const T of V.strings)
                          x._l10nPromise.set(T, L.get(T));
                      if (x._borderLineWidth !== -1) return;
                      const Y = getComputedStyle(document.documentElement);
                      x._borderLineWidth =
                        parseFloat(Y.getPropertyValue("--outline-width")) || 0;
                    }
                    static updateDefaultParams(L, V) {}
                    static get defaultPropertiesToUpdate() {
                      return [];
                    }
                    static isHandlingMimeForPasting(L) {
                      return !1;
                    }
                    static paste(L, V) {
                      (0, S.unreachable)("Not implemented");
                    }
                    get propertiesToUpdate() {
                      return [];
                    }
                    get _isDraggable() {
                      return l(this, v);
                    }
                    set _isDraggable(L) {
                      var V;
                      (Se(this, v, L),
                        (V = this.div) == null ||
                          V.classList.toggle("draggable", L));
                    }
                    center() {
                      const [L, V] = this.pageDimensions;
                      switch (this.parentRotation) {
                        case 90:
                          ((this.x -= (this.height * V) / (L * 2)),
                            (this.y += (this.width * L) / (V * 2)));
                          break;
                        case 180:
                          ((this.x += this.width / 2),
                            (this.y += this.height / 2));
                          break;
                        case 270:
                          ((this.x += (this.height * V) / (L * 2)),
                            (this.y -= (this.width * L) / (V * 2)));
                          break;
                        default:
                          ((this.x -= this.width / 2),
                            (this.y -= this.height / 2));
                          break;
                      }
                      this.fixAndSetPosition();
                    }
                    addCommands(L) {
                      this._uiManager.addCommands(L);
                    }
                    get currentLayer() {
                      return this._uiManager.currentLayer;
                    }
                    setInBackground() {
                      this.div.style.zIndex = 0;
                    }
                    setInForeground() {
                      this.div.style.zIndex = l(this, f);
                    }
                    setParent(L) {
                      (L !== null &&
                        ((this.pageIndex = L.pageIndex),
                        (this.pageDimensions = L.pageDimensions)),
                        (this.parent = L));
                    }
                    focusin(L) {
                      this._focusEventsAllowed &&
                        (l(this, p)
                          ? Se(this, p, !1)
                          : this.parent.setSelected(this));
                    }
                    focusout(L) {
                      var Y;
                      if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                        return;
                      const V = L.relatedTarget;
                      (V != null && V.closest(`#${this.id}`)) ||
                        (L.preventDefault(),
                        ((Y = this.parent) != null && Y.isMultipleSelection) ||
                          this.commitOrRemove());
                    }
                    commitOrRemove() {
                      this.isEmpty() ? this.remove() : this.commit();
                    }
                    commit() {
                      this.addToAnnotationStorage();
                    }
                    addToAnnotationStorage() {
                      this._uiManager.addToAnnotationStorage(this);
                    }
                    setAt(L, V, Y, T) {
                      const [s, g] = this.parentDimensions;
                      (([Y, T] = this.screenToPageTranslation(Y, T)),
                        (this.x = (L + Y) / s),
                        (this.y = (V + T) / g),
                        this.fixAndSetPosition());
                    }
                    translate(L, V) {
                      le(this, b, Rr).call(this, this.parentDimensions, L, V);
                    }
                    translateInPage(L, V) {
                      (le(this, b, Rr).call(this, this.pageDimensions, L, V),
                        this.div.scrollIntoView({ block: "nearest" }));
                    }
                    drag(L, V) {
                      const [Y, T] = this.parentDimensions;
                      if (
                        ((this.x += L / Y),
                        (this.y += V / T),
                        this.parent &&
                          (this.x < 0 ||
                            this.x > 1 ||
                            this.y < 0 ||
                            this.y > 1))
                      ) {
                        const { x: j, y: U } = this.div.getBoundingClientRect();
                        this.parent.findNewParent(this, j, U) &&
                          ((this.x -= Math.floor(this.x)),
                          (this.y -= Math.floor(this.y)));
                      }
                      let { x: s, y: g } = this;
                      const [R, $] = le(this, b, Lr).call(this);
                      ((s += R),
                        (g += $),
                        (this.div.style.left = `${(100 * s).toFixed(2)}%`),
                        (this.div.style.top = `${(100 * g).toFixed(2)}%`),
                        this.div.scrollIntoView({ block: "nearest" }));
                    }
                    fixAndSetPosition() {
                      const [L, V] = this.pageDimensions;
                      let { x: Y, y: T, width: s, height: g } = this;
                      switch (
                        ((s *= L), (g *= V), (Y *= L), (T *= V), this.rotation)
                      ) {
                        case 0:
                          ((Y = Math.max(0, Math.min(L - s, Y))),
                            (T = Math.max(0, Math.min(V - g, T))));
                          break;
                        case 90:
                          ((Y = Math.max(0, Math.min(L - g, Y))),
                            (T = Math.min(V, Math.max(s, T))));
                          break;
                        case 180:
                          ((Y = Math.min(L, Math.max(s, Y))),
                            (T = Math.min(V, Math.max(g, T))));
                          break;
                        case 270:
                          ((Y = Math.min(L, Math.max(g, Y))),
                            (T = Math.max(0, Math.min(V - s, T))));
                          break;
                      }
                      ((this.x = Y /= L), (this.y = T /= V));
                      const [R, $] = le(this, b, Lr).call(this);
                      ((Y += R), (T += $));
                      const { style: j } = this.div;
                      ((j.left = `${(100 * Y).toFixed(2)}%`),
                        (j.top = `${(100 * T).toFixed(2)}%`),
                        this.moveInDOM());
                    }
                    screenToPageTranslation(L, V) {
                      var Y;
                      return le((Y = x), m, Fr).call(
                        Y,
                        L,
                        V,
                        this.parentRotation,
                      );
                    }
                    pageTranslationToScreen(L, V) {
                      var Y;
                      return le((Y = x), m, Fr).call(
                        Y,
                        L,
                        V,
                        360 - this.parentRotation,
                      );
                    }
                    get parentScale() {
                      return this._uiManager.viewParameters.realScale;
                    }
                    get parentRotation() {
                      return (
                        (this._uiManager.viewParameters.rotation +
                          this.pageRotation) %
                        360
                      );
                    }
                    get parentDimensions() {
                      const {
                          parentScale: L,
                          pageDimensions: [V, Y],
                        } = this,
                        T = V * L,
                        s = Y * L;
                      return S.FeatureTest.isCSSRoundSupported
                        ? [Math.round(T), Math.round(s)]
                        : [T, s];
                    }
                    setDims(L, V) {
                      var s;
                      const [Y, T] = this.parentDimensions;
                      ((this.div.style.width = `${((100 * L) / Y).toFixed(2)}%`),
                        l(this, _) ||
                          (this.div.style.height = `${((100 * V) / T).toFixed(2)}%`),
                        (s = l(this, k)) == null ||
                          s.classList.toggle(
                            "small",
                            L < x.SMALL_EDITOR_SIZE || V < x.SMALL_EDITOR_SIZE,
                          ));
                    }
                    fixDims() {
                      const { style: L } = this.div,
                        { height: V, width: Y } = L,
                        T = Y.endsWith("%"),
                        s = !l(this, _) && V.endsWith("%");
                      if (T && s) return;
                      const [g, R] = this.parentDimensions;
                      (T ||
                        (L.width = `${((100 * parseFloat(Y)) / g).toFixed(2)}%`),
                        !l(this, _) &&
                          !s &&
                          (L.height = `${((100 * parseFloat(V)) / R).toFixed(2)}%`));
                    }
                    getInitialTranslation() {
                      return [0, 0];
                    }
                    async addAltTextButton() {
                      if (l(this, k)) return;
                      const L = Se(this, k, document.createElement("button"));
                      L.className = "altText";
                      const V = await x._l10nPromise.get(
                        "editor_alt_text_button_label",
                      );
                      ((L.textContent = V),
                        L.setAttribute("aria-label", V),
                        (L.tabIndex = "0"),
                        L.addEventListener("contextmenu", i.noContextMenu),
                        L.addEventListener("pointerdown", (Y) =>
                          Y.stopPropagation(),
                        ),
                        L.addEventListener(
                          "click",
                          (Y) => {
                            (Y.preventDefault(),
                              this._uiManager.editAltText(this));
                          },
                          { capture: !0 },
                        ),
                        L.addEventListener("keydown", (Y) => {
                          Y.target === L &&
                            Y.key === "Enter" &&
                            (Y.preventDefault(),
                            this._uiManager.editAltText(this));
                        }),
                        le(this, b, Dr).call(this),
                        this.div.append(L),
                        x.SMALL_EDITOR_SIZE ||
                          (x.SMALL_EDITOR_SIZE = Math.min(
                            128,
                            Math.round(L.getBoundingClientRect().width * 1.4),
                          )));
                    }
                    getClientDimensions() {
                      return this.div.getBoundingClientRect();
                    }
                    get altTextData() {
                      return { altText: l(this, X), decorative: l(this, W) };
                    }
                    set altTextData({ altText: L, decorative: V }) {
                      (l(this, X) === L && l(this, W) === V) ||
                        (Se(this, X, L),
                        Se(this, W, V),
                        le(this, b, Dr).call(this));
                    }
                    render() {
                      ((this.div = document.createElement("div")),
                        this.div.setAttribute(
                          "data-editor-rotation",
                          (360 - this.rotation) % 360,
                        ),
                        (this.div.className = this.name),
                        this.div.setAttribute("id", this.id),
                        this.div.setAttribute("tabIndex", 0),
                        this.setInForeground(),
                        this.div.addEventListener("focusin", l(this, r)),
                        this.div.addEventListener("focusout", l(this, d)));
                      const [L, V] = this.parentDimensions;
                      this.parentRotation % 180 !== 0 &&
                        ((this.div.style.maxWidth = `${((100 * V) / L).toFixed(2)}%`),
                        (this.div.style.maxHeight = `${((100 * L) / V).toFixed(2)}%`));
                      const [Y, T] = this.getInitialTranslation();
                      return (
                        this.translate(Y, T),
                        (0, w.bindEvents)(this, this.div, ["pointerdown"]),
                        this.div
                      );
                    }
                    pointerdown(L) {
                      const { isMac: V } = S.FeatureTest.platform;
                      if (L.button !== 0 || (L.ctrlKey && V)) {
                        L.preventDefault();
                        return;
                      }
                      (Se(this, p, !0), le(this, b, Fi).call(this, L));
                    }
                    moveInDOM() {
                      var L;
                      (L = this.parent) == null || L.moveEditorInDOM(this);
                    }
                    _setParentAndPosition(L, V, Y) {
                      (L.changeParent(this),
                        (this.x = V),
                        (this.y = Y),
                        this.fixAndSetPosition());
                    }
                    getRect(L, V) {
                      const Y = this.parentScale,
                        [T, s] = this.pageDimensions,
                        [g, R] = this.pageTranslation,
                        $ = L / Y,
                        j = V / Y,
                        U = this.x * T,
                        Q = this.y * s,
                        fe = this.width * T,
                        we = this.height * s;
                      switch (this.rotation) {
                        case 0:
                          return [
                            U + $ + g,
                            s - Q - j - we + R,
                            U + $ + fe + g,
                            s - Q - j + R,
                          ];
                        case 90:
                          return [
                            U + j + g,
                            s - Q + $ + R,
                            U + j + we + g,
                            s - Q + $ + fe + R,
                          ];
                        case 180:
                          return [
                            U - $ - fe + g,
                            s - Q + j + R,
                            U - $ + g,
                            s - Q + j + we + R,
                          ];
                        case 270:
                          return [
                            U - j - we + g,
                            s - Q - $ - fe + R,
                            U - j + g,
                            s - Q - $ + R,
                          ];
                        default:
                          throw new Error("Invalid rotation");
                      }
                    }
                    getRectInCurrentCoords(L, V) {
                      const [Y, T, s, g] = L,
                        R = s - Y,
                        $ = g - T;
                      switch (this.rotation) {
                        case 0:
                          return [Y, V - g, R, $];
                        case 90:
                          return [Y, V - T, $, R];
                        case 180:
                          return [s, V - T, R, $];
                        case 270:
                          return [s, V - g, $, R];
                        default:
                          throw new Error("Invalid rotation");
                      }
                    }
                    onceAdded() {}
                    isEmpty() {
                      return !1;
                    }
                    enableEditMode() {
                      Se(this, F, !0);
                    }
                    disableEditMode() {
                      Se(this, F, !1);
                    }
                    isInEditMode() {
                      return l(this, F);
                    }
                    shouldGetKeyboardEvents() {
                      return !1;
                    }
                    needsToBeRebuilt() {
                      return this.div && !this.isAttachedToDOM;
                    }
                    rebuild() {
                      var L, V;
                      ((L = this.div) == null ||
                        L.addEventListener("focusin", l(this, r)),
                        (V = this.div) == null ||
                          V.addEventListener("focusout", l(this, d)));
                    }
                    serialize(L = !1, V = null) {
                      (0, S.unreachable)("An editor must be serializable");
                    }
                    static deserialize(L, V, Y) {
                      const T = new this.prototype.constructor({
                        parent: V,
                        id: V.getNextId(),
                        uiManager: Y,
                      });
                      T.rotation = L.rotation;
                      const [s, g] = T.pageDimensions,
                        [R, $, j, U] = T.getRectInCurrentCoords(L.rect, g);
                      return (
                        (T.x = R / s),
                        (T.y = $ / g),
                        (T.width = j / s),
                        (T.height = U / g),
                        T
                      );
                    }
                    remove() {
                      var L;
                      (this.div.removeEventListener("focusin", l(this, r)),
                        this.div.removeEventListener("focusout", l(this, d)),
                        this.isEmpty() || this.commit(),
                        this.parent
                          ? this.parent.remove(this)
                          : this._uiManager.removeEditor(this),
                        (L = l(this, k)) == null || L.remove(),
                        Se(this, k, null),
                        Se(this, N, null));
                    }
                    get isResizable() {
                      return !1;
                    }
                    makeResizable() {
                      this.isResizable &&
                        (le(this, b, xi).call(this),
                        l(this, h).classList.remove("hidden"));
                    }
                    select() {
                      var L;
                      (this.makeResizable(),
                        (L = this.div) == null ||
                          L.classList.add("selectedEditor"));
                    }
                    unselect() {
                      var L, V, Y;
                      ((L = l(this, h)) == null || L.classList.add("hidden"),
                        (V = this.div) == null ||
                          V.classList.remove("selectedEditor"),
                        (Y = this.div) != null &&
                          Y.contains(document.activeElement) &&
                          this._uiManager.currentLayer.div.focus());
                    }
                    updateParams(L, V) {}
                    disableEditing() {
                      l(this, k) && (l(this, k).hidden = !0);
                    }
                    enableEditing() {
                      l(this, k) && (l(this, k).hidden = !1);
                    }
                    enterInEditMode() {}
                    get contentDiv() {
                      return this.div;
                    }
                    get isEditing() {
                      return l(this, u);
                    }
                    set isEditing(L) {
                      (Se(this, u, L),
                        this.parent &&
                          (L
                            ? (this.parent.setSelected(this),
                              this.parent.setActiveEditor(this))
                            : this.parent.setActiveEditor(null)));
                    }
                    setAspectRatio(L, V) {
                      Se(this, _, !0);
                      const Y = L / V,
                        { style: T } = this.div;
                      ((T.aspectRatio = Y), (T.height = "auto"));
                    }
                    static get MIN_SIZE() {
                      return 16;
                    }
                  };
                  ((X = new WeakMap()),
                    (W = new WeakMap()),
                    (k = new WeakMap()),
                    (N = new WeakMap()),
                    (P = new WeakMap()),
                    (_ = new WeakMap()),
                    (h = new WeakMap()),
                    (r = new WeakMap()),
                    (d = new WeakMap()),
                    (p = new WeakMap()),
                    (u = new WeakMap()),
                    (F = new WeakMap()),
                    (v = new WeakMap()),
                    (f = new WeakMap()),
                    (b = new WeakSet()),
                    (Rr = function ([L, V], Y, T) {
                      (([Y, T] = this.screenToPageTranslation(Y, T)),
                        (this.x += Y / L),
                        (this.y += T / V),
                        this.fixAndSetPosition());
                    }),
                    (Lr = function () {
                      const [L, V] = this.parentDimensions,
                        { _borderLineWidth: Y } = x,
                        T = Y / L,
                        s = Y / V;
                      switch (this.rotation) {
                        case 90:
                          return [-T, s];
                        case 180:
                          return [T, s];
                        case 270:
                          return [T, -s];
                        default:
                          return [-T, -s];
                      }
                    }),
                    (m = new WeakSet()),
                    (Fr = function (L, V, Y) {
                      switch (Y) {
                        case 90:
                          return [V, -L];
                        case 180:
                          return [-L, -V];
                        case 270:
                          return [-V, L];
                        default:
                          return [L, V];
                      }
                    }),
                    (Ir = function (L) {
                      switch (L) {
                        case 90: {
                          const [V, Y] = this.pageDimensions;
                          return [0, -V / Y, Y / V, 0];
                        }
                        case 180:
                          return [-1, 0, 0, -1];
                        case 270: {
                          const [V, Y] = this.pageDimensions;
                          return [0, V / Y, -Y / V, 0];
                        }
                        default:
                          return [1, 0, 0, 1];
                      }
                    }),
                    (xi = function () {
                      if (l(this, h)) return;
                      (Se(this, h, document.createElement("div")),
                        l(this, h).classList.add("resizers"));
                      const L = [
                        "topLeft",
                        "topRight",
                        "bottomRight",
                        "bottomLeft",
                      ];
                      this._willKeepAspectRatio ||
                        L.push(
                          "topMiddle",
                          "middleRight",
                          "bottomMiddle",
                          "middleLeft",
                        );
                      for (const V of L) {
                        const Y = document.createElement("div");
                        (l(this, h).append(Y),
                          Y.classList.add("resizer", V),
                          Y.addEventListener(
                            "pointerdown",
                            le(this, b, Ri).bind(this, V),
                          ),
                          Y.addEventListener("contextmenu", i.noContextMenu));
                      }
                      this.div.prepend(l(this, h));
                    }),
                    (Ri = function (L, V) {
                      V.preventDefault();
                      const { isMac: Y } = S.FeatureTest.platform;
                      if (V.button !== 0 || (V.ctrlKey && Y)) return;
                      const T = le(this, b, Li).bind(this, L),
                        s = this._isDraggable;
                      this._isDraggable = !1;
                      const g = { passive: !0, capture: !0 };
                      window.addEventListener("pointermove", T, g);
                      const R = this.x,
                        $ = this.y,
                        j = this.width,
                        U = this.height,
                        Q = this.parent.div.style.cursor,
                        fe = this.div.style.cursor;
                      this.div.style.cursor = this.parent.div.style.cursor =
                        window.getComputedStyle(V.target).cursor;
                      const we = () => {
                        ((this._isDraggable = s),
                          window.removeEventListener("pointerup", we),
                          window.removeEventListener("blur", we),
                          window.removeEventListener("pointermove", T, g),
                          (this.parent.div.style.cursor = Q),
                          (this.div.style.cursor = fe));
                        const Ee = this.x,
                          Ce = this.y,
                          xe = this.width,
                          Re = this.height;
                        (Ee === R && Ce === $ && xe === j && Re === U) ||
                          this.addCommands({
                            cmd: () => {
                              ((this.width = xe),
                                (this.height = Re),
                                (this.x = Ee),
                                (this.y = Ce));
                              const [ue, de] = this.parentDimensions;
                              (this.setDims(ue * xe, de * Re),
                                this.fixAndSetPosition());
                            },
                            undo: () => {
                              ((this.width = j),
                                (this.height = U),
                                (this.x = R),
                                (this.y = $));
                              const [ue, de] = this.parentDimensions;
                              (this.setDims(ue * j, de * U),
                                this.fixAndSetPosition());
                            },
                            mustExec: !0,
                          });
                      };
                      (window.addEventListener("pointerup", we),
                        window.addEventListener("blur", we));
                    }),
                    (Li = function (L, V) {
                      const [Y, T] = this.parentDimensions,
                        s = this.x,
                        g = this.y,
                        R = this.width,
                        $ = this.height,
                        j = x.MIN_SIZE / Y,
                        U = x.MIN_SIZE / T,
                        Q = (ze) => Math.round(ze * 1e4) / 1e4,
                        fe = le(this, b, Ir).call(this, this.rotation),
                        we = (ze, Je) => [
                          fe[0] * ze + fe[2] * Je,
                          fe[1] * ze + fe[3] * Je,
                        ],
                        Ee = le(this, b, Ir).call(this, 360 - this.rotation),
                        Ce = (ze, Je) => [
                          Ee[0] * ze + Ee[2] * Je,
                          Ee[1] * ze + Ee[3] * Je,
                        ];
                      let xe,
                        Re,
                        ue = !1,
                        de = !1;
                      switch (L) {
                        case "topLeft":
                          ((ue = !0),
                            (xe = (ze, Je) => [0, 0]),
                            (Re = (ze, Je) => [ze, Je]));
                          break;
                        case "topMiddle":
                          ((xe = (ze, Je) => [ze / 2, 0]),
                            (Re = (ze, Je) => [ze / 2, Je]));
                          break;
                        case "topRight":
                          ((ue = !0),
                            (xe = (ze, Je) => [ze, 0]),
                            (Re = (ze, Je) => [0, Je]));
                          break;
                        case "middleRight":
                          ((de = !0),
                            (xe = (ze, Je) => [ze, Je / 2]),
                            (Re = (ze, Je) => [0, Je / 2]));
                          break;
                        case "bottomRight":
                          ((ue = !0),
                            (xe = (ze, Je) => [ze, Je]),
                            (Re = (ze, Je) => [0, 0]));
                          break;
                        case "bottomMiddle":
                          ((xe = (ze, Je) => [ze / 2, Je]),
                            (Re = (ze, Je) => [ze / 2, 0]));
                          break;
                        case "bottomLeft":
                          ((ue = !0),
                            (xe = (ze, Je) => [0, Je]),
                            (Re = (ze, Je) => [ze, 0]));
                          break;
                        case "middleLeft":
                          ((de = !0),
                            (xe = (ze, Je) => [0, Je / 2]),
                            (Re = (ze, Je) => [ze, Je / 2]));
                          break;
                      }
                      const I = xe(R, $),
                        q = Re(R, $);
                      let ie = we(...q);
                      const re = Q(s + ie[0]),
                        he = Q(g + ie[1]);
                      let Pe = 1,
                        Me = 1,
                        [se, je] = this.screenToPageTranslation(
                          V.movementX,
                          V.movementY,
                        );
                      if ((([se, je] = Ce(se / Y, je / T)), ue)) {
                        const ze = Math.hypot(R, $);
                        Pe = Me = Math.max(
                          Math.min(
                            Math.hypot(q[0] - I[0] - se, q[1] - I[1] - je) / ze,
                            1 / R,
                            1 / $,
                          ),
                          j / R,
                          U / $,
                        );
                      } else
                        de
                          ? (Pe =
                              Math.max(
                                j,
                                Math.min(1, Math.abs(q[0] - I[0] - se)),
                              ) / R)
                          : (Me =
                              Math.max(
                                U,
                                Math.min(1, Math.abs(q[1] - I[1] - je)),
                              ) / $);
                      const Ie = Q(R * Pe),
                        it = Q($ * Me);
                      ie = we(...Re(Ie, it));
                      const Ke = re - ie[0],
                        dt = he - ie[1];
                      ((this.width = Ie),
                        (this.height = it),
                        (this.x = Ke),
                        (this.y = dt),
                        this.setDims(Y * Ie, T * it),
                        this.fixAndSetPosition());
                    }),
                    (Dr = async function () {
                      var Y;
                      const L = l(this, k);
                      if (!L) return;
                      if (!l(this, X) && !l(this, W)) {
                        (L.classList.remove("done"),
                          (Y = l(this, N)) == null || Y.remove());
                        return;
                      }
                      x._l10nPromise
                        .get("editor_alt_text_edit_button_label")
                        .then((T) => {
                          L.setAttribute("aria-label", T);
                        });
                      let V = l(this, N);
                      if (!V) {
                        (Se(this, N, (V = document.createElement("span"))),
                          (V.className = "tooltip"),
                          V.setAttribute("role", "tooltip"));
                        const T = (V.id = `alt-text-tooltip-${this.id}`);
                        L.setAttribute("aria-describedby", T);
                        const s = 100;
                        (L.addEventListener("mouseenter", () => {
                          Se(
                            this,
                            P,
                            setTimeout(() => {
                              (Se(this, P, null),
                                l(this, N).classList.add("show"),
                                this._uiManager._eventBus.dispatch(
                                  "reporttelemetry",
                                  {
                                    source: this,
                                    details: {
                                      type: "editing",
                                      subtype: this.editorType,
                                      data: { action: "alt_text_tooltip" },
                                    },
                                  },
                                ));
                            }, s),
                          );
                        }),
                          L.addEventListener("mouseleave", () => {
                            var g;
                            (clearTimeout(l(this, P)),
                              Se(this, P, null),
                              (g = l(this, N)) == null ||
                                g.classList.remove("show"));
                          }));
                      }
                      (L.classList.add("done"),
                        (V.innerText = l(this, W)
                          ? await x._l10nPromise.get(
                              "editor_alt_text_decorative_tooltip",
                            )
                          : l(this, X)),
                        V.parentNode || L.append(V));
                    }),
                    (Fi = function (L) {
                      if (!this._isDraggable) return;
                      const V = this._uiManager.isSelected(this);
                      this._uiManager.setUpDragSession();
                      let Y, T;
                      V &&
                        ((Y = { passive: !0, capture: !0 }),
                        (T = (g) => {
                          const [R, $] = this.screenToPageTranslation(
                            g.movementX,
                            g.movementY,
                          );
                          this._uiManager.dragSelectedEditors(R, $);
                        }),
                        window.addEventListener("pointermove", T, Y));
                      const s = () => {
                        if (
                          (window.removeEventListener("pointerup", s),
                          window.removeEventListener("blur", s),
                          V && window.removeEventListener("pointermove", T, Y),
                          Se(this, p, !1),
                          !this._uiManager.endDragSession())
                        ) {
                          const { isMac: g } = S.FeatureTest.platform;
                          (L.ctrlKey && !g) || L.shiftKey || (L.metaKey && g)
                            ? this.parent.toggleSelected(this)
                            : this.parent.setSelected(this);
                        }
                      };
                      (window.addEventListener("pointerup", s),
                        window.addEventListener("blur", s));
                    }),
                    ye(x, m),
                    $t(x, "_borderLineWidth", -1),
                    $t(x, "_colorManager", new w.ColorManager()),
                    $t(x, "_zIndex", 1),
                    $t(x, "SMALL_EDITOR_SIZE", 0));
                  let H = x;
                  A.AnnotationEditor = H;
                  class ee extends H {
                    constructor(L) {
                      (super(L),
                        (this.annotationElementId = L.annotationElementId),
                        (this.deleted = !0));
                    }
                    serialize() {
                      return {
                        id: this.annotationElementId,
                        deleted: !0,
                        pageIndex: this.pageIndex,
                      };
                    }
                  }
                },
                (t, A, n) => {
                  var _,
                    h,
                    r,
                    d,
                    p,
                    Or,
                    v,
                    f,
                    b,
                    c,
                    a,
                    Ii,
                    e,
                    o,
                    y,
                    B,
                    M,
                    D,
                    x,
                    z,
                    L,
                    V,
                    Y,
                    T,
                    s,
                    g,
                    R,
                    $,
                    j,
                    U,
                    Q,
                    fe,
                    we,
                    Ee,
                    Ce,
                    xe,
                    Re,
                    ue,
                    de,
                    I,
                    q,
                    ie,
                    re,
                    he,
                    Pe,
                    Me,
                    se,
                    Di,
                    Nr,
                    Br,
                    ar,
                    jr,
                    zr,
                    mn,
                    qn,
                    Oi,
                    Ni,
                    Hr,
                    Vn,
                    qr;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.KeyboardManager =
                      A.CommandManager =
                      A.ColorManager =
                      A.AnnotationEditorUIManager =
                        void 0),
                    (A.bindEvents = i),
                    (A.opacityToHex = H));
                  var w = n(1),
                    S = n(6);
                  function i(ot, Z, Te) {
                    for (const He of Te)
                      Z.addEventListener(He, ot[He].bind(ot));
                  }
                  function H(ot) {
                    return Math.round(Math.min(255, Math.max(1, 255 * ot)))
                      .toString(16)
                      .padStart(2, "0");
                  }
                  class ee {
                    constructor() {
                      ye(this, _, 0);
                    }
                    getId() {
                      return `${w.AnnotationEditorPrefix}${Hn(this, _)._++}`;
                    }
                  }
                  _ = new WeakMap();
                  const F = class F {
                    constructor() {
                      ye(this, p);
                      ye(this, h, (0, w.getUuid)());
                      ye(this, r, 0);
                      ye(this, d, null);
                    }
                    static get _isSVGFittingCanvas() {
                      const Z =
                          'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>',
                        He = new OffscreenCanvas(1, 3).getContext("2d"),
                        Ze = new Image();
                      Ze.src = Z;
                      const tt = Ze.decode().then(
                        () => (
                          He.drawImage(Ze, 0, 0, 1, 1, 0, 0, 1, 3),
                          new Uint32Array(
                            He.getImageData(0, 0, 1, 1).data.buffer,
                          )[0] === 0
                        ),
                      );
                      return (0, w.shadow)(this, "_isSVGFittingCanvas", tt);
                    }
                    async getFromFile(Z) {
                      const {
                        lastModified: Te,
                        name: He,
                        size: Ze,
                        type: tt,
                      } = Z;
                      return le(this, p, Or).call(
                        this,
                        `${Te}_${He}_${Ze}_${tt}`,
                        Z,
                      );
                    }
                    async getFromUrl(Z) {
                      return le(this, p, Or).call(this, Z, Z);
                    }
                    async getFromId(Z) {
                      l(this, d) || Se(this, d, new Map());
                      const Te = l(this, d).get(Z);
                      return Te
                        ? Te.bitmap
                          ? ((Te.refCounter += 1), Te)
                          : Te.file
                            ? this.getFromFile(Te.file)
                            : this.getFromUrl(Te.url)
                        : null;
                    }
                    getSvgUrl(Z) {
                      const Te = l(this, d).get(Z);
                      return Te != null && Te.isSvg ? Te.svgUrl : null;
                    }
                    deleteId(Z) {
                      l(this, d) || Se(this, d, new Map());
                      const Te = l(this, d).get(Z);
                      Te &&
                        ((Te.refCounter -= 1),
                        Te.refCounter === 0 && (Te.bitmap = null));
                    }
                    isValidId(Z) {
                      return Z.startsWith(`image_${l(this, h)}_`);
                    }
                  };
                  ((h = new WeakMap()),
                    (r = new WeakMap()),
                    (d = new WeakMap()),
                    (p = new WeakSet()),
                    (Or = async function (Z, Te) {
                      l(this, d) || Se(this, d, new Map());
                      let He = l(this, d).get(Z);
                      if (He === null) return null;
                      if (He != null && He.bitmap)
                        return ((He.refCounter += 1), He);
                      try {
                        He ||
                          (He = {
                            bitmap: null,
                            id: `image_${l(this, h)}_${Hn(this, r)._++}`,
                            refCounter: 0,
                            isSvg: !1,
                          });
                        let Ze;
                        if (typeof Te == "string") {
                          He.url = Te;
                          const tt = await fetch(Te);
                          if (!tt.ok) throw new Error(tt.statusText);
                          Ze = await tt.blob();
                        } else Ze = He.file = Te;
                        if (Ze.type === "image/svg+xml") {
                          const tt = F._isSVGFittingCanvas,
                            Ge = new FileReader(),
                            K = new Image(),
                            G = new Promise((ae, Ae) => {
                              ((K.onload = () => {
                                ((He.bitmap = K), (He.isSvg = !0), ae());
                              }),
                                (Ge.onload = async () => {
                                  const ke = (He.svgUrl = Ge.result);
                                  K.src = (await tt)
                                    ? `${ke}#svgView(preserveAspectRatio(none))`
                                    : ke;
                                }),
                                (K.onerror = Ge.onerror = Ae));
                            });
                          (Ge.readAsDataURL(Ze), await G);
                        } else He.bitmap = await createImageBitmap(Ze);
                        He.refCounter = 1;
                      } catch (Ze) {
                        (console.error(Ze), (He = null));
                      }
                      return (
                        l(this, d).set(Z, He),
                        He && l(this, d).set(He.id, He),
                        He
                      );
                    }));
                  let X = F;
                  class W {
                    constructor(Z = 128) {
                      ye(this, v, []);
                      ye(this, f, !1);
                      ye(this, b);
                      ye(this, c, -1);
                      Se(this, b, Z);
                    }
                    add({
                      cmd: Z,
                      undo: Te,
                      mustExec: He,
                      type: Ze = NaN,
                      overwriteIfSameType: tt = !1,
                      keepUndo: Ge = !1,
                    }) {
                      if ((He && Z(), l(this, f))) return;
                      const K = { cmd: Z, undo: Te, type: Ze };
                      if (l(this, c) === -1) {
                        (l(this, v).length > 0 && (l(this, v).length = 0),
                          Se(this, c, 0),
                          l(this, v).push(K));
                        return;
                      }
                      if (tt && l(this, v)[l(this, c)].type === Ze) {
                        (Ge && (K.undo = l(this, v)[l(this, c)].undo),
                          (l(this, v)[l(this, c)] = K));
                        return;
                      }
                      const G = l(this, c) + 1;
                      (G === l(this, b)
                        ? l(this, v).splice(0, 1)
                        : (Se(this, c, G),
                          G < l(this, v).length && l(this, v).splice(G)),
                        l(this, v).push(K));
                    }
                    undo() {
                      l(this, c) !== -1 &&
                        (Se(this, f, !0),
                        l(this, v)[l(this, c)].undo(),
                        Se(this, f, !1),
                        Se(this, c, l(this, c) - 1));
                    }
                    redo() {
                      l(this, c) < l(this, v).length - 1 &&
                        (Se(this, c, l(this, c) + 1),
                        Se(this, f, !0),
                        l(this, v)[l(this, c)].cmd(),
                        Se(this, f, !1));
                    }
                    hasSomethingToUndo() {
                      return l(this, c) !== -1;
                    }
                    hasSomethingToRedo() {
                      return l(this, c) < l(this, v).length - 1;
                    }
                    destroy() {
                      Se(this, v, null);
                    }
                  }
                  ((v = new WeakMap()),
                    (f = new WeakMap()),
                    (b = new WeakMap()),
                    (c = new WeakMap()),
                    (A.CommandManager = W));
                  class k {
                    constructor(Z) {
                      ye(this, a);
                      ((this.buffer = []),
                        (this.callbacks = new Map()),
                        (this.allKeys = new Set()));
                      const { isMac: Te } = w.FeatureTest.platform;
                      for (const [He, Ze, tt = {}] of Z)
                        for (const Ge of He) {
                          const K = Ge.startsWith("mac+");
                          Te && K
                            ? (this.callbacks.set(Ge.slice(4), {
                                callback: Ze,
                                options: tt,
                              }),
                              this.allKeys.add(Ge.split("+").at(-1)))
                            : !Te &&
                              !K &&
                              (this.callbacks.set(Ge, {
                                callback: Ze,
                                options: tt,
                              }),
                              this.allKeys.add(Ge.split("+").at(-1)));
                        }
                    }
                    exec(Z, Te) {
                      if (!this.allKeys.has(Te.key)) return;
                      const He = this.callbacks.get(
                        le(this, a, Ii).call(this, Te),
                      );
                      if (!He) return;
                      const {
                        callback: Ze,
                        options: {
                          bubbles: tt = !1,
                          args: Ge = [],
                          checker: K = null,
                        },
                      } = He;
                      (K && !K(Z, Te)) ||
                        (Ze.bind(Z, ...Ge)(),
                        tt || (Te.stopPropagation(), Te.preventDefault()));
                    }
                  }
                  ((a = new WeakSet()),
                    (Ii = function (Z) {
                      (Z.altKey && this.buffer.push("alt"),
                        Z.ctrlKey && this.buffer.push("ctrl"),
                        Z.metaKey && this.buffer.push("meta"),
                        Z.shiftKey && this.buffer.push("shift"),
                        this.buffer.push(Z.key));
                      const Te = this.buffer.join("+");
                      return ((this.buffer.length = 0), Te);
                    }),
                    (A.KeyboardManager = k));
                  const C = class C {
                    get _colors() {
                      const Z = new Map([
                        ["CanvasText", null],
                        ["Canvas", null],
                      ]);
                      return (
                        (0, S.getColorValues)(Z),
                        (0, w.shadow)(this, "_colors", Z)
                      );
                    }
                    convert(Z) {
                      const Te = (0, S.getRGB)(Z);
                      if (!window.matchMedia("(forced-colors: active)").matches)
                        return Te;
                      for (const [He, Ze] of this._colors)
                        if (Ze.every((tt, Ge) => tt === Te[Ge]))
                          return C._colorsMapping.get(He);
                      return Te;
                    }
                    getHexCode(Z) {
                      const Te = this._colors.get(Z);
                      return Te ? w.Util.makeHexColor(...Te) : Z;
                    }
                  };
                  $t(
                    C,
                    "_colorsMapping",
                    new Map([
                      ["CanvasText", [0, 0, 0]],
                      ["Canvas", [255, 255, 255]],
                    ]),
                  );
                  let N = C;
                  A.ColorManager = N;
                  const Ye = class Ye {
                    constructor(Z, Te, He, Ze, tt, Ge) {
                      ye(this, se);
                      ye(this, e, null);
                      ye(this, o, new Map());
                      ye(this, y, new Map());
                      ye(this, B, null);
                      ye(this, M, null);
                      ye(this, D, new W());
                      ye(this, x, 0);
                      ye(this, z, new Set());
                      ye(this, L, null);
                      ye(this, V, null);
                      ye(this, Y, new Set());
                      ye(this, T, null);
                      ye(this, s, new ee());
                      ye(this, g, !1);
                      ye(this, R, !1);
                      ye(this, $, null);
                      ye(this, j, w.AnnotationEditorType.NONE);
                      ye(this, U, new Set());
                      ye(this, Q, null);
                      ye(this, fe, this.blur.bind(this));
                      ye(this, we, this.focus.bind(this));
                      ye(this, Ee, this.copy.bind(this));
                      ye(this, Ce, this.cut.bind(this));
                      ye(this, xe, this.paste.bind(this));
                      ye(this, Re, this.keydown.bind(this));
                      ye(this, ue, this.onEditingAction.bind(this));
                      ye(this, de, this.onPageChanging.bind(this));
                      ye(this, I, this.onScaleChanging.bind(this));
                      ye(this, q, this.onRotationChanging.bind(this));
                      ye(this, ie, {
                        isEditing: !1,
                        isEmpty: !0,
                        hasSomethingToUndo: !1,
                        hasSomethingToRedo: !1,
                        hasSelectedEditor: !1,
                      });
                      ye(this, re, [0, 0]);
                      ye(this, he, null);
                      ye(this, Pe, null);
                      ye(this, Me, null);
                      (Se(this, Pe, Z),
                        Se(this, Me, Te),
                        Se(this, B, He),
                        (this._eventBus = Ze),
                        this._eventBus._on("editingaction", l(this, ue)),
                        this._eventBus._on("pagechanging", l(this, de)),
                        this._eventBus._on("scalechanging", l(this, I)),
                        this._eventBus._on("rotationchanging", l(this, q)),
                        Se(this, M, tt.annotationStorage),
                        Se(this, T, tt.filterFactory),
                        Se(this, Q, Ge),
                        (this.viewParameters = {
                          realScale: S.PixelsPerInch.PDF_TO_CSS_UNITS,
                          rotation: 0,
                        }));
                    }
                    static get _keyboardManager() {
                      const Z = Ye.prototype,
                        Te = (tt) => {
                          const { activeElement: Ge } = document;
                          return (
                            Ge &&
                            l(tt, Pe).contains(Ge) &&
                            tt.hasSomethingToControl()
                          );
                        },
                        He = this.TRANSLATE_SMALL,
                        Ze = this.TRANSLATE_BIG;
                      return (0, w.shadow)(
                        this,
                        "_keyboardManager",
                        new k([
                          [["ctrl+a", "mac+meta+a"], Z.selectAll],
                          [["ctrl+z", "mac+meta+z"], Z.undo],
                          [
                            [
                              "ctrl+y",
                              "ctrl+shift+z",
                              "mac+meta+shift+z",
                              "ctrl+shift+Z",
                              "mac+meta+shift+Z",
                            ],
                            Z.redo,
                          ],
                          [
                            [
                              "Backspace",
                              "alt+Backspace",
                              "ctrl+Backspace",
                              "shift+Backspace",
                              "mac+Backspace",
                              "mac+alt+Backspace",
                              "mac+ctrl+Backspace",
                              "Delete",
                              "ctrl+Delete",
                              "shift+Delete",
                              "mac+Delete",
                            ],
                            Z.delete,
                          ],
                          [["Escape", "mac+Escape"], Z.unselectAll],
                          [
                            ["ArrowLeft", "mac+ArrowLeft"],
                            Z.translateSelectedEditors,
                            { args: [-He, 0], checker: Te },
                          ],
                          [
                            ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
                            Z.translateSelectedEditors,
                            { args: [-Ze, 0], checker: Te },
                          ],
                          [
                            ["ArrowRight", "mac+ArrowRight"],
                            Z.translateSelectedEditors,
                            { args: [He, 0], checker: Te },
                          ],
                          [
                            ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
                            Z.translateSelectedEditors,
                            { args: [Ze, 0], checker: Te },
                          ],
                          [
                            ["ArrowUp", "mac+ArrowUp"],
                            Z.translateSelectedEditors,
                            { args: [0, -He], checker: Te },
                          ],
                          [
                            ["ctrl+ArrowUp", "mac+shift+ArrowUp"],
                            Z.translateSelectedEditors,
                            { args: [0, -Ze], checker: Te },
                          ],
                          [
                            ["ArrowDown", "mac+ArrowDown"],
                            Z.translateSelectedEditors,
                            { args: [0, He], checker: Te },
                          ],
                          [
                            ["ctrl+ArrowDown", "mac+shift+ArrowDown"],
                            Z.translateSelectedEditors,
                            { args: [0, Ze], checker: Te },
                          ],
                        ]),
                      );
                    }
                    destroy() {
                      (le(this, se, ar).call(this),
                        le(this, se, Nr).call(this),
                        this._eventBus._off("editingaction", l(this, ue)),
                        this._eventBus._off("pagechanging", l(this, de)),
                        this._eventBus._off("scalechanging", l(this, I)),
                        this._eventBus._off("rotationchanging", l(this, q)));
                      for (const Z of l(this, y).values()) Z.destroy();
                      (l(this, y).clear(),
                        l(this, o).clear(),
                        l(this, Y).clear(),
                        Se(this, e, null),
                        l(this, U).clear(),
                        l(this, D).destroy(),
                        l(this, B).destroy());
                    }
                    get hcmFilter() {
                      return (0, w.shadow)(
                        this,
                        "hcmFilter",
                        l(this, Q)
                          ? l(this, T).addHCMFilter(
                              l(this, Q).foreground,
                              l(this, Q).background,
                            )
                          : "none",
                      );
                    }
                    get direction() {
                      return (0, w.shadow)(
                        this,
                        "direction",
                        getComputedStyle(l(this, Pe)).direction,
                      );
                    }
                    editAltText(Z) {
                      var Te;
                      (Te = l(this, B)) == null || Te.editAltText(this, Z);
                    }
                    onPageChanging({ pageNumber: Z }) {
                      Se(this, x, Z - 1);
                    }
                    focusMainContainer() {
                      l(this, Pe).focus();
                    }
                    findParent(Z, Te) {
                      for (const He of l(this, y).values()) {
                        const {
                          x: Ze,
                          y: tt,
                          width: Ge,
                          height: K,
                        } = He.div.getBoundingClientRect();
                        if (Z >= Ze && Z <= Ze + Ge && Te >= tt && Te <= tt + K)
                          return He;
                      }
                      return null;
                    }
                    disableUserSelect(Z = !1) {
                      l(this, Me).classList.toggle("noUserSelect", Z);
                    }
                    addShouldRescale(Z) {
                      l(this, Y).add(Z);
                    }
                    removeShouldRescale(Z) {
                      l(this, Y).delete(Z);
                    }
                    onScaleChanging({ scale: Z }) {
                      (this.commitOrRemove(),
                        (this.viewParameters.realScale =
                          Z * S.PixelsPerInch.PDF_TO_CSS_UNITS));
                      for (const Te of l(this, Y)) Te.onScaleChanging();
                    }
                    onRotationChanging({ pagesRotation: Z }) {
                      (this.commitOrRemove(),
                        (this.viewParameters.rotation = Z));
                    }
                    addToAnnotationStorage(Z) {
                      !Z.isEmpty() &&
                        l(this, M) &&
                        !l(this, M).has(Z.id) &&
                        l(this, M).setValue(Z.id, Z);
                    }
                    blur() {
                      if (!this.hasSelection) return;
                      const { activeElement: Z } = document;
                      for (const Te of l(this, U))
                        if (Te.div.contains(Z)) {
                          (Se(this, $, [Te, Z]), (Te._focusEventsAllowed = !1));
                          break;
                        }
                    }
                    focus() {
                      if (!l(this, $)) return;
                      const [Z, Te] = l(this, $);
                      (Se(this, $, null),
                        Te.addEventListener(
                          "focusin",
                          () => {
                            Z._focusEventsAllowed = !0;
                          },
                          { once: !0 },
                        ),
                        Te.focus());
                    }
                    addEditListeners() {
                      (le(this, se, Br).call(this),
                        le(this, se, jr).call(this));
                    }
                    removeEditListeners() {
                      (le(this, se, ar).call(this),
                        le(this, se, zr).call(this));
                    }
                    copy(Z) {
                      var He;
                      if (
                        (Z.preventDefault(),
                        (He = l(this, e)) == null || He.commitOrRemove(),
                        !this.hasSelection)
                      )
                        return;
                      const Te = [];
                      for (const Ze of l(this, U)) {
                        const tt = Ze.serialize(!0);
                        tt && Te.push(tt);
                      }
                      Te.length !== 0 &&
                        Z.clipboardData.setData(
                          "application/pdfjs",
                          JSON.stringify(Te),
                        );
                    }
                    cut(Z) {
                      (this.copy(Z), this.delete());
                    }
                    paste(Z) {
                      Z.preventDefault();
                      const { clipboardData: Te } = Z;
                      for (const tt of Te.items)
                        for (const Ge of l(this, V))
                          if (Ge.isHandlingMimeForPasting(tt.type)) {
                            Ge.paste(tt, this.currentLayer);
                            return;
                          }
                      let He = Te.getData("application/pdfjs");
                      if (!He) return;
                      try {
                        He = JSON.parse(He);
                      } catch (tt) {
                        (0, w.warn)(`paste: "${tt.message}".`);
                        return;
                      }
                      if (!Array.isArray(He)) return;
                      this.unselectAll();
                      const Ze = this.currentLayer;
                      try {
                        const tt = [];
                        for (const G of He) {
                          const ae = Ze.deserialize(G);
                          if (!ae) return;
                          tt.push(ae);
                        }
                        const Ge = () => {
                            for (const G of tt) le(this, se, Hr).call(this, G);
                            le(this, se, qr).call(this, tt);
                          },
                          K = () => {
                            for (const G of tt) G.remove();
                          };
                        this.addCommands({ cmd: Ge, undo: K, mustExec: !0 });
                      } catch (tt) {
                        (0, w.warn)(`paste: "${tt.message}".`);
                      }
                    }
                    keydown(Z) {
                      var Te;
                      ((Te = this.getActive()) != null &&
                        Te.shouldGetKeyboardEvents()) ||
                        Ye._keyboardManager.exec(this, Z);
                    }
                    onEditingAction(Z) {
                      ["undo", "redo", "delete", "selectAll"].includes(
                        Z.name,
                      ) && this[Z.name]();
                    }
                    setEditingState(Z) {
                      Z
                        ? (le(this, se, Di).call(this),
                          le(this, se, Br).call(this),
                          le(this, se, jr).call(this),
                          le(this, se, mn).call(this, {
                            isEditing:
                              l(this, j) !== w.AnnotationEditorType.NONE,
                            isEmpty: le(this, se, Vn).call(this),
                            hasSomethingToUndo: l(this, D).hasSomethingToUndo(),
                            hasSomethingToRedo: l(this, D).hasSomethingToRedo(),
                            hasSelectedEditor: !1,
                          }))
                        : (le(this, se, Nr).call(this),
                          le(this, se, ar).call(this),
                          le(this, se, zr).call(this),
                          le(this, se, mn).call(this, { isEditing: !1 }),
                          this.disableUserSelect(!1));
                    }
                    registerEditorTypes(Z) {
                      if (!l(this, V)) {
                        Se(this, V, Z);
                        for (const Te of l(this, V))
                          le(this, se, qn).call(
                            this,
                            Te.defaultPropertiesToUpdate,
                          );
                      }
                    }
                    getId() {
                      return l(this, s).getId();
                    }
                    get currentLayer() {
                      return l(this, y).get(l(this, x));
                    }
                    getLayer(Z) {
                      return l(this, y).get(Z);
                    }
                    get currentPageIndex() {
                      return l(this, x);
                    }
                    addLayer(Z) {
                      (l(this, y).set(Z.pageIndex, Z),
                        l(this, g) ? Z.enable() : Z.disable());
                    }
                    removeLayer(Z) {
                      l(this, y).delete(Z.pageIndex);
                    }
                    updateMode(Z, Te = null) {
                      if (l(this, j) !== Z) {
                        if (
                          (Se(this, j, Z), Z === w.AnnotationEditorType.NONE)
                        ) {
                          (this.setEditingState(!1),
                            le(this, se, Ni).call(this));
                          return;
                        }
                        (this.setEditingState(!0),
                          le(this, se, Oi).call(this),
                          this.unselectAll());
                        for (const He of l(this, y).values()) He.updateMode(Z);
                        if (Te) {
                          for (const He of l(this, o).values())
                            if (He.annotationElementId === Te) {
                              (this.setSelected(He), He.enterInEditMode());
                              break;
                            }
                        }
                      }
                    }
                    updateToolbar(Z) {
                      Z !== l(this, j) &&
                        this._eventBus.dispatch("switchannotationeditormode", {
                          source: this,
                          mode: Z,
                        });
                    }
                    updateParams(Z, Te) {
                      if (l(this, V)) {
                        if (Z === w.AnnotationEditorParamsType.CREATE) {
                          this.currentLayer.addNewEditor(Z);
                          return;
                        }
                        for (const He of l(this, U)) He.updateParams(Z, Te);
                        for (const He of l(this, V))
                          He.updateDefaultParams(Z, Te);
                      }
                    }
                    enableWaiting(Z = !1) {
                      if (l(this, R) !== Z) {
                        Se(this, R, Z);
                        for (const Te of l(this, y).values())
                          (Z ? Te.disableClick() : Te.enableClick(),
                            Te.div.classList.toggle("waiting", Z));
                      }
                    }
                    getEditors(Z) {
                      const Te = [];
                      for (const He of l(this, o).values())
                        He.pageIndex === Z && Te.push(He);
                      return Te;
                    }
                    getEditor(Z) {
                      return l(this, o).get(Z);
                    }
                    addEditor(Z) {
                      l(this, o).set(Z.id, Z);
                    }
                    removeEditor(Z) {
                      var Te;
                      (l(this, o).delete(Z.id),
                        this.unselect(Z),
                        (!Z.annotationElementId ||
                          !l(this, z).has(Z.annotationElementId)) &&
                          ((Te = l(this, M)) == null || Te.remove(Z.id)));
                    }
                    addDeletedAnnotationElement(Z) {
                      (l(this, z).add(Z.annotationElementId), (Z.deleted = !0));
                    }
                    isDeletedAnnotationElement(Z) {
                      return l(this, z).has(Z);
                    }
                    removeDeletedAnnotationElement(Z) {
                      (l(this, z).delete(Z.annotationElementId),
                        (Z.deleted = !1));
                    }
                    setActiveEditor(Z) {
                      l(this, e) !== Z &&
                        (Se(this, e, Z),
                        Z && le(this, se, qn).call(this, Z.propertiesToUpdate));
                    }
                    toggleSelected(Z) {
                      if (l(this, U).has(Z)) {
                        (l(this, U).delete(Z),
                          Z.unselect(),
                          le(this, se, mn).call(this, {
                            hasSelectedEditor: this.hasSelection,
                          }));
                        return;
                      }
                      (l(this, U).add(Z),
                        Z.select(),
                        le(this, se, qn).call(this, Z.propertiesToUpdate),
                        le(this, se, mn).call(this, { hasSelectedEditor: !0 }));
                    }
                    setSelected(Z) {
                      for (const Te of l(this, U)) Te !== Z && Te.unselect();
                      (l(this, U).clear(),
                        l(this, U).add(Z),
                        Z.select(),
                        le(this, se, qn).call(this, Z.propertiesToUpdate),
                        le(this, se, mn).call(this, { hasSelectedEditor: !0 }));
                    }
                    isSelected(Z) {
                      return l(this, U).has(Z);
                    }
                    unselect(Z) {
                      (Z.unselect(),
                        l(this, U).delete(Z),
                        le(this, se, mn).call(this, {
                          hasSelectedEditor: this.hasSelection,
                        }));
                    }
                    get hasSelection() {
                      return l(this, U).size !== 0;
                    }
                    undo() {
                      (l(this, D).undo(),
                        le(this, se, mn).call(this, {
                          hasSomethingToUndo: l(this, D).hasSomethingToUndo(),
                          hasSomethingToRedo: !0,
                          isEmpty: le(this, se, Vn).call(this),
                        }));
                    }
                    redo() {
                      (l(this, D).redo(),
                        le(this, se, mn).call(this, {
                          hasSomethingToUndo: !0,
                          hasSomethingToRedo: l(this, D).hasSomethingToRedo(),
                          isEmpty: le(this, se, Vn).call(this),
                        }));
                    }
                    addCommands(Z) {
                      (l(this, D).add(Z),
                        le(this, se, mn).call(this, {
                          hasSomethingToUndo: !0,
                          hasSomethingToRedo: !1,
                          isEmpty: le(this, se, Vn).call(this),
                        }));
                    }
                    delete() {
                      if ((this.commitOrRemove(), !this.hasSelection)) return;
                      const Z = [...l(this, U)],
                        Te = () => {
                          for (const Ze of Z) Ze.remove();
                        },
                        He = () => {
                          for (const Ze of Z) le(this, se, Hr).call(this, Ze);
                        };
                      this.addCommands({ cmd: Te, undo: He, mustExec: !0 });
                    }
                    commitOrRemove() {
                      var Z;
                      (Z = l(this, e)) == null || Z.commitOrRemove();
                    }
                    hasSomethingToControl() {
                      return l(this, e) || this.hasSelection;
                    }
                    selectAll() {
                      for (const Z of l(this, U)) Z.commit();
                      le(this, se, qr).call(this, l(this, o).values());
                    }
                    unselectAll() {
                      if (l(this, e)) {
                        l(this, e).commitOrRemove();
                        return;
                      }
                      if (this.hasSelection) {
                        for (const Z of l(this, U)) Z.unselect();
                        (l(this, U).clear(),
                          le(this, se, mn).call(this, {
                            hasSelectedEditor: !1,
                          }));
                      }
                    }
                    translateSelectedEditors(Z, Te, He = !1) {
                      if ((He || this.commitOrRemove(), !this.hasSelection))
                        return;
                      ((l(this, re)[0] += Z), (l(this, re)[1] += Te));
                      const [Ze, tt] = l(this, re),
                        Ge = [...l(this, U)],
                        K = 1e3;
                      (l(this, he) && clearTimeout(l(this, he)),
                        Se(
                          this,
                          he,
                          setTimeout(() => {
                            (Se(this, he, null),
                              (l(this, re)[0] = l(this, re)[1] = 0),
                              this.addCommands({
                                cmd: () => {
                                  for (const G of Ge)
                                    l(this, o).has(G.id) &&
                                      G.translateInPage(Ze, tt);
                                },
                                undo: () => {
                                  for (const G of Ge)
                                    l(this, o).has(G.id) &&
                                      G.translateInPage(-Ze, -tt);
                                },
                                mustExec: !1,
                              }));
                          }, K),
                        ));
                      for (const G of Ge) G.translateInPage(Z, Te);
                    }
                    setUpDragSession() {
                      if (this.hasSelection) {
                        (this.disableUserSelect(!0), Se(this, L, new Map()));
                        for (const Z of l(this, U))
                          l(this, L).set(Z, {
                            savedX: Z.x,
                            savedY: Z.y,
                            savedPageIndex: Z.pageIndex,
                            newX: 0,
                            newY: 0,
                            newPageIndex: -1,
                          });
                      }
                    }
                    endDragSession() {
                      if (!l(this, L)) return !1;
                      this.disableUserSelect(!1);
                      const Z = l(this, L);
                      Se(this, L, null);
                      let Te = !1;
                      for (const [{ x: Ze, y: tt, pageIndex: Ge }, K] of Z)
                        ((K.newX = Ze),
                          (K.newY = tt),
                          (K.newPageIndex = Ge),
                          Te ||
                            (Te =
                              Ze !== K.savedX ||
                              tt !== K.savedY ||
                              Ge !== K.savedPageIndex));
                      if (!Te) return !1;
                      const He = (Ze, tt, Ge, K) => {
                        if (l(this, o).has(Ze.id)) {
                          const G = l(this, y).get(K);
                          G
                            ? Ze._setParentAndPosition(G, tt, Ge)
                            : ((Ze.pageIndex = K), (Ze.x = tt), (Ze.y = Ge));
                        }
                      };
                      return (
                        this.addCommands({
                          cmd: () => {
                            for (const [
                              Ze,
                              { newX: tt, newY: Ge, newPageIndex: K },
                            ] of Z)
                              He(Ze, tt, Ge, K);
                          },
                          undo: () => {
                            for (const [
                              Ze,
                              { savedX: tt, savedY: Ge, savedPageIndex: K },
                            ] of Z)
                              He(Ze, tt, Ge, K);
                          },
                          mustExec: !0,
                        }),
                        !0
                      );
                    }
                    dragSelectedEditors(Z, Te) {
                      if (l(this, L))
                        for (const He of l(this, L).keys()) He.drag(Z, Te);
                    }
                    rebuild(Z) {
                      if (Z.parent === null) {
                        const Te = this.getLayer(Z.pageIndex);
                        Te
                          ? (Te.changeParent(Z), Te.addOrRebuild(Z))
                          : (this.addEditor(Z),
                            this.addToAnnotationStorage(Z),
                            Z.rebuild());
                      } else Z.parent.addOrRebuild(Z);
                    }
                    isActive(Z) {
                      return l(this, e) === Z;
                    }
                    getActive() {
                      return l(this, e);
                    }
                    getMode() {
                      return l(this, j);
                    }
                    get imageManager() {
                      return (0, w.shadow)(this, "imageManager", new X());
                    }
                  };
                  ((e = new WeakMap()),
                    (o = new WeakMap()),
                    (y = new WeakMap()),
                    (B = new WeakMap()),
                    (M = new WeakMap()),
                    (D = new WeakMap()),
                    (x = new WeakMap()),
                    (z = new WeakMap()),
                    (L = new WeakMap()),
                    (V = new WeakMap()),
                    (Y = new WeakMap()),
                    (T = new WeakMap()),
                    (s = new WeakMap()),
                    (g = new WeakMap()),
                    (R = new WeakMap()),
                    ($ = new WeakMap()),
                    (j = new WeakMap()),
                    (U = new WeakMap()),
                    (Q = new WeakMap()),
                    (fe = new WeakMap()),
                    (we = new WeakMap()),
                    (Ee = new WeakMap()),
                    (Ce = new WeakMap()),
                    (xe = new WeakMap()),
                    (Re = new WeakMap()),
                    (ue = new WeakMap()),
                    (de = new WeakMap()),
                    (I = new WeakMap()),
                    (q = new WeakMap()),
                    (ie = new WeakMap()),
                    (re = new WeakMap()),
                    (he = new WeakMap()),
                    (Pe = new WeakMap()),
                    (Me = new WeakMap()),
                    (se = new WeakSet()),
                    (Di = function () {
                      (window.addEventListener("focus", l(this, we)),
                        window.addEventListener("blur", l(this, fe)));
                    }),
                    (Nr = function () {
                      (window.removeEventListener("focus", l(this, we)),
                        window.removeEventListener("blur", l(this, fe)));
                    }),
                    (Br = function () {
                      window.addEventListener("keydown", l(this, Re), {
                        capture: !0,
                      });
                    }),
                    (ar = function () {
                      window.removeEventListener("keydown", l(this, Re), {
                        capture: !0,
                      });
                    }),
                    (jr = function () {
                      (document.addEventListener("copy", l(this, Ee)),
                        document.addEventListener("cut", l(this, Ce)),
                        document.addEventListener("paste", l(this, xe)));
                    }),
                    (zr = function () {
                      (document.removeEventListener("copy", l(this, Ee)),
                        document.removeEventListener("cut", l(this, Ce)),
                        document.removeEventListener("paste", l(this, xe)));
                    }),
                    (mn = function (Z) {
                      Object.entries(Z).some(
                        ([He, Ze]) => l(this, ie)[He] !== Ze,
                      ) &&
                        this._eventBus.dispatch(
                          "annotationeditorstateschanged",
                          {
                            source: this,
                            details: Object.assign(l(this, ie), Z),
                          },
                        );
                    }),
                    (qn = function (Z) {
                      this._eventBus.dispatch("annotationeditorparamschanged", {
                        source: this,
                        details: Z,
                      });
                    }),
                    (Oi = function () {
                      if (!l(this, g)) {
                        Se(this, g, !0);
                        for (const Z of l(this, y).values()) Z.enable();
                      }
                    }),
                    (Ni = function () {
                      if ((this.unselectAll(), l(this, g))) {
                        Se(this, g, !1);
                        for (const Z of l(this, y).values()) Z.disable();
                      }
                    }),
                    (Hr = function (Z) {
                      const Te = l(this, y).get(Z.pageIndex);
                      Te ? Te.addOrRebuild(Z) : this.addEditor(Z);
                    }),
                    (Vn = function () {
                      if (l(this, o).size === 0) return !0;
                      if (l(this, o).size === 1)
                        for (const Z of l(this, o).values()) return Z.isEmpty();
                      return !1;
                    }),
                    (qr = function (Z) {
                      l(this, U).clear();
                      for (const Te of Z)
                        Te.isEmpty() || (l(this, U).add(Te), Te.select());
                      le(this, se, mn).call(this, { hasSelectedEditor: !0 });
                    }),
                    $t(Ye, "TRANSLATE_SMALL", 1),
                    $t(Ye, "TRANSLATE_BIG", 10));
                  let P = Ye;
                  A.AnnotationEditorUIManager = P;
                },
                (t, A, n) => {
                  var x,
                    z,
                    L,
                    V,
                    Y,
                    T,
                    s,
                    g,
                    R,
                    $,
                    j,
                    U,
                    Dn,
                    On,
                    Vr,
                    or,
                    sr,
                    Wn,
                    Un;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.StatTimer =
                      A.RenderingCancelledException =
                      A.PixelsPerInch =
                      A.PageViewport =
                      A.PDFDateString =
                      A.DOMStandardFontDataFactory =
                      A.DOMSVGFactory =
                      A.DOMFilterFactory =
                      A.DOMCanvasFactory =
                      A.DOMCMapReaderFactory =
                        void 0),
                    (A.deprecated = c),
                    (A.getColorValues = o),
                    (A.getCurrentTransform = y),
                    (A.getCurrentTransformInverse = B),
                    (A.getFilenameFromUrl = p),
                    (A.getPdfFilenameFromUrl = u),
                    (A.getRGB = e),
                    (A.getXfaPageViewport = C),
                    (A.isDataScheme = r),
                    (A.isPdfFile = d),
                    (A.isValidFetchUrl = v),
                    (A.loadScript = b),
                    (A.noContextMenu = f),
                    (A.setLayerDimensions = M));
                  var w = n(7),
                    S = n(1);
                  const i = "http://www.w3.org/2000/svg",
                    D = class D {};
                  ($t(D, "CSS", 96),
                    $t(D, "PDF", 72),
                    $t(D, "PDF_TO_CSS_UNITS", D.CSS / D.PDF));
                  let H = D;
                  A.PixelsPerInch = H;
                  class ee extends w.BaseFilterFactory {
                    constructor({
                      docId: I,
                      ownerDocument: q = globalThis.document,
                    } = {}) {
                      super();
                      ye(this, U);
                      ye(this, x);
                      ye(this, z);
                      ye(this, L);
                      ye(this, V);
                      ye(this, Y);
                      ye(this, T);
                      ye(this, s);
                      ye(this, g);
                      ye(this, R);
                      ye(this, $);
                      ye(this, j, 0);
                      (Se(this, L, I), Se(this, V, q));
                    }
                    addFilter(I) {
                      if (!I) return "none";
                      let q = l(this, U, Dn).get(I);
                      if (q) return q;
                      let ie, re, he, Pe;
                      if (I.length === 1) {
                        const Ie = I[0],
                          it = new Array(256);
                        for (let Ke = 0; Ke < 256; Ke++) it[Ke] = Ie[Ke] / 255;
                        Pe = ie = re = he = it.join(",");
                      } else {
                        const [Ie, it, Ke] = I,
                          dt = new Array(256),
                          ze = new Array(256),
                          Je = new Array(256);
                        for (let st = 0; st < 256; st++)
                          ((dt[st] = Ie[st] / 255),
                            (ze[st] = it[st] / 255),
                            (Je[st] = Ke[st] / 255));
                        ((ie = dt.join(",")),
                          (re = ze.join(",")),
                          (he = Je.join(",")),
                          (Pe = `${ie}${re}${he}`));
                      }
                      if (((q = l(this, U, Dn).get(Pe)), q))
                        return (l(this, U, Dn).set(I, q), q);
                      const Me = `g_${l(this, L)}_transfer_map_${Hn(this, j)._++}`,
                        se = `url(#${Me})`;
                      (l(this, U, Dn).set(I, se), l(this, U, Dn).set(Pe, se));
                      const je = le(this, U, or).call(this, Me);
                      return (le(this, U, Wn).call(this, ie, re, he, je), se);
                    }
                    addHCMFilter(I, q) {
                      var it;
                      const ie = `${I}-${q}`;
                      if (l(this, T) === ie) return l(this, s);
                      if (
                        (Se(this, T, ie),
                        Se(this, s, "none"),
                        (it = l(this, Y)) == null || it.remove(),
                        !I || !q)
                      )
                        return l(this, s);
                      const re = le(this, U, Un).call(this, I);
                      I = S.Util.makeHexColor(...re);
                      const he = le(this, U, Un).call(this, q);
                      if (
                        ((q = S.Util.makeHexColor(...he)),
                        (l(this, U, On).style.color = ""),
                        (I === "#000000" && q === "#ffffff") || I === q)
                      )
                        return l(this, s);
                      const Pe = new Array(256);
                      for (let Ke = 0; Ke <= 255; Ke++) {
                        const dt = Ke / 255;
                        Pe[Ke] =
                          dt <= 0.03928
                            ? dt / 12.92
                            : ((dt + 0.055) / 1.055) ** 2.4;
                      }
                      const Me = Pe.join(","),
                        se = `g_${l(this, L)}_hcm_filter`,
                        je = Se(this, g, le(this, U, or).call(this, se));
                      (le(this, U, Wn).call(this, Me, Me, Me, je),
                        le(this, U, Vr).call(this, je));
                      const Ie = (Ke, dt) => {
                        const ze = re[Ke] / 255,
                          Je = he[Ke] / 255,
                          st = new Array(dt + 1);
                        for (let kt = 0; kt <= dt; kt++)
                          st[kt] = ze + (kt / dt) * (Je - ze);
                        return st.join(",");
                      };
                      return (
                        le(this, U, Wn).call(
                          this,
                          Ie(0, 5),
                          Ie(1, 5),
                          Ie(2, 5),
                          je,
                        ),
                        Se(this, s, `url(#${se})`),
                        l(this, s)
                      );
                    }
                    addHighlightHCMFilter(I, q, ie, re) {
                      var Je;
                      const he = `${I}-${q}-${ie}-${re}`;
                      if (l(this, R) === he) return l(this, $);
                      if (
                        (Se(this, R, he),
                        Se(this, $, "none"),
                        (Je = l(this, g)) == null || Je.remove(),
                        !I || !q)
                      )
                        return l(this, $);
                      const [Pe, Me] = [I, q].map(le(this, U, Un).bind(this));
                      let se = Math.round(
                          0.2126 * Pe[0] + 0.7152 * Pe[1] + 0.0722 * Pe[2],
                        ),
                        je = Math.round(
                          0.2126 * Me[0] + 0.7152 * Me[1] + 0.0722 * Me[2],
                        ),
                        [Ie, it] = [ie, re].map(le(this, U, Un).bind(this));
                      (je < se && ([se, je, Ie, it] = [je, se, it, Ie]),
                        (l(this, U, On).style.color = ""));
                      const Ke = (st, kt, Le) => {
                          const pe = new Array(256),
                            me = (je - se) / Le,
                            Xe = st / 255,
                            Ye = (kt - st) / (255 * Le);
                          let ot = 0;
                          for (let Z = 0; Z <= Le; Z++) {
                            const Te = Math.round(se + Z * me),
                              He = Xe + Z * Ye;
                            for (let Ze = ot; Ze <= Te; Ze++) pe[Ze] = He;
                            ot = Te + 1;
                          }
                          for (let Z = ot; Z < 256; Z++) pe[Z] = pe[ot - 1];
                          return pe.join(",");
                        },
                        dt = `g_${l(this, L)}_hcm_highlight_filter`,
                        ze = Se(this, g, le(this, U, or).call(this, dt));
                      return (
                        le(this, U, Vr).call(this, ze),
                        le(this, U, Wn).call(
                          this,
                          Ke(Ie[0], it[0], 5),
                          Ke(Ie[1], it[1], 5),
                          Ke(Ie[2], it[2], 5),
                          ze,
                        ),
                        Se(this, $, `url(#${dt})`),
                        l(this, $)
                      );
                    }
                    destroy(I = !1) {
                      (I && (l(this, s) || l(this, $))) ||
                        (l(this, z) &&
                          (l(this, z).parentNode.parentNode.remove(),
                          Se(this, z, null)),
                        l(this, x) && (l(this, x).clear(), Se(this, x, null)),
                        Se(this, j, 0));
                    }
                  }
                  ((x = new WeakMap()),
                    (z = new WeakMap()),
                    (L = new WeakMap()),
                    (V = new WeakMap()),
                    (Y = new WeakMap()),
                    (T = new WeakMap()),
                    (s = new WeakMap()),
                    (g = new WeakMap()),
                    (R = new WeakMap()),
                    ($ = new WeakMap()),
                    (j = new WeakMap()),
                    (U = new WeakSet()),
                    (Dn = function () {
                      return l(this, x) || Se(this, x, new Map());
                    }),
                    (On = function () {
                      if (!l(this, z)) {
                        const I = l(this, V).createElement("div"),
                          { style: q } = I;
                        ((q.visibility = "hidden"),
                          (q.contain = "strict"),
                          (q.width = q.height = 0),
                          (q.position = "absolute"),
                          (q.top = q.left = 0),
                          (q.zIndex = -1));
                        const ie = l(this, V).createElementNS(i, "svg");
                        (ie.setAttribute("width", 0),
                          ie.setAttribute("height", 0),
                          Se(this, z, l(this, V).createElementNS(i, "defs")),
                          I.append(ie),
                          ie.append(l(this, z)),
                          l(this, V).body.append(I));
                      }
                      return l(this, z);
                    }),
                    (Vr = function (I) {
                      const q = l(this, V).createElementNS(i, "feColorMatrix");
                      (q.setAttribute("type", "matrix"),
                        q.setAttribute(
                          "values",
                          "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0",
                        ),
                        I.append(q));
                    }),
                    (or = function (I) {
                      const q = l(this, V).createElementNS(i, "filter");
                      return (
                        q.setAttribute("color-interpolation-filters", "sRGB"),
                        q.setAttribute("id", I),
                        l(this, U, On).append(q),
                        q
                      );
                    }),
                    (sr = function (I, q, ie) {
                      const re = l(this, V).createElementNS(i, q);
                      (re.setAttribute("type", "discrete"),
                        re.setAttribute("tableValues", ie),
                        I.append(re));
                    }),
                    (Wn = function (I, q, ie, re) {
                      const he = l(this, V).createElementNS(
                        i,
                        "feComponentTransfer",
                      );
                      (re.append(he),
                        le(this, U, sr).call(this, he, "feFuncR", I),
                        le(this, U, sr).call(this, he, "feFuncG", q),
                        le(this, U, sr).call(this, he, "feFuncB", ie));
                    }),
                    (Un = function (I) {
                      return (
                        (l(this, U, On).style.color = I),
                        e(
                          getComputedStyle(l(this, U, On)).getPropertyValue(
                            "color",
                          ),
                        )
                      );
                    }),
                    (A.DOMFilterFactory = ee));
                  class X extends w.BaseCanvasFactory {
                    constructor({
                      ownerDocument: de = globalThis.document,
                    } = {}) {
                      (super(), (this._document = de));
                    }
                    _createCanvas(de, I) {
                      const q = this._document.createElement("canvas");
                      return ((q.width = de), (q.height = I), q);
                    }
                  }
                  A.DOMCanvasFactory = X;
                  async function W(ue, de = !1) {
                    if (v(ue, document.baseURI)) {
                      const I = await fetch(ue);
                      if (!I.ok) throw new Error(I.statusText);
                      return de
                        ? new Uint8Array(await I.arrayBuffer())
                        : (0, S.stringToBytes)(await I.text());
                    }
                    return new Promise((I, q) => {
                      const ie = new XMLHttpRequest();
                      (ie.open("GET", ue, !0),
                        de && (ie.responseType = "arraybuffer"),
                        (ie.onreadystatechange = () => {
                          if (ie.readyState === XMLHttpRequest.DONE) {
                            if (ie.status === 200 || ie.status === 0) {
                              let re;
                              if (
                                (de && ie.response
                                  ? (re = new Uint8Array(ie.response))
                                  : !de &&
                                    ie.responseText &&
                                    (re = (0, S.stringToBytes)(
                                      ie.responseText,
                                    )),
                                re)
                              ) {
                                I(re);
                                return;
                              }
                            }
                            q(new Error(ie.statusText));
                          }
                        }),
                        ie.send(null));
                    });
                  }
                  class k extends w.BaseCMapReaderFactory {
                    _fetchData(de, I) {
                      return W(de, this.isCompressed).then((q) => ({
                        cMapData: q,
                        compressionType: I,
                      }));
                    }
                  }
                  A.DOMCMapReaderFactory = k;
                  class N extends w.BaseStandardFontDataFactory {
                    _fetchData(de) {
                      return W(de, !0);
                    }
                  }
                  A.DOMStandardFontDataFactory = N;
                  class P extends w.BaseSVGFactory {
                    _createSVG(de) {
                      return document.createElementNS(i, de);
                    }
                  }
                  A.DOMSVGFactory = P;
                  class _ {
                    constructor({
                      viewBox: de,
                      scale: I,
                      rotation: q,
                      offsetX: ie = 0,
                      offsetY: re = 0,
                      dontFlip: he = !1,
                    }) {
                      ((this.viewBox = de),
                        (this.scale = I),
                        (this.rotation = q),
                        (this.offsetX = ie),
                        (this.offsetY = re));
                      const Pe = (de[2] + de[0]) / 2,
                        Me = (de[3] + de[1]) / 2;
                      let se, je, Ie, it;
                      switch (((q %= 360), q < 0 && (q += 360), q)) {
                        case 180:
                          ((se = -1), (je = 0), (Ie = 0), (it = 1));
                          break;
                        case 90:
                          ((se = 0), (je = 1), (Ie = 1), (it = 0));
                          break;
                        case 270:
                          ((se = 0), (je = -1), (Ie = -1), (it = 0));
                          break;
                        case 0:
                          ((se = 1), (je = 0), (Ie = 0), (it = -1));
                          break;
                        default:
                          throw new Error(
                            "PageViewport: Invalid rotation, must be a multiple of 90 degrees.",
                          );
                      }
                      he && ((Ie = -Ie), (it = -it));
                      let Ke, dt, ze, Je;
                      (se === 0
                        ? ((Ke = Math.abs(Me - de[1]) * I + ie),
                          (dt = Math.abs(Pe - de[0]) * I + re),
                          (ze = (de[3] - de[1]) * I),
                          (Je = (de[2] - de[0]) * I))
                        : ((Ke = Math.abs(Pe - de[0]) * I + ie),
                          (dt = Math.abs(Me - de[1]) * I + re),
                          (ze = (de[2] - de[0]) * I),
                          (Je = (de[3] - de[1]) * I)),
                        (this.transform = [
                          se * I,
                          je * I,
                          Ie * I,
                          it * I,
                          Ke - se * I * Pe - Ie * I * Me,
                          dt - je * I * Pe - it * I * Me,
                        ]),
                        (this.width = ze),
                        (this.height = Je));
                    }
                    get rawDims() {
                      const { viewBox: de } = this;
                      return (0, S.shadow)(this, "rawDims", {
                        pageWidth: de[2] - de[0],
                        pageHeight: de[3] - de[1],
                        pageX: de[0],
                        pageY: de[1],
                      });
                    }
                    clone({
                      scale: de = this.scale,
                      rotation: I = this.rotation,
                      offsetX: q = this.offsetX,
                      offsetY: ie = this.offsetY,
                      dontFlip: re = !1,
                    } = {}) {
                      return new _({
                        viewBox: this.viewBox.slice(),
                        scale: de,
                        rotation: I,
                        offsetX: q,
                        offsetY: ie,
                        dontFlip: re,
                      });
                    }
                    convertToViewportPoint(de, I) {
                      return S.Util.applyTransform([de, I], this.transform);
                    }
                    convertToViewportRectangle(de) {
                      const I = S.Util.applyTransform(
                          [de[0], de[1]],
                          this.transform,
                        ),
                        q = S.Util.applyTransform(
                          [de[2], de[3]],
                          this.transform,
                        );
                      return [I[0], I[1], q[0], q[1]];
                    }
                    convertToPdfPoint(de, I) {
                      return S.Util.applyInverseTransform(
                        [de, I],
                        this.transform,
                      );
                    }
                  }
                  A.PageViewport = _;
                  class h extends S.BaseException {
                    constructor(de, I = 0) {
                      (super(de, "RenderingCancelledException"),
                        (this.extraDelay = I));
                    }
                  }
                  A.RenderingCancelledException = h;
                  function r(ue) {
                    const de = ue.length;
                    let I = 0;
                    for (; I < de && ue[I].trim() === ""; ) I++;
                    return ue.substring(I, I + 5).toLowerCase() === "data:";
                  }
                  function d(ue) {
                    return typeof ue == "string" && /\.pdf$/i.test(ue);
                  }
                  function p(ue, de = !1) {
                    return (
                      de || ([ue] = ue.split(/[#?]/, 1)),
                      ue.substring(ue.lastIndexOf("/") + 1)
                    );
                  }
                  function u(ue, de = "document.pdf") {
                    if (typeof ue != "string") return de;
                    if (r(ue))
                      return (
                        (0, S.warn)(
                          'getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.',
                        ),
                        de
                      );
                    const I =
                        /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/,
                      q = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,
                      ie = I.exec(ue);
                    let re = q.exec(ie[1]) || q.exec(ie[2]) || q.exec(ie[3]);
                    if (re && ((re = re[0]), re.includes("%")))
                      try {
                        re = q.exec(decodeURIComponent(re))[0];
                      } catch {}
                    return re || de;
                  }
                  class F {
                    constructor() {
                      $t(this, "started", Object.create(null));
                      $t(this, "times", []);
                    }
                    time(de) {
                      (de in this.started &&
                        (0, S.warn)(`Timer is already running for ${de}`),
                        (this.started[de] = Date.now()));
                    }
                    timeEnd(de) {
                      (de in this.started ||
                        (0, S.warn)(`Timer has not been started for ${de}`),
                        this.times.push({
                          name: de,
                          start: this.started[de],
                          end: Date.now(),
                        }),
                        delete this.started[de]);
                    }
                    toString() {
                      const de = [];
                      let I = 0;
                      for (const { name: q } of this.times)
                        I = Math.max(q.length, I);
                      for (const { name: q, start: ie, end: re } of this.times)
                        de.push(`${q.padEnd(I)} ${re - ie}ms
`);
                      return de.join("");
                    }
                  }
                  A.StatTimer = F;
                  function v(ue, de) {
                    try {
                      const { protocol: I } = de
                        ? new URL(ue, de)
                        : new URL(ue);
                      return I === "http:" || I === "https:";
                    } catch {
                      return !1;
                    }
                  }
                  function f(ue) {
                    ue.preventDefault();
                  }
                  function b(ue, de = !1) {
                    return new Promise((I, q) => {
                      const ie = document.createElement("script");
                      ((ie.src = ue),
                        (ie.onload = function (re) {
                          (de && ie.remove(), I(re));
                        }),
                        (ie.onerror = function () {
                          q(new Error(`Cannot load script at: ${ie.src}`));
                        }),
                        (document.head || document.documentElement).append(ie));
                    });
                  }
                  function c(ue) {
                    console.log("Deprecated API usage: " + ue);
                  }
                  let a;
                  class m {
                    static toDateObject(de) {
                      if (!de || typeof de != "string") return null;
                      a ||
                        (a = new RegExp(
                          "^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?",
                        ));
                      const I = a.exec(de);
                      if (!I) return null;
                      const q = parseInt(I[1], 10);
                      let ie = parseInt(I[2], 10);
                      ie = ie >= 1 && ie <= 12 ? ie - 1 : 0;
                      let re = parseInt(I[3], 10);
                      re = re >= 1 && re <= 31 ? re : 1;
                      let he = parseInt(I[4], 10);
                      he = he >= 0 && he <= 23 ? he : 0;
                      let Pe = parseInt(I[5], 10);
                      Pe = Pe >= 0 && Pe <= 59 ? Pe : 0;
                      let Me = parseInt(I[6], 10);
                      Me = Me >= 0 && Me <= 59 ? Me : 0;
                      const se = I[7] || "Z";
                      let je = parseInt(I[8], 10);
                      je = je >= 0 && je <= 23 ? je : 0;
                      let Ie = parseInt(I[9], 10) || 0;
                      return (
                        (Ie = Ie >= 0 && Ie <= 59 ? Ie : 0),
                        se === "-"
                          ? ((he += je), (Pe += Ie))
                          : se === "+" && ((he -= je), (Pe -= Ie)),
                        new Date(Date.UTC(q, ie, re, he, Pe, Me))
                      );
                    }
                  }
                  A.PDFDateString = m;
                  function C(ue, { scale: de = 1, rotation: I = 0 }) {
                    const { width: q, height: ie } = ue.attributes.style,
                      re = [0, 0, parseInt(q), parseInt(ie)];
                    return new _({ viewBox: re, scale: de, rotation: I });
                  }
                  function e(ue) {
                    if (ue.startsWith("#")) {
                      const de = parseInt(ue.slice(1), 16);
                      return [
                        (de & 16711680) >> 16,
                        (de & 65280) >> 8,
                        de & 255,
                      ];
                    }
                    return ue.startsWith("rgb(")
                      ? ue
                          .slice(4, -1)
                          .split(",")
                          .map((de) => parseInt(de))
                      : ue.startsWith("rgba(")
                        ? ue
                            .slice(5, -1)
                            .split(",")
                            .map((de) => parseInt(de))
                            .slice(0, 3)
                        : ((0, S.warn)(`Not a valid color format: "${ue}"`),
                          [0, 0, 0]);
                  }
                  function o(ue) {
                    const de = document.createElement("span");
                    ((de.style.visibility = "hidden"),
                      document.body.append(de));
                    for (const I of ue.keys()) {
                      de.style.color = I;
                      const q = window.getComputedStyle(de).color;
                      ue.set(I, e(q));
                    }
                    de.remove();
                  }
                  function y(ue) {
                    const {
                      a: de,
                      b: I,
                      c: q,
                      d: ie,
                      e: re,
                      f: he,
                    } = ue.getTransform();
                    return [de, I, q, ie, re, he];
                  }
                  function B(ue) {
                    const {
                      a: de,
                      b: I,
                      c: q,
                      d: ie,
                      e: re,
                      f: he,
                    } = ue.getTransform().invertSelf();
                    return [de, I, q, ie, re, he];
                  }
                  function M(ue, de, I = !1, q = !0) {
                    if (de instanceof _) {
                      const { pageWidth: ie, pageHeight: re } = de.rawDims,
                        { style: he } = ue,
                        Pe = S.FeatureTest.isCSSRoundSupported,
                        Me = `var(--scale-factor) * ${ie}px`,
                        se = `var(--scale-factor) * ${re}px`,
                        je = Pe ? `round(${Me}, 1px)` : `calc(${Me})`,
                        Ie = Pe ? `round(${se}, 1px)` : `calc(${se})`;
                      !I || de.rotation % 180 === 0
                        ? ((he.width = je), (he.height = Ie))
                        : ((he.width = Ie), (he.height = je));
                    }
                    q && ue.setAttribute("data-main-rotation", de.rotation);
                  }
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.BaseStandardFontDataFactory =
                      A.BaseSVGFactory =
                      A.BaseFilterFactory =
                      A.BaseCanvasFactory =
                      A.BaseCMapReaderFactory =
                        void 0));
                  var w = n(1);
                  class S {
                    constructor() {
                      this.constructor === S &&
                        (0, w.unreachable)(
                          "Cannot initialize BaseFilterFactory.",
                        );
                    }
                    addFilter(k) {
                      return "none";
                    }
                    addHCMFilter(k, N) {
                      return "none";
                    }
                    addHighlightHCMFilter(k, N, P, _) {
                      return "none";
                    }
                    destroy(k = !1) {}
                  }
                  A.BaseFilterFactory = S;
                  class i {
                    constructor() {
                      this.constructor === i &&
                        (0, w.unreachable)(
                          "Cannot initialize BaseCanvasFactory.",
                        );
                    }
                    create(k, N) {
                      if (k <= 0 || N <= 0)
                        throw new Error("Invalid canvas size");
                      const P = this._createCanvas(k, N);
                      return { canvas: P, context: P.getContext("2d") };
                    }
                    reset(k, N, P) {
                      if (!k.canvas) throw new Error("Canvas is not specified");
                      if (N <= 0 || P <= 0)
                        throw new Error("Invalid canvas size");
                      ((k.canvas.width = N), (k.canvas.height = P));
                    }
                    destroy(k) {
                      if (!k.canvas) throw new Error("Canvas is not specified");
                      ((k.canvas.width = 0),
                        (k.canvas.height = 0),
                        (k.canvas = null),
                        (k.context = null));
                    }
                    _createCanvas(k, N) {
                      (0, w.unreachable)(
                        "Abstract method `_createCanvas` called.",
                      );
                    }
                  }
                  A.BaseCanvasFactory = i;
                  class H {
                    constructor({ baseUrl: k = null, isCompressed: N = !0 }) {
                      (this.constructor === H &&
                        (0, w.unreachable)(
                          "Cannot initialize BaseCMapReaderFactory.",
                        ),
                        (this.baseUrl = k),
                        (this.isCompressed = N));
                    }
                    async fetch({ name: k }) {
                      if (!this.baseUrl)
                        throw new Error(
                          'The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.',
                        );
                      if (!k) throw new Error("CMap name must be specified.");
                      const N =
                          this.baseUrl +
                          k +
                          (this.isCompressed ? ".bcmap" : ""),
                        P = this.isCompressed
                          ? w.CMapCompressionType.BINARY
                          : w.CMapCompressionType.NONE;
                      return this._fetchData(N, P).catch((_) => {
                        throw new Error(
                          `Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${N}`,
                        );
                      });
                    }
                    _fetchData(k, N) {
                      (0, w.unreachable)(
                        "Abstract method `_fetchData` called.",
                      );
                    }
                  }
                  A.BaseCMapReaderFactory = H;
                  class ee {
                    constructor({ baseUrl: k = null }) {
                      (this.constructor === ee &&
                        (0, w.unreachable)(
                          "Cannot initialize BaseStandardFontDataFactory.",
                        ),
                        (this.baseUrl = k));
                    }
                    async fetch({ filename: k }) {
                      if (!this.baseUrl)
                        throw new Error(
                          'The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.',
                        );
                      if (!k)
                        throw new Error("Font filename must be specified.");
                      const N = `${this.baseUrl}${k}`;
                      return this._fetchData(N).catch((P) => {
                        throw new Error(`Unable to load font data at: ${N}`);
                      });
                    }
                    _fetchData(k) {
                      (0, w.unreachable)(
                        "Abstract method `_fetchData` called.",
                      );
                    }
                  }
                  A.BaseStandardFontDataFactory = ee;
                  class X {
                    constructor() {
                      this.constructor === X &&
                        (0, w.unreachable)("Cannot initialize BaseSVGFactory.");
                    }
                    create(k, N, P = !1) {
                      if (k <= 0 || N <= 0)
                        throw new Error("Invalid SVG dimensions");
                      const _ = this._createSVG("svg:svg");
                      return (
                        _.setAttribute("version", "1.1"),
                        P ||
                          (_.setAttribute("width", `${k}px`),
                          _.setAttribute("height", `${N}px`)),
                        _.setAttribute("preserveAspectRatio", "none"),
                        _.setAttribute("viewBox", `0 0 ${k} ${N}`),
                        _
                      );
                    }
                    createElement(k) {
                      if (typeof k != "string")
                        throw new Error("Invalid SVG element type");
                      return this._createSVG(k);
                    }
                    _createSVG(k) {
                      (0, w.unreachable)(
                        "Abstract method `_createSVG` called.",
                      );
                    }
                  }
                  A.BaseSVGFactory = X;
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.MurmurHash3_64 = void 0));
                  var w = n(1);
                  const S = 3285377520,
                    i = 4294901760,
                    H = 65535;
                  class ee {
                    constructor(W) {
                      ((this.h1 = W ? W & 4294967295 : S),
                        (this.h2 = W ? W & 4294967295 : S));
                    }
                    update(W) {
                      let k, N;
                      if (typeof W == "string") {
                        ((k = new Uint8Array(W.length * 2)), (N = 0));
                        for (let c = 0, a = W.length; c < a; c++) {
                          const m = W.charCodeAt(c);
                          m <= 255
                            ? (k[N++] = m)
                            : ((k[N++] = m >>> 8), (k[N++] = m & 255));
                        }
                      } else if ((0, w.isArrayBuffer)(W))
                        ((k = W.slice()), (N = k.byteLength));
                      else
                        throw new Error(
                          "Wrong data format in MurmurHash3_64_update. Input must be a string or array.",
                        );
                      const P = N >> 2,
                        _ = N - P * 4,
                        h = new Uint32Array(k.buffer, 0, P);
                      let r = 0,
                        d = 0,
                        p = this.h1,
                        u = this.h2;
                      const F = 3432918353,
                        v = 461845907,
                        f = F & H,
                        b = v & H;
                      for (let c = 0; c < P; c++)
                        c & 1
                          ? ((r = h[c]),
                            (r = ((r * F) & i) | ((r * f) & H)),
                            (r = (r << 15) | (r >>> 17)),
                            (r = ((r * v) & i) | ((r * b) & H)),
                            (p ^= r),
                            (p = (p << 13) | (p >>> 19)),
                            (p = p * 5 + 3864292196))
                          : ((d = h[c]),
                            (d = ((d * F) & i) | ((d * f) & H)),
                            (d = (d << 15) | (d >>> 17)),
                            (d = ((d * v) & i) | ((d * b) & H)),
                            (u ^= d),
                            (u = (u << 13) | (u >>> 19)),
                            (u = u * 5 + 3864292196));
                      switch (((r = 0), _)) {
                        case 3:
                          r ^= k[P * 4 + 2] << 16;
                        case 2:
                          r ^= k[P * 4 + 1] << 8;
                        case 1:
                          ((r ^= k[P * 4]),
                            (r = ((r * F) & i) | ((r * f) & H)),
                            (r = (r << 15) | (r >>> 17)),
                            (r = ((r * v) & i) | ((r * b) & H)),
                            P & 1 ? (p ^= r) : (u ^= r));
                      }
                      ((this.h1 = p), (this.h2 = u));
                    }
                    hexdigest() {
                      let W = this.h1,
                        k = this.h2;
                      return (
                        (W ^= k >>> 1),
                        (W = ((W * 3981806797) & i) | ((W * 36045) & H)),
                        (k =
                          ((k * 4283543511) & i) |
                          (((((k << 16) | (W >>> 16)) * 2950163797) & i) >>>
                            16)),
                        (W ^= k >>> 1),
                        (W = ((W * 444984403) & i) | ((W * 60499) & H)),
                        (k =
                          ((k * 3301882366) & i) |
                          (((((k << 16) | (W >>> 16)) * 3120437893) & i) >>>
                            16)),
                        (W ^= k >>> 1),
                        (W >>> 0).toString(16).padStart(8, "0") +
                          (k >>> 0).toString(16).padStart(8, "0")
                      );
                    }
                  }
                  A.MurmurHash3_64 = ee;
                },
                (t, A, n) => {
                  var H;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.FontLoader = A.FontFaceObject = void 0));
                  var w = n(1);
                  class S {
                    constructor({
                      ownerDocument: X = globalThis.document,
                      styleElement: W = null,
                    }) {
                      ye(this, H, new Set());
                      ((this._document = X),
                        (this.nativeFontFaces = new Set()),
                        (this.styleElement = null),
                        (this.loadingRequests = []),
                        (this.loadTestFontId = 0));
                    }
                    addNativeFontFace(X) {
                      (this.nativeFontFaces.add(X),
                        this._document.fonts.add(X));
                    }
                    removeNativeFontFace(X) {
                      (this.nativeFontFaces.delete(X),
                        this._document.fonts.delete(X));
                    }
                    insertRule(X) {
                      this.styleElement ||
                        ((this.styleElement =
                          this._document.createElement("style")),
                        this._document.documentElement
                          .getElementsByTagName("head")[0]
                          .append(this.styleElement));
                      const W = this.styleElement.sheet;
                      W.insertRule(X, W.cssRules.length);
                    }
                    clear() {
                      for (const X of this.nativeFontFaces)
                        this._document.fonts.delete(X);
                      (this.nativeFontFaces.clear(),
                        l(this, H).clear(),
                        this.styleElement &&
                          (this.styleElement.remove(),
                          (this.styleElement = null)));
                    }
                    async loadSystemFont(X) {
                      if (!(!X || l(this, H).has(X.loadedName))) {
                        if (
                          ((0, w.assert)(
                            !this.disableFontFace,
                            "loadSystemFont shouldn't be called when `disableFontFace` is set.",
                          ),
                          this.isFontLoadingAPISupported)
                        ) {
                          const { loadedName: W, src: k, style: N } = X,
                            P = new FontFace(W, k, N);
                          this.addNativeFontFace(P);
                          try {
                            (await P.load(), l(this, H).add(W));
                          } catch {
                            ((0, w.warn)(
                              `Cannot load system font: ${X.baseFontName}, installing it could help to improve PDF rendering.`,
                            ),
                              this.removeNativeFontFace(P));
                          }
                          return;
                        }
                        (0, w.unreachable)(
                          "Not implemented: loadSystemFont without the Font Loading API.",
                        );
                      }
                    }
                    async bind(X) {
                      if (X.attached || (X.missingFile && !X.systemFontInfo))
                        return;
                      if (((X.attached = !0), X.systemFontInfo)) {
                        await this.loadSystemFont(X.systemFontInfo);
                        return;
                      }
                      if (this.isFontLoadingAPISupported) {
                        const k = X.createNativeFontFace();
                        if (k) {
                          this.addNativeFontFace(k);
                          try {
                            await k.loaded;
                          } catch (N) {
                            throw (
                              (0, w.warn)(
                                `Failed to load font '${k.family}': '${N}'.`,
                              ),
                              (X.disableFontFace = !0),
                              N
                            );
                          }
                        }
                        return;
                      }
                      const W = X.createFontFaceRule();
                      if (W) {
                        if (
                          (this.insertRule(W), this.isSyncFontLoadingSupported)
                        )
                          return;
                        await new Promise((k) => {
                          const N = this._queueLoadingCallback(k);
                          this._prepareFontLoadEvent(X, N);
                        });
                      }
                    }
                    get isFontLoadingAPISupported() {
                      var W;
                      const X = !!((W = this._document) != null && W.fonts);
                      return (0, w.shadow)(
                        this,
                        "isFontLoadingAPISupported",
                        X,
                      );
                    }
                    get isSyncFontLoadingSupported() {
                      let X = !1;
                      return (
                        (w.isNodeJS ||
                          (typeof navigator < "u" &&
                            /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(
                              navigator.userAgent,
                            ))) &&
                          (X = !0),
                        (0, w.shadow)(this, "isSyncFontLoadingSupported", X)
                      );
                    }
                    _queueLoadingCallback(X) {
                      function W() {
                        for (
                          (0, w.assert)(
                            !N.done,
                            "completeRequest() cannot be called twice.",
                          ),
                            N.done = !0;
                          k.length > 0 && k[0].done;

                        ) {
                          const P = k.shift();
                          setTimeout(P.callback, 0);
                        }
                      }
                      const { loadingRequests: k } = this,
                        N = { done: !1, complete: W, callback: X };
                      return (k.push(N), N);
                    }
                    get _loadTestFont() {
                      const X = atob(
                        "T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==",
                      );
                      return (0, w.shadow)(this, "_loadTestFont", X);
                    }
                    _prepareFontLoadEvent(X, W) {
                      function k(e, o) {
                        return (
                          (e.charCodeAt(o) << 24) |
                          (e.charCodeAt(o + 1) << 16) |
                          (e.charCodeAt(o + 2) << 8) |
                          (e.charCodeAt(o + 3) & 255)
                        );
                      }
                      function N(e, o, y, B) {
                        const M = e.substring(0, o),
                          D = e.substring(o + y);
                        return M + B + D;
                      }
                      let P, _;
                      const h = this._document.createElement("canvas");
                      ((h.width = 1), (h.height = 1));
                      const r = h.getContext("2d");
                      let d = 0;
                      function p(e, o) {
                        if (++d > 30) {
                          ((0, w.warn)("Load test font never loaded."), o());
                          return;
                        }
                        if (
                          ((r.font = "30px " + e),
                          r.fillText(".", 0, 20),
                          r.getImageData(0, 0, 1, 1).data[3] > 0)
                        ) {
                          o();
                          return;
                        }
                        setTimeout(p.bind(null, e, o));
                      }
                      const u = `lt${Date.now()}${this.loadTestFontId++}`;
                      let F = this._loadTestFont;
                      F = N(F, 976, u.length, u);
                      const f = 16,
                        b = 1482184792;
                      let c = k(F, f);
                      for (P = 0, _ = u.length - 3; P < _; P += 4)
                        c = (c - b + k(u, P)) | 0;
                      (P < u.length && (c = (c - b + k(u + "XXX", P)) | 0),
                        (F = N(F, f, 4, (0, w.string32)(c))));
                      const a = `url(data:font/opentype;base64,${btoa(F)});`,
                        m = `@font-face {font-family:"${u}";src:${a}}`;
                      this.insertRule(m);
                      const C = this._document.createElement("div");
                      ((C.style.visibility = "hidden"),
                        (C.style.width = C.style.height = "10px"),
                        (C.style.position = "absolute"),
                        (C.style.top = C.style.left = "0px"));
                      for (const e of [X.loadedName, u]) {
                        const o = this._document.createElement("span");
                        ((o.textContent = "Hi"),
                          (o.style.fontFamily = e),
                          C.append(o));
                      }
                      (this._document.body.append(C),
                        p(u, () => {
                          (C.remove(), W.complete());
                        }));
                    }
                  }
                  ((H = new WeakMap()), (A.FontLoader = S));
                  class i {
                    constructor(
                      X,
                      {
                        isEvalSupported: W = !0,
                        disableFontFace: k = !1,
                        ignoreErrors: N = !1,
                        inspectFont: P = null,
                      },
                    ) {
                      this.compiledGlyphs = Object.create(null);
                      for (const _ in X) this[_] = X[_];
                      ((this.isEvalSupported = W !== !1),
                        (this.disableFontFace = k === !0),
                        (this.ignoreErrors = N === !0),
                        (this._inspectFont = P));
                    }
                    createNativeFontFace() {
                      var W;
                      if (!this.data || this.disableFontFace) return null;
                      let X;
                      if (!this.cssFontInfo)
                        X = new FontFace(this.loadedName, this.data, {});
                      else {
                        const k = { weight: this.cssFontInfo.fontWeight };
                        (this.cssFontInfo.italicAngle &&
                          (k.style = `oblique ${this.cssFontInfo.italicAngle}deg`),
                          (X = new FontFace(
                            this.cssFontInfo.fontFamily,
                            this.data,
                            k,
                          )));
                      }
                      return (
                        (W = this._inspectFont) == null || W.call(this, this),
                        X
                      );
                    }
                    createFontFaceRule() {
                      var N;
                      if (!this.data || this.disableFontFace) return null;
                      const X = (0, w.bytesToString)(this.data),
                        W = `url(data:${this.mimetype};base64,${btoa(X)});`;
                      let k;
                      if (!this.cssFontInfo)
                        k = `@font-face {font-family:"${this.loadedName}";src:${W}}`;
                      else {
                        let P = `font-weight: ${this.cssFontInfo.fontWeight};`;
                        (this.cssFontInfo.italicAngle &&
                          (P += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`),
                          (k = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${P}src:${W}}`));
                      }
                      return (
                        (N = this._inspectFont) == null ||
                          N.call(this, this, W),
                        k
                      );
                    }
                    getPathGenerator(X, W) {
                      if (this.compiledGlyphs[W] !== void 0)
                        return this.compiledGlyphs[W];
                      let k;
                      try {
                        k = X.get(this.loadedName + "_path_" + W);
                      } catch (N) {
                        if (!this.ignoreErrors) throw N;
                        return (
                          (0, w.warn)(
                            `getPathGenerator - ignoring character: "${N}".`,
                          ),
                          (this.compiledGlyphs[W] = function (P, _) {})
                        );
                      }
                      if (
                        this.isEvalSupported &&
                        w.FeatureTest.isEvalSupported
                      ) {
                        const N = [];
                        for (const P of k) {
                          const _ = P.args !== void 0 ? P.args.join(",") : "";
                          N.push(
                            "c.",
                            P.cmd,
                            "(",
                            _,
                            `);
`,
                          );
                        }
                        return (this.compiledGlyphs[W] = new Function(
                          "c",
                          "size",
                          N.join(""),
                        ));
                      }
                      return (this.compiledGlyphs[W] = function (N, P) {
                        for (const _ of k)
                          (_.cmd === "scale" && (_.args = [P, -P]),
                            N[_.cmd].apply(N, _.args));
                      });
                    }
                  }
                  A.FontFaceObject = i;
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.NodeStandardFontDataFactory =
                      A.NodeFilterFactory =
                      A.NodeCanvasFactory =
                      A.NodeCMapReaderFactory =
                        void 0));
                  var w = n(7);
                  n(1);
                  const S = function (W) {
                    return new Promise((k, N) => {
                      require$$5.readFile(W, (_, h) => {
                        if (_ || !h) {
                          N(new Error(_));
                          return;
                        }
                        k(new Uint8Array(h));
                      });
                    });
                  };
                  class i extends w.BaseFilterFactory {}
                  A.NodeFilterFactory = i;
                  class H extends w.BaseCanvasFactory {
                    _createCanvas(k, N) {
                      return require$$5.createCanvas(k, N);
                    }
                  }
                  A.NodeCanvasFactory = H;
                  class ee extends w.BaseCMapReaderFactory {
                    _fetchData(k, N) {
                      return S(k).then((P) => ({
                        cMapData: P,
                        compressionType: N,
                      }));
                    }
                  }
                  A.NodeCMapReaderFactory = ee;
                  class X extends w.BaseStandardFontDataFactory {
                    _fetchData(k) {
                      return S(k);
                    }
                  }
                  A.NodeStandardFontDataFactory = X;
                },
                (t, A, n) => {
                  var z, Wr, Ur;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.CanvasGraphics = void 0));
                  var w = n(1),
                    S = n(6),
                    i = n(12),
                    H = n(13);
                  const ee = 16,
                    X = 100,
                    W = 4096,
                    k = 15,
                    N = 10,
                    P = 1e3,
                    _ = 16;
                  function h(T, s) {
                    if (T._removeMirroring)
                      throw new Error(
                        "Context is already forwarding operations.",
                      );
                    ((T.__originalSave = T.save),
                      (T.__originalRestore = T.restore),
                      (T.__originalRotate = T.rotate),
                      (T.__originalScale = T.scale),
                      (T.__originalTranslate = T.translate),
                      (T.__originalTransform = T.transform),
                      (T.__originalSetTransform = T.setTransform),
                      (T.__originalResetTransform = T.resetTransform),
                      (T.__originalClip = T.clip),
                      (T.__originalMoveTo = T.moveTo),
                      (T.__originalLineTo = T.lineTo),
                      (T.__originalBezierCurveTo = T.bezierCurveTo),
                      (T.__originalRect = T.rect),
                      (T.__originalClosePath = T.closePath),
                      (T.__originalBeginPath = T.beginPath),
                      (T._removeMirroring = () => {
                        ((T.save = T.__originalSave),
                          (T.restore = T.__originalRestore),
                          (T.rotate = T.__originalRotate),
                          (T.scale = T.__originalScale),
                          (T.translate = T.__originalTranslate),
                          (T.transform = T.__originalTransform),
                          (T.setTransform = T.__originalSetTransform),
                          (T.resetTransform = T.__originalResetTransform),
                          (T.clip = T.__originalClip),
                          (T.moveTo = T.__originalMoveTo),
                          (T.lineTo = T.__originalLineTo),
                          (T.bezierCurveTo = T.__originalBezierCurveTo),
                          (T.rect = T.__originalRect),
                          (T.closePath = T.__originalClosePath),
                          (T.beginPath = T.__originalBeginPath),
                          delete T._removeMirroring);
                      }),
                      (T.save = function () {
                        (s.save(), this.__originalSave());
                      }),
                      (T.restore = function () {
                        (s.restore(), this.__originalRestore());
                      }),
                      (T.translate = function (R, $) {
                        (s.translate(R, $), this.__originalTranslate(R, $));
                      }),
                      (T.scale = function (R, $) {
                        (s.scale(R, $), this.__originalScale(R, $));
                      }),
                      (T.transform = function (R, $, j, U, Q, fe) {
                        (s.transform(R, $, j, U, Q, fe),
                          this.__originalTransform(R, $, j, U, Q, fe));
                      }),
                      (T.setTransform = function (R, $, j, U, Q, fe) {
                        (s.setTransform(R, $, j, U, Q, fe),
                          this.__originalSetTransform(R, $, j, U, Q, fe));
                      }),
                      (T.resetTransform = function () {
                        (s.resetTransform(), this.__originalResetTransform());
                      }),
                      (T.rotate = function (R) {
                        (s.rotate(R), this.__originalRotate(R));
                      }),
                      (T.clip = function (R) {
                        (s.clip(R), this.__originalClip(R));
                      }),
                      (T.moveTo = function (g, R) {
                        (s.moveTo(g, R), this.__originalMoveTo(g, R));
                      }),
                      (T.lineTo = function (g, R) {
                        (s.lineTo(g, R), this.__originalLineTo(g, R));
                      }),
                      (T.bezierCurveTo = function (g, R, $, j, U, Q) {
                        (s.bezierCurveTo(g, R, $, j, U, Q),
                          this.__originalBezierCurveTo(g, R, $, j, U, Q));
                      }),
                      (T.rect = function (g, R, $, j) {
                        (s.rect(g, R, $, j), this.__originalRect(g, R, $, j));
                      }),
                      (T.closePath = function () {
                        (s.closePath(), this.__originalClosePath());
                      }),
                      (T.beginPath = function () {
                        (s.beginPath(), this.__originalBeginPath());
                      }));
                  }
                  class r {
                    constructor(s) {
                      ((this.canvasFactory = s),
                        (this.cache = Object.create(null)));
                    }
                    getCanvas(s, g, R) {
                      let $;
                      return (
                        this.cache[s] !== void 0
                          ? (($ = this.cache[s]),
                            this.canvasFactory.reset($, g, R))
                          : (($ = this.canvasFactory.create(g, R)),
                            (this.cache[s] = $)),
                        $
                      );
                    }
                    delete(s) {
                      delete this.cache[s];
                    }
                    clear() {
                      for (const s in this.cache) {
                        const g = this.cache[s];
                        (this.canvasFactory.destroy(g), delete this.cache[s]);
                      }
                    }
                  }
                  function d(T, s, g, R, $, j, U, Q, fe, we) {
                    const [Ee, Ce, xe, Re, ue, de] = (0, S.getCurrentTransform)(
                      T,
                    );
                    if (Ce === 0 && xe === 0) {
                      const ie = U * Ee + ue,
                        re = Math.round(ie),
                        he = Q * Re + de,
                        Pe = Math.round(he),
                        Me = (U + fe) * Ee + ue,
                        se = Math.abs(Math.round(Me) - re) || 1,
                        je = (Q + we) * Re + de,
                        Ie = Math.abs(Math.round(je) - Pe) || 1;
                      return (
                        T.setTransform(
                          Math.sign(Ee),
                          0,
                          0,
                          Math.sign(Re),
                          re,
                          Pe,
                        ),
                        T.drawImage(s, g, R, $, j, 0, 0, se, Ie),
                        T.setTransform(Ee, Ce, xe, Re, ue, de),
                        [se, Ie]
                      );
                    }
                    if (Ee === 0 && Re === 0) {
                      const ie = Q * xe + ue,
                        re = Math.round(ie),
                        he = U * Ce + de,
                        Pe = Math.round(he),
                        Me = (Q + we) * xe + ue,
                        se = Math.abs(Math.round(Me) - re) || 1,
                        je = (U + fe) * Ce + de,
                        Ie = Math.abs(Math.round(je) - Pe) || 1;
                      return (
                        T.setTransform(
                          0,
                          Math.sign(Ce),
                          Math.sign(xe),
                          0,
                          re,
                          Pe,
                        ),
                        T.drawImage(s, g, R, $, j, 0, 0, Ie, se),
                        T.setTransform(Ee, Ce, xe, Re, ue, de),
                        [Ie, se]
                      );
                    }
                    T.drawImage(s, g, R, $, j, U, Q, fe, we);
                    const I = Math.hypot(Ee, Ce),
                      q = Math.hypot(xe, Re);
                    return [I * fe, q * we];
                  }
                  function p(T) {
                    const { width: s, height: g } = T;
                    if (s > P || g > P) return null;
                    const R = 1e3,
                      $ = new Uint8Array([
                        0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
                      ]),
                      j = s + 1;
                    let U = new Uint8Array(j * (g + 1)),
                      Q,
                      fe,
                      we;
                    const Ee = (s + 7) & -8;
                    let Ce = new Uint8Array(Ee * g),
                      xe = 0;
                    for (const q of T.data) {
                      let ie = 128;
                      for (; ie > 0; )
                        ((Ce[xe++] = q & ie ? 0 : 255), (ie >>= 1));
                    }
                    let Re = 0;
                    for (
                      xe = 0, Ce[xe] !== 0 && ((U[0] = 1), ++Re), fe = 1;
                      fe < s;
                      fe++
                    )
                      (Ce[xe] !== Ce[xe + 1] &&
                        ((U[fe] = Ce[xe] ? 2 : 1), ++Re),
                        xe++);
                    for (
                      Ce[xe] !== 0 && ((U[fe] = 2), ++Re), Q = 1;
                      Q < g;
                      Q++
                    ) {
                      ((xe = Q * Ee),
                        (we = Q * j),
                        Ce[xe - Ee] !== Ce[xe] &&
                          ((U[we] = Ce[xe] ? 1 : 8), ++Re));
                      let q = (Ce[xe] ? 4 : 0) + (Ce[xe - Ee] ? 8 : 0);
                      for (fe = 1; fe < s; fe++)
                        ((q =
                          (q >> 2) +
                          (Ce[xe + 1] ? 4 : 0) +
                          (Ce[xe - Ee + 1] ? 8 : 0)),
                          $[q] && ((U[we + fe] = $[q]), ++Re),
                          xe++);
                      if (
                        (Ce[xe - Ee] !== Ce[xe] &&
                          ((U[we + fe] = Ce[xe] ? 2 : 4), ++Re),
                        Re > R)
                      )
                        return null;
                    }
                    for (
                      xe = Ee * (g - 1),
                        we = Q * j,
                        Ce[xe] !== 0 && ((U[we] = 8), ++Re),
                        fe = 1;
                      fe < s;
                      fe++
                    )
                      (Ce[xe] !== Ce[xe + 1] &&
                        ((U[we + fe] = Ce[xe] ? 4 : 8), ++Re),
                        xe++);
                    if ((Ce[xe] !== 0 && ((U[we + fe] = 4), ++Re), Re > R))
                      return null;
                    const ue = new Int32Array([0, j, -1, 0, -j, 0, 0, 0, 1]),
                      de = new Path2D();
                    for (Q = 0; Re && Q <= g; Q++) {
                      let q = Q * j;
                      const ie = q + s;
                      for (; q < ie && !U[q]; ) q++;
                      if (q === ie) continue;
                      de.moveTo(q % j, Q);
                      const re = q;
                      let he = U[q];
                      do {
                        const Pe = ue[he];
                        do q += Pe;
                        while (!U[q]);
                        const Me = U[q];
                        (Me !== 5 && Me !== 10
                          ? ((he = Me), (U[q] = 0))
                          : ((he = Me & ((51 * he) >> 4)),
                            (U[q] &= (he >> 2) | (he << 2))),
                          de.lineTo(q % j, (q / j) | 0),
                          U[q] || --Re);
                      } while (re !== q);
                      --Q;
                    }
                    return (
                      (Ce = null),
                      (U = null),
                      function (q) {
                        (q.save(),
                          q.scale(1 / s, -1 / g),
                          q.translate(0, -g),
                          q.fill(de),
                          q.beginPath(),
                          q.restore());
                      }
                    );
                  }
                  class u {
                    constructor(s, g) {
                      ((this.alphaIsShape = !1),
                        (this.fontSize = 0),
                        (this.fontSizeScale = 1),
                        (this.textMatrix = w.IDENTITY_MATRIX),
                        (this.textMatrixScale = 1),
                        (this.fontMatrix = w.FONT_IDENTITY_MATRIX),
                        (this.leading = 0),
                        (this.x = 0),
                        (this.y = 0),
                        (this.lineX = 0),
                        (this.lineY = 0),
                        (this.charSpacing = 0),
                        (this.wordSpacing = 0),
                        (this.textHScale = 1),
                        (this.textRenderingMode = w.TextRenderingMode.FILL),
                        (this.textRise = 0),
                        (this.fillColor = "#000000"),
                        (this.strokeColor = "#000000"),
                        (this.patternFill = !1),
                        (this.fillAlpha = 1),
                        (this.strokeAlpha = 1),
                        (this.lineWidth = 1),
                        (this.activeSMask = null),
                        (this.transferMaps = "none"),
                        this.startNewPathAndClipBox([0, 0, s, g]));
                    }
                    clone() {
                      const s = Object.create(this);
                      return ((s.clipBox = this.clipBox.slice()), s);
                    }
                    setCurrentPoint(s, g) {
                      ((this.x = s), (this.y = g));
                    }
                    updatePathMinMax(s, g, R) {
                      (([g, R] = w.Util.applyTransform([g, R], s)),
                        (this.minX = Math.min(this.minX, g)),
                        (this.minY = Math.min(this.minY, R)),
                        (this.maxX = Math.max(this.maxX, g)),
                        (this.maxY = Math.max(this.maxY, R)));
                    }
                    updateRectMinMax(s, g) {
                      const R = w.Util.applyTransform(g, s),
                        $ = w.Util.applyTransform(g.slice(2), s);
                      ((this.minX = Math.min(this.minX, R[0], $[0])),
                        (this.minY = Math.min(this.minY, R[1], $[1])),
                        (this.maxX = Math.max(this.maxX, R[0], $[0])),
                        (this.maxY = Math.max(this.maxY, R[1], $[1])));
                    }
                    updateScalingPathMinMax(s, g) {
                      (w.Util.scaleMinMax(s, g),
                        (this.minX = Math.min(this.minX, g[0])),
                        (this.maxX = Math.max(this.maxX, g[1])),
                        (this.minY = Math.min(this.minY, g[2])),
                        (this.maxY = Math.max(this.maxY, g[3])));
                    }
                    updateCurvePathMinMax(s, g, R, $, j, U, Q, fe, we, Ee) {
                      const Ce = w.Util.bezierBoundingBox(
                        g,
                        R,
                        $,
                        j,
                        U,
                        Q,
                        fe,
                        we,
                      );
                      if (Ee) {
                        ((Ee[0] = Math.min(Ee[0], Ce[0], Ce[2])),
                          (Ee[1] = Math.max(Ee[1], Ce[0], Ce[2])),
                          (Ee[2] = Math.min(Ee[2], Ce[1], Ce[3])),
                          (Ee[3] = Math.max(Ee[3], Ce[1], Ce[3])));
                        return;
                      }
                      this.updateRectMinMax(s, Ce);
                    }
                    getPathBoundingBox(s = i.PathType.FILL, g = null) {
                      const R = [this.minX, this.minY, this.maxX, this.maxY];
                      if (s === i.PathType.STROKE) {
                        g ||
                          (0, w.unreachable)(
                            "Stroke bounding box must include transform.",
                          );
                        const $ = w.Util.singularValueDecompose2dScale(g),
                          j = ($[0] * this.lineWidth) / 2,
                          U = ($[1] * this.lineWidth) / 2;
                        ((R[0] -= j), (R[1] -= U), (R[2] += j), (R[3] += U));
                      }
                      return R;
                    }
                    updateClipFromPath() {
                      const s = w.Util.intersect(
                        this.clipBox,
                        this.getPathBoundingBox(),
                      );
                      this.startNewPathAndClipBox(s || [0, 0, 0, 0]);
                    }
                    isEmptyClip() {
                      return this.minX === 1 / 0;
                    }
                    startNewPathAndClipBox(s) {
                      ((this.clipBox = s),
                        (this.minX = 1 / 0),
                        (this.minY = 1 / 0),
                        (this.maxX = 0),
                        (this.maxY = 0));
                    }
                    getClippedPathBoundingBox(s = i.PathType.FILL, g = null) {
                      return w.Util.intersect(
                        this.clipBox,
                        this.getPathBoundingBox(s, g),
                      );
                    }
                  }
                  function F(T, s) {
                    if (typeof ImageData < "u" && s instanceof ImageData) {
                      T.putImageData(s, 0, 0);
                      return;
                    }
                    const g = s.height,
                      R = s.width,
                      $ = g % _,
                      j = (g - $) / _,
                      U = $ === 0 ? j : j + 1,
                      Q = T.createImageData(R, _);
                    let fe = 0,
                      we;
                    const Ee = s.data,
                      Ce = Q.data;
                    let xe, Re, ue, de;
                    if (s.kind === w.ImageKind.GRAYSCALE_1BPP) {
                      const I = Ee.byteLength,
                        q = new Uint32Array(Ce.buffer, 0, Ce.byteLength >> 2),
                        ie = q.length,
                        re = (R + 7) >> 3,
                        he = 4294967295,
                        Pe = w.FeatureTest.isLittleEndian ? 4278190080 : 255;
                      for (xe = 0; xe < U; xe++) {
                        for (
                          ue = xe < j ? _ : $, we = 0, Re = 0;
                          Re < ue;
                          Re++
                        ) {
                          const Me = I - fe;
                          let se = 0;
                          const je = Me > re ? R : Me * 8 - 7,
                            Ie = je & -8;
                          let it = 0,
                            Ke = 0;
                          for (; se < Ie; se += 8)
                            ((Ke = Ee[fe++]),
                              (q[we++] = Ke & 128 ? he : Pe),
                              (q[we++] = Ke & 64 ? he : Pe),
                              (q[we++] = Ke & 32 ? he : Pe),
                              (q[we++] = Ke & 16 ? he : Pe),
                              (q[we++] = Ke & 8 ? he : Pe),
                              (q[we++] = Ke & 4 ? he : Pe),
                              (q[we++] = Ke & 2 ? he : Pe),
                              (q[we++] = Ke & 1 ? he : Pe));
                          for (; se < je; se++)
                            (it === 0 && ((Ke = Ee[fe++]), (it = 128)),
                              (q[we++] = Ke & it ? he : Pe),
                              (it >>= 1));
                        }
                        for (; we < ie; ) q[we++] = 0;
                        T.putImageData(Q, 0, xe * _);
                      }
                    } else if (s.kind === w.ImageKind.RGBA_32BPP) {
                      for (Re = 0, de = R * _ * 4, xe = 0; xe < j; xe++)
                        (Ce.set(Ee.subarray(fe, fe + de)),
                          (fe += de),
                          T.putImageData(Q, 0, Re),
                          (Re += _));
                      xe < U &&
                        ((de = R * $ * 4),
                        Ce.set(Ee.subarray(fe, fe + de)),
                        T.putImageData(Q, 0, Re));
                    } else if (s.kind === w.ImageKind.RGB_24BPP)
                      for (ue = _, de = R * ue, xe = 0; xe < U; xe++) {
                        for (
                          xe >= j && ((ue = $), (de = R * ue)), we = 0, Re = de;
                          Re--;

                        )
                          ((Ce[we++] = Ee[fe++]),
                            (Ce[we++] = Ee[fe++]),
                            (Ce[we++] = Ee[fe++]),
                            (Ce[we++] = 255));
                        T.putImageData(Q, 0, xe * _);
                      }
                    else throw new Error(`bad image kind: ${s.kind}`);
                  }
                  function v(T, s) {
                    if (s.bitmap) {
                      T.drawImage(s.bitmap, 0, 0);
                      return;
                    }
                    const g = s.height,
                      R = s.width,
                      $ = g % _,
                      j = (g - $) / _,
                      U = $ === 0 ? j : j + 1,
                      Q = T.createImageData(R, _);
                    let fe = 0;
                    const we = s.data,
                      Ee = Q.data;
                    for (let Ce = 0; Ce < U; Ce++) {
                      const xe = Ce < j ? _ : $;
                      (({ srcPos: fe } = (0, H.convertBlackAndWhiteToRGBA)({
                        src: we,
                        srcPos: fe,
                        dest: Ee,
                        width: R,
                        height: xe,
                        nonBlackColor: 0,
                      })),
                        T.putImageData(Q, 0, Ce * _));
                    }
                  }
                  function f(T, s) {
                    const g = [
                      "strokeStyle",
                      "fillStyle",
                      "fillRule",
                      "globalAlpha",
                      "lineWidth",
                      "lineCap",
                      "lineJoin",
                      "miterLimit",
                      "globalCompositeOperation",
                      "font",
                      "filter",
                    ];
                    for (const R of g) T[R] !== void 0 && (s[R] = T[R]);
                    T.setLineDash !== void 0 &&
                      (s.setLineDash(T.getLineDash()),
                      (s.lineDashOffset = T.lineDashOffset));
                  }
                  function b(T) {
                    if (
                      ((T.strokeStyle = T.fillStyle = "#000000"),
                      (T.fillRule = "nonzero"),
                      (T.globalAlpha = 1),
                      (T.lineWidth = 1),
                      (T.lineCap = "butt"),
                      (T.lineJoin = "miter"),
                      (T.miterLimit = 10),
                      (T.globalCompositeOperation = "source-over"),
                      (T.font = "10px sans-serif"),
                      T.setLineDash !== void 0 &&
                        (T.setLineDash([]), (T.lineDashOffset = 0)),
                      !w.isNodeJS)
                    ) {
                      const { filter: s } = T;
                      s !== "none" && s !== "" && (T.filter = "none");
                    }
                  }
                  function c(T, s, g, R) {
                    const $ = T.length;
                    for (let j = 3; j < $; j += 4) {
                      const U = T[j];
                      if (U === 0)
                        ((T[j - 3] = s), (T[j - 2] = g), (T[j - 1] = R));
                      else if (U < 255) {
                        const Q = 255 - U;
                        ((T[j - 3] = (T[j - 3] * U + s * Q) >> 8),
                          (T[j - 2] = (T[j - 2] * U + g * Q) >> 8),
                          (T[j - 1] = (T[j - 1] * U + R * Q) >> 8));
                      }
                    }
                  }
                  function a(T, s, g) {
                    const R = T.length,
                      $ = 1 / 255;
                    for (let j = 3; j < R; j += 4) {
                      const U = g ? g[T[j]] : T[j];
                      s[j] = (s[j] * U * $) | 0;
                    }
                  }
                  function m(T, s, g) {
                    const R = T.length;
                    for (let $ = 3; $ < R; $ += 4) {
                      const j = T[$ - 3] * 77 + T[$ - 2] * 152 + T[$ - 1] * 28;
                      s[$] = g ? (s[$] * g[j >> 8]) >> 8 : (s[$] * j) >> 16;
                    }
                  }
                  function C(T, s, g, R, $, j, U, Q, fe, we, Ee) {
                    const Ce = !!j,
                      xe = Ce ? j[0] : 0,
                      Re = Ce ? j[1] : 0,
                      ue = Ce ? j[2] : 0,
                      de = $ === "Luminosity" ? m : a,
                      q = Math.min(R, Math.ceil(1048576 / g));
                    for (let ie = 0; ie < R; ie += q) {
                      const re = Math.min(q, R - ie),
                        he = T.getImageData(Q - we, ie + (fe - Ee), g, re),
                        Pe = s.getImageData(Q, ie + fe, g, re);
                      (Ce && c(he.data, xe, Re, ue),
                        de(he.data, Pe.data, U),
                        s.putImageData(Pe, Q, ie + fe));
                    }
                  }
                  function e(T, s, g, R) {
                    const $ = R[0],
                      j = R[1],
                      U = R[2] - $,
                      Q = R[3] - j;
                    U === 0 ||
                      Q === 0 ||
                      (C(
                        s.context,
                        g,
                        U,
                        Q,
                        s.subtype,
                        s.backdrop,
                        s.transferMap,
                        $,
                        j,
                        s.offsetX,
                        s.offsetY,
                      ),
                      T.save(),
                      (T.globalAlpha = 1),
                      (T.globalCompositeOperation = "source-over"),
                      T.setTransform(1, 0, 0, 1, 0, 0),
                      T.drawImage(g.canvas, 0, 0),
                      T.restore());
                  }
                  function o(T, s) {
                    const g = w.Util.singularValueDecompose2dScale(T);
                    ((g[0] = Math.fround(g[0])), (g[1] = Math.fround(g[1])));
                    const R = Math.fround(
                      (globalThis.devicePixelRatio || 1) *
                        S.PixelsPerInch.PDF_TO_CSS_UNITS,
                    );
                    return s !== void 0 ? s : g[0] <= R || g[1] <= R;
                  }
                  const y = ["butt", "round", "square"],
                    B = ["miter", "round", "bevel"],
                    M = {},
                    D = {},
                    Y = class Y {
                      constructor(
                        s,
                        g,
                        R,
                        $,
                        j,
                        {
                          optionalContentConfig: U,
                          markedContentStack: Q = null,
                        },
                        fe,
                        we,
                      ) {
                        ye(this, z);
                        ((this.ctx = s),
                          (this.current = new u(
                            this.ctx.canvas.width,
                            this.ctx.canvas.height,
                          )),
                          (this.stateStack = []),
                          (this.pendingClip = null),
                          (this.pendingEOFill = !1),
                          (this.res = null),
                          (this.xobjs = null),
                          (this.commonObjs = g),
                          (this.objs = R),
                          (this.canvasFactory = $),
                          (this.filterFactory = j),
                          (this.groupStack = []),
                          (this.processingType3 = null),
                          (this.baseTransform = null),
                          (this.baseTransformStack = []),
                          (this.groupLevel = 0),
                          (this.smaskStack = []),
                          (this.smaskCounter = 0),
                          (this.tempSMask = null),
                          (this.suspendedCtx = null),
                          (this.contentVisible = !0),
                          (this.markedContentStack = Q || []),
                          (this.optionalContentConfig = U),
                          (this.cachedCanvases = new r(this.canvasFactory)),
                          (this.cachedPatterns = new Map()),
                          (this.annotationCanvasMap = fe),
                          (this.viewportScale = 1),
                          (this.outputScaleX = 1),
                          (this.outputScaleY = 1),
                          (this.pageColors = we),
                          (this._cachedScaleForStroking = [-1, 0]),
                          (this._cachedGetSinglePixelWidth = null),
                          (this._cachedBitmapsMap = new Map()));
                      }
                      getObject(s, g = null) {
                        return typeof s == "string"
                          ? s.startsWith("g_")
                            ? this.commonObjs.get(s)
                            : this.objs.get(s)
                          : g;
                      }
                      beginDrawing({
                        transform: s,
                        viewport: g,
                        transparency: R = !1,
                        background: $ = null,
                      }) {
                        const j = this.ctx.canvas.width,
                          U = this.ctx.canvas.height,
                          Q = this.ctx.fillStyle;
                        if (
                          ((this.ctx.fillStyle = $ || "#ffffff"),
                          this.ctx.fillRect(0, 0, j, U),
                          (this.ctx.fillStyle = Q),
                          R)
                        ) {
                          const fe = this.cachedCanvases.getCanvas(
                            "transparent",
                            j,
                            U,
                          );
                          ((this.compositeCtx = this.ctx),
                            (this.transparentCanvas = fe.canvas),
                            (this.ctx = fe.context),
                            this.ctx.save(),
                            this.ctx.transform(
                              ...(0, S.getCurrentTransform)(this.compositeCtx),
                            ));
                        }
                        (this.ctx.save(),
                          b(this.ctx),
                          s &&
                            (this.ctx.transform(...s),
                            (this.outputScaleX = s[0]),
                            (this.outputScaleY = s[0])),
                          this.ctx.transform(...g.transform),
                          (this.viewportScale = g.scale),
                          (this.baseTransform = (0, S.getCurrentTransform)(
                            this.ctx,
                          )));
                      }
                      executeOperatorList(s, g, R, $) {
                        const j = s.argsArray,
                          U = s.fnArray;
                        let Q = g || 0;
                        const fe = j.length;
                        if (fe === Q) return Q;
                        const we = fe - Q > N && typeof R == "function",
                          Ee = we ? Date.now() + k : 0;
                        let Ce = 0;
                        const xe = this.commonObjs,
                          Re = this.objs;
                        let ue;
                        for (;;) {
                          if ($ !== void 0 && Q === $.nextBreakPoint)
                            return ($.breakIt(Q, R), Q);
                          if (((ue = U[Q]), ue !== w.OPS.dependency))
                            this[ue].apply(this, j[Q]);
                          else
                            for (const de of j[Q]) {
                              const I = de.startsWith("g_") ? xe : Re;
                              if (!I.has(de)) return (I.get(de, R), Q);
                            }
                          if ((Q++, Q === fe)) return Q;
                          if (we && ++Ce > N) {
                            if (Date.now() > Ee) return (R(), Q);
                            Ce = 0;
                          }
                        }
                      }
                      endDrawing() {
                        (le(this, z, Wr).call(this),
                          this.cachedCanvases.clear(),
                          this.cachedPatterns.clear());
                        for (const s of this._cachedBitmapsMap.values()) {
                          for (const g of s.values())
                            typeof HTMLCanvasElement < "u" &&
                              g instanceof HTMLCanvasElement &&
                              (g.width = g.height = 0);
                          s.clear();
                        }
                        (this._cachedBitmapsMap.clear(),
                          le(this, z, Ur).call(this));
                      }
                      _scaleImage(s, g) {
                        const R = s.width,
                          $ = s.height;
                        let j = Math.max(Math.hypot(g[0], g[1]), 1),
                          U = Math.max(Math.hypot(g[2], g[3]), 1),
                          Q = R,
                          fe = $,
                          we = "prescale1",
                          Ee,
                          Ce;
                        for (; (j > 2 && Q > 1) || (U > 2 && fe > 1); ) {
                          let xe = Q,
                            Re = fe;
                          (j > 2 &&
                            Q > 1 &&
                            ((xe =
                              Q >= 16384
                                ? Math.floor(Q / 2) - 1 || 1
                                : Math.ceil(Q / 2)),
                            (j /= Q / xe)),
                            U > 2 &&
                              fe > 1 &&
                              ((Re =
                                fe >= 16384
                                  ? Math.floor(fe / 2) - 1 || 1
                                  : Math.ceil(fe) / 2),
                              (U /= fe / Re)),
                            (Ee = this.cachedCanvases.getCanvas(we, xe, Re)),
                            (Ce = Ee.context),
                            Ce.clearRect(0, 0, xe, Re),
                            Ce.drawImage(s, 0, 0, Q, fe, 0, 0, xe, Re),
                            (s = Ee.canvas),
                            (Q = xe),
                            (fe = Re),
                            (we =
                              we === "prescale1" ? "prescale2" : "prescale1"));
                        }
                        return { img: s, paintWidth: Q, paintHeight: fe };
                      }
                      _createMaskCanvas(s) {
                        const g = this.ctx,
                          { width: R, height: $ } = s,
                          j = this.current.fillColor,
                          U = this.current.patternFill,
                          Q = (0, S.getCurrentTransform)(g);
                        let fe, we, Ee, Ce;
                        if ((s.bitmap || s.data) && s.count > 1) {
                          const se = s.bitmap || s.data.buffer;
                          ((we = JSON.stringify(U ? Q : [Q.slice(0, 4), j])),
                            (fe = this._cachedBitmapsMap.get(se)),
                            fe ||
                              ((fe = new Map()),
                              this._cachedBitmapsMap.set(se, fe)));
                          const je = fe.get(we);
                          if (je && !U) {
                            const Ie = Math.round(Math.min(Q[0], Q[2]) + Q[4]),
                              it = Math.round(Math.min(Q[1], Q[3]) + Q[5]);
                            return { canvas: je, offsetX: Ie, offsetY: it };
                          }
                          Ee = je;
                        }
                        Ee ||
                          ((Ce = this.cachedCanvases.getCanvas(
                            "maskCanvas",
                            R,
                            $,
                          )),
                          v(Ce.context, s));
                        let xe = w.Util.transform(Q, [
                          1 / R,
                          0,
                          0,
                          -1 / $,
                          0,
                          0,
                        ]);
                        xe = w.Util.transform(xe, [1, 0, 0, 1, 0, -$]);
                        const Re = w.Util.applyTransform([0, 0], xe),
                          ue = w.Util.applyTransform([R, $], xe),
                          de = w.Util.normalizeRect([
                            Re[0],
                            Re[1],
                            ue[0],
                            ue[1],
                          ]),
                          I = Math.round(de[2] - de[0]) || 1,
                          q = Math.round(de[3] - de[1]) || 1,
                          ie = this.cachedCanvases.getCanvas(
                            "fillCanvas",
                            I,
                            q,
                          ),
                          re = ie.context,
                          he = Math.min(Re[0], ue[0]),
                          Pe = Math.min(Re[1], ue[1]);
                        (re.translate(-he, -Pe),
                          re.transform(...xe),
                          Ee ||
                            ((Ee = this._scaleImage(
                              Ce.canvas,
                              (0, S.getCurrentTransformInverse)(re),
                            )),
                            (Ee = Ee.img),
                            fe && U && fe.set(we, Ee)),
                          (re.imageSmoothingEnabled = o(
                            (0, S.getCurrentTransform)(re),
                            s.interpolate,
                          )),
                          d(re, Ee, 0, 0, Ee.width, Ee.height, 0, 0, R, $),
                          (re.globalCompositeOperation = "source-in"));
                        const Me = w.Util.transform(
                          (0, S.getCurrentTransformInverse)(re),
                          [1, 0, 0, 1, -he, -Pe],
                        );
                        return (
                          (re.fillStyle = U
                            ? j.getPattern(g, this, Me, i.PathType.FILL)
                            : j),
                          re.fillRect(0, 0, R, $),
                          fe &&
                            !U &&
                            (this.cachedCanvases.delete("fillCanvas"),
                            fe.set(we, ie.canvas)),
                          {
                            canvas: ie.canvas,
                            offsetX: Math.round(he),
                            offsetY: Math.round(Pe),
                          }
                        );
                      }
                      setLineWidth(s) {
                        (s !== this.current.lineWidth &&
                          (this._cachedScaleForStroking[0] = -1),
                          (this.current.lineWidth = s),
                          (this.ctx.lineWidth = s));
                      }
                      setLineCap(s) {
                        this.ctx.lineCap = y[s];
                      }
                      setLineJoin(s) {
                        this.ctx.lineJoin = B[s];
                      }
                      setMiterLimit(s) {
                        this.ctx.miterLimit = s;
                      }
                      setDash(s, g) {
                        const R = this.ctx;
                        R.setLineDash !== void 0 &&
                          (R.setLineDash(s), (R.lineDashOffset = g));
                      }
                      setRenderingIntent(s) {}
                      setFlatness(s) {}
                      setGState(s) {
                        for (const [g, R] of s)
                          switch (g) {
                            case "LW":
                              this.setLineWidth(R);
                              break;
                            case "LC":
                              this.setLineCap(R);
                              break;
                            case "LJ":
                              this.setLineJoin(R);
                              break;
                            case "ML":
                              this.setMiterLimit(R);
                              break;
                            case "D":
                              this.setDash(R[0], R[1]);
                              break;
                            case "RI":
                              this.setRenderingIntent(R);
                              break;
                            case "FL":
                              this.setFlatness(R);
                              break;
                            case "Font":
                              this.setFont(R[0], R[1]);
                              break;
                            case "CA":
                              this.current.strokeAlpha = R;
                              break;
                            case "ca":
                              ((this.current.fillAlpha = R),
                                (this.ctx.globalAlpha = R));
                              break;
                            case "BM":
                              this.ctx.globalCompositeOperation = R;
                              break;
                            case "SMask":
                              ((this.current.activeSMask = R
                                ? this.tempSMask
                                : null),
                                (this.tempSMask = null),
                                this.checkSMaskState());
                              break;
                            case "TR":
                              this.ctx.filter = this.current.transferMaps =
                                this.filterFactory.addFilter(R);
                              break;
                          }
                      }
                      get inSMaskMode() {
                        return !!this.suspendedCtx;
                      }
                      checkSMaskState() {
                        const s = this.inSMaskMode;
                        this.current.activeSMask && !s
                          ? this.beginSMaskMode()
                          : !this.current.activeSMask &&
                            s &&
                            this.endSMaskMode();
                      }
                      beginSMaskMode() {
                        if (this.inSMaskMode)
                          throw new Error(
                            "beginSMaskMode called while already in smask mode",
                          );
                        const s = this.ctx.canvas.width,
                          g = this.ctx.canvas.height,
                          R = "smaskGroupAt" + this.groupLevel,
                          $ = this.cachedCanvases.getCanvas(R, s, g);
                        ((this.suspendedCtx = this.ctx),
                          (this.ctx = $.context));
                        const j = this.ctx;
                        (j.setTransform(
                          ...(0, S.getCurrentTransform)(this.suspendedCtx),
                        ),
                          f(this.suspendedCtx, j),
                          h(j, this.suspendedCtx),
                          this.setGState([
                            ["BM", "source-over"],
                            ["ca", 1],
                            ["CA", 1],
                          ]));
                      }
                      endSMaskMode() {
                        if (!this.inSMaskMode)
                          throw new Error(
                            "endSMaskMode called while not in smask mode",
                          );
                        (this.ctx._removeMirroring(),
                          f(this.ctx, this.suspendedCtx),
                          (this.ctx = this.suspendedCtx),
                          (this.suspendedCtx = null));
                      }
                      compose(s) {
                        if (!this.current.activeSMask) return;
                        s
                          ? ((s[0] = Math.floor(s[0])),
                            (s[1] = Math.floor(s[1])),
                            (s[2] = Math.ceil(s[2])),
                            (s[3] = Math.ceil(s[3])))
                          : (s = [
                              0,
                              0,
                              this.ctx.canvas.width,
                              this.ctx.canvas.height,
                            ]);
                        const g = this.current.activeSMask,
                          R = this.suspendedCtx;
                        (e(R, g, this.ctx, s),
                          this.ctx.save(),
                          this.ctx.setTransform(1, 0, 0, 1, 0, 0),
                          this.ctx.clearRect(
                            0,
                            0,
                            this.ctx.canvas.width,
                            this.ctx.canvas.height,
                          ),
                          this.ctx.restore());
                      }
                      save() {
                        this.inSMaskMode
                          ? (f(this.ctx, this.suspendedCtx),
                            this.suspendedCtx.save())
                          : this.ctx.save();
                        const s = this.current;
                        (this.stateStack.push(s), (this.current = s.clone()));
                      }
                      restore() {
                        (this.stateStack.length === 0 &&
                          this.inSMaskMode &&
                          this.endSMaskMode(),
                          this.stateStack.length !== 0 &&
                            ((this.current = this.stateStack.pop()),
                            this.inSMaskMode
                              ? (this.suspendedCtx.restore(),
                                f(this.suspendedCtx, this.ctx))
                              : this.ctx.restore(),
                            this.checkSMaskState(),
                            (this.pendingClip = null),
                            (this._cachedScaleForStroking[0] = -1),
                            (this._cachedGetSinglePixelWidth = null)));
                      }
                      transform(s, g, R, $, j, U) {
                        (this.ctx.transform(s, g, R, $, j, U),
                          (this._cachedScaleForStroking[0] = -1),
                          (this._cachedGetSinglePixelWidth = null));
                      }
                      constructPath(s, g, R) {
                        const $ = this.ctx,
                          j = this.current;
                        let U = j.x,
                          Q = j.y,
                          fe,
                          we;
                        const Ee = (0, S.getCurrentTransform)($),
                          Ce =
                            (Ee[0] === 0 && Ee[3] === 0) ||
                            (Ee[1] === 0 && Ee[2] === 0),
                          xe = Ce ? R.slice(0) : null;
                        for (let Re = 0, ue = 0, de = s.length; Re < de; Re++)
                          switch (s[Re] | 0) {
                            case w.OPS.rectangle:
                              ((U = g[ue++]), (Q = g[ue++]));
                              const I = g[ue++],
                                q = g[ue++],
                                ie = U + I,
                                re = Q + q;
                              ($.moveTo(U, Q),
                                I === 0 || q === 0
                                  ? $.lineTo(ie, re)
                                  : ($.lineTo(ie, Q),
                                    $.lineTo(ie, re),
                                    $.lineTo(U, re)),
                                Ce || j.updateRectMinMax(Ee, [U, Q, ie, re]),
                                $.closePath());
                              break;
                            case w.OPS.moveTo:
                              ((U = g[ue++]),
                                (Q = g[ue++]),
                                $.moveTo(U, Q),
                                Ce || j.updatePathMinMax(Ee, U, Q));
                              break;
                            case w.OPS.lineTo:
                              ((U = g[ue++]),
                                (Q = g[ue++]),
                                $.lineTo(U, Q),
                                Ce || j.updatePathMinMax(Ee, U, Q));
                              break;
                            case w.OPS.curveTo:
                              ((fe = U),
                                (we = Q),
                                (U = g[ue + 4]),
                                (Q = g[ue + 5]),
                                $.bezierCurveTo(
                                  g[ue],
                                  g[ue + 1],
                                  g[ue + 2],
                                  g[ue + 3],
                                  U,
                                  Q,
                                ),
                                j.updateCurvePathMinMax(
                                  Ee,
                                  fe,
                                  we,
                                  g[ue],
                                  g[ue + 1],
                                  g[ue + 2],
                                  g[ue + 3],
                                  U,
                                  Q,
                                  xe,
                                ),
                                (ue += 6));
                              break;
                            case w.OPS.curveTo2:
                              ((fe = U),
                                (we = Q),
                                $.bezierCurveTo(
                                  U,
                                  Q,
                                  g[ue],
                                  g[ue + 1],
                                  g[ue + 2],
                                  g[ue + 3],
                                ),
                                j.updateCurvePathMinMax(
                                  Ee,
                                  fe,
                                  we,
                                  U,
                                  Q,
                                  g[ue],
                                  g[ue + 1],
                                  g[ue + 2],
                                  g[ue + 3],
                                  xe,
                                ),
                                (U = g[ue + 2]),
                                (Q = g[ue + 3]),
                                (ue += 4));
                              break;
                            case w.OPS.curveTo3:
                              ((fe = U),
                                (we = Q),
                                (U = g[ue + 2]),
                                (Q = g[ue + 3]),
                                $.bezierCurveTo(g[ue], g[ue + 1], U, Q, U, Q),
                                j.updateCurvePathMinMax(
                                  Ee,
                                  fe,
                                  we,
                                  g[ue],
                                  g[ue + 1],
                                  U,
                                  Q,
                                  U,
                                  Q,
                                  xe,
                                ),
                                (ue += 4));
                              break;
                            case w.OPS.closePath:
                              $.closePath();
                              break;
                          }
                        (Ce && j.updateScalingPathMinMax(Ee, xe),
                          j.setCurrentPoint(U, Q));
                      }
                      closePath() {
                        this.ctx.closePath();
                      }
                      stroke(s = !0) {
                        const g = this.ctx,
                          R = this.current.strokeColor;
                        ((g.globalAlpha = this.current.strokeAlpha),
                          this.contentVisible &&
                            (typeof R == "object" && R != null && R.getPattern
                              ? (g.save(),
                                (g.strokeStyle = R.getPattern(
                                  g,
                                  this,
                                  (0, S.getCurrentTransformInverse)(g),
                                  i.PathType.STROKE,
                                )),
                                this.rescaleAndStroke(!1),
                                g.restore())
                              : this.rescaleAndStroke(!0)),
                          s &&
                            this.consumePath(
                              this.current.getClippedPathBoundingBox(),
                            ),
                          (g.globalAlpha = this.current.fillAlpha));
                      }
                      closeStroke() {
                        (this.closePath(), this.stroke());
                      }
                      fill(s = !0) {
                        const g = this.ctx,
                          R = this.current.fillColor,
                          $ = this.current.patternFill;
                        let j = !1;
                        $ &&
                          (g.save(),
                          (g.fillStyle = R.getPattern(
                            g,
                            this,
                            (0, S.getCurrentTransformInverse)(g),
                            i.PathType.FILL,
                          )),
                          (j = !0));
                        const U = this.current.getClippedPathBoundingBox();
                        (this.contentVisible &&
                          U !== null &&
                          (this.pendingEOFill
                            ? (g.fill("evenodd"), (this.pendingEOFill = !1))
                            : g.fill()),
                          j && g.restore(),
                          s && this.consumePath(U));
                      }
                      eoFill() {
                        ((this.pendingEOFill = !0), this.fill());
                      }
                      fillStroke() {
                        (this.fill(!1), this.stroke(!1), this.consumePath());
                      }
                      eoFillStroke() {
                        ((this.pendingEOFill = !0), this.fillStroke());
                      }
                      closeFillStroke() {
                        (this.closePath(), this.fillStroke());
                      }
                      closeEOFillStroke() {
                        ((this.pendingEOFill = !0),
                          this.closePath(),
                          this.fillStroke());
                      }
                      endPath() {
                        this.consumePath();
                      }
                      clip() {
                        this.pendingClip = M;
                      }
                      eoClip() {
                        this.pendingClip = D;
                      }
                      beginText() {
                        ((this.current.textMatrix = w.IDENTITY_MATRIX),
                          (this.current.textMatrixScale = 1),
                          (this.current.x = this.current.lineX = 0),
                          (this.current.y = this.current.lineY = 0));
                      }
                      endText() {
                        const s = this.pendingTextPaths,
                          g = this.ctx;
                        if (s === void 0) {
                          g.beginPath();
                          return;
                        }
                        (g.save(), g.beginPath());
                        for (const R of s)
                          (g.setTransform(...R.transform),
                            g.translate(R.x, R.y),
                            R.addToPath(g, R.fontSize));
                        (g.restore(),
                          g.clip(),
                          g.beginPath(),
                          delete this.pendingTextPaths);
                      }
                      setCharSpacing(s) {
                        this.current.charSpacing = s;
                      }
                      setWordSpacing(s) {
                        this.current.wordSpacing = s;
                      }
                      setHScale(s) {
                        this.current.textHScale = s / 100;
                      }
                      setLeading(s) {
                        this.current.leading = -s;
                      }
                      setFont(s, g) {
                        var Ee;
                        const R = this.commonObjs.get(s),
                          $ = this.current;
                        if (!R) throw new Error(`Can't find font for ${s}`);
                        if (
                          (($.fontMatrix =
                            R.fontMatrix || w.FONT_IDENTITY_MATRIX),
                          ($.fontMatrix[0] === 0 || $.fontMatrix[3] === 0) &&
                            (0, w.warn)("Invalid font matrix for font " + s),
                          g < 0
                            ? ((g = -g), ($.fontDirection = -1))
                            : ($.fontDirection = 1),
                          (this.current.font = R),
                          (this.current.fontSize = g),
                          R.isType3Font)
                        )
                          return;
                        const j = R.loadedName || "sans-serif",
                          U =
                            ((Ee = R.systemFontInfo) == null
                              ? void 0
                              : Ee.css) || `"${j}", ${R.fallbackName}`;
                        let Q = "normal";
                        R.black ? (Q = "900") : R.bold && (Q = "bold");
                        const fe = R.italic ? "italic" : "normal";
                        let we = g;
                        (g < ee ? (we = ee) : g > X && (we = X),
                          (this.current.fontSizeScale = g / we),
                          (this.ctx.font = `${fe} ${Q} ${we}px ${U}`));
                      }
                      setTextRenderingMode(s) {
                        this.current.textRenderingMode = s;
                      }
                      setTextRise(s) {
                        this.current.textRise = s;
                      }
                      moveText(s, g) {
                        ((this.current.x = this.current.lineX += s),
                          (this.current.y = this.current.lineY += g));
                      }
                      setLeadingMoveText(s, g) {
                        (this.setLeading(-g), this.moveText(s, g));
                      }
                      setTextMatrix(s, g, R, $, j, U) {
                        ((this.current.textMatrix = [s, g, R, $, j, U]),
                          (this.current.textMatrixScale = Math.hypot(s, g)),
                          (this.current.x = this.current.lineX = 0),
                          (this.current.y = this.current.lineY = 0));
                      }
                      nextLine() {
                        this.moveText(0, this.current.leading);
                      }
                      paintChar(s, g, R, $) {
                        const j = this.ctx,
                          U = this.current,
                          Q = U.font,
                          fe = U.textRenderingMode,
                          we = U.fontSize / U.fontSizeScale,
                          Ee = fe & w.TextRenderingMode.FILL_STROKE_MASK,
                          Ce = !!(fe & w.TextRenderingMode.ADD_TO_PATH_FLAG),
                          xe = U.patternFill && !Q.missingFile;
                        let Re;
                        ((Q.disableFontFace || Ce || xe) &&
                          (Re = Q.getPathGenerator(this.commonObjs, s)),
                          Q.disableFontFace || xe
                            ? (j.save(),
                              j.translate(g, R),
                              j.beginPath(),
                              Re(j, we),
                              $ && j.setTransform(...$),
                              (Ee === w.TextRenderingMode.FILL ||
                                Ee === w.TextRenderingMode.FILL_STROKE) &&
                                j.fill(),
                              (Ee === w.TextRenderingMode.STROKE ||
                                Ee === w.TextRenderingMode.FILL_STROKE) &&
                                j.stroke(),
                              j.restore())
                            : ((Ee === w.TextRenderingMode.FILL ||
                                Ee === w.TextRenderingMode.FILL_STROKE) &&
                                j.fillText(s, g, R),
                              (Ee === w.TextRenderingMode.STROKE ||
                                Ee === w.TextRenderingMode.FILL_STROKE) &&
                                j.strokeText(s, g, R)),
                          Ce &&
                            (
                              this.pendingTextPaths ||
                              (this.pendingTextPaths = [])
                            ).push({
                              transform: (0, S.getCurrentTransform)(j),
                              x: g,
                              y: R,
                              fontSize: we,
                              addToPath: Re,
                            }));
                      }
                      get isFontSubpixelAAEnabled() {
                        const { context: s } = this.cachedCanvases.getCanvas(
                          "isFontSubpixelAAEnabled",
                          10,
                          10,
                        );
                        (s.scale(1.5, 1), s.fillText("I", 0, 10));
                        const g = s.getImageData(0, 0, 10, 10).data;
                        let R = !1;
                        for (let $ = 3; $ < g.length; $ += 4)
                          if (g[$] > 0 && g[$] < 255) {
                            R = !0;
                            break;
                          }
                        return (0, w.shadow)(
                          this,
                          "isFontSubpixelAAEnabled",
                          R,
                        );
                      }
                      showText(s) {
                        const g = this.current,
                          R = g.font;
                        if (R.isType3Font) return this.showType3Text(s);
                        const $ = g.fontSize;
                        if ($ === 0) return;
                        const j = this.ctx,
                          U = g.fontSizeScale,
                          Q = g.charSpacing,
                          fe = g.wordSpacing,
                          we = g.fontDirection,
                          Ee = g.textHScale * we,
                          Ce = s.length,
                          xe = R.vertical,
                          Re = xe ? 1 : -1,
                          ue = R.defaultVMetrics,
                          de = $ * g.fontMatrix[0],
                          I =
                            g.textRenderingMode === w.TextRenderingMode.FILL &&
                            !R.disableFontFace &&
                            !g.patternFill;
                        (j.save(),
                          j.transform(...g.textMatrix),
                          j.translate(g.x, g.y + g.textRise),
                          we > 0 ? j.scale(Ee, -1) : j.scale(Ee, 1));
                        let q;
                        if (g.patternFill) {
                          j.save();
                          const Me = g.fillColor.getPattern(
                            j,
                            this,
                            (0, S.getCurrentTransformInverse)(j),
                            i.PathType.FILL,
                          );
                          ((q = (0, S.getCurrentTransform)(j)),
                            j.restore(),
                            (j.fillStyle = Me));
                        }
                        let ie = g.lineWidth;
                        const re = g.textMatrixScale;
                        if (re === 0 || ie === 0) {
                          const Me =
                            g.textRenderingMode &
                            w.TextRenderingMode.FILL_STROKE_MASK;
                          (Me === w.TextRenderingMode.STROKE ||
                            Me === w.TextRenderingMode.FILL_STROKE) &&
                            (ie = this.getSinglePixelWidth());
                        } else ie /= re;
                        if (
                          (U !== 1 && (j.scale(U, U), (ie /= U)),
                          (j.lineWidth = ie),
                          R.isInvalidPDFjsFont)
                        ) {
                          const Me = [];
                          let se = 0;
                          for (const je of s)
                            (Me.push(je.unicode), (se += je.width));
                          (j.fillText(Me.join(""), 0, 0),
                            (g.x += se * de * Ee),
                            j.restore(),
                            this.compose());
                          return;
                        }
                        let he = 0,
                          Pe;
                        for (Pe = 0; Pe < Ce; ++Pe) {
                          const Me = s[Pe];
                          if (typeof Me == "number") {
                            he += (Re * Me * $) / 1e3;
                            continue;
                          }
                          let se = !1;
                          const je = (Me.isSpace ? fe : 0) + Q,
                            Ie = Me.fontChar,
                            it = Me.accent;
                          let Ke,
                            dt,
                            ze = Me.width;
                          if (xe) {
                            const st = Me.vmetric || ue,
                              kt = -(Me.vmetric ? st[1] : ze * 0.5) * de,
                              Le = st[2] * de;
                            ((ze = st ? -st[0] : ze),
                              (Ke = kt / U),
                              (dt = (he + Le) / U));
                          } else ((Ke = he / U), (dt = 0));
                          if (R.remeasure && ze > 0) {
                            const st =
                              ((j.measureText(Ie).width * 1e3) / $) * U;
                            if (ze < st && this.isFontSubpixelAAEnabled) {
                              const kt = ze / st;
                              ((se = !0), j.save(), j.scale(kt, 1), (Ke /= kt));
                            } else
                              ze !== st && (Ke += (((ze - st) / 2e3) * $) / U);
                          }
                          if (
                            this.contentVisible &&
                            (Me.isInFont || R.missingFile)
                          ) {
                            if (I && !it) j.fillText(Ie, Ke, dt);
                            else if ((this.paintChar(Ie, Ke, dt, q), it)) {
                              const st = Ke + ($ * it.offset.x) / U,
                                kt = dt - ($ * it.offset.y) / U;
                              this.paintChar(it.fontChar, st, kt, q);
                            }
                          }
                          const Je = xe ? ze * de - je * we : ze * de + je * we;
                          ((he += Je), se && j.restore());
                        }
                        (xe ? (g.y -= he) : (g.x += he * Ee),
                          j.restore(),
                          this.compose());
                      }
                      showType3Text(s) {
                        const g = this.ctx,
                          R = this.current,
                          $ = R.font,
                          j = R.fontSize,
                          U = R.fontDirection,
                          Q = $.vertical ? 1 : -1,
                          fe = R.charSpacing,
                          we = R.wordSpacing,
                          Ee = R.textHScale * U,
                          Ce = R.fontMatrix || w.FONT_IDENTITY_MATRIX,
                          xe = s.length,
                          Re =
                            R.textRenderingMode ===
                            w.TextRenderingMode.INVISIBLE;
                        let ue, de, I, q;
                        if (!(Re || j === 0)) {
                          for (
                            this._cachedScaleForStroking[0] = -1,
                              this._cachedGetSinglePixelWidth = null,
                              g.save(),
                              g.transform(...R.textMatrix),
                              g.translate(R.x, R.y),
                              g.scale(Ee, U),
                              ue = 0;
                            ue < xe;
                            ++ue
                          ) {
                            if (((de = s[ue]), typeof de == "number")) {
                              ((q = (Q * de * j) / 1e3),
                                this.ctx.translate(q, 0),
                                (R.x += q * Ee));
                              continue;
                            }
                            const ie = (de.isSpace ? we : 0) + fe,
                              re = $.charProcOperatorList[de.operatorListId];
                            if (!re) {
                              (0, w.warn)(
                                `Type3 character "${de.operatorListId}" is not available.`,
                              );
                              continue;
                            }
                            (this.contentVisible &&
                              ((this.processingType3 = de),
                              this.save(),
                              g.scale(j, j),
                              g.transform(...Ce),
                              this.executeOperatorList(re),
                              this.restore()),
                              (I =
                                w.Util.applyTransform([de.width, 0], Ce)[0] *
                                  j +
                                ie),
                              g.translate(I, 0),
                              (R.x += I * Ee));
                          }
                          (g.restore(), (this.processingType3 = null));
                        }
                      }
                      setCharWidth(s, g) {}
                      setCharWidthAndBounds(s, g, R, $, j, U) {
                        (this.ctx.rect(R, $, j - R, U - $),
                          this.ctx.clip(),
                          this.endPath());
                      }
                      getColorN_Pattern(s) {
                        let g;
                        if (s[0] === "TilingPattern") {
                          const R = s[1],
                            $ =
                              this.baseTransform ||
                              (0, S.getCurrentTransform)(this.ctx),
                            j = {
                              createCanvasGraphics: (U) =>
                                new Y(
                                  U,
                                  this.commonObjs,
                                  this.objs,
                                  this.canvasFactory,
                                  this.filterFactory,
                                  {
                                    optionalContentConfig:
                                      this.optionalContentConfig,
                                    markedContentStack: this.markedContentStack,
                                  },
                                ),
                            };
                          g = new i.TilingPattern(s, R, this.ctx, j, $);
                        } else g = this._getPattern(s[1], s[2]);
                        return g;
                      }
                      setStrokeColorN() {
                        this.current.strokeColor =
                          this.getColorN_Pattern(arguments);
                      }
                      setFillColorN() {
                        ((this.current.fillColor =
                          this.getColorN_Pattern(arguments)),
                          (this.current.patternFill = !0));
                      }
                      setStrokeRGBColor(s, g, R) {
                        const $ = w.Util.makeHexColor(s, g, R);
                        ((this.ctx.strokeStyle = $),
                          (this.current.strokeColor = $));
                      }
                      setFillRGBColor(s, g, R) {
                        const $ = w.Util.makeHexColor(s, g, R);
                        ((this.ctx.fillStyle = $),
                          (this.current.fillColor = $),
                          (this.current.patternFill = !1));
                      }
                      _getPattern(s, g = null) {
                        let R;
                        return (
                          this.cachedPatterns.has(s)
                            ? (R = this.cachedPatterns.get(s))
                            : ((R = (0, i.getShadingPattern)(
                                this.getObject(s),
                              )),
                              this.cachedPatterns.set(s, R)),
                          g && (R.matrix = g),
                          R
                        );
                      }
                      shadingFill(s) {
                        if (!this.contentVisible) return;
                        const g = this.ctx;
                        this.save();
                        const R = this._getPattern(s);
                        g.fillStyle = R.getPattern(
                          g,
                          this,
                          (0, S.getCurrentTransformInverse)(g),
                          i.PathType.SHADING,
                        );
                        const $ = (0, S.getCurrentTransformInverse)(g);
                        if ($) {
                          const { width: j, height: U } = g.canvas,
                            [Q, fe, we, Ee] = w.Util.getAxialAlignedBoundingBox(
                              [0, 0, j, U],
                              $,
                            );
                          this.ctx.fillRect(Q, fe, we - Q, Ee - fe);
                        } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                        (this.compose(this.current.getClippedPathBoundingBox()),
                          this.restore());
                      }
                      beginInlineImage() {
                        (0, w.unreachable)("Should not call beginInlineImage");
                      }
                      beginImageData() {
                        (0, w.unreachable)("Should not call beginImageData");
                      }
                      paintFormXObjectBegin(s, g) {
                        if (
                          this.contentVisible &&
                          (this.save(),
                          this.baseTransformStack.push(this.baseTransform),
                          Array.isArray(s) &&
                            s.length === 6 &&
                            this.transform(...s),
                          (this.baseTransform = (0, S.getCurrentTransform)(
                            this.ctx,
                          )),
                          g)
                        ) {
                          const R = g[2] - g[0],
                            $ = g[3] - g[1];
                          (this.ctx.rect(g[0], g[1], R, $),
                            this.current.updateRectMinMax(
                              (0, S.getCurrentTransform)(this.ctx),
                              g,
                            ),
                            this.clip(),
                            this.endPath());
                        }
                      }
                      paintFormXObjectEnd() {
                        this.contentVisible &&
                          (this.restore(),
                          (this.baseTransform = this.baseTransformStack.pop()));
                      }
                      beginGroup(s) {
                        if (!this.contentVisible) return;
                        (this.save(),
                          this.inSMaskMode &&
                            (this.endSMaskMode(),
                            (this.current.activeSMask = null)));
                        const g = this.ctx;
                        (s.isolated ||
                          (0, w.info)("TODO: Support non-isolated groups."),
                          s.knockout &&
                            (0, w.warn)("Knockout groups not supported."));
                        const R = (0, S.getCurrentTransform)(g);
                        if ((s.matrix && g.transform(...s.matrix), !s.bbox))
                          throw new Error("Bounding box is required.");
                        let $ = w.Util.getAxialAlignedBoundingBox(
                          s.bbox,
                          (0, S.getCurrentTransform)(g),
                        );
                        const j = [0, 0, g.canvas.width, g.canvas.height];
                        $ = w.Util.intersect($, j) || [0, 0, 0, 0];
                        const U = Math.floor($[0]),
                          Q = Math.floor($[1]);
                        let fe = Math.max(Math.ceil($[2]) - U, 1),
                          we = Math.max(Math.ceil($[3]) - Q, 1),
                          Ee = 1,
                          Ce = 1;
                        (fe > W && ((Ee = fe / W), (fe = W)),
                          we > W && ((Ce = we / W), (we = W)),
                          this.current.startNewPathAndClipBox([0, 0, fe, we]));
                        let xe = "groupAt" + this.groupLevel;
                        s.smask &&
                          (xe += "_smask_" + (this.smaskCounter++ % 2));
                        const Re = this.cachedCanvases.getCanvas(xe, fe, we),
                          ue = Re.context;
                        (ue.scale(1 / Ee, 1 / Ce),
                          ue.translate(-U, -Q),
                          ue.transform(...R),
                          s.smask
                            ? this.smaskStack.push({
                                canvas: Re.canvas,
                                context: ue,
                                offsetX: U,
                                offsetY: Q,
                                scaleX: Ee,
                                scaleY: Ce,
                                subtype: s.smask.subtype,
                                backdrop: s.smask.backdrop,
                                transferMap: s.smask.transferMap || null,
                                startTransformInverse: null,
                              })
                            : (g.setTransform(1, 0, 0, 1, 0, 0),
                              g.translate(U, Q),
                              g.scale(Ee, Ce),
                              g.save()),
                          f(g, ue),
                          (this.ctx = ue),
                          this.setGState([
                            ["BM", "source-over"],
                            ["ca", 1],
                            ["CA", 1],
                          ]),
                          this.groupStack.push(g),
                          this.groupLevel++);
                      }
                      endGroup(s) {
                        if (!this.contentVisible) return;
                        this.groupLevel--;
                        const g = this.ctx,
                          R = this.groupStack.pop();
                        if (
                          ((this.ctx = R),
                          (this.ctx.imageSmoothingEnabled = !1),
                          s.smask)
                        )
                          ((this.tempSMask = this.smaskStack.pop()),
                            this.restore());
                        else {
                          this.ctx.restore();
                          const $ = (0, S.getCurrentTransform)(this.ctx);
                          (this.restore(),
                            this.ctx.save(),
                            this.ctx.setTransform(...$));
                          const j = w.Util.getAxialAlignedBoundingBox(
                            [0, 0, g.canvas.width, g.canvas.height],
                            $,
                          );
                          (this.ctx.drawImage(g.canvas, 0, 0),
                            this.ctx.restore(),
                            this.compose(j));
                        }
                      }
                      beginAnnotation(s, g, R, $, j) {
                        if (
                          (le(this, z, Wr).call(this),
                          b(this.ctx),
                          this.ctx.save(),
                          this.save(),
                          this.baseTransform &&
                            this.ctx.setTransform(...this.baseTransform),
                          Array.isArray(g) && g.length === 4)
                        ) {
                          const U = g[2] - g[0],
                            Q = g[3] - g[1];
                          if (j && this.annotationCanvasMap) {
                            ((R = R.slice()),
                              (R[4] -= g[0]),
                              (R[5] -= g[1]),
                              (g = g.slice()),
                              (g[0] = g[1] = 0),
                              (g[2] = U),
                              (g[3] = Q));
                            const [fe, we] =
                                w.Util.singularValueDecompose2dScale(
                                  (0, S.getCurrentTransform)(this.ctx),
                                ),
                              { viewportScale: Ee } = this,
                              Ce = Math.ceil(U * this.outputScaleX * Ee),
                              xe = Math.ceil(Q * this.outputScaleY * Ee);
                            this.annotationCanvas = this.canvasFactory.create(
                              Ce,
                              xe,
                            );
                            const { canvas: Re, context: ue } =
                              this.annotationCanvas;
                            (this.annotationCanvasMap.set(s, Re),
                              (this.annotationCanvas.savedCtx = this.ctx),
                              (this.ctx = ue),
                              this.ctx.save(),
                              this.ctx.setTransform(fe, 0, 0, -we, 0, Q * we),
                              b(this.ctx));
                          } else
                            (b(this.ctx),
                              this.ctx.rect(g[0], g[1], U, Q),
                              this.ctx.clip(),
                              this.endPath());
                        }
                        ((this.current = new u(
                          this.ctx.canvas.width,
                          this.ctx.canvas.height,
                        )),
                          this.transform(...R),
                          this.transform(...$));
                      }
                      endAnnotation() {
                        this.annotationCanvas &&
                          (this.ctx.restore(),
                          le(this, z, Ur).call(this),
                          (this.ctx = this.annotationCanvas.savedCtx),
                          delete this.annotationCanvas.savedCtx,
                          delete this.annotationCanvas);
                      }
                      paintImageMaskXObject(s) {
                        if (!this.contentVisible) return;
                        const g = s.count;
                        ((s = this.getObject(s.data, s)), (s.count = g));
                        const R = this.ctx,
                          $ = this.processingType3;
                        if (
                          $ &&
                          ($.compiled === void 0 && ($.compiled = p(s)),
                          $.compiled)
                        ) {
                          $.compiled(R);
                          return;
                        }
                        const j = this._createMaskCanvas(s),
                          U = j.canvas;
                        (R.save(),
                          R.setTransform(1, 0, 0, 1, 0, 0),
                          R.drawImage(U, j.offsetX, j.offsetY),
                          R.restore(),
                          this.compose());
                      }
                      paintImageMaskXObjectRepeat(s, g, R = 0, $ = 0, j, U) {
                        if (!this.contentVisible) return;
                        s = this.getObject(s.data, s);
                        const Q = this.ctx;
                        Q.save();
                        const fe = (0, S.getCurrentTransform)(Q);
                        Q.transform(g, R, $, j, 0, 0);
                        const we = this._createMaskCanvas(s);
                        Q.setTransform(
                          1,
                          0,
                          0,
                          1,
                          we.offsetX - fe[4],
                          we.offsetY - fe[5],
                        );
                        for (let Ee = 0, Ce = U.length; Ee < Ce; Ee += 2) {
                          const xe = w.Util.transform(fe, [
                              g,
                              R,
                              $,
                              j,
                              U[Ee],
                              U[Ee + 1],
                            ]),
                            [Re, ue] = w.Util.applyTransform([0, 0], xe);
                          Q.drawImage(we.canvas, Re, ue);
                        }
                        (Q.restore(), this.compose());
                      }
                      paintImageMaskXObjectGroup(s) {
                        if (!this.contentVisible) return;
                        const g = this.ctx,
                          R = this.current.fillColor,
                          $ = this.current.patternFill;
                        for (const j of s) {
                          const {
                              data: U,
                              width: Q,
                              height: fe,
                              transform: we,
                            } = j,
                            Ee = this.cachedCanvases.getCanvas(
                              "maskCanvas",
                              Q,
                              fe,
                            ),
                            Ce = Ee.context;
                          Ce.save();
                          const xe = this.getObject(U, j);
                          (v(Ce, xe),
                            (Ce.globalCompositeOperation = "source-in"),
                            (Ce.fillStyle = $
                              ? R.getPattern(
                                  Ce,
                                  this,
                                  (0, S.getCurrentTransformInverse)(g),
                                  i.PathType.FILL,
                                )
                              : R),
                            Ce.fillRect(0, 0, Q, fe),
                            Ce.restore(),
                            g.save(),
                            g.transform(...we),
                            g.scale(1, -1),
                            d(g, Ee.canvas, 0, 0, Q, fe, 0, -1, 1, 1),
                            g.restore());
                        }
                        this.compose();
                      }
                      paintImageXObject(s) {
                        if (!this.contentVisible) return;
                        const g = this.getObject(s);
                        if (!g) {
                          (0, w.warn)("Dependent image isn't ready yet");
                          return;
                        }
                        this.paintInlineImageXObject(g);
                      }
                      paintImageXObjectRepeat(s, g, R, $) {
                        if (!this.contentVisible) return;
                        const j = this.getObject(s);
                        if (!j) {
                          (0, w.warn)("Dependent image isn't ready yet");
                          return;
                        }
                        const U = j.width,
                          Q = j.height,
                          fe = [];
                        for (let we = 0, Ee = $.length; we < Ee; we += 2)
                          fe.push({
                            transform: [g, 0, 0, R, $[we], $[we + 1]],
                            x: 0,
                            y: 0,
                            w: U,
                            h: Q,
                          });
                        this.paintInlineImageXObjectGroup(j, fe);
                      }
                      applyTransferMapsToCanvas(s) {
                        return (
                          this.current.transferMaps !== "none" &&
                            ((s.filter = this.current.transferMaps),
                            s.drawImage(s.canvas, 0, 0),
                            (s.filter = "none")),
                          s.canvas
                        );
                      }
                      applyTransferMapsToBitmap(s) {
                        if (this.current.transferMaps === "none")
                          return s.bitmap;
                        const { bitmap: g, width: R, height: $ } = s,
                          j = this.cachedCanvases.getCanvas(
                            "inlineImage",
                            R,
                            $,
                          ),
                          U = j.context;
                        return (
                          (U.filter = this.current.transferMaps),
                          U.drawImage(g, 0, 0),
                          (U.filter = "none"),
                          j.canvas
                        );
                      }
                      paintInlineImageXObject(s) {
                        if (!this.contentVisible) return;
                        const g = s.width,
                          R = s.height,
                          $ = this.ctx;
                        if ((this.save(), !w.isNodeJS)) {
                          const { filter: Q } = $;
                          Q !== "none" && Q !== "" && ($.filter = "none");
                        }
                        $.scale(1 / g, -1 / R);
                        let j;
                        if (s.bitmap) j = this.applyTransferMapsToBitmap(s);
                        else if (
                          (typeof HTMLElement == "function" &&
                            s instanceof HTMLElement) ||
                          !s.data
                        )
                          j = s;
                        else {
                          const fe = this.cachedCanvases.getCanvas(
                            "inlineImage",
                            g,
                            R,
                          ).context;
                          (F(fe, s), (j = this.applyTransferMapsToCanvas(fe)));
                        }
                        const U = this._scaleImage(
                          j,
                          (0, S.getCurrentTransformInverse)($),
                        );
                        (($.imageSmoothingEnabled = o(
                          (0, S.getCurrentTransform)($),
                          s.interpolate,
                        )),
                          d(
                            $,
                            U.img,
                            0,
                            0,
                            U.paintWidth,
                            U.paintHeight,
                            0,
                            -R,
                            g,
                            R,
                          ),
                          this.compose(),
                          this.restore());
                      }
                      paintInlineImageXObjectGroup(s, g) {
                        if (!this.contentVisible) return;
                        const R = this.ctx;
                        let $;
                        if (s.bitmap) $ = s.bitmap;
                        else {
                          const j = s.width,
                            U = s.height,
                            fe = this.cachedCanvases.getCanvas(
                              "inlineImage",
                              j,
                              U,
                            ).context;
                          (F(fe, s), ($ = this.applyTransferMapsToCanvas(fe)));
                        }
                        for (const j of g)
                          (R.save(),
                            R.transform(...j.transform),
                            R.scale(1, -1),
                            d(R, $, j.x, j.y, j.w, j.h, 0, -1, 1, 1),
                            R.restore());
                        this.compose();
                      }
                      paintSolidColorImageMask() {
                        this.contentVisible &&
                          (this.ctx.fillRect(0, 0, 1, 1), this.compose());
                      }
                      markPoint(s) {}
                      markPointProps(s, g) {}
                      beginMarkedContent(s) {
                        this.markedContentStack.push({ visible: !0 });
                      }
                      beginMarkedContentProps(s, g) {
                        (s === "OC"
                          ? this.markedContentStack.push({
                              visible: this.optionalContentConfig.isVisible(g),
                            })
                          : this.markedContentStack.push({ visible: !0 }),
                          (this.contentVisible = this.isContentVisible()));
                      }
                      endMarkedContent() {
                        (this.markedContentStack.pop(),
                          (this.contentVisible = this.isContentVisible()));
                      }
                      beginCompat() {}
                      endCompat() {}
                      consumePath(s) {
                        const g = this.current.isEmptyClip();
                        (this.pendingClip && this.current.updateClipFromPath(),
                          this.pendingClip || this.compose(s));
                        const R = this.ctx;
                        (this.pendingClip &&
                          (g ||
                            (this.pendingClip === D
                              ? R.clip("evenodd")
                              : R.clip()),
                          (this.pendingClip = null)),
                          this.current.startNewPathAndClipBox(
                            this.current.clipBox,
                          ),
                          R.beginPath());
                      }
                      getSinglePixelWidth() {
                        if (!this._cachedGetSinglePixelWidth) {
                          const s = (0, S.getCurrentTransform)(this.ctx);
                          if (s[1] === 0 && s[2] === 0)
                            this._cachedGetSinglePixelWidth =
                              1 / Math.min(Math.abs(s[0]), Math.abs(s[3]));
                          else {
                            const g = Math.abs(s[0] * s[3] - s[2] * s[1]),
                              R = Math.hypot(s[0], s[2]),
                              $ = Math.hypot(s[1], s[3]);
                            this._cachedGetSinglePixelWidth =
                              Math.max(R, $) / g;
                          }
                        }
                        return this._cachedGetSinglePixelWidth;
                      }
                      getScaleForStroking() {
                        if (this._cachedScaleForStroking[0] === -1) {
                          const { lineWidth: s } = this.current,
                            {
                              a: g,
                              b: R,
                              c: $,
                              d: j,
                            } = this.ctx.getTransform();
                          let U, Q;
                          if (R === 0 && $ === 0) {
                            const fe = Math.abs(g),
                              we = Math.abs(j);
                            if (fe === we)
                              if (s === 0) U = Q = 1 / fe;
                              else {
                                const Ee = fe * s;
                                U = Q = Ee < 1 ? 1 / Ee : 1;
                              }
                            else if (s === 0) ((U = 1 / fe), (Q = 1 / we));
                            else {
                              const Ee = fe * s,
                                Ce = we * s;
                              ((U = Ee < 1 ? 1 / Ee : 1),
                                (Q = Ce < 1 ? 1 / Ce : 1));
                            }
                          } else {
                            const fe = Math.abs(g * j - R * $),
                              we = Math.hypot(g, R),
                              Ee = Math.hypot($, j);
                            if (s === 0) ((U = Ee / fe), (Q = we / fe));
                            else {
                              const Ce = s * fe;
                              ((U = Ee > Ce ? Ee / Ce : 1),
                                (Q = we > Ce ? we / Ce : 1));
                            }
                          }
                          ((this._cachedScaleForStroking[0] = U),
                            (this._cachedScaleForStroking[1] = Q));
                        }
                        return this._cachedScaleForStroking;
                      }
                      rescaleAndStroke(s) {
                        const { ctx: g } = this,
                          { lineWidth: R } = this.current,
                          [$, j] = this.getScaleForStroking();
                        if (((g.lineWidth = R || 1), $ === 1 && j === 1)) {
                          g.stroke();
                          return;
                        }
                        const U = g.getLineDash();
                        if ((s && g.save(), g.scale($, j), U.length > 0)) {
                          const Q = Math.max($, j);
                          (g.setLineDash(U.map((fe) => fe / Q)),
                            (g.lineDashOffset /= Q));
                        }
                        (g.stroke(), s && g.restore());
                      }
                      isContentVisible() {
                        for (
                          let s = this.markedContentStack.length - 1;
                          s >= 0;
                          s--
                        )
                          if (!this.markedContentStack[s].visible) return !1;
                        return !0;
                      }
                    };
                  ((z = new WeakSet()),
                    (Wr = function () {
                      for (; this.stateStack.length || this.inSMaskMode; )
                        this.restore();
                      (this.ctx.restore(),
                        this.transparentCanvas &&
                          ((this.ctx = this.compositeCtx),
                          this.ctx.save(),
                          this.ctx.setTransform(1, 0, 0, 1, 0, 0),
                          this.ctx.drawImage(this.transparentCanvas, 0, 0),
                          this.ctx.restore(),
                          (this.transparentCanvas = null)));
                    }),
                    (Ur = function () {
                      if (this.pageColors) {
                        const s = this.filterFactory.addHCMFilter(
                          this.pageColors.foreground,
                          this.pageColors.background,
                        );
                        if (s !== "none") {
                          const g = this.ctx.filter;
                          ((this.ctx.filter = s),
                            this.ctx.drawImage(this.ctx.canvas, 0, 0),
                            (this.ctx.filter = g));
                        }
                      }
                    }));
                  let x = Y;
                  A.CanvasGraphics = x;
                  for (const T in w.OPS)
                    x.prototype[T] !== void 0 &&
                      (x.prototype[w.OPS[T]] = x.prototype[T]);
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.TilingPattern = A.PathType = void 0),
                    (A.getShadingPattern = _));
                  var w = n(1),
                    S = n(6);
                  const i = {
                    FILL: "Fill",
                    STROKE: "Stroke",
                    SHADING: "Shading",
                  };
                  A.PathType = i;
                  function H(p, u) {
                    if (!u) return;
                    const F = u[2] - u[0],
                      v = u[3] - u[1],
                      f = new Path2D();
                    (f.rect(u[0], u[1], F, v), p.clip(f));
                  }
                  class ee {
                    constructor() {
                      this.constructor === ee &&
                        (0, w.unreachable)(
                          "Cannot initialize BaseShadingPattern.",
                        );
                    }
                    getPattern() {
                      (0, w.unreachable)(
                        "Abstract method `getPattern` called.",
                      );
                    }
                  }
                  class X extends ee {
                    constructor(u) {
                      (super(),
                        (this._type = u[1]),
                        (this._bbox = u[2]),
                        (this._colorStops = u[3]),
                        (this._p0 = u[4]),
                        (this._p1 = u[5]),
                        (this._r0 = u[6]),
                        (this._r1 = u[7]),
                        (this.matrix = null));
                    }
                    _createGradient(u) {
                      let F;
                      this._type === "axial"
                        ? (F = u.createLinearGradient(
                            this._p0[0],
                            this._p0[1],
                            this._p1[0],
                            this._p1[1],
                          ))
                        : this._type === "radial" &&
                          (F = u.createRadialGradient(
                            this._p0[0],
                            this._p0[1],
                            this._r0,
                            this._p1[0],
                            this._p1[1],
                            this._r1,
                          ));
                      for (const v of this._colorStops)
                        F.addColorStop(v[0], v[1]);
                      return F;
                    }
                    getPattern(u, F, v, f) {
                      let b;
                      if (f === i.STROKE || f === i.FILL) {
                        const c = F.current.getClippedPathBoundingBox(
                            f,
                            (0, S.getCurrentTransform)(u),
                          ) || [0, 0, 0, 0],
                          a = Math.ceil(c[2] - c[0]) || 1,
                          m = Math.ceil(c[3] - c[1]) || 1,
                          C = F.cachedCanvases.getCanvas("pattern", a, m, !0),
                          e = C.context;
                        (e.clearRect(0, 0, e.canvas.width, e.canvas.height),
                          e.beginPath(),
                          e.rect(0, 0, e.canvas.width, e.canvas.height),
                          e.translate(-c[0], -c[1]),
                          (v = w.Util.transform(v, [1, 0, 0, 1, c[0], c[1]])),
                          e.transform(...F.baseTransform),
                          this.matrix && e.transform(...this.matrix),
                          H(e, this._bbox),
                          (e.fillStyle = this._createGradient(e)),
                          e.fill(),
                          (b = u.createPattern(C.canvas, "no-repeat")));
                        const o = new DOMMatrix(v);
                        b.setTransform(o);
                      } else (H(u, this._bbox), (b = this._createGradient(u)));
                      return b;
                    }
                  }
                  function W(p, u, F, v, f, b, c, a) {
                    const m = u.coords,
                      C = u.colors,
                      e = p.data,
                      o = p.width * 4;
                    let y;
                    (m[F + 1] > m[v + 1] &&
                      ((y = F), (F = v), (v = y), (y = b), (b = c), (c = y)),
                      m[v + 1] > m[f + 1] &&
                        ((y = v), (v = f), (f = y), (y = c), (c = a), (a = y)),
                      m[F + 1] > m[v + 1] &&
                        ((y = F), (F = v), (v = y), (y = b), (b = c), (c = y)));
                    const B = (m[F] + u.offsetX) * u.scaleX,
                      M = (m[F + 1] + u.offsetY) * u.scaleY,
                      D = (m[v] + u.offsetX) * u.scaleX,
                      x = (m[v + 1] + u.offsetY) * u.scaleY,
                      z = (m[f] + u.offsetX) * u.scaleX,
                      L = (m[f + 1] + u.offsetY) * u.scaleY;
                    if (M >= L) return;
                    const V = C[b],
                      Y = C[b + 1],
                      T = C[b + 2],
                      s = C[c],
                      g = C[c + 1],
                      R = C[c + 2],
                      $ = C[a],
                      j = C[a + 1],
                      U = C[a + 2],
                      Q = Math.round(M),
                      fe = Math.round(L);
                    let we, Ee, Ce, xe, Re, ue, de, I;
                    for (let q = Q; q <= fe; q++) {
                      if (q < x) {
                        const Me = q < M ? 0 : (M - q) / (M - x);
                        ((we = B - (B - D) * Me),
                          (Ee = V - (V - s) * Me),
                          (Ce = Y - (Y - g) * Me),
                          (xe = T - (T - R) * Me));
                      } else {
                        let Me;
                        (q > L
                          ? (Me = 1)
                          : x === L
                            ? (Me = 0)
                            : (Me = (x - q) / (x - L)),
                          (we = D - (D - z) * Me),
                          (Ee = s - (s - $) * Me),
                          (Ce = g - (g - j) * Me),
                          (xe = R - (R - U) * Me));
                      }
                      let ie;
                      (q < M
                        ? (ie = 0)
                        : q > L
                          ? (ie = 1)
                          : (ie = (M - q) / (M - L)),
                        (Re = B - (B - z) * ie),
                        (ue = V - (V - $) * ie),
                        (de = Y - (Y - j) * ie),
                        (I = T - (T - U) * ie));
                      const re = Math.round(Math.min(we, Re)),
                        he = Math.round(Math.max(we, Re));
                      let Pe = o * q + re * 4;
                      for (let Me = re; Me <= he; Me++)
                        ((ie = (we - Me) / (we - Re)),
                          ie < 0 ? (ie = 0) : ie > 1 && (ie = 1),
                          (e[Pe++] = (Ee - (Ee - ue) * ie) | 0),
                          (e[Pe++] = (Ce - (Ce - de) * ie) | 0),
                          (e[Pe++] = (xe - (xe - I) * ie) | 0),
                          (e[Pe++] = 255));
                    }
                  }
                  function k(p, u, F) {
                    const v = u.coords,
                      f = u.colors;
                    let b, c;
                    switch (u.type) {
                      case "lattice":
                        const a = u.verticesPerRow,
                          m = Math.floor(v.length / a) - 1,
                          C = a - 1;
                        for (b = 0; b < m; b++) {
                          let e = b * a;
                          for (let o = 0; o < C; o++, e++)
                            (W(
                              p,
                              F,
                              v[e],
                              v[e + 1],
                              v[e + a],
                              f[e],
                              f[e + 1],
                              f[e + a],
                            ),
                              W(
                                p,
                                F,
                                v[e + a + 1],
                                v[e + 1],
                                v[e + a],
                                f[e + a + 1],
                                f[e + 1],
                                f[e + a],
                              ));
                        }
                        break;
                      case "triangles":
                        for (b = 0, c = v.length; b < c; b += 3)
                          W(
                            p,
                            F,
                            v[b],
                            v[b + 1],
                            v[b + 2],
                            f[b],
                            f[b + 1],
                            f[b + 2],
                          );
                        break;
                      default:
                        throw new Error("illegal figure");
                    }
                  }
                  class N extends ee {
                    constructor(u) {
                      (super(),
                        (this._coords = u[2]),
                        (this._colors = u[3]),
                        (this._figures = u[4]),
                        (this._bounds = u[5]),
                        (this._bbox = u[7]),
                        (this._background = u[8]),
                        (this.matrix = null));
                    }
                    _createMeshCanvas(u, F, v) {
                      const a = Math.floor(this._bounds[0]),
                        m = Math.floor(this._bounds[1]),
                        C = Math.ceil(this._bounds[2]) - a,
                        e = Math.ceil(this._bounds[3]) - m,
                        o = Math.min(Math.ceil(Math.abs(C * u[0] * 1.1)), 3e3),
                        y = Math.min(Math.ceil(Math.abs(e * u[1] * 1.1)), 3e3),
                        B = C / o,
                        M = e / y,
                        D = {
                          coords: this._coords,
                          colors: this._colors,
                          offsetX: -a,
                          offsetY: -m,
                          scaleX: 1 / B,
                          scaleY: 1 / M,
                        },
                        x = o + 4,
                        z = y + 4,
                        L = v.getCanvas("mesh", x, z, !1),
                        V = L.context,
                        Y = V.createImageData(o, y);
                      if (F) {
                        const s = Y.data;
                        for (let g = 0, R = s.length; g < R; g += 4)
                          ((s[g] = F[0]),
                            (s[g + 1] = F[1]),
                            (s[g + 2] = F[2]),
                            (s[g + 3] = 255));
                      }
                      for (const s of this._figures) k(Y, s, D);
                      return (
                        V.putImageData(Y, 2, 2),
                        {
                          canvas: L.canvas,
                          offsetX: a - 2 * B,
                          offsetY: m - 2 * M,
                          scaleX: B,
                          scaleY: M,
                        }
                      );
                    }
                    getPattern(u, F, v, f) {
                      H(u, this._bbox);
                      let b;
                      if (f === i.SHADING)
                        b = w.Util.singularValueDecompose2dScale(
                          (0, S.getCurrentTransform)(u),
                        );
                      else if (
                        ((b = w.Util.singularValueDecompose2dScale(
                          F.baseTransform,
                        )),
                        this.matrix)
                      ) {
                        const a = w.Util.singularValueDecompose2dScale(
                          this.matrix,
                        );
                        b = [b[0] * a[0], b[1] * a[1]];
                      }
                      const c = this._createMeshCanvas(
                        b,
                        f === i.SHADING ? null : this._background,
                        F.cachedCanvases,
                      );
                      return (
                        f !== i.SHADING &&
                          (u.setTransform(...F.baseTransform),
                          this.matrix && u.transform(...this.matrix)),
                        u.translate(c.offsetX, c.offsetY),
                        u.scale(c.scaleX, c.scaleY),
                        u.createPattern(c.canvas, "no-repeat")
                      );
                    }
                  }
                  class P extends ee {
                    getPattern() {
                      return "hotpink";
                    }
                  }
                  function _(p) {
                    switch (p[0]) {
                      case "RadialAxial":
                        return new X(p);
                      case "Mesh":
                        return new N(p);
                      case "Dummy":
                        return new P();
                    }
                    throw new Error(`Unknown IR type: ${p[0]}`);
                  }
                  const h = { COLORED: 1, UNCOLORED: 2 },
                    d = class d {
                      constructor(u, F, v, f, b) {
                        ((this.operatorList = u[2]),
                          (this.matrix = u[3] || [1, 0, 0, 1, 0, 0]),
                          (this.bbox = u[4]),
                          (this.xstep = u[5]),
                          (this.ystep = u[6]),
                          (this.paintType = u[7]),
                          (this.tilingType = u[8]),
                          (this.color = F),
                          (this.ctx = v),
                          (this.canvasGraphicsFactory = f),
                          (this.baseTransform = b));
                      }
                      createPatternCanvas(u) {
                        const F = this.operatorList,
                          v = this.bbox,
                          f = this.xstep,
                          b = this.ystep,
                          c = this.paintType,
                          a = this.tilingType,
                          m = this.color,
                          C = this.canvasGraphicsFactory;
                        (0, w.info)("TilingType: " + a);
                        const e = v[0],
                          o = v[1],
                          y = v[2],
                          B = v[3],
                          M = w.Util.singularValueDecompose2dScale(this.matrix),
                          D = w.Util.singularValueDecompose2dScale(
                            this.baseTransform,
                          ),
                          x = [M[0] * D[0], M[1] * D[1]],
                          z = this.getSizeAndScale(
                            f,
                            this.ctx.canvas.width,
                            x[0],
                          ),
                          L = this.getSizeAndScale(
                            b,
                            this.ctx.canvas.height,
                            x[1],
                          ),
                          V = u.cachedCanvases.getCanvas(
                            "pattern",
                            z.size,
                            L.size,
                            !0,
                          ),
                          Y = V.context,
                          T = C.createCanvasGraphics(Y);
                        ((T.groupLevel = u.groupLevel),
                          this.setFillAndStrokeStyleToContext(T, c, m));
                        let s = e,
                          g = o,
                          R = y,
                          $ = B;
                        return (
                          e < 0 && ((s = 0), (R += Math.abs(e))),
                          o < 0 && ((g = 0), ($ += Math.abs(o))),
                          Y.translate(-(z.scale * s), -(L.scale * g)),
                          T.transform(z.scale, 0, 0, L.scale, 0, 0),
                          Y.save(),
                          this.clipBbox(T, s, g, R, $),
                          (T.baseTransform = (0, S.getCurrentTransform)(T.ctx)),
                          T.executeOperatorList(F),
                          T.endDrawing(),
                          {
                            canvas: V.canvas,
                            scaleX: z.scale,
                            scaleY: L.scale,
                            offsetX: s,
                            offsetY: g,
                          }
                        );
                      }
                      getSizeAndScale(u, F, v) {
                        u = Math.abs(u);
                        const f = Math.max(d.MAX_PATTERN_SIZE, F);
                        let b = Math.ceil(u * v);
                        return (
                          b >= f ? (b = f) : (v = b / u),
                          { scale: v, size: b }
                        );
                      }
                      clipBbox(u, F, v, f, b) {
                        const c = f - F,
                          a = b - v;
                        (u.ctx.rect(F, v, c, a),
                          u.current.updateRectMinMax(
                            (0, S.getCurrentTransform)(u.ctx),
                            [F, v, f, b],
                          ),
                          u.clip(),
                          u.endPath());
                      }
                      setFillAndStrokeStyleToContext(u, F, v) {
                        const f = u.ctx,
                          b = u.current;
                        switch (F) {
                          case h.COLORED:
                            const c = this.ctx;
                            ((f.fillStyle = c.fillStyle),
                              (f.strokeStyle = c.strokeStyle),
                              (b.fillColor = c.fillStyle),
                              (b.strokeColor = c.strokeStyle));
                            break;
                          case h.UNCOLORED:
                            const a = w.Util.makeHexColor(v[0], v[1], v[2]);
                            ((f.fillStyle = a),
                              (f.strokeStyle = a),
                              (b.fillColor = a),
                              (b.strokeColor = a));
                            break;
                          default:
                            throw new w.FormatError(
                              `Unsupported paint type: ${F}`,
                            );
                        }
                      }
                      getPattern(u, F, v, f) {
                        let b = v;
                        f !== i.SHADING &&
                          ((b = w.Util.transform(b, F.baseTransform)),
                          this.matrix &&
                            (b = w.Util.transform(b, this.matrix)));
                        const c = this.createPatternCanvas(F);
                        let a = new DOMMatrix(b);
                        ((a = a.translate(c.offsetX, c.offsetY)),
                          (a = a.scale(1 / c.scaleX, 1 / c.scaleY)));
                        const m = u.createPattern(c.canvas, "repeat");
                        return (m.setTransform(a), m);
                      }
                    };
                  $t(d, "MAX_PATTERN_SIZE", 3e3);
                  let r = d;
                  A.TilingPattern = r;
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.convertBlackAndWhiteToRGBA = i),
                    (A.convertToRGBA = S),
                    (A.grayToRGBA = ee));
                  var w = n(1);
                  function S(X) {
                    switch (X.kind) {
                      case w.ImageKind.GRAYSCALE_1BPP:
                        return i(X);
                      case w.ImageKind.RGB_24BPP:
                        return H(X);
                    }
                    return null;
                  }
                  function i({
                    src: X,
                    srcPos: W = 0,
                    dest: k,
                    width: N,
                    height: P,
                    nonBlackColor: _ = 4294967295,
                    inverseDecode: h = !1,
                  }) {
                    const r = w.FeatureTest.isLittleEndian ? 4278190080 : 255,
                      [d, p] = h ? [_, r] : [r, _],
                      u = N >> 3,
                      F = N & 7,
                      v = X.length;
                    k = new Uint32Array(k.buffer);
                    let f = 0;
                    for (let b = 0; b < P; b++) {
                      for (const a = W + u; W < a; W++) {
                        const m = W < v ? X[W] : 255;
                        ((k[f++] = m & 128 ? p : d),
                          (k[f++] = m & 64 ? p : d),
                          (k[f++] = m & 32 ? p : d),
                          (k[f++] = m & 16 ? p : d),
                          (k[f++] = m & 8 ? p : d),
                          (k[f++] = m & 4 ? p : d),
                          (k[f++] = m & 2 ? p : d),
                          (k[f++] = m & 1 ? p : d));
                      }
                      if (F === 0) continue;
                      const c = W < v ? X[W++] : 255;
                      for (let a = 0; a < F; a++)
                        k[f++] = c & (1 << (7 - a)) ? p : d;
                    }
                    return { srcPos: W, destPos: f };
                  }
                  function H({
                    src: X,
                    srcPos: W = 0,
                    dest: k,
                    destPos: N = 0,
                    width: P,
                    height: _,
                  }) {
                    let h = 0;
                    const r = X.length >> 2,
                      d = new Uint32Array(X.buffer, W, r);
                    if (w.FeatureTest.isLittleEndian) {
                      for (; h < r - 2; h += 3, N += 4) {
                        const p = d[h],
                          u = d[h + 1],
                          F = d[h + 2];
                        ((k[N] = p | 4278190080),
                          (k[N + 1] = (p >>> 24) | (u << 8) | 4278190080),
                          (k[N + 2] = (u >>> 16) | (F << 16) | 4278190080),
                          (k[N + 3] = (F >>> 8) | 4278190080));
                      }
                      for (let p = h * 4, u = X.length; p < u; p += 3)
                        k[N++] =
                          X[p] |
                          (X[p + 1] << 8) |
                          (X[p + 2] << 16) |
                          4278190080;
                    } else {
                      for (; h < r - 2; h += 3, N += 4) {
                        const p = d[h],
                          u = d[h + 1],
                          F = d[h + 2];
                        ((k[N] = p | 255),
                          (k[N + 1] = (p << 24) | (u >>> 8) | 255),
                          (k[N + 2] = (u << 16) | (F >>> 16) | 255),
                          (k[N + 3] = (F << 8) | 255));
                      }
                      for (let p = h * 4, u = X.length; p < u; p += 3)
                        k[N++] =
                          (X[p] << 24) |
                          (X[p + 1] << 16) |
                          (X[p + 2] << 8) |
                          255;
                    }
                    return { srcPos: W, destPos: N };
                  }
                  function ee(X, W) {
                    if (w.FeatureTest.isLittleEndian)
                      for (let k = 0, N = X.length; k < N; k++)
                        W[k] = (X[k] * 65793) | 4278190080;
                    else
                      for (let k = 0, N = X.length; k < N; k++)
                        W[k] = (X[k] * 16843008) | 255;
                  }
                },
                (t, A) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.GlobalWorkerOptions = void 0));
                  const n = Object.create(null);
                  ((A.GlobalWorkerOptions = n),
                    (n.workerPort = null),
                    (n.workerSrc = ""));
                },
                (t, A, n) => {
                  var X, Bi, ji, cr;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.MessageHandler = void 0));
                  var w = n(1);
                  const S = { DATA: 1, ERROR: 2 },
                    i = {
                      CANCEL: 1,
                      CANCEL_COMPLETE: 2,
                      CLOSE: 3,
                      ENQUEUE: 4,
                      ERROR: 5,
                      PULL: 6,
                      PULL_COMPLETE: 7,
                      START_COMPLETE: 8,
                    };
                  function H(P) {
                    switch (
                      (P instanceof Error ||
                        (typeof P == "object" && P !== null) ||
                        (0, w.unreachable)(
                          'wrapReason: Expected "reason" to be a (possibly cloned) Error.',
                        ),
                      P.name)
                    ) {
                      case "AbortException":
                        return new w.AbortException(P.message);
                      case "MissingPDFException":
                        return new w.MissingPDFException(P.message);
                      case "PasswordException":
                        return new w.PasswordException(P.message, P.code);
                      case "UnexpectedResponseException":
                        return new w.UnexpectedResponseException(
                          P.message,
                          P.status,
                        );
                      case "UnknownErrorException":
                        return new w.UnknownErrorException(
                          P.message,
                          P.details,
                        );
                      default:
                        return new w.UnknownErrorException(
                          P.message,
                          P.toString(),
                        );
                    }
                  }
                  class ee {
                    constructor(_, h, r) {
                      ye(this, X);
                      ((this.sourceName = _),
                        (this.targetName = h),
                        (this.comObj = r),
                        (this.callbackId = 1),
                        (this.streamId = 1),
                        (this.streamSinks = Object.create(null)),
                        (this.streamControllers = Object.create(null)),
                        (this.callbackCapabilities = Object.create(null)),
                        (this.actionHandler = Object.create(null)),
                        (this._onComObjOnMessage = (d) => {
                          const p = d.data;
                          if (p.targetName !== this.sourceName) return;
                          if (p.stream) {
                            le(this, X, ji).call(this, p);
                            return;
                          }
                          if (p.callback) {
                            const F = p.callbackId,
                              v = this.callbackCapabilities[F];
                            if (!v)
                              throw new Error(`Cannot resolve callback ${F}`);
                            if (
                              (delete this.callbackCapabilities[F],
                              p.callback === S.DATA)
                            )
                              v.resolve(p.data);
                            else if (p.callback === S.ERROR)
                              v.reject(H(p.reason));
                            else throw new Error("Unexpected callback case");
                            return;
                          }
                          const u = this.actionHandler[p.action];
                          if (!u)
                            throw new Error(
                              `Unknown action from worker: ${p.action}`,
                            );
                          if (p.callbackId) {
                            const F = this.sourceName,
                              v = p.sourceName;
                            new Promise(function (f) {
                              f(u(p.data));
                            }).then(
                              function (f) {
                                r.postMessage({
                                  sourceName: F,
                                  targetName: v,
                                  callback: S.DATA,
                                  callbackId: p.callbackId,
                                  data: f,
                                });
                              },
                              function (f) {
                                r.postMessage({
                                  sourceName: F,
                                  targetName: v,
                                  callback: S.ERROR,
                                  callbackId: p.callbackId,
                                  reason: H(f),
                                });
                              },
                            );
                            return;
                          }
                          if (p.streamId) {
                            le(this, X, Bi).call(this, p);
                            return;
                          }
                          u(p.data);
                        }),
                        r.addEventListener("message", this._onComObjOnMessage));
                    }
                    on(_, h) {
                      const r = this.actionHandler;
                      if (r[_])
                        throw new Error(
                          `There is already an actionName called "${_}"`,
                        );
                      r[_] = h;
                    }
                    send(_, h, r) {
                      this.comObj.postMessage(
                        {
                          sourceName: this.sourceName,
                          targetName: this.targetName,
                          action: _,
                          data: h,
                        },
                        r,
                      );
                    }
                    sendWithPromise(_, h, r) {
                      const d = this.callbackId++,
                        p = new w.PromiseCapability();
                      this.callbackCapabilities[d] = p;
                      try {
                        this.comObj.postMessage(
                          {
                            sourceName: this.sourceName,
                            targetName: this.targetName,
                            action: _,
                            callbackId: d,
                            data: h,
                          },
                          r,
                        );
                      } catch (u) {
                        p.reject(u);
                      }
                      return p.promise;
                    }
                    sendWithStream(_, h, r, d) {
                      const p = this.streamId++,
                        u = this.sourceName,
                        F = this.targetName,
                        v = this.comObj;
                      return new ReadableStream(
                        {
                          start: (f) => {
                            const b = new w.PromiseCapability();
                            return (
                              (this.streamControllers[p] = {
                                controller: f,
                                startCall: b,
                                pullCall: null,
                                cancelCall: null,
                                isClosed: !1,
                              }),
                              v.postMessage(
                                {
                                  sourceName: u,
                                  targetName: F,
                                  action: _,
                                  streamId: p,
                                  data: h,
                                  desiredSize: f.desiredSize,
                                },
                                d,
                              ),
                              b.promise
                            );
                          },
                          pull: (f) => {
                            const b = new w.PromiseCapability();
                            return (
                              (this.streamControllers[p].pullCall = b),
                              v.postMessage({
                                sourceName: u,
                                targetName: F,
                                stream: i.PULL,
                                streamId: p,
                                desiredSize: f.desiredSize,
                              }),
                              b.promise
                            );
                          },
                          cancel: (f) => {
                            (0, w.assert)(
                              f instanceof Error,
                              "cancel must have a valid reason",
                            );
                            const b = new w.PromiseCapability();
                            return (
                              (this.streamControllers[p].cancelCall = b),
                              (this.streamControllers[p].isClosed = !0),
                              v.postMessage({
                                sourceName: u,
                                targetName: F,
                                stream: i.CANCEL,
                                streamId: p,
                                reason: H(f),
                              }),
                              b.promise
                            );
                          },
                        },
                        r,
                      );
                    }
                    destroy() {
                      this.comObj.removeEventListener(
                        "message",
                        this._onComObjOnMessage,
                      );
                    }
                  }
                  ((X = new WeakSet()),
                    (Bi = function (_) {
                      const h = _.streamId,
                        r = this.sourceName,
                        d = _.sourceName,
                        p = this.comObj,
                        u = this,
                        F = this.actionHandler[_.action],
                        v = {
                          enqueue(f, b = 1, c) {
                            if (this.isCancelled) return;
                            const a = this.desiredSize;
                            ((this.desiredSize -= b),
                              a > 0 &&
                                this.desiredSize <= 0 &&
                                ((this.sinkCapability =
                                  new w.PromiseCapability()),
                                (this.ready = this.sinkCapability.promise)),
                              p.postMessage(
                                {
                                  sourceName: r,
                                  targetName: d,
                                  stream: i.ENQUEUE,
                                  streamId: h,
                                  chunk: f,
                                },
                                c,
                              ));
                          },
                          close() {
                            this.isCancelled ||
                              ((this.isCancelled = !0),
                              p.postMessage({
                                sourceName: r,
                                targetName: d,
                                stream: i.CLOSE,
                                streamId: h,
                              }),
                              delete u.streamSinks[h]);
                          },
                          error(f) {
                            ((0, w.assert)(
                              f instanceof Error,
                              "error must have a valid reason",
                            ),
                              !this.isCancelled &&
                                ((this.isCancelled = !0),
                                p.postMessage({
                                  sourceName: r,
                                  targetName: d,
                                  stream: i.ERROR,
                                  streamId: h,
                                  reason: H(f),
                                })));
                          },
                          sinkCapability: new w.PromiseCapability(),
                          onPull: null,
                          onCancel: null,
                          isCancelled: !1,
                          desiredSize: _.desiredSize,
                          ready: null,
                        };
                      (v.sinkCapability.resolve(),
                        (v.ready = v.sinkCapability.promise),
                        (this.streamSinks[h] = v),
                        new Promise(function (f) {
                          f(F(_.data, v));
                        }).then(
                          function () {
                            p.postMessage({
                              sourceName: r,
                              targetName: d,
                              stream: i.START_COMPLETE,
                              streamId: h,
                              success: !0,
                            });
                          },
                          function (f) {
                            p.postMessage({
                              sourceName: r,
                              targetName: d,
                              stream: i.START_COMPLETE,
                              streamId: h,
                              reason: H(f),
                            });
                          },
                        ));
                    }),
                    (ji = function (_) {
                      const h = _.streamId,
                        r = this.sourceName,
                        d = _.sourceName,
                        p = this.comObj,
                        u = this.streamControllers[h],
                        F = this.streamSinks[h];
                      switch (_.stream) {
                        case i.START_COMPLETE:
                          _.success
                            ? u.startCall.resolve()
                            : u.startCall.reject(H(_.reason));
                          break;
                        case i.PULL_COMPLETE:
                          _.success
                            ? u.pullCall.resolve()
                            : u.pullCall.reject(H(_.reason));
                          break;
                        case i.PULL:
                          if (!F) {
                            p.postMessage({
                              sourceName: r,
                              targetName: d,
                              stream: i.PULL_COMPLETE,
                              streamId: h,
                              success: !0,
                            });
                            break;
                          }
                          (F.desiredSize <= 0 &&
                            _.desiredSize > 0 &&
                            F.sinkCapability.resolve(),
                            (F.desiredSize = _.desiredSize),
                            new Promise(function (v) {
                              var f;
                              v((f = F.onPull) == null ? void 0 : f.call(F));
                            }).then(
                              function () {
                                p.postMessage({
                                  sourceName: r,
                                  targetName: d,
                                  stream: i.PULL_COMPLETE,
                                  streamId: h,
                                  success: !0,
                                });
                              },
                              function (v) {
                                p.postMessage({
                                  sourceName: r,
                                  targetName: d,
                                  stream: i.PULL_COMPLETE,
                                  streamId: h,
                                  reason: H(v),
                                });
                              },
                            ));
                          break;
                        case i.ENQUEUE:
                          if (
                            ((0, w.assert)(
                              u,
                              "enqueue should have stream controller",
                            ),
                            u.isClosed)
                          )
                            break;
                          u.controller.enqueue(_.chunk);
                          break;
                        case i.CLOSE:
                          if (
                            ((0, w.assert)(
                              u,
                              "close should have stream controller",
                            ),
                            u.isClosed)
                          )
                            break;
                          ((u.isClosed = !0),
                            u.controller.close(),
                            le(this, X, cr).call(this, u, h));
                          break;
                        case i.ERROR:
                          ((0, w.assert)(
                            u,
                            "error should have stream controller",
                          ),
                            u.controller.error(H(_.reason)),
                            le(this, X, cr).call(this, u, h));
                          break;
                        case i.CANCEL_COMPLETE:
                          (_.success
                            ? u.cancelCall.resolve()
                            : u.cancelCall.reject(H(_.reason)),
                            le(this, X, cr).call(this, u, h));
                          break;
                        case i.CANCEL:
                          if (!F) break;
                          (new Promise(function (v) {
                            var f;
                            v(
                              (f = F.onCancel) == null
                                ? void 0
                                : f.call(F, H(_.reason)),
                            );
                          }).then(
                            function () {
                              p.postMessage({
                                sourceName: r,
                                targetName: d,
                                stream: i.CANCEL_COMPLETE,
                                streamId: h,
                                success: !0,
                              });
                            },
                            function (v) {
                              p.postMessage({
                                sourceName: r,
                                targetName: d,
                                stream: i.CANCEL_COMPLETE,
                                streamId: h,
                                reason: H(v),
                              });
                            },
                          ),
                            F.sinkCapability.reject(H(_.reason)),
                            (F.isCancelled = !0),
                            delete this.streamSinks[h]);
                          break;
                        default:
                          throw new Error("Unexpected stream case");
                      }
                    }),
                    (cr = async function (_, h) {
                      var r, d, p;
                      (await Promise.allSettled([
                        (r = _.startCall) == null ? void 0 : r.promise,
                        (d = _.pullCall) == null ? void 0 : d.promise,
                        (p = _.cancelCall) == null ? void 0 : p.promise,
                      ]),
                        delete this.streamControllers[h]);
                    }),
                    (A.MessageHandler = ee));
                },
                (t, A, n) => {
                  var i, H;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.Metadata = void 0));
                  var w = n(1);
                  class S {
                    constructor({ parsedData: X, rawData: W }) {
                      ye(this, i);
                      ye(this, H);
                      (Se(this, i, X), Se(this, H, W));
                    }
                    getRaw() {
                      return l(this, H);
                    }
                    get(X) {
                      return l(this, i).get(X) ?? null;
                    }
                    getAll() {
                      return (0, w.objectFromMap)(l(this, i));
                    }
                    has(X) {
                      return l(this, i).has(X);
                    }
                  }
                  ((i = new WeakMap()), (H = new WeakMap()), (A.Metadata = S));
                },
                (t, A, n) => {
                  var X, W, k, N, P, _, $r;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.OptionalContentConfig = void 0));
                  var w = n(1),
                    S = n(8);
                  const i = Symbol("INTERNAL");
                  class H {
                    constructor(d, p) {
                      ye(this, X, !0);
                      ((this.name = d), (this.intent = p));
                    }
                    get visible() {
                      return l(this, X);
                    }
                    _setVisible(d, p) {
                      (d !== i &&
                        (0, w.unreachable)(
                          "Internal method `_setVisible` called.",
                        ),
                        Se(this, X, p));
                    }
                  }
                  X = new WeakMap();
                  class ee {
                    constructor(d) {
                      ye(this, _);
                      ye(this, W, null);
                      ye(this, k, new Map());
                      ye(this, N, null);
                      ye(this, P, null);
                      if (
                        ((this.name = null), (this.creator = null), d !== null)
                      ) {
                        ((this.name = d.name),
                          (this.creator = d.creator),
                          Se(this, P, d.order));
                        for (const p of d.groups)
                          l(this, k).set(p.id, new H(p.name, p.intent));
                        if (d.baseState === "OFF")
                          for (const p of l(this, k).values())
                            p._setVisible(i, !1);
                        for (const p of d.on)
                          l(this, k).get(p)._setVisible(i, !0);
                        for (const p of d.off)
                          l(this, k).get(p)._setVisible(i, !1);
                        Se(this, N, this.getHash());
                      }
                    }
                    isVisible(d) {
                      if (l(this, k).size === 0) return !0;
                      if (!d)
                        return (
                          (0, w.warn)("Optional content group not defined."),
                          !0
                        );
                      if (d.type === "OCG")
                        return l(this, k).has(d.id)
                          ? l(this, k).get(d.id).visible
                          : ((0, w.warn)(
                              `Optional content group not found: ${d.id}`,
                            ),
                            !0);
                      if (d.type === "OCMD") {
                        if (d.expression)
                          return le(this, _, $r).call(this, d.expression);
                        if (!d.policy || d.policy === "AnyOn") {
                          for (const p of d.ids) {
                            if (!l(this, k).has(p))
                              return (
                                (0, w.warn)(
                                  `Optional content group not found: ${p}`,
                                ),
                                !0
                              );
                            if (l(this, k).get(p).visible) return !0;
                          }
                          return !1;
                        } else if (d.policy === "AllOn") {
                          for (const p of d.ids) {
                            if (!l(this, k).has(p))
                              return (
                                (0, w.warn)(
                                  `Optional content group not found: ${p}`,
                                ),
                                !0
                              );
                            if (!l(this, k).get(p).visible) return !1;
                          }
                          return !0;
                        } else if (d.policy === "AnyOff") {
                          for (const p of d.ids) {
                            if (!l(this, k).has(p))
                              return (
                                (0, w.warn)(
                                  `Optional content group not found: ${p}`,
                                ),
                                !0
                              );
                            if (!l(this, k).get(p).visible) return !0;
                          }
                          return !1;
                        } else if (d.policy === "AllOff") {
                          for (const p of d.ids) {
                            if (!l(this, k).has(p))
                              return (
                                (0, w.warn)(
                                  `Optional content group not found: ${p}`,
                                ),
                                !0
                              );
                            if (l(this, k).get(p).visible) return !1;
                          }
                          return !0;
                        }
                        return (
                          (0, w.warn)(
                            `Unknown optional content policy ${d.policy}.`,
                          ),
                          !0
                        );
                      }
                      return ((0, w.warn)(`Unknown group type ${d.type}.`), !0);
                    }
                    setVisibility(d, p = !0) {
                      if (!l(this, k).has(d)) {
                        (0, w.warn)(`Optional content group not found: ${d}`);
                        return;
                      }
                      (l(this, k).get(d)._setVisible(i, !!p),
                        Se(this, W, null));
                    }
                    get hasInitialVisibility() {
                      return (
                        l(this, N) === null || this.getHash() === l(this, N)
                      );
                    }
                    getOrder() {
                      return l(this, k).size
                        ? l(this, P)
                          ? l(this, P).slice()
                          : [...l(this, k).keys()]
                        : null;
                    }
                    getGroups() {
                      return l(this, k).size > 0
                        ? (0, w.objectFromMap)(l(this, k))
                        : null;
                    }
                    getGroup(d) {
                      return l(this, k).get(d) || null;
                    }
                    getHash() {
                      if (l(this, W) !== null) return l(this, W);
                      const d = new S.MurmurHash3_64();
                      for (const [p, u] of l(this, k))
                        d.update(`${p}:${u.visible}`);
                      return Se(this, W, d.hexdigest());
                    }
                  }
                  ((W = new WeakMap()),
                    (k = new WeakMap()),
                    (N = new WeakMap()),
                    (P = new WeakMap()),
                    (_ = new WeakSet()),
                    ($r = function (d) {
                      const p = d.length;
                      if (p < 2) return !0;
                      const u = d[0];
                      for (let F = 1; F < p; F++) {
                        const v = d[F];
                        let f;
                        if (Array.isArray(v)) f = le(this, _, $r).call(this, v);
                        else if (l(this, k).has(v))
                          f = l(this, k).get(v).visible;
                        else
                          return (
                            (0, w.warn)(
                              `Optional content group not found: ${v}`,
                            ),
                            !0
                          );
                        switch (u) {
                          case "And":
                            if (!f) return !1;
                            break;
                          case "Or":
                            if (f) return !0;
                            break;
                          case "Not":
                            return !f;
                          default:
                            return !0;
                        }
                      }
                      return u === "And";
                    }),
                    (A.OptionalContentConfig = ee));
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.PDFDataTransportStream = void 0));
                  var w = n(1),
                    S = n(6);
                  class i {
                    constructor(
                      {
                        length: W,
                        initialData: k,
                        progressiveDone: N = !1,
                        contentDispositionFilename: P = null,
                        disableRange: _ = !1,
                        disableStream: h = !1,
                      },
                      r,
                    ) {
                      if (
                        ((0, w.assert)(
                          r,
                          'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.',
                        ),
                        (this._queuedChunks = []),
                        (this._progressiveDone = N),
                        (this._contentDispositionFilename = P),
                        (k == null ? void 0 : k.length) > 0)
                      ) {
                        const d =
                          k instanceof Uint8Array &&
                          k.byteLength === k.buffer.byteLength
                            ? k.buffer
                            : new Uint8Array(k).buffer;
                        this._queuedChunks.push(d);
                      }
                      ((this._pdfDataRangeTransport = r),
                        (this._isStreamingSupported = !h),
                        (this._isRangeSupported = !_),
                        (this._contentLength = W),
                        (this._fullRequestReader = null),
                        (this._rangeReaders = []),
                        this._pdfDataRangeTransport.addRangeListener((d, p) => {
                          this._onReceiveData({ begin: d, chunk: p });
                        }),
                        this._pdfDataRangeTransport.addProgressListener(
                          (d, p) => {
                            this._onProgress({ loaded: d, total: p });
                          },
                        ),
                        this._pdfDataRangeTransport.addProgressiveReadListener(
                          (d) => {
                            this._onReceiveData({ chunk: d });
                          },
                        ),
                        this._pdfDataRangeTransport.addProgressiveDoneListener(
                          () => {
                            this._onProgressiveDone();
                          },
                        ),
                        this._pdfDataRangeTransport.transportReady());
                    }
                    _onReceiveData({ begin: W, chunk: k }) {
                      const N =
                        k instanceof Uint8Array &&
                        k.byteLength === k.buffer.byteLength
                          ? k.buffer
                          : new Uint8Array(k).buffer;
                      if (W === void 0)
                        this._fullRequestReader
                          ? this._fullRequestReader._enqueue(N)
                          : this._queuedChunks.push(N);
                      else {
                        const P = this._rangeReaders.some(function (_) {
                          return _._begin !== W ? !1 : (_._enqueue(N), !0);
                        });
                        (0, w.assert)(
                          P,
                          "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.",
                        );
                      }
                    }
                    get _progressiveDataLength() {
                      var W;
                      return (
                        ((W = this._fullRequestReader) == null
                          ? void 0
                          : W._loaded) ?? 0
                      );
                    }
                    _onProgress(W) {
                      var k, N, P, _;
                      W.total === void 0
                        ? (N =
                            (k = this._rangeReaders[0]) == null
                              ? void 0
                              : k.onProgress) == null ||
                          N.call(k, { loaded: W.loaded })
                        : (_ =
                            (P = this._fullRequestReader) == null
                              ? void 0
                              : P.onProgress) == null ||
                          _.call(P, { loaded: W.loaded, total: W.total });
                    }
                    _onProgressiveDone() {
                      var W;
                      ((W = this._fullRequestReader) == null ||
                        W.progressiveDone(),
                        (this._progressiveDone = !0));
                    }
                    _removeRangeReader(W) {
                      const k = this._rangeReaders.indexOf(W);
                      k >= 0 && this._rangeReaders.splice(k, 1);
                    }
                    getFullReader() {
                      (0, w.assert)(
                        !this._fullRequestReader,
                        "PDFDataTransportStream.getFullReader can only be called once.",
                      );
                      const W = this._queuedChunks;
                      return (
                        (this._queuedChunks = null),
                        new H(
                          this,
                          W,
                          this._progressiveDone,
                          this._contentDispositionFilename,
                        )
                      );
                    }
                    getRangeReader(W, k) {
                      if (k <= this._progressiveDataLength) return null;
                      const N = new ee(this, W, k);
                      return (
                        this._pdfDataRangeTransport.requestDataRange(W, k),
                        this._rangeReaders.push(N),
                        N
                      );
                    }
                    cancelAllRequests(W) {
                      var k;
                      (k = this._fullRequestReader) == null || k.cancel(W);
                      for (const N of this._rangeReaders.slice(0)) N.cancel(W);
                      this._pdfDataRangeTransport.abort();
                    }
                  }
                  A.PDFDataTransportStream = i;
                  class H {
                    constructor(W, k, N = !1, P = null) {
                      ((this._stream = W),
                        (this._done = N || !1),
                        (this._filename = (0, S.isPdfFile)(P) ? P : null),
                        (this._queuedChunks = k || []),
                        (this._loaded = 0));
                      for (const _ of this._queuedChunks)
                        this._loaded += _.byteLength;
                      ((this._requests = []),
                        (this._headersReady = Promise.resolve()),
                        (W._fullRequestReader = this),
                        (this.onProgress = null));
                    }
                    _enqueue(W) {
                      this._done ||
                        (this._requests.length > 0
                          ? this._requests
                              .shift()
                              .resolve({ value: W, done: !1 })
                          : this._queuedChunks.push(W),
                        (this._loaded += W.byteLength));
                    }
                    get headersReady() {
                      return this._headersReady;
                    }
                    get filename() {
                      return this._filename;
                    }
                    get isRangeSupported() {
                      return this._stream._isRangeSupported;
                    }
                    get isStreamingSupported() {
                      return this._stream._isStreamingSupported;
                    }
                    get contentLength() {
                      return this._stream._contentLength;
                    }
                    async read() {
                      if (this._queuedChunks.length > 0)
                        return { value: this._queuedChunks.shift(), done: !1 };
                      if (this._done) return { value: void 0, done: !0 };
                      const W = new w.PromiseCapability();
                      return (this._requests.push(W), W.promise);
                    }
                    cancel(W) {
                      this._done = !0;
                      for (const k of this._requests)
                        k.resolve({ value: void 0, done: !0 });
                      this._requests.length = 0;
                    }
                    progressiveDone() {
                      this._done || (this._done = !0);
                    }
                  }
                  class ee {
                    constructor(W, k, N) {
                      ((this._stream = W),
                        (this._begin = k),
                        (this._end = N),
                        (this._queuedChunk = null),
                        (this._requests = []),
                        (this._done = !1),
                        (this.onProgress = null));
                    }
                    _enqueue(W) {
                      if (!this._done) {
                        if (this._requests.length === 0) this._queuedChunk = W;
                        else {
                          this._requests
                            .shift()
                            .resolve({ value: W, done: !1 });
                          for (const N of this._requests)
                            N.resolve({ value: void 0, done: !0 });
                          this._requests.length = 0;
                        }
                        ((this._done = !0),
                          this._stream._removeRangeReader(this));
                      }
                    }
                    get isStreamingSupported() {
                      return !1;
                    }
                    async read() {
                      if (this._queuedChunk) {
                        const k = this._queuedChunk;
                        return (
                          (this._queuedChunk = null),
                          { value: k, done: !1 }
                        );
                      }
                      if (this._done) return { value: void 0, done: !0 };
                      const W = new w.PromiseCapability();
                      return (this._requests.push(W), W.promise);
                    }
                    cancel(W) {
                      this._done = !0;
                      for (const k of this._requests)
                        k.resolve({ value: void 0, done: !0 });
                      ((this._requests.length = 0),
                        this._stream._removeRangeReader(this));
                    }
                  }
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.PDFFetchStream = void 0));
                  var w = n(1),
                    S = n(20);
                  function i(N, P, _) {
                    return {
                      method: "GET",
                      headers: N,
                      signal: _.signal,
                      mode: "cors",
                      credentials: P ? "include" : "same-origin",
                      redirect: "follow",
                    };
                  }
                  function H(N) {
                    const P = new Headers();
                    for (const _ in N) {
                      const h = N[_];
                      h !== void 0 && P.append(_, h);
                    }
                    return P;
                  }
                  function ee(N) {
                    return N instanceof Uint8Array
                      ? N.buffer
                      : N instanceof ArrayBuffer
                        ? N
                        : ((0, w.warn)(
                            `getArrayBuffer - unexpected data format: ${N}`,
                          ),
                          new Uint8Array(N).buffer);
                  }
                  class X {
                    constructor(P) {
                      ((this.source = P),
                        (this.isHttp = /^https?:/i.test(P.url)),
                        (this.httpHeaders =
                          (this.isHttp && P.httpHeaders) || {}),
                        (this._fullRequestReader = null),
                        (this._rangeRequestReaders = []));
                    }
                    get _progressiveDataLength() {
                      var P;
                      return (
                        ((P = this._fullRequestReader) == null
                          ? void 0
                          : P._loaded) ?? 0
                      );
                    }
                    getFullReader() {
                      return (
                        (0, w.assert)(
                          !this._fullRequestReader,
                          "PDFFetchStream.getFullReader can only be called once.",
                        ),
                        (this._fullRequestReader = new W(this)),
                        this._fullRequestReader
                      );
                    }
                    getRangeReader(P, _) {
                      if (_ <= this._progressiveDataLength) return null;
                      const h = new k(this, P, _);
                      return (this._rangeRequestReaders.push(h), h);
                    }
                    cancelAllRequests(P) {
                      var _;
                      (_ = this._fullRequestReader) == null || _.cancel(P);
                      for (const h of this._rangeRequestReaders.slice(0))
                        h.cancel(P);
                    }
                  }
                  A.PDFFetchStream = X;
                  class W {
                    constructor(P) {
                      ((this._stream = P),
                        (this._reader = null),
                        (this._loaded = 0),
                        (this._filename = null));
                      const _ = P.source;
                      ((this._withCredentials = _.withCredentials || !1),
                        (this._contentLength = _.length),
                        (this._headersCapability = new w.PromiseCapability()),
                        (this._disableRange = _.disableRange || !1),
                        (this._rangeChunkSize = _.rangeChunkSize),
                        !this._rangeChunkSize &&
                          !this._disableRange &&
                          (this._disableRange = !0),
                        (this._abortController = new AbortController()),
                        (this._isStreamingSupported = !_.disableStream),
                        (this._isRangeSupported = !_.disableRange),
                        (this._headers = H(this._stream.httpHeaders)));
                      const h = _.url;
                      (fetch(
                        h,
                        i(
                          this._headers,
                          this._withCredentials,
                          this._abortController,
                        ),
                      )
                        .then((r) => {
                          if (!(0, S.validateResponseStatus)(r.status))
                            throw (0, S.createResponseStatusError)(r.status, h);
                          ((this._reader = r.body.getReader()),
                            this._headersCapability.resolve());
                          const d = (F) => r.headers.get(F),
                            { allowRangeRequests: p, suggestedLength: u } = (0,
                            S.validateRangeRequestCapabilities)({
                              getResponseHeader: d,
                              isHttp: this._stream.isHttp,
                              rangeChunkSize: this._rangeChunkSize,
                              disableRange: this._disableRange,
                            });
                          ((this._isRangeSupported = p),
                            (this._contentLength = u || this._contentLength),
                            (this._filename = (0, S.extractFilenameFromHeader)(
                              d,
                            )),
                            !this._isStreamingSupported &&
                              this._isRangeSupported &&
                              this.cancel(
                                new w.AbortException("Streaming is disabled."),
                              ));
                        })
                        .catch(this._headersCapability.reject),
                        (this.onProgress = null));
                    }
                    get headersReady() {
                      return this._headersCapability.promise;
                    }
                    get filename() {
                      return this._filename;
                    }
                    get contentLength() {
                      return this._contentLength;
                    }
                    get isRangeSupported() {
                      return this._isRangeSupported;
                    }
                    get isStreamingSupported() {
                      return this._isStreamingSupported;
                    }
                    async read() {
                      var h;
                      await this._headersCapability.promise;
                      const { value: P, done: _ } = await this._reader.read();
                      return _
                        ? { value: P, done: _ }
                        : ((this._loaded += P.byteLength),
                          (h = this.onProgress) == null ||
                            h.call(this, {
                              loaded: this._loaded,
                              total: this._contentLength,
                            }),
                          { value: ee(P), done: !1 });
                    }
                    cancel(P) {
                      var _;
                      ((_ = this._reader) == null || _.cancel(P),
                        this._abortController.abort());
                    }
                  }
                  class k {
                    constructor(P, _, h) {
                      ((this._stream = P),
                        (this._reader = null),
                        (this._loaded = 0));
                      const r = P.source;
                      ((this._withCredentials = r.withCredentials || !1),
                        (this._readCapability = new w.PromiseCapability()),
                        (this._isStreamingSupported = !r.disableStream),
                        (this._abortController = new AbortController()),
                        (this._headers = H(this._stream.httpHeaders)),
                        this._headers.append("Range", `bytes=${_}-${h - 1}`));
                      const d = r.url;
                      (fetch(
                        d,
                        i(
                          this._headers,
                          this._withCredentials,
                          this._abortController,
                        ),
                      )
                        .then((p) => {
                          if (!(0, S.validateResponseStatus)(p.status))
                            throw (0, S.createResponseStatusError)(p.status, d);
                          (this._readCapability.resolve(),
                            (this._reader = p.body.getReader()));
                        })
                        .catch(this._readCapability.reject),
                        (this.onProgress = null));
                    }
                    get isStreamingSupported() {
                      return this._isStreamingSupported;
                    }
                    async read() {
                      var h;
                      await this._readCapability.promise;
                      const { value: P, done: _ } = await this._reader.read();
                      return _
                        ? { value: P, done: _ }
                        : ((this._loaded += P.byteLength),
                          (h = this.onProgress) == null ||
                            h.call(this, { loaded: this._loaded }),
                          { value: ee(P), done: !1 });
                    }
                    cancel(P) {
                      var _;
                      ((_ = this._reader) == null || _.cancel(P),
                        this._abortController.abort());
                    }
                  }
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.createResponseStatusError = X),
                    (A.extractFilenameFromHeader = ee),
                    (A.validateRangeRequestCapabilities = H),
                    (A.validateResponseStatus = W));
                  var w = n(1),
                    S = n(21),
                    i = n(6);
                  function H({
                    getResponseHeader: k,
                    isHttp: N,
                    rangeChunkSize: P,
                    disableRange: _,
                  }) {
                    const h = {
                        allowRangeRequests: !1,
                        suggestedLength: void 0,
                      },
                      r = parseInt(k("Content-Length"), 10);
                    return (
                      !Number.isInteger(r) ||
                        ((h.suggestedLength = r), r <= 2 * P) ||
                        _ ||
                        !N ||
                        k("Accept-Ranges") !== "bytes" ||
                        (k("Content-Encoding") || "identity") !== "identity" ||
                        (h.allowRangeRequests = !0),
                      h
                    );
                  }
                  function ee(k) {
                    const N = k("Content-Disposition");
                    if (N) {
                      let P = (0, S.getFilenameFromContentDispositionHeader)(N);
                      if (P.includes("%"))
                        try {
                          P = decodeURIComponent(P);
                        } catch {}
                      if ((0, i.isPdfFile)(P)) return P;
                    }
                    return null;
                  }
                  function X(k, N) {
                    return k === 404 || (k === 0 && N.startsWith("file:"))
                      ? new w.MissingPDFException('Missing PDF "' + N + '".')
                      : new w.UnexpectedResponseException(
                          `Unexpected server response (${k}) while retrieving PDF "${N}".`,
                          k,
                        );
                  }
                  function W(k) {
                    return k === 200 || k === 206;
                  }
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.getFilenameFromContentDispositionHeader = S));
                  var w = n(1);
                  function S(i) {
                    let H = !0,
                      ee = X("filename\\*", "i").exec(i);
                    if (ee) {
                      ee = ee[1];
                      let r = P(ee);
                      return ((r = unescape(r)), (r = _(r)), (r = h(r)), k(r));
                    }
                    if (((ee = N(i)), ee)) {
                      const r = h(ee);
                      return k(r);
                    }
                    if (((ee = X("filename", "i").exec(i)), ee)) {
                      ee = ee[1];
                      let r = P(ee);
                      return ((r = h(r)), k(r));
                    }
                    function X(r, d) {
                      return new RegExp(
                        "(?:^|;)\\s*" +
                          r +
                          '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)',
                        d,
                      );
                    }
                    function W(r, d) {
                      if (r) {
                        if (!/^[\x00-\xFF]+$/.test(d)) return d;
                        try {
                          const p = new TextDecoder(r, { fatal: !0 }),
                            u = (0, w.stringToBytes)(d);
                          ((d = p.decode(u)), (H = !1));
                        } catch {}
                      }
                      return d;
                    }
                    function k(r) {
                      return (
                        H &&
                          /[\x80-\xff]/.test(r) &&
                          ((r = W("utf-8", r)), H && (r = W("iso-8859-1", r))),
                        r
                      );
                    }
                    function N(r) {
                      const d = [];
                      let p;
                      const u = X("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                      for (; (p = u.exec(r)) !== null; ) {
                        let [, v, f, b] = p;
                        if (((v = parseInt(v, 10)), v in d)) {
                          if (v === 0) break;
                          continue;
                        }
                        d[v] = [f, b];
                      }
                      const F = [];
                      for (let v = 0; v < d.length && v in d; ++v) {
                        let [f, b] = d[v];
                        ((b = P(b)),
                          f && ((b = unescape(b)), v === 0 && (b = _(b))),
                          F.push(b));
                      }
                      return F.join("");
                    }
                    function P(r) {
                      if (r.startsWith('"')) {
                        const d = r.slice(1).split('\\"');
                        for (let p = 0; p < d.length; ++p) {
                          const u = d[p].indexOf('"');
                          (u !== -1 &&
                            ((d[p] = d[p].slice(0, u)), (d.length = p + 1)),
                            (d[p] = d[p].replaceAll(/\\(.)/g, "$1")));
                        }
                        r = d.join('"');
                      }
                      return r;
                    }
                    function _(r) {
                      const d = r.indexOf("'");
                      if (d === -1) return r;
                      const p = r.slice(0, d),
                        F = r.slice(d + 1).replace(/^[^']*'/, "");
                      return W(p, F);
                    }
                    function h(r) {
                      return !r.startsWith("=?") ||
                        /[\x00-\x19\x80-\xff]/.test(r)
                        ? r
                        : r.replaceAll(
                            /=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g,
                            function (d, p, u, F) {
                              if (u === "q" || u === "Q")
                                return (
                                  (F = F.replaceAll("_", " ")),
                                  (F = F.replaceAll(
                                    /=([0-9a-fA-F]{2})/g,
                                    function (v, f) {
                                      return String.fromCharCode(
                                        parseInt(f, 16),
                                      );
                                    },
                                  )),
                                  W(p, F)
                                );
                              try {
                                F = atob(F);
                              } catch {}
                              return W(p, F);
                            },
                          );
                    }
                    return "";
                  }
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.PDFNetworkStream = void 0));
                  var w = n(1),
                    S = n(20);
                  const i = 200,
                    H = 206;
                  function ee(P) {
                    const _ = P.response;
                    return typeof _ != "string"
                      ? _
                      : (0, w.stringToBytes)(_).buffer;
                  }
                  class X {
                    constructor(_, h = {}) {
                      ((this.url = _),
                        (this.isHttp = /^https?:/i.test(_)),
                        (this.httpHeaders =
                          (this.isHttp && h.httpHeaders) ||
                          Object.create(null)),
                        (this.withCredentials = h.withCredentials || !1),
                        (this.currXhrId = 0),
                        (this.pendingRequests = Object.create(null)));
                    }
                    requestRange(_, h, r) {
                      const d = { begin: _, end: h };
                      for (const p in r) d[p] = r[p];
                      return this.request(d);
                    }
                    requestFull(_) {
                      return this.request(_);
                    }
                    request(_) {
                      const h = new XMLHttpRequest(),
                        r = this.currXhrId++,
                        d = (this.pendingRequests[r] = { xhr: h });
                      (h.open("GET", this.url),
                        (h.withCredentials = this.withCredentials));
                      for (const p in this.httpHeaders) {
                        const u = this.httpHeaders[p];
                        u !== void 0 && h.setRequestHeader(p, u);
                      }
                      return (
                        this.isHttp && "begin" in _ && "end" in _
                          ? (h.setRequestHeader(
                              "Range",
                              `bytes=${_.begin}-${_.end - 1}`,
                            ),
                            (d.expectedStatus = H))
                          : (d.expectedStatus = i),
                        (h.responseType = "arraybuffer"),
                        _.onError &&
                          (h.onerror = function (p) {
                            _.onError(h.status);
                          }),
                        (h.onreadystatechange = this.onStateChange.bind(
                          this,
                          r,
                        )),
                        (h.onprogress = this.onProgress.bind(this, r)),
                        (d.onHeadersReceived = _.onHeadersReceived),
                        (d.onDone = _.onDone),
                        (d.onError = _.onError),
                        (d.onProgress = _.onProgress),
                        h.send(null),
                        r
                      );
                    }
                    onProgress(_, h) {
                      var d;
                      const r = this.pendingRequests[_];
                      r && ((d = r.onProgress) == null || d.call(r, h));
                    }
                    onStateChange(_, h) {
                      var v, f, b;
                      const r = this.pendingRequests[_];
                      if (!r) return;
                      const d = r.xhr;
                      if (
                        (d.readyState >= 2 &&
                          r.onHeadersReceived &&
                          (r.onHeadersReceived(), delete r.onHeadersReceived),
                        d.readyState !== 4 || !(_ in this.pendingRequests))
                      )
                        return;
                      if (
                        (delete this.pendingRequests[_],
                        d.status === 0 && this.isHttp)
                      ) {
                        (v = r.onError) == null || v.call(r, d.status);
                        return;
                      }
                      const p = d.status || i;
                      if (
                        !(p === i && r.expectedStatus === H) &&
                        p !== r.expectedStatus
                      ) {
                        (f = r.onError) == null || f.call(r, d.status);
                        return;
                      }
                      const F = ee(d);
                      if (p === H) {
                        const c = d.getResponseHeader("Content-Range"),
                          a = /bytes (\d+)-(\d+)\/(\d+)/.exec(c);
                        r.onDone({ begin: parseInt(a[1], 10), chunk: F });
                      } else
                        F
                          ? r.onDone({ begin: 0, chunk: F })
                          : (b = r.onError) == null || b.call(r, d.status);
                    }
                    getRequestXhr(_) {
                      return this.pendingRequests[_].xhr;
                    }
                    isPendingRequest(_) {
                      return _ in this.pendingRequests;
                    }
                    abortRequest(_) {
                      const h = this.pendingRequests[_].xhr;
                      (delete this.pendingRequests[_], h.abort());
                    }
                  }
                  class W {
                    constructor(_) {
                      ((this._source = _),
                        (this._manager = new X(_.url, {
                          httpHeaders: _.httpHeaders,
                          withCredentials: _.withCredentials,
                        })),
                        (this._rangeChunkSize = _.rangeChunkSize),
                        (this._fullRequestReader = null),
                        (this._rangeRequestReaders = []));
                    }
                    _onRangeRequestReaderClosed(_) {
                      const h = this._rangeRequestReaders.indexOf(_);
                      h >= 0 && this._rangeRequestReaders.splice(h, 1);
                    }
                    getFullReader() {
                      return (
                        (0, w.assert)(
                          !this._fullRequestReader,
                          "PDFNetworkStream.getFullReader can only be called once.",
                        ),
                        (this._fullRequestReader = new k(
                          this._manager,
                          this._source,
                        )),
                        this._fullRequestReader
                      );
                    }
                    getRangeReader(_, h) {
                      const r = new N(this._manager, _, h);
                      return (
                        (r.onClosed =
                          this._onRangeRequestReaderClosed.bind(this)),
                        this._rangeRequestReaders.push(r),
                        r
                      );
                    }
                    cancelAllRequests(_) {
                      var h;
                      (h = this._fullRequestReader) == null || h.cancel(_);
                      for (const r of this._rangeRequestReaders.slice(0))
                        r.cancel(_);
                    }
                  }
                  A.PDFNetworkStream = W;
                  class k {
                    constructor(_, h) {
                      this._manager = _;
                      const r = {
                        onHeadersReceived: this._onHeadersReceived.bind(this),
                        onDone: this._onDone.bind(this),
                        onError: this._onError.bind(this),
                        onProgress: this._onProgress.bind(this),
                      };
                      ((this._url = h.url),
                        (this._fullRequestId = _.requestFull(r)),
                        (this._headersReceivedCapability =
                          new w.PromiseCapability()),
                        (this._disableRange = h.disableRange || !1),
                        (this._contentLength = h.length),
                        (this._rangeChunkSize = h.rangeChunkSize),
                        !this._rangeChunkSize &&
                          !this._disableRange &&
                          (this._disableRange = !0),
                        (this._isStreamingSupported = !1),
                        (this._isRangeSupported = !1),
                        (this._cachedChunks = []),
                        (this._requests = []),
                        (this._done = !1),
                        (this._storedError = void 0),
                        (this._filename = null),
                        (this.onProgress = null));
                    }
                    _onHeadersReceived() {
                      const _ = this._fullRequestId,
                        h = this._manager.getRequestXhr(_),
                        r = (u) => h.getResponseHeader(u),
                        { allowRangeRequests: d, suggestedLength: p } = (0,
                        S.validateRangeRequestCapabilities)({
                          getResponseHeader: r,
                          isHttp: this._manager.isHttp,
                          rangeChunkSize: this._rangeChunkSize,
                          disableRange: this._disableRange,
                        });
                      (d && (this._isRangeSupported = !0),
                        (this._contentLength = p || this._contentLength),
                        (this._filename = (0, S.extractFilenameFromHeader)(r)),
                        this._isRangeSupported && this._manager.abortRequest(_),
                        this._headersReceivedCapability.resolve());
                    }
                    _onDone(_) {
                      if (
                        (_ &&
                          (this._requests.length > 0
                            ? this._requests
                                .shift()
                                .resolve({ value: _.chunk, done: !1 })
                            : this._cachedChunks.push(_.chunk)),
                        (this._done = !0),
                        !(this._cachedChunks.length > 0))
                      ) {
                        for (const h of this._requests)
                          h.resolve({ value: void 0, done: !0 });
                        this._requests.length = 0;
                      }
                    }
                    _onError(_) {
                      ((this._storedError = (0, S.createResponseStatusError)(
                        _,
                        this._url,
                      )),
                        this._headersReceivedCapability.reject(
                          this._storedError,
                        ));
                      for (const h of this._requests)
                        h.reject(this._storedError);
                      ((this._requests.length = 0),
                        (this._cachedChunks.length = 0));
                    }
                    _onProgress(_) {
                      var h;
                      (h = this.onProgress) == null ||
                        h.call(this, {
                          loaded: _.loaded,
                          total: _.lengthComputable
                            ? _.total
                            : this._contentLength,
                        });
                    }
                    get filename() {
                      return this._filename;
                    }
                    get isRangeSupported() {
                      return this._isRangeSupported;
                    }
                    get isStreamingSupported() {
                      return this._isStreamingSupported;
                    }
                    get contentLength() {
                      return this._contentLength;
                    }
                    get headersReady() {
                      return this._headersReceivedCapability.promise;
                    }
                    async read() {
                      if (this._storedError) throw this._storedError;
                      if (this._cachedChunks.length > 0)
                        return { value: this._cachedChunks.shift(), done: !1 };
                      if (this._done) return { value: void 0, done: !0 };
                      const _ = new w.PromiseCapability();
                      return (this._requests.push(_), _.promise);
                    }
                    cancel(_) {
                      ((this._done = !0),
                        this._headersReceivedCapability.reject(_));
                      for (const h of this._requests)
                        h.resolve({ value: void 0, done: !0 });
                      ((this._requests.length = 0),
                        this._manager.isPendingRequest(this._fullRequestId) &&
                          this._manager.abortRequest(this._fullRequestId),
                        (this._fullRequestReader = null));
                    }
                  }
                  class N {
                    constructor(_, h, r) {
                      this._manager = _;
                      const d = {
                        onDone: this._onDone.bind(this),
                        onError: this._onError.bind(this),
                        onProgress: this._onProgress.bind(this),
                      };
                      ((this._url = _.url),
                        (this._requestId = _.requestRange(h, r, d)),
                        (this._requests = []),
                        (this._queuedChunk = null),
                        (this._done = !1),
                        (this._storedError = void 0),
                        (this.onProgress = null),
                        (this.onClosed = null));
                    }
                    _close() {
                      var _;
                      (_ = this.onClosed) == null || _.call(this, this);
                    }
                    _onDone(_) {
                      const h = _.chunk;
                      (this._requests.length > 0
                        ? this._requests.shift().resolve({ value: h, done: !1 })
                        : (this._queuedChunk = h),
                        (this._done = !0));
                      for (const r of this._requests)
                        r.resolve({ value: void 0, done: !0 });
                      ((this._requests.length = 0), this._close());
                    }
                    _onError(_) {
                      this._storedError = (0, S.createResponseStatusError)(
                        _,
                        this._url,
                      );
                      for (const h of this._requests)
                        h.reject(this._storedError);
                      ((this._requests.length = 0), (this._queuedChunk = null));
                    }
                    _onProgress(_) {
                      var h;
                      this.isStreamingSupported ||
                        (h = this.onProgress) == null ||
                        h.call(this, { loaded: _.loaded });
                    }
                    get isStreamingSupported() {
                      return !1;
                    }
                    async read() {
                      if (this._storedError) throw this._storedError;
                      if (this._queuedChunk !== null) {
                        const h = this._queuedChunk;
                        return (
                          (this._queuedChunk = null),
                          { value: h, done: !1 }
                        );
                      }
                      if (this._done) return { value: void 0, done: !0 };
                      const _ = new w.PromiseCapability();
                      return (this._requests.push(_), _.promise);
                    }
                    cancel(_) {
                      this._done = !0;
                      for (const h of this._requests)
                        h.resolve({ value: void 0, done: !0 });
                      ((this._requests.length = 0),
                        this._manager.isPendingRequest(this._requestId) &&
                          this._manager.abortRequest(this._requestId),
                        this._close());
                    }
                  }
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.PDFNodeStream = void 0));
                  var w = n(1),
                    S = n(20);
                  const i = /^file:\/\/\/[a-zA-Z]:\//;
                  function H(r) {
                    const d = require$$5,
                      p = d.parse(r);
                    return p.protocol === "file:" || p.host
                      ? p
                      : /^[a-z]:[/\\]/i.test(r)
                        ? d.parse(`file:///${r}`)
                        : (p.host || (p.protocol = "file:"), p);
                  }
                  class ee {
                    constructor(d) {
                      ((this.source = d),
                        (this.url = H(d.url)),
                        (this.isHttp =
                          this.url.protocol === "http:" ||
                          this.url.protocol === "https:"),
                        (this.isFsUrl = this.url.protocol === "file:"),
                        (this.httpHeaders =
                          (this.isHttp && d.httpHeaders) || {}),
                        (this._fullRequestReader = null),
                        (this._rangeRequestReaders = []));
                    }
                    get _progressiveDataLength() {
                      var d;
                      return (
                        ((d = this._fullRequestReader) == null
                          ? void 0
                          : d._loaded) ?? 0
                      );
                    }
                    getFullReader() {
                      return (
                        (0, w.assert)(
                          !this._fullRequestReader,
                          "PDFNodeStream.getFullReader can only be called once.",
                        ),
                        (this._fullRequestReader = this.isFsUrl
                          ? new _(this)
                          : new N(this)),
                        this._fullRequestReader
                      );
                    }
                    getRangeReader(d, p) {
                      if (p <= this._progressiveDataLength) return null;
                      const u = this.isFsUrl
                        ? new h(this, d, p)
                        : new P(this, d, p);
                      return (this._rangeRequestReaders.push(u), u);
                    }
                    cancelAllRequests(d) {
                      var p;
                      (p = this._fullRequestReader) == null || p.cancel(d);
                      for (const u of this._rangeRequestReaders.slice(0))
                        u.cancel(d);
                    }
                  }
                  A.PDFNodeStream = ee;
                  class X {
                    constructor(d) {
                      ((this._url = d.url),
                        (this._done = !1),
                        (this._storedError = null),
                        (this.onProgress = null));
                      const p = d.source;
                      ((this._contentLength = p.length),
                        (this._loaded = 0),
                        (this._filename = null),
                        (this._disableRange = p.disableRange || !1),
                        (this._rangeChunkSize = p.rangeChunkSize),
                        !this._rangeChunkSize &&
                          !this._disableRange &&
                          (this._disableRange = !0),
                        (this._isStreamingSupported = !p.disableStream),
                        (this._isRangeSupported = !p.disableRange),
                        (this._readableStream = null),
                        (this._readCapability = new w.PromiseCapability()),
                        (this._headersCapability = new w.PromiseCapability()));
                    }
                    get headersReady() {
                      return this._headersCapability.promise;
                    }
                    get filename() {
                      return this._filename;
                    }
                    get contentLength() {
                      return this._contentLength;
                    }
                    get isRangeSupported() {
                      return this._isRangeSupported;
                    }
                    get isStreamingSupported() {
                      return this._isStreamingSupported;
                    }
                    async read() {
                      var u;
                      if ((await this._readCapability.promise, this._done))
                        return { value: void 0, done: !0 };
                      if (this._storedError) throw this._storedError;
                      const d = this._readableStream.read();
                      return d === null
                        ? ((this._readCapability = new w.PromiseCapability()),
                          this.read())
                        : ((this._loaded += d.length),
                          (u = this.onProgress) == null ||
                            u.call(this, {
                              loaded: this._loaded,
                              total: this._contentLength,
                            }),
                          { value: new Uint8Array(d).buffer, done: !1 });
                    }
                    cancel(d) {
                      if (!this._readableStream) {
                        this._error(d);
                        return;
                      }
                      this._readableStream.destroy(d);
                    }
                    _error(d) {
                      ((this._storedError = d), this._readCapability.resolve());
                    }
                    _setReadableStream(d) {
                      ((this._readableStream = d),
                        d.on("readable", () => {
                          this._readCapability.resolve();
                        }),
                        d.on("end", () => {
                          (d.destroy(),
                            (this._done = !0),
                            this._readCapability.resolve());
                        }),
                        d.on("error", (p) => {
                          this._error(p);
                        }),
                        !this._isStreamingSupported &&
                          this._isRangeSupported &&
                          this._error(
                            new w.AbortException("streaming is disabled"),
                          ),
                        this._storedError &&
                          this._readableStream.destroy(this._storedError));
                    }
                  }
                  class W {
                    constructor(d) {
                      ((this._url = d.url),
                        (this._done = !1),
                        (this._storedError = null),
                        (this.onProgress = null),
                        (this._loaded = 0),
                        (this._readableStream = null),
                        (this._readCapability = new w.PromiseCapability()));
                      const p = d.source;
                      this._isStreamingSupported = !p.disableStream;
                    }
                    get isStreamingSupported() {
                      return this._isStreamingSupported;
                    }
                    async read() {
                      var u;
                      if ((await this._readCapability.promise, this._done))
                        return { value: void 0, done: !0 };
                      if (this._storedError) throw this._storedError;
                      const d = this._readableStream.read();
                      return d === null
                        ? ((this._readCapability = new w.PromiseCapability()),
                          this.read())
                        : ((this._loaded += d.length),
                          (u = this.onProgress) == null ||
                            u.call(this, { loaded: this._loaded }),
                          { value: new Uint8Array(d).buffer, done: !1 });
                    }
                    cancel(d) {
                      if (!this._readableStream) {
                        this._error(d);
                        return;
                      }
                      this._readableStream.destroy(d);
                    }
                    _error(d) {
                      ((this._storedError = d), this._readCapability.resolve());
                    }
                    _setReadableStream(d) {
                      ((this._readableStream = d),
                        d.on("readable", () => {
                          this._readCapability.resolve();
                        }),
                        d.on("end", () => {
                          (d.destroy(),
                            (this._done = !0),
                            this._readCapability.resolve());
                        }),
                        d.on("error", (p) => {
                          this._error(p);
                        }),
                        this._storedError &&
                          this._readableStream.destroy(this._storedError));
                    }
                  }
                  function k(r, d) {
                    return {
                      protocol: r.protocol,
                      auth: r.auth,
                      host: r.hostname,
                      port: r.port,
                      path: r.path,
                      method: "GET",
                      headers: d,
                    };
                  }
                  class N extends X {
                    constructor(d) {
                      super(d);
                      const p = (u) => {
                        if (u.statusCode === 404) {
                          const b = new w.MissingPDFException(
                            `Missing PDF "${this._url}".`,
                          );
                          ((this._storedError = b),
                            this._headersCapability.reject(b));
                          return;
                        }
                        (this._headersCapability.resolve(),
                          this._setReadableStream(u));
                        const F = (b) =>
                            this._readableStream.headers[b.toLowerCase()],
                          { allowRangeRequests: v, suggestedLength: f } = (0,
                          S.validateRangeRequestCapabilities)({
                            getResponseHeader: F,
                            isHttp: d.isHttp,
                            rangeChunkSize: this._rangeChunkSize,
                            disableRange: this._disableRange,
                          });
                        ((this._isRangeSupported = v),
                          (this._contentLength = f || this._contentLength),
                          (this._filename = (0, S.extractFilenameFromHeader)(
                            F,
                          )));
                      };
                      if (
                        ((this._request = null), this._url.protocol === "http:")
                      ) {
                        const u = require$$5;
                        this._request = u.request(
                          k(this._url, d.httpHeaders),
                          p,
                        );
                      } else {
                        const u = require$$5;
                        this._request = u.request(
                          k(this._url, d.httpHeaders),
                          p,
                        );
                      }
                      (this._request.on("error", (u) => {
                        ((this._storedError = u),
                          this._headersCapability.reject(u));
                      }),
                        this._request.end());
                    }
                  }
                  class P extends W {
                    constructor(d, p, u) {
                      (super(d), (this._httpHeaders = {}));
                      for (const v in d.httpHeaders) {
                        const f = d.httpHeaders[v];
                        f !== void 0 && (this._httpHeaders[v] = f);
                      }
                      this._httpHeaders.Range = `bytes=${p}-${u - 1}`;
                      const F = (v) => {
                        if (v.statusCode === 404) {
                          const f = new w.MissingPDFException(
                            `Missing PDF "${this._url}".`,
                          );
                          this._storedError = f;
                          return;
                        }
                        this._setReadableStream(v);
                      };
                      if (
                        ((this._request = null), this._url.protocol === "http:")
                      ) {
                        const v = require$$5;
                        this._request = v.request(
                          k(this._url, this._httpHeaders),
                          F,
                        );
                      } else {
                        const v = require$$5;
                        this._request = v.request(
                          k(this._url, this._httpHeaders),
                          F,
                        );
                      }
                      (this._request.on("error", (v) => {
                        this._storedError = v;
                      }),
                        this._request.end());
                    }
                  }
                  class _ extends X {
                    constructor(d) {
                      super(d);
                      let p = decodeURIComponent(this._url.path);
                      i.test(this._url.href) && (p = p.replace(/^\//, ""));
                      const u = require$$5;
                      u.lstat(p, (F, v) => {
                        if (F) {
                          (F.code === "ENOENT" &&
                            (F = new w.MissingPDFException(
                              `Missing PDF "${p}".`,
                            )),
                            (this._storedError = F),
                            this._headersCapability.reject(F));
                          return;
                        }
                        ((this._contentLength = v.size),
                          this._setReadableStream(u.createReadStream(p)),
                          this._headersCapability.resolve());
                      });
                    }
                  }
                  class h extends W {
                    constructor(d, p, u) {
                      super(d);
                      let F = decodeURIComponent(this._url.path);
                      i.test(this._url.href) && (F = F.replace(/^\//, ""));
                      const v = require$$5;
                      this._setReadableStream(
                        v.createReadStream(F, { start: p, end: u - 1 }),
                      );
                    }
                  }
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.SVGGraphics = void 0));
                  var w = n(6),
                    S = n(1);
                  const i = {
                      fontStyle: "normal",
                      fontWeight: "normal",
                      fillColor: "#000000",
                    },
                    H = "http://www.w3.org/XML/1998/namespace",
                    ee = "http://www.w3.org/1999/xlink",
                    X = ["butt", "round", "square"],
                    W = ["miter", "round", "bevel"],
                    k = function (v, f = "", b = !1) {
                      if (URL.createObjectURL && typeof Blob < "u" && !b)
                        return URL.createObjectURL(new Blob([v], { type: f }));
                      const c =
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                      let a = `data:${f};base64,`;
                      for (let m = 0, C = v.length; m < C; m += 3) {
                        const e = v[m] & 255,
                          o = v[m + 1] & 255,
                          y = v[m + 2] & 255,
                          B = e >> 2,
                          M = ((e & 3) << 4) | (o >> 4),
                          D = m + 1 < C ? ((o & 15) << 2) | (y >> 6) : 64,
                          x = m + 2 < C ? y & 63 : 64;
                        a += c[B] + c[M] + c[D] + c[x];
                      }
                      return a;
                    },
                    N = (function () {
                      const v = new Uint8Array([
                          137, 80, 78, 71, 13, 10, 26, 10,
                        ]),
                        f = 12,
                        b = new Int32Array(256);
                      for (let y = 0; y < 256; y++) {
                        let B = y;
                        for (let M = 0; M < 8; M++)
                          B =
                            B & 1
                              ? 3988292384 ^ ((B >> 1) & 2147483647)
                              : (B >> 1) & 2147483647;
                        b[y] = B;
                      }
                      function c(y, B, M) {
                        let D = -1;
                        for (let x = B; x < M; x++) {
                          const z = (D ^ y[x]) & 255,
                            L = b[z];
                          D = (D >>> 8) ^ L;
                        }
                        return D ^ -1;
                      }
                      function a(y, B, M, D) {
                        let x = D;
                        const z = B.length;
                        ((M[x] = (z >> 24) & 255),
                          (M[x + 1] = (z >> 16) & 255),
                          (M[x + 2] = (z >> 8) & 255),
                          (M[x + 3] = z & 255),
                          (x += 4),
                          (M[x] = y.charCodeAt(0) & 255),
                          (M[x + 1] = y.charCodeAt(1) & 255),
                          (M[x + 2] = y.charCodeAt(2) & 255),
                          (M[x + 3] = y.charCodeAt(3) & 255),
                          (x += 4),
                          M.set(B, x),
                          (x += B.length));
                        const L = c(M, D + 4, x);
                        ((M[x] = (L >> 24) & 255),
                          (M[x + 1] = (L >> 16) & 255),
                          (M[x + 2] = (L >> 8) & 255),
                          (M[x + 3] = L & 255));
                      }
                      function m(y, B, M) {
                        let D = 1,
                          x = 0;
                        for (let z = B; z < M; ++z)
                          ((D = (D + (y[z] & 255)) % 65521),
                            (x = (x + D) % 65521));
                        return (x << 16) | D;
                      }
                      function C(y) {
                        if (!S.isNodeJS) return e(y);
                        try {
                          const B =
                              parseInt(process.versions.node) >= 8
                                ? y
                                : Buffer.from(y),
                            M = require$$5.deflateSync(B, { level: 9 });
                          return M instanceof Uint8Array
                            ? M
                            : new Uint8Array(M);
                        } catch (B) {
                          (0, S.warn)(
                            "Not compressing PNG because zlib.deflateSync is unavailable: " +
                              B,
                          );
                        }
                        return e(y);
                      }
                      function e(y) {
                        let B = y.length;
                        const M = 65535,
                          D = Math.ceil(B / M),
                          x = new Uint8Array(2 + B + D * 5 + 4);
                        let z = 0;
                        ((x[z++] = 120), (x[z++] = 156));
                        let L = 0;
                        for (; B > M; )
                          ((x[z++] = 0),
                            (x[z++] = 255),
                            (x[z++] = 255),
                            (x[z++] = 0),
                            (x[z++] = 0),
                            x.set(y.subarray(L, L + M), z),
                            (z += M),
                            (L += M),
                            (B -= M));
                        ((x[z++] = 1),
                          (x[z++] = B & 255),
                          (x[z++] = (B >> 8) & 255),
                          (x[z++] = ~B & 65535 & 255),
                          (x[z++] = ((~B & 65535) >> 8) & 255),
                          x.set(y.subarray(L), z),
                          (z += y.length - L));
                        const V = m(y, 0, y.length);
                        return (
                          (x[z++] = (V >> 24) & 255),
                          (x[z++] = (V >> 16) & 255),
                          (x[z++] = (V >> 8) & 255),
                          (x[z++] = V & 255),
                          x
                        );
                      }
                      function o(y, B, M, D) {
                        const x = y.width,
                          z = y.height;
                        let L, V, Y;
                        const T = y.data;
                        switch (B) {
                          case S.ImageKind.GRAYSCALE_1BPP:
                            ((V = 0), (L = 1), (Y = (x + 7) >> 3));
                            break;
                          case S.ImageKind.RGB_24BPP:
                            ((V = 2), (L = 8), (Y = x * 3));
                            break;
                          case S.ImageKind.RGBA_32BPP:
                            ((V = 6), (L = 8), (Y = x * 4));
                            break;
                          default:
                            throw new Error("invalid format");
                        }
                        const s = new Uint8Array((1 + Y) * z);
                        let g = 0,
                          R = 0;
                        for (let we = 0; we < z; ++we)
                          ((s[g++] = 0),
                            s.set(T.subarray(R, R + Y), g),
                            (R += Y),
                            (g += Y));
                        if (B === S.ImageKind.GRAYSCALE_1BPP && D) {
                          g = 0;
                          for (let we = 0; we < z; we++) {
                            g++;
                            for (let Ee = 0; Ee < Y; Ee++) s[g++] ^= 255;
                          }
                        }
                        const $ = new Uint8Array([
                            (x >> 24) & 255,
                            (x >> 16) & 255,
                            (x >> 8) & 255,
                            x & 255,
                            (z >> 24) & 255,
                            (z >> 16) & 255,
                            (z >> 8) & 255,
                            z & 255,
                            L,
                            V,
                            0,
                            0,
                            0,
                          ]),
                          j = C(s),
                          U = v.length + f * 3 + $.length + j.length,
                          Q = new Uint8Array(U);
                        let fe = 0;
                        return (
                          Q.set(v, fe),
                          (fe += v.length),
                          a("IHDR", $, Q, fe),
                          (fe += f + $.length),
                          a("IDATA", j, Q, fe),
                          (fe += f + j.length),
                          a("IEND", new Uint8Array(0), Q, fe),
                          k(Q, "image/png", M)
                        );
                      }
                      return function (B, M, D) {
                        const x =
                          B.kind === void 0
                            ? S.ImageKind.GRAYSCALE_1BPP
                            : B.kind;
                        return o(B, x, M, D);
                      };
                    })();
                  class P {
                    constructor() {
                      ((this.fontSizeScale = 1),
                        (this.fontWeight = i.fontWeight),
                        (this.fontSize = 0),
                        (this.textMatrix = S.IDENTITY_MATRIX),
                        (this.fontMatrix = S.FONT_IDENTITY_MATRIX),
                        (this.leading = 0),
                        (this.textRenderingMode = S.TextRenderingMode.FILL),
                        (this.textMatrixScale = 1),
                        (this.x = 0),
                        (this.y = 0),
                        (this.lineX = 0),
                        (this.lineY = 0),
                        (this.charSpacing = 0),
                        (this.wordSpacing = 0),
                        (this.textHScale = 1),
                        (this.textRise = 0),
                        (this.fillColor = i.fillColor),
                        (this.strokeColor = "#000000"),
                        (this.fillAlpha = 1),
                        (this.strokeAlpha = 1),
                        (this.lineWidth = 1),
                        (this.lineJoin = ""),
                        (this.lineCap = ""),
                        (this.miterLimit = 0),
                        (this.dashArray = []),
                        (this.dashPhase = 0),
                        (this.dependencies = []),
                        (this.activeClipUrl = null),
                        (this.clipGroup = null),
                        (this.maskId = ""));
                    }
                    clone() {
                      return Object.create(this);
                    }
                    setCurrentPoint(f, b) {
                      ((this.x = f), (this.y = b));
                    }
                  }
                  function _(v) {
                    let f = [];
                    const b = [];
                    for (const c of v) {
                      if (c.fn === "save") {
                        (f.push({ fnId: 92, fn: "group", items: [] }),
                          b.push(f),
                          (f = f.at(-1).items));
                        continue;
                      }
                      c.fn === "restore" ? (f = b.pop()) : f.push(c);
                    }
                    return f;
                  }
                  function h(v) {
                    if (Number.isInteger(v)) return v.toString();
                    const f = v.toFixed(10);
                    let b = f.length - 1;
                    if (f[b] !== "0") return f;
                    do b--;
                    while (f[b] === "0");
                    return f.substring(0, f[b] === "." ? b : b + 1);
                  }
                  function r(v) {
                    if (v[4] === 0 && v[5] === 0) {
                      if (v[1] === 0 && v[2] === 0)
                        return v[0] === 1 && v[3] === 1
                          ? ""
                          : `scale(${h(v[0])} ${h(v[3])})`;
                      if (v[0] === v[3] && v[1] === -v[2]) {
                        const f = (Math.acos(v[0]) * 180) / Math.PI;
                        return `rotate(${h(f)})`;
                      }
                    } else if (
                      v[0] === 1 &&
                      v[1] === 0 &&
                      v[2] === 0 &&
                      v[3] === 1
                    )
                      return `translate(${h(v[4])} ${h(v[5])})`;
                    return `matrix(${h(v[0])} ${h(v[1])} ${h(v[2])} ${h(v[3])} ${h(v[4])} ${h(v[5])})`;
                  }
                  let d = 0,
                    p = 0,
                    u = 0;
                  class F {
                    constructor(f, b, c = !1) {
                      ((0, w.deprecated)(
                        "The SVG back-end is no longer maintained and *may* be removed in the future.",
                      ),
                        (this.svgFactory = new w.DOMSVGFactory()),
                        (this.current = new P()),
                        (this.transformMatrix = S.IDENTITY_MATRIX),
                        (this.transformStack = []),
                        (this.extraStack = []),
                        (this.commonObjs = f),
                        (this.objs = b),
                        (this.pendingClip = null),
                        (this.pendingEOFill = !1),
                        (this.embedFonts = !1),
                        (this.embeddedFonts = Object.create(null)),
                        (this.cssStyle = null),
                        (this.forceDataSchema = !!c),
                        (this._operatorIdMapping = []));
                      for (const a in S.OPS)
                        this._operatorIdMapping[S.OPS[a]] = a;
                    }
                    getObject(f, b = null) {
                      return typeof f == "string"
                        ? f.startsWith("g_")
                          ? this.commonObjs.get(f)
                          : this.objs.get(f)
                        : b;
                    }
                    save() {
                      this.transformStack.push(this.transformMatrix);
                      const f = this.current;
                      (this.extraStack.push(f), (this.current = f.clone()));
                    }
                    restore() {
                      ((this.transformMatrix = this.transformStack.pop()),
                        (this.current = this.extraStack.pop()),
                        (this.pendingClip = null),
                        (this.tgrp = null));
                    }
                    group(f) {
                      (this.save(), this.executeOpTree(f), this.restore());
                    }
                    loadDependencies(f) {
                      const b = f.fnArray,
                        c = f.argsArray;
                      for (let a = 0, m = b.length; a < m; a++)
                        if (b[a] === S.OPS.dependency)
                          for (const C of c[a]) {
                            const e = C.startsWith("g_")
                                ? this.commonObjs
                                : this.objs,
                              o = new Promise((y) => {
                                e.get(C, y);
                              });
                            this.current.dependencies.push(o);
                          }
                      return Promise.all(this.current.dependencies);
                    }
                    transform(f, b, c, a, m, C) {
                      const e = [f, b, c, a, m, C];
                      ((this.transformMatrix = S.Util.transform(
                        this.transformMatrix,
                        e,
                      )),
                        (this.tgrp = null));
                    }
                    getSVG(f, b) {
                      this.viewport = b;
                      const c = this._initialize(b);
                      return this.loadDependencies(f).then(
                        () => (
                          (this.transformMatrix = S.IDENTITY_MATRIX),
                          this.executeOpTree(this.convertOpList(f)),
                          c
                        ),
                      );
                    }
                    convertOpList(f) {
                      const b = this._operatorIdMapping,
                        c = f.argsArray,
                        a = f.fnArray,
                        m = [];
                      for (let C = 0, e = a.length; C < e; C++) {
                        const o = a[C];
                        m.push({ fnId: o, fn: b[o], args: c[C] });
                      }
                      return _(m);
                    }
                    executeOpTree(f) {
                      for (const b of f) {
                        const c = b.fn,
                          a = b.fnId,
                          m = b.args;
                        switch (a | 0) {
                          case S.OPS.beginText:
                            this.beginText();
                            break;
                          case S.OPS.dependency:
                            break;
                          case S.OPS.setLeading:
                            this.setLeading(m);
                            break;
                          case S.OPS.setLeadingMoveText:
                            this.setLeadingMoveText(m[0], m[1]);
                            break;
                          case S.OPS.setFont:
                            this.setFont(m);
                            break;
                          case S.OPS.showText:
                            this.showText(m[0]);
                            break;
                          case S.OPS.showSpacedText:
                            this.showText(m[0]);
                            break;
                          case S.OPS.endText:
                            this.endText();
                            break;
                          case S.OPS.moveText:
                            this.moveText(m[0], m[1]);
                            break;
                          case S.OPS.setCharSpacing:
                            this.setCharSpacing(m[0]);
                            break;
                          case S.OPS.setWordSpacing:
                            this.setWordSpacing(m[0]);
                            break;
                          case S.OPS.setHScale:
                            this.setHScale(m[0]);
                            break;
                          case S.OPS.setTextMatrix:
                            this.setTextMatrix(
                              m[0],
                              m[1],
                              m[2],
                              m[3],
                              m[4],
                              m[5],
                            );
                            break;
                          case S.OPS.setTextRise:
                            this.setTextRise(m[0]);
                            break;
                          case S.OPS.setTextRenderingMode:
                            this.setTextRenderingMode(m[0]);
                            break;
                          case S.OPS.setLineWidth:
                            this.setLineWidth(m[0]);
                            break;
                          case S.OPS.setLineJoin:
                            this.setLineJoin(m[0]);
                            break;
                          case S.OPS.setLineCap:
                            this.setLineCap(m[0]);
                            break;
                          case S.OPS.setMiterLimit:
                            this.setMiterLimit(m[0]);
                            break;
                          case S.OPS.setFillRGBColor:
                            this.setFillRGBColor(m[0], m[1], m[2]);
                            break;
                          case S.OPS.setStrokeRGBColor:
                            this.setStrokeRGBColor(m[0], m[1], m[2]);
                            break;
                          case S.OPS.setStrokeColorN:
                            this.setStrokeColorN(m);
                            break;
                          case S.OPS.setFillColorN:
                            this.setFillColorN(m);
                            break;
                          case S.OPS.shadingFill:
                            this.shadingFill(m[0]);
                            break;
                          case S.OPS.setDash:
                            this.setDash(m[0], m[1]);
                            break;
                          case S.OPS.setRenderingIntent:
                            this.setRenderingIntent(m[0]);
                            break;
                          case S.OPS.setFlatness:
                            this.setFlatness(m[0]);
                            break;
                          case S.OPS.setGState:
                            this.setGState(m[0]);
                            break;
                          case S.OPS.fill:
                            this.fill();
                            break;
                          case S.OPS.eoFill:
                            this.eoFill();
                            break;
                          case S.OPS.stroke:
                            this.stroke();
                            break;
                          case S.OPS.fillStroke:
                            this.fillStroke();
                            break;
                          case S.OPS.eoFillStroke:
                            this.eoFillStroke();
                            break;
                          case S.OPS.clip:
                            this.clip("nonzero");
                            break;
                          case S.OPS.eoClip:
                            this.clip("evenodd");
                            break;
                          case S.OPS.paintSolidColorImageMask:
                            this.paintSolidColorImageMask();
                            break;
                          case S.OPS.paintImageXObject:
                            this.paintImageXObject(m[0]);
                            break;
                          case S.OPS.paintInlineImageXObject:
                            this.paintInlineImageXObject(m[0]);
                            break;
                          case S.OPS.paintImageMaskXObject:
                            this.paintImageMaskXObject(m[0]);
                            break;
                          case S.OPS.paintFormXObjectBegin:
                            this.paintFormXObjectBegin(m[0], m[1]);
                            break;
                          case S.OPS.paintFormXObjectEnd:
                            this.paintFormXObjectEnd();
                            break;
                          case S.OPS.closePath:
                            this.closePath();
                            break;
                          case S.OPS.closeStroke:
                            this.closeStroke();
                            break;
                          case S.OPS.closeFillStroke:
                            this.closeFillStroke();
                            break;
                          case S.OPS.closeEOFillStroke:
                            this.closeEOFillStroke();
                            break;
                          case S.OPS.nextLine:
                            this.nextLine();
                            break;
                          case S.OPS.transform:
                            this.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                            break;
                          case S.OPS.constructPath:
                            this.constructPath(m[0], m[1]);
                            break;
                          case S.OPS.endPath:
                            this.endPath();
                            break;
                          case 92:
                            this.group(b.items);
                            break;
                          default:
                            (0, S.warn)(`Unimplemented operator ${c}`);
                            break;
                        }
                      }
                    }
                    setWordSpacing(f) {
                      this.current.wordSpacing = f;
                    }
                    setCharSpacing(f) {
                      this.current.charSpacing = f;
                    }
                    nextLine() {
                      this.moveText(0, this.current.leading);
                    }
                    setTextMatrix(f, b, c, a, m, C) {
                      const e = this.current;
                      ((e.textMatrix = e.lineMatrix = [f, b, c, a, m, C]),
                        (e.textMatrixScale = Math.hypot(f, b)),
                        (e.x = e.lineX = 0),
                        (e.y = e.lineY = 0),
                        (e.xcoords = []),
                        (e.ycoords = []),
                        (e.tspan = this.svgFactory.createElement("svg:tspan")),
                        e.tspan.setAttributeNS(
                          null,
                          "font-family",
                          e.fontFamily,
                        ),
                        e.tspan.setAttributeNS(
                          null,
                          "font-size",
                          `${h(e.fontSize)}px`,
                        ),
                        e.tspan.setAttributeNS(null, "y", h(-e.y)),
                        (e.txtElement =
                          this.svgFactory.createElement("svg:text")),
                        e.txtElement.append(e.tspan));
                    }
                    beginText() {
                      const f = this.current;
                      ((f.x = f.lineX = 0),
                        (f.y = f.lineY = 0),
                        (f.textMatrix = S.IDENTITY_MATRIX),
                        (f.lineMatrix = S.IDENTITY_MATRIX),
                        (f.textMatrixScale = 1),
                        (f.tspan = this.svgFactory.createElement("svg:tspan")),
                        (f.txtElement =
                          this.svgFactory.createElement("svg:text")),
                        (f.txtgrp = this.svgFactory.createElement("svg:g")),
                        (f.xcoords = []),
                        (f.ycoords = []));
                    }
                    moveText(f, b) {
                      const c = this.current;
                      ((c.x = c.lineX += f),
                        (c.y = c.lineY += b),
                        (c.xcoords = []),
                        (c.ycoords = []),
                        (c.tspan = this.svgFactory.createElement("svg:tspan")),
                        c.tspan.setAttributeNS(
                          null,
                          "font-family",
                          c.fontFamily,
                        ),
                        c.tspan.setAttributeNS(
                          null,
                          "font-size",
                          `${h(c.fontSize)}px`,
                        ),
                        c.tspan.setAttributeNS(null, "y", h(-c.y)));
                    }
                    showText(f) {
                      const b = this.current,
                        c = b.font,
                        a = b.fontSize;
                      if (a === 0) return;
                      const m = b.fontSizeScale,
                        C = b.charSpacing,
                        e = b.wordSpacing,
                        o = b.fontDirection,
                        y = b.textHScale * o,
                        B = c.vertical,
                        M = B ? 1 : -1,
                        D = c.defaultVMetrics,
                        x = a * b.fontMatrix[0];
                      let z = 0;
                      for (const Y of f) {
                        if (Y === null) {
                          z += o * e;
                          continue;
                        } else if (typeof Y == "number") {
                          z += (M * Y * a) / 1e3;
                          continue;
                        }
                        const T = (Y.isSpace ? e : 0) + C,
                          s = Y.fontChar;
                        let g,
                          R,
                          $ = Y.width;
                        if (B) {
                          let U;
                          const Q = Y.vmetric || D;
                          ((U = Y.vmetric ? Q[1] : $ * 0.5), (U = -U * x));
                          const fe = Q[2] * x;
                          (($ = Q ? -Q[0] : $),
                            (g = U / m),
                            (R = (z + fe) / m));
                        } else ((g = z / m), (R = 0));
                        (Y.isInFont || c.missingFile) &&
                          (b.xcoords.push(b.x + g),
                          B && b.ycoords.push(-b.y + R),
                          (b.tspan.textContent += s));
                        const j = B ? $ * x - T * o : $ * x + T * o;
                        z += j;
                      }
                      (b.tspan.setAttributeNS(
                        null,
                        "x",
                        b.xcoords.map(h).join(" "),
                      ),
                        B
                          ? b.tspan.setAttributeNS(
                              null,
                              "y",
                              b.ycoords.map(h).join(" "),
                            )
                          : b.tspan.setAttributeNS(null, "y", h(-b.y)),
                        B ? (b.y -= z) : (b.x += z * y),
                        b.tspan.setAttributeNS(
                          null,
                          "font-family",
                          b.fontFamily,
                        ),
                        b.tspan.setAttributeNS(
                          null,
                          "font-size",
                          `${h(b.fontSize)}px`,
                        ),
                        b.fontStyle !== i.fontStyle &&
                          b.tspan.setAttributeNS(
                            null,
                            "font-style",
                            b.fontStyle,
                          ),
                        b.fontWeight !== i.fontWeight &&
                          b.tspan.setAttributeNS(
                            null,
                            "font-weight",
                            b.fontWeight,
                          ));
                      const L =
                        b.textRenderingMode &
                        S.TextRenderingMode.FILL_STROKE_MASK;
                      if (
                        (L === S.TextRenderingMode.FILL ||
                        L === S.TextRenderingMode.FILL_STROKE
                          ? (b.fillColor !== i.fillColor &&
                              b.tspan.setAttributeNS(null, "fill", b.fillColor),
                            b.fillAlpha < 1 &&
                              b.tspan.setAttributeNS(
                                null,
                                "fill-opacity",
                                b.fillAlpha,
                              ))
                          : b.textRenderingMode ===
                              S.TextRenderingMode.ADD_TO_PATH
                            ? b.tspan.setAttributeNS(
                                null,
                                "fill",
                                "transparent",
                              )
                            : b.tspan.setAttributeNS(null, "fill", "none"),
                        L === S.TextRenderingMode.STROKE ||
                          L === S.TextRenderingMode.FILL_STROKE)
                      ) {
                        const Y = 1 / (b.textMatrixScale || 1);
                        this._setStrokeAttributes(b.tspan, Y);
                      }
                      let V = b.textMatrix;
                      (b.textRise !== 0 &&
                        ((V = V.slice()), (V[5] += b.textRise)),
                        b.txtElement.setAttributeNS(
                          null,
                          "transform",
                          `${r(V)} scale(${h(y)}, -1)`,
                        ),
                        b.txtElement.setAttributeNS(H, "xml:space", "preserve"),
                        b.txtElement.append(b.tspan),
                        b.txtgrp.append(b.txtElement),
                        this._ensureTransformGroup().append(b.txtElement));
                    }
                    setLeadingMoveText(f, b) {
                      (this.setLeading(-b), this.moveText(f, b));
                    }
                    addFontStyle(f) {
                      if (!f.data)
                        throw new Error(
                          'addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.',
                        );
                      this.cssStyle ||
                        ((this.cssStyle =
                          this.svgFactory.createElement("svg:style")),
                        this.cssStyle.setAttributeNS(null, "type", "text/css"),
                        this.defs.append(this.cssStyle));
                      const b = k(f.data, f.mimetype, this.forceDataSchema);
                      this.cssStyle.textContent += `@font-face { font-family: "${f.loadedName}"; src: url(${b}); }
`;
                    }
                    setFont(f) {
                      const b = this.current,
                        c = this.commonObjs.get(f[0]);
                      let a = f[1];
                      ((b.font = c),
                        this.embedFonts &&
                          !c.missingFile &&
                          !this.embeddedFonts[c.loadedName] &&
                          (this.addFontStyle(c),
                          (this.embeddedFonts[c.loadedName] = c)),
                        (b.fontMatrix =
                          c.fontMatrix || S.FONT_IDENTITY_MATRIX));
                      let m = "normal";
                      c.black ? (m = "900") : c.bold && (m = "bold");
                      const C = c.italic ? "italic" : "normal";
                      (a < 0
                        ? ((a = -a), (b.fontDirection = -1))
                        : (b.fontDirection = 1),
                        (b.fontSize = a),
                        (b.fontFamily = c.loadedName),
                        (b.fontWeight = m),
                        (b.fontStyle = C),
                        (b.tspan = this.svgFactory.createElement("svg:tspan")),
                        b.tspan.setAttributeNS(null, "y", h(-b.y)),
                        (b.xcoords = []),
                        (b.ycoords = []));
                    }
                    endText() {
                      var b;
                      const f = this.current;
                      f.textRenderingMode &
                        S.TextRenderingMode.ADD_TO_PATH_FLAG &&
                        (b = f.txtElement) != null &&
                        b.hasChildNodes() &&
                        ((f.element = f.txtElement),
                        this.clip("nonzero"),
                        this.endPath());
                    }
                    setLineWidth(f) {
                      f > 0 && (this.current.lineWidth = f);
                    }
                    setLineCap(f) {
                      this.current.lineCap = X[f];
                    }
                    setLineJoin(f) {
                      this.current.lineJoin = W[f];
                    }
                    setMiterLimit(f) {
                      this.current.miterLimit = f;
                    }
                    setStrokeAlpha(f) {
                      this.current.strokeAlpha = f;
                    }
                    setStrokeRGBColor(f, b, c) {
                      this.current.strokeColor = S.Util.makeHexColor(f, b, c);
                    }
                    setFillAlpha(f) {
                      this.current.fillAlpha = f;
                    }
                    setFillRGBColor(f, b, c) {
                      ((this.current.fillColor = S.Util.makeHexColor(f, b, c)),
                        (this.current.tspan =
                          this.svgFactory.createElement("svg:tspan")),
                        (this.current.xcoords = []),
                        (this.current.ycoords = []));
                    }
                    setStrokeColorN(f) {
                      this.current.strokeColor = this._makeColorN_Pattern(f);
                    }
                    setFillColorN(f) {
                      this.current.fillColor = this._makeColorN_Pattern(f);
                    }
                    shadingFill(f) {
                      const { width: b, height: c } = this.viewport,
                        a = S.Util.inverseTransform(this.transformMatrix),
                        [m, C, e, o] = S.Util.getAxialAlignedBoundingBox(
                          [0, 0, b, c],
                          a,
                        ),
                        y = this.svgFactory.createElement("svg:rect");
                      (y.setAttributeNS(null, "x", m),
                        y.setAttributeNS(null, "y", C),
                        y.setAttributeNS(null, "width", e - m),
                        y.setAttributeNS(null, "height", o - C),
                        y.setAttributeNS(
                          null,
                          "fill",
                          this._makeShadingPattern(f),
                        ),
                        this.current.fillAlpha < 1 &&
                          y.setAttributeNS(
                            null,
                            "fill-opacity",
                            this.current.fillAlpha,
                          ),
                        this._ensureTransformGroup().append(y));
                    }
                    _makeColorN_Pattern(f) {
                      return f[0] === "TilingPattern"
                        ? this._makeTilingPattern(f)
                        : this._makeShadingPattern(f);
                    }
                    _makeTilingPattern(f) {
                      const b = f[1],
                        c = f[2],
                        a = f[3] || S.IDENTITY_MATRIX,
                        [m, C, e, o] = f[4],
                        y = f[5],
                        B = f[6],
                        M = f[7],
                        D = `shading${u++}`,
                        [x, z, L, V] = S.Util.normalizeRect([
                          ...S.Util.applyTransform([m, C], a),
                          ...S.Util.applyTransform([e, o], a),
                        ]),
                        [Y, T] = S.Util.singularValueDecompose2dScale(a),
                        s = y * Y,
                        g = B * T,
                        R = this.svgFactory.createElement("svg:pattern");
                      (R.setAttributeNS(null, "id", D),
                        R.setAttributeNS(
                          null,
                          "patternUnits",
                          "userSpaceOnUse",
                        ),
                        R.setAttributeNS(null, "width", s),
                        R.setAttributeNS(null, "height", g),
                        R.setAttributeNS(null, "x", `${x}`),
                        R.setAttributeNS(null, "y", `${z}`));
                      const $ = this.svg,
                        j = this.transformMatrix,
                        U = this.current.fillColor,
                        Q = this.current.strokeColor,
                        fe = this.svgFactory.create(L - x, V - z);
                      if (
                        ((this.svg = fe), (this.transformMatrix = a), M === 2)
                      ) {
                        const we = S.Util.makeHexColor(...b);
                        ((this.current.fillColor = we),
                          (this.current.strokeColor = we));
                      }
                      return (
                        this.executeOpTree(this.convertOpList(c)),
                        (this.svg = $),
                        (this.transformMatrix = j),
                        (this.current.fillColor = U),
                        (this.current.strokeColor = Q),
                        R.append(fe.childNodes[0]),
                        this.defs.append(R),
                        `url(#${D})`
                      );
                    }
                    _makeShadingPattern(f) {
                      switch (
                        (typeof f == "string" && (f = this.objs.get(f)), f[0])
                      ) {
                        case "RadialAxial":
                          const b = `shading${u++}`,
                            c = f[3];
                          let a;
                          switch (f[1]) {
                            case "axial":
                              const m = f[4],
                                C = f[5];
                              ((a =
                                this.svgFactory.createElement(
                                  "svg:linearGradient",
                                )),
                                a.setAttributeNS(null, "id", b),
                                a.setAttributeNS(
                                  null,
                                  "gradientUnits",
                                  "userSpaceOnUse",
                                ),
                                a.setAttributeNS(null, "x1", m[0]),
                                a.setAttributeNS(null, "y1", m[1]),
                                a.setAttributeNS(null, "x2", C[0]),
                                a.setAttributeNS(null, "y2", C[1]));
                              break;
                            case "radial":
                              const e = f[4],
                                o = f[5],
                                y = f[6],
                                B = f[7];
                              ((a =
                                this.svgFactory.createElement(
                                  "svg:radialGradient",
                                )),
                                a.setAttributeNS(null, "id", b),
                                a.setAttributeNS(
                                  null,
                                  "gradientUnits",
                                  "userSpaceOnUse",
                                ),
                                a.setAttributeNS(null, "cx", o[0]),
                                a.setAttributeNS(null, "cy", o[1]),
                                a.setAttributeNS(null, "r", B),
                                a.setAttributeNS(null, "fx", e[0]),
                                a.setAttributeNS(null, "fy", e[1]),
                                a.setAttributeNS(null, "fr", y));
                              break;
                            default:
                              throw new Error(
                                `Unknown RadialAxial type: ${f[1]}`,
                              );
                          }
                          for (const m of c) {
                            const C = this.svgFactory.createElement("svg:stop");
                            (C.setAttributeNS(null, "offset", m[0]),
                              C.setAttributeNS(null, "stop-color", m[1]),
                              a.append(C));
                          }
                          return (this.defs.append(a), `url(#${b})`);
                        case "Mesh":
                          return (
                            (0, S.warn)("Unimplemented pattern Mesh"),
                            null
                          );
                        case "Dummy":
                          return "hotpink";
                        default:
                          throw new Error(`Unknown IR type: ${f[0]}`);
                      }
                    }
                    setDash(f, b) {
                      ((this.current.dashArray = f),
                        (this.current.dashPhase = b));
                    }
                    constructPath(f, b) {
                      const c = this.current;
                      let a = c.x,
                        m = c.y,
                        C = [],
                        e = 0;
                      for (const o of f)
                        switch (o | 0) {
                          case S.OPS.rectangle:
                            ((a = b[e++]), (m = b[e++]));
                            const y = b[e++],
                              B = b[e++],
                              M = a + y,
                              D = m + B;
                            C.push(
                              "M",
                              h(a),
                              h(m),
                              "L",
                              h(M),
                              h(m),
                              "L",
                              h(M),
                              h(D),
                              "L",
                              h(a),
                              h(D),
                              "Z",
                            );
                            break;
                          case S.OPS.moveTo:
                            ((a = b[e++]),
                              (m = b[e++]),
                              C.push("M", h(a), h(m)));
                            break;
                          case S.OPS.lineTo:
                            ((a = b[e++]),
                              (m = b[e++]),
                              C.push("L", h(a), h(m)));
                            break;
                          case S.OPS.curveTo:
                            ((a = b[e + 4]),
                              (m = b[e + 5]),
                              C.push(
                                "C",
                                h(b[e]),
                                h(b[e + 1]),
                                h(b[e + 2]),
                                h(b[e + 3]),
                                h(a),
                                h(m),
                              ),
                              (e += 6));
                            break;
                          case S.OPS.curveTo2:
                            (C.push(
                              "C",
                              h(a),
                              h(m),
                              h(b[e]),
                              h(b[e + 1]),
                              h(b[e + 2]),
                              h(b[e + 3]),
                            ),
                              (a = b[e + 2]),
                              (m = b[e + 3]),
                              (e += 4));
                            break;
                          case S.OPS.curveTo3:
                            ((a = b[e + 2]),
                              (m = b[e + 3]),
                              C.push(
                                "C",
                                h(b[e]),
                                h(b[e + 1]),
                                h(a),
                                h(m),
                                h(a),
                                h(m),
                              ),
                              (e += 4));
                            break;
                          case S.OPS.closePath:
                            C.push("Z");
                            break;
                        }
                      ((C = C.join(" ")),
                        c.path &&
                        f.length > 0 &&
                        f[0] !== S.OPS.rectangle &&
                        f[0] !== S.OPS.moveTo
                          ? (C = c.path.getAttributeNS(null, "d") + C)
                          : ((c.path =
                              this.svgFactory.createElement("svg:path")),
                            this._ensureTransformGroup().append(c.path)),
                        c.path.setAttributeNS(null, "d", C),
                        c.path.setAttributeNS(null, "fill", "none"),
                        (c.element = c.path),
                        c.setCurrentPoint(a, m));
                    }
                    endPath() {
                      const f = this.current;
                      if (((f.path = null), !this.pendingClip)) return;
                      if (!f.element) {
                        this.pendingClip = null;
                        return;
                      }
                      const b = `clippath${d++}`,
                        c = this.svgFactory.createElement("svg:clipPath");
                      (c.setAttributeNS(null, "id", b),
                        c.setAttributeNS(
                          null,
                          "transform",
                          r(this.transformMatrix),
                        ));
                      const a = f.element.cloneNode(!0);
                      if (
                        (this.pendingClip === "evenodd"
                          ? a.setAttributeNS(null, "clip-rule", "evenodd")
                          : a.setAttributeNS(null, "clip-rule", "nonzero"),
                        (this.pendingClip = null),
                        c.append(a),
                        this.defs.append(c),
                        f.activeClipUrl)
                      ) {
                        f.clipGroup = null;
                        for (const m of this.extraStack) m.clipGroup = null;
                        c.setAttributeNS(null, "clip-path", f.activeClipUrl);
                      }
                      ((f.activeClipUrl = `url(#${b})`), (this.tgrp = null));
                    }
                    clip(f) {
                      this.pendingClip = f;
                    }
                    closePath() {
                      const f = this.current;
                      if (f.path) {
                        const b = `${f.path.getAttributeNS(null, "d")}Z`;
                        f.path.setAttributeNS(null, "d", b);
                      }
                    }
                    setLeading(f) {
                      this.current.leading = -f;
                    }
                    setTextRise(f) {
                      this.current.textRise = f;
                    }
                    setTextRenderingMode(f) {
                      this.current.textRenderingMode = f;
                    }
                    setHScale(f) {
                      this.current.textHScale = f / 100;
                    }
                    setRenderingIntent(f) {}
                    setFlatness(f) {}
                    setGState(f) {
                      for (const [b, c] of f)
                        switch (b) {
                          case "LW":
                            this.setLineWidth(c);
                            break;
                          case "LC":
                            this.setLineCap(c);
                            break;
                          case "LJ":
                            this.setLineJoin(c);
                            break;
                          case "ML":
                            this.setMiterLimit(c);
                            break;
                          case "D":
                            this.setDash(c[0], c[1]);
                            break;
                          case "RI":
                            this.setRenderingIntent(c);
                            break;
                          case "FL":
                            this.setFlatness(c);
                            break;
                          case "Font":
                            this.setFont(c);
                            break;
                          case "CA":
                            this.setStrokeAlpha(c);
                            break;
                          case "ca":
                            this.setFillAlpha(c);
                            break;
                          default:
                            (0, S.warn)(
                              `Unimplemented graphic state operator ${b}`,
                            );
                            break;
                        }
                    }
                    fill() {
                      const f = this.current;
                      f.element &&
                        (f.element.setAttributeNS(null, "fill", f.fillColor),
                        f.element.setAttributeNS(
                          null,
                          "fill-opacity",
                          f.fillAlpha,
                        ),
                        this.endPath());
                    }
                    stroke() {
                      const f = this.current;
                      f.element &&
                        (this._setStrokeAttributes(f.element),
                        f.element.setAttributeNS(null, "fill", "none"),
                        this.endPath());
                    }
                    _setStrokeAttributes(f, b = 1) {
                      const c = this.current;
                      let a = c.dashArray;
                      (b !== 1 &&
                        a.length > 0 &&
                        (a = a.map(function (m) {
                          return b * m;
                        })),
                        f.setAttributeNS(null, "stroke", c.strokeColor),
                        f.setAttributeNS(null, "stroke-opacity", c.strokeAlpha),
                        f.setAttributeNS(
                          null,
                          "stroke-miterlimit",
                          h(c.miterLimit),
                        ),
                        f.setAttributeNS(null, "stroke-linecap", c.lineCap),
                        f.setAttributeNS(null, "stroke-linejoin", c.lineJoin),
                        f.setAttributeNS(
                          null,
                          "stroke-width",
                          h(b * c.lineWidth) + "px",
                        ),
                        f.setAttributeNS(
                          null,
                          "stroke-dasharray",
                          a.map(h).join(" "),
                        ),
                        f.setAttributeNS(
                          null,
                          "stroke-dashoffset",
                          h(b * c.dashPhase) + "px",
                        ));
                    }
                    eoFill() {
                      var f;
                      ((f = this.current.element) == null ||
                        f.setAttributeNS(null, "fill-rule", "evenodd"),
                        this.fill());
                    }
                    fillStroke() {
                      (this.stroke(), this.fill());
                    }
                    eoFillStroke() {
                      var f;
                      ((f = this.current.element) == null ||
                        f.setAttributeNS(null, "fill-rule", "evenodd"),
                        this.fillStroke());
                    }
                    closeStroke() {
                      (this.closePath(), this.stroke());
                    }
                    closeFillStroke() {
                      (this.closePath(), this.fillStroke());
                    }
                    closeEOFillStroke() {
                      (this.closePath(), this.eoFillStroke());
                    }
                    paintSolidColorImageMask() {
                      const f = this.svgFactory.createElement("svg:rect");
                      (f.setAttributeNS(null, "x", "0"),
                        f.setAttributeNS(null, "y", "0"),
                        f.setAttributeNS(null, "width", "1px"),
                        f.setAttributeNS(null, "height", "1px"),
                        f.setAttributeNS(null, "fill", this.current.fillColor),
                        this._ensureTransformGroup().append(f));
                    }
                    paintImageXObject(f) {
                      const b = this.getObject(f);
                      if (!b) {
                        (0, S.warn)(
                          `Dependent image with object ID ${f} is not ready yet`,
                        );
                        return;
                      }
                      this.paintInlineImageXObject(b);
                    }
                    paintInlineImageXObject(f, b) {
                      const c = f.width,
                        a = f.height,
                        m = N(f, this.forceDataSchema, !!b),
                        C = this.svgFactory.createElement("svg:rect");
                      (C.setAttributeNS(null, "x", "0"),
                        C.setAttributeNS(null, "y", "0"),
                        C.setAttributeNS(null, "width", h(c)),
                        C.setAttributeNS(null, "height", h(a)),
                        (this.current.element = C),
                        this.clip("nonzero"));
                      const e = this.svgFactory.createElement("svg:image");
                      (e.setAttributeNS(ee, "xlink:href", m),
                        e.setAttributeNS(null, "x", "0"),
                        e.setAttributeNS(null, "y", h(-a)),
                        e.setAttributeNS(null, "width", h(c) + "px"),
                        e.setAttributeNS(null, "height", h(a) + "px"),
                        e.setAttributeNS(
                          null,
                          "transform",
                          `scale(${h(1 / c)} ${h(-1 / a)})`,
                        ),
                        b
                          ? b.append(e)
                          : this._ensureTransformGroup().append(e));
                    }
                    paintImageMaskXObject(f) {
                      const b = this.getObject(f.data, f);
                      if (b.bitmap) {
                        (0, S.warn)(
                          "paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.",
                        );
                        return;
                      }
                      const c = this.current,
                        a = b.width,
                        m = b.height,
                        C = c.fillColor;
                      c.maskId = `mask${p++}`;
                      const e = this.svgFactory.createElement("svg:mask");
                      e.setAttributeNS(null, "id", c.maskId);
                      const o = this.svgFactory.createElement("svg:rect");
                      (o.setAttributeNS(null, "x", "0"),
                        o.setAttributeNS(null, "y", "0"),
                        o.setAttributeNS(null, "width", h(a)),
                        o.setAttributeNS(null, "height", h(m)),
                        o.setAttributeNS(null, "fill", C),
                        o.setAttributeNS(null, "mask", `url(#${c.maskId})`),
                        this.defs.append(e),
                        this._ensureTransformGroup().append(o),
                        this.paintInlineImageXObject(b, e));
                    }
                    paintFormXObjectBegin(f, b) {
                      if (
                        (Array.isArray(f) &&
                          f.length === 6 &&
                          this.transform(f[0], f[1], f[2], f[3], f[4], f[5]),
                        b)
                      ) {
                        const c = b[2] - b[0],
                          a = b[3] - b[1],
                          m = this.svgFactory.createElement("svg:rect");
                        (m.setAttributeNS(null, "x", b[0]),
                          m.setAttributeNS(null, "y", b[1]),
                          m.setAttributeNS(null, "width", h(c)),
                          m.setAttributeNS(null, "height", h(a)),
                          (this.current.element = m),
                          this.clip("nonzero"),
                          this.endPath());
                      }
                    }
                    paintFormXObjectEnd() {}
                    _initialize(f) {
                      const b = this.svgFactory.create(f.width, f.height),
                        c = this.svgFactory.createElement("svg:defs");
                      (b.append(c), (this.defs = c));
                      const a = this.svgFactory.createElement("svg:g");
                      return (
                        a.setAttributeNS(null, "transform", r(f.transform)),
                        b.append(a),
                        (this.svg = a),
                        b
                      );
                    }
                    _ensureClipGroup() {
                      if (!this.current.clipGroup) {
                        const f = this.svgFactory.createElement("svg:g");
                        (f.setAttributeNS(
                          null,
                          "clip-path",
                          this.current.activeClipUrl,
                        ),
                          this.svg.append(f),
                          (this.current.clipGroup = f));
                      }
                      return this.current.clipGroup;
                    }
                    _ensureTransformGroup() {
                      return (
                        this.tgrp ||
                          ((this.tgrp = this.svgFactory.createElement("svg:g")),
                          this.tgrp.setAttributeNS(
                            null,
                            "transform",
                            r(this.transformMatrix),
                          ),
                          this.current.activeClipUrl
                            ? this._ensureClipGroup().append(this.tgrp)
                            : this.svg.append(this.tgrp)),
                        this.tgrp
                      );
                    }
                  }
                  A.SVGGraphics = F;
                },
                (t, A) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.XfaText = void 0));
                  class n {
                    static textContent(S) {
                      const i = [],
                        H = { items: i, styles: Object.create(null) };
                      function ee(X) {
                        var N;
                        if (!X) return;
                        let W = null;
                        const k = X.name;
                        if (k === "#text") W = X.value;
                        else if (n.shouldBuildText(k))
                          (N = X == null ? void 0 : X.attributes) != null &&
                          N.textContent
                            ? (W = X.attributes.textContent)
                            : X.value && (W = X.value);
                        else return;
                        if ((W !== null && i.push({ str: W }), !!X.children))
                          for (const P of X.children) ee(P);
                      }
                      return (ee(S), H);
                    }
                    static shouldBuildText(S) {
                      return !(
                        S === "textarea" ||
                        S === "input" ||
                        S === "option" ||
                        S === "select"
                      );
                    }
                  }
                  A.XfaText = n;
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.TextLayerRenderTask = void 0),
                    (A.renderTextLayer = r),
                    (A.updateTextLayer = d));
                  var w = n(1),
                    S = n(6);
                  const i = 1e5,
                    H = 30,
                    ee = 0.8,
                    X = new Map();
                  function W(p, u) {
                    let F;
                    if (u && w.FeatureTest.isOffscreenCanvasSupported)
                      F = new OffscreenCanvas(p, p).getContext("2d", {
                        alpha: !1,
                      });
                    else {
                      const v = document.createElement("canvas");
                      ((v.width = v.height = p),
                        (F = v.getContext("2d", { alpha: !1 })));
                    }
                    return F;
                  }
                  function k(p, u) {
                    const F = X.get(p);
                    if (F) return F;
                    const v = W(H, u);
                    v.font = `${H}px ${p}`;
                    const f = v.measureText("");
                    let b = f.fontBoundingBoxAscent,
                      c = Math.abs(f.fontBoundingBoxDescent);
                    if (b) {
                      const m = b / (b + c);
                      return (
                        X.set(p, m),
                        (v.canvas.width = v.canvas.height = 0),
                        m
                      );
                    }
                    ((v.strokeStyle = "red"),
                      v.clearRect(0, 0, H, H),
                      v.strokeText("g", 0, 0));
                    let a = v.getImageData(0, 0, H, H).data;
                    c = 0;
                    for (let m = a.length - 1 - 3; m >= 0; m -= 4)
                      if (a[m] > 0) {
                        c = Math.ceil(m / 4 / H);
                        break;
                      }
                    (v.clearRect(0, 0, H, H),
                      v.strokeText("A", 0, H),
                      (a = v.getImageData(0, 0, H, H).data),
                      (b = 0));
                    for (let m = 0, C = a.length; m < C; m += 4)
                      if (a[m] > 0) {
                        b = H - Math.floor(m / 4 / H);
                        break;
                      }
                    if (((v.canvas.width = v.canvas.height = 0), b)) {
                      const m = b / (b + c);
                      return (X.set(p, m), m);
                    }
                    return (X.set(p, ee), ee);
                  }
                  function N(p, u, F) {
                    const v = document.createElement("span"),
                      f = {
                        angle: 0,
                        canvasWidth: 0,
                        hasText: u.str !== "",
                        hasEOL: u.hasEOL,
                        fontSize: 0,
                      };
                    p._textDivs.push(v);
                    const b = w.Util.transform(p._transform, u.transform);
                    let c = Math.atan2(b[1], b[0]);
                    const a = F[u.fontName];
                    a.vertical && (c += Math.PI / 2);
                    const m = Math.hypot(b[2], b[3]),
                      C = m * k(a.fontFamily, p._isOffscreenCanvasSupported);
                    let e, o;
                    c === 0
                      ? ((e = b[4]), (o = b[5] - C))
                      : ((e = b[4] + C * Math.sin(c)),
                        (o = b[5] - C * Math.cos(c)));
                    const y = "calc(var(--scale-factor)*",
                      B = v.style;
                    (p._container === p._rootContainer
                      ? ((B.left = `${((100 * e) / p._pageWidth).toFixed(2)}%`),
                        (B.top = `${((100 * o) / p._pageHeight).toFixed(2)}%`))
                      : ((B.left = `${y}${e.toFixed(2)}px)`),
                        (B.top = `${y}${o.toFixed(2)}px)`)),
                      (B.fontSize = `${y}${m.toFixed(2)}px)`),
                      (B.fontFamily = a.fontFamily),
                      (f.fontSize = m),
                      v.setAttribute("role", "presentation"),
                      (v.textContent = u.str),
                      (v.dir = u.dir),
                      p._fontInspectorEnabled &&
                        (v.dataset.fontName = u.fontName),
                      c !== 0 && (f.angle = c * (180 / Math.PI)));
                    let M = !1;
                    if (u.str.length > 1) M = !0;
                    else if (
                      u.str !== " " &&
                      u.transform[0] !== u.transform[3]
                    ) {
                      const D = Math.abs(u.transform[0]),
                        x = Math.abs(u.transform[3]);
                      D !== x &&
                        Math.max(D, x) / Math.min(D, x) > 1.5 &&
                        (M = !0);
                    }
                    (M && (f.canvasWidth = a.vertical ? u.height : u.width),
                      p._textDivProperties.set(v, f),
                      p._isReadableStream && p._layoutText(v));
                  }
                  function P(p) {
                    const {
                        div: u,
                        scale: F,
                        properties: v,
                        ctx: f,
                        prevFontSize: b,
                        prevFontFamily: c,
                      } = p,
                      { style: a } = u;
                    let m = "";
                    if (v.canvasWidth !== 0 && v.hasText) {
                      const { fontFamily: C } = a,
                        { canvasWidth: e, fontSize: o } = v;
                      (b !== o || c !== C) &&
                        ((f.font = `${o * F}px ${C}`),
                        (p.prevFontSize = o),
                        (p.prevFontFamily = C));
                      const { width: y } = f.measureText(u.textContent);
                      y > 0 && (m = `scaleX(${(e * F) / y})`);
                    }
                    (v.angle !== 0 && (m = `rotate(${v.angle}deg) ${m}`),
                      m.length > 0 && (a.transform = m));
                  }
                  function _(p) {
                    if (p._canceled) return;
                    const u = p._textDivs,
                      F = p._capability;
                    if (u.length > i) {
                      F.resolve();
                      return;
                    }
                    if (!p._isReadableStream)
                      for (const f of u) p._layoutText(f);
                    F.resolve();
                  }
                  class h {
                    constructor({
                      textContentSource: u,
                      container: F,
                      viewport: v,
                      textDivs: f,
                      textDivProperties: b,
                      textContentItemsStr: c,
                      isOffscreenCanvasSupported: a,
                    }) {
                      var y;
                      ((this._textContentSource = u),
                        (this._isReadableStream = u instanceof ReadableStream),
                        (this._container = this._rootContainer = F),
                        (this._textDivs = f || []),
                        (this._textContentItemsStr = c || []),
                        (this._isOffscreenCanvasSupported = a),
                        (this._fontInspectorEnabled = !!(
                          (y = globalThis.FontInspector) != null && y.enabled
                        )),
                        (this._reader = null),
                        (this._textDivProperties = b || new WeakMap()),
                        (this._canceled = !1),
                        (this._capability = new w.PromiseCapability()),
                        (this._layoutTextParams = {
                          prevFontSize: null,
                          prevFontFamily: null,
                          div: null,
                          scale: v.scale * (globalThis.devicePixelRatio || 1),
                          properties: null,
                          ctx: W(0, a),
                        }));
                      const {
                        pageWidth: m,
                        pageHeight: C,
                        pageX: e,
                        pageY: o,
                      } = v.rawDims;
                      ((this._transform = [1, 0, 0, -1, -e, o + C]),
                        (this._pageWidth = m),
                        (this._pageHeight = C),
                        (0, S.setLayerDimensions)(F, v),
                        this._capability.promise
                          .finally(() => {
                            this._layoutTextParams = null;
                          })
                          .catch(() => {}));
                    }
                    get promise() {
                      return this._capability.promise;
                    }
                    cancel() {
                      ((this._canceled = !0),
                        this._reader &&
                          (this._reader
                            .cancel(
                              new w.AbortException("TextLayer task cancelled."),
                            )
                            .catch(() => {}),
                          (this._reader = null)),
                        this._capability.reject(
                          new w.AbortException("TextLayer task cancelled."),
                        ));
                    }
                    _processItems(u, F) {
                      for (const v of u) {
                        if (v.str === void 0) {
                          if (
                            v.type === "beginMarkedContentProps" ||
                            v.type === "beginMarkedContent"
                          ) {
                            const f = this._container;
                            ((this._container = document.createElement("span")),
                              this._container.classList.add("markedContent"),
                              v.id !== null &&
                                this._container.setAttribute("id", `${v.id}`),
                              f.append(this._container));
                          } else
                            v.type === "endMarkedContent" &&
                              (this._container = this._container.parentNode);
                          continue;
                        }
                        (this._textContentItemsStr.push(v.str), N(this, v, F));
                      }
                    }
                    _layoutText(u) {
                      const F = (this._layoutTextParams.properties =
                        this._textDivProperties.get(u));
                      if (
                        ((this._layoutTextParams.div = u),
                        P(this._layoutTextParams),
                        F.hasText && this._container.append(u),
                        F.hasEOL)
                      ) {
                        const v = document.createElement("br");
                        (v.setAttribute("role", "presentation"),
                          this._container.append(v));
                      }
                    }
                    _render() {
                      const u = new w.PromiseCapability();
                      let F = Object.create(null);
                      if (this._isReadableStream) {
                        const v = () => {
                          this._reader.read().then(({ value: f, done: b }) => {
                            if (b) {
                              u.resolve();
                              return;
                            }
                            (Object.assign(F, f.styles),
                              this._processItems(f.items, F),
                              v());
                          }, u.reject);
                        };
                        ((this._reader = this._textContentSource.getReader()),
                          v());
                      } else if (this._textContentSource) {
                        const { items: v, styles: f } = this._textContentSource;
                        (this._processItems(v, f), u.resolve());
                      } else
                        throw new Error(
                          'No "textContentSource" parameter specified.',
                        );
                      u.promise.then(() => {
                        ((F = null), _(this));
                      }, this._capability.reject);
                    }
                  }
                  A.TextLayerRenderTask = h;
                  function r(p) {
                    !p.textContentSource &&
                      (p.textContent || p.textContentStream) &&
                      ((0, S.deprecated)(
                        "The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead.",
                      ),
                      (p.textContentSource =
                        p.textContent || p.textContentStream));
                    const { container: u, viewport: F } = p,
                      v = getComputedStyle(u),
                      f = v.getPropertyValue("visibility"),
                      b = parseFloat(v.getPropertyValue("--scale-factor"));
                    f === "visible" &&
                      (!b || Math.abs(b - F.scale) > 1e-5) &&
                      console.error(
                        "The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.",
                      );
                    const c = new h(p);
                    return (c._render(), c);
                  }
                  function d({
                    container: p,
                    viewport: u,
                    textDivs: F,
                    textDivProperties: v,
                    isOffscreenCanvasSupported: f,
                    mustRotate: b = !0,
                    mustRescale: c = !0,
                  }) {
                    if (
                      (b &&
                        (0, S.setLayerDimensions)(p, { rotation: u.rotation }),
                      c)
                    ) {
                      const a = W(0, f),
                        C = {
                          prevFontSize: null,
                          prevFontFamily: null,
                          div: null,
                          scale: u.scale * (globalThis.devicePixelRatio || 1),
                          properties: null,
                          ctx: a,
                        };
                      for (const e of F)
                        ((C.properties = v.get(e)), (C.div = e), P(C));
                    }
                  }
                },
                (t, A, n) => {
                  var k, N, P, _, h, r, d, p, u, F, v, Gr, lr, Xr, Kr;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.AnnotationEditorLayer = void 0));
                  var w = n(1),
                    S = n(4),
                    i = n(28),
                    H = n(33),
                    ee = n(6),
                    X = n(34);
                  const m = class m {
                    constructor({
                      uiManager: e,
                      pageIndex: o,
                      div: y,
                      accessibilityManager: B,
                      annotationLayer: M,
                      viewport: D,
                      l10n: x,
                    }) {
                      ye(this, v);
                      ye(this, k);
                      ye(this, N, !1);
                      ye(this, P, null);
                      ye(this, _, this.pointerup.bind(this));
                      ye(this, h, this.pointerdown.bind(this));
                      ye(this, r, new Map());
                      ye(this, d, !1);
                      ye(this, p, !1);
                      ye(this, u, !1);
                      ye(this, F);
                      const z = [i.FreeTextEditor, H.InkEditor, X.StampEditor];
                      if (!m._initialized) {
                        m._initialized = !0;
                        for (const L of z) L.initialize(x);
                      }
                      (e.registerEditorTypes(z),
                        Se(this, F, e),
                        (this.pageIndex = o),
                        (this.div = y),
                        Se(this, k, B),
                        Se(this, P, M),
                        (this.viewport = D),
                        l(this, F).addLayer(this));
                    }
                    get isEmpty() {
                      return l(this, r).size === 0;
                    }
                    updateToolbar(e) {
                      l(this, F).updateToolbar(e);
                    }
                    updateMode(e = l(this, F).getMode()) {
                      (le(this, v, Kr).call(this),
                        e === w.AnnotationEditorType.INK
                          ? (this.addInkEditorIfNeeded(!1), this.disableClick())
                          : this.enableClick(),
                        e !== w.AnnotationEditorType.NONE &&
                          (this.div.classList.toggle(
                            "freeTextEditing",
                            e === w.AnnotationEditorType.FREETEXT,
                          ),
                          this.div.classList.toggle(
                            "inkEditing",
                            e === w.AnnotationEditorType.INK,
                          ),
                          this.div.classList.toggle(
                            "stampEditing",
                            e === w.AnnotationEditorType.STAMP,
                          ),
                          (this.div.hidden = !1)));
                    }
                    addInkEditorIfNeeded(e) {
                      if (
                        !e &&
                        l(this, F).getMode() !== w.AnnotationEditorType.INK
                      )
                        return;
                      if (!e) {
                        for (const y of l(this, r).values())
                          if (y.isEmpty()) {
                            y.setInBackground();
                            return;
                          }
                      }
                      le(this, v, lr)
                        .call(this, { offsetX: 0, offsetY: 0 }, !1)
                        .setInBackground();
                    }
                    setEditingState(e) {
                      l(this, F).setEditingState(e);
                    }
                    addCommands(e) {
                      l(this, F).addCommands(e);
                    }
                    enable() {
                      this.div.style.pointerEvents = "auto";
                      const e = new Set();
                      for (const y of l(this, r).values())
                        (y.enableEditing(),
                          y.annotationElementId &&
                            e.add(y.annotationElementId));
                      if (!l(this, P)) return;
                      const o = l(this, P).getEditableAnnotations();
                      for (const y of o) {
                        if (
                          (y.hide(),
                          l(this, F).isDeletedAnnotationElement(y.data.id) ||
                            e.has(y.data.id))
                        )
                          continue;
                        const B = this.deserialize(y);
                        B && (this.addOrRebuild(B), B.enableEditing());
                      }
                    }
                    disable() {
                      var o;
                      (Se(this, u, !0),
                        (this.div.style.pointerEvents = "none"));
                      const e = new Set();
                      for (const y of l(this, r).values()) {
                        if (
                          (y.disableEditing(),
                          !y.annotationElementId || y.serialize() !== null)
                        ) {
                          e.add(y.annotationElementId);
                          continue;
                        }
                        ((o = this.getEditableAnnotation(
                          y.annotationElementId,
                        )) == null || o.show(),
                          y.remove());
                      }
                      if (l(this, P)) {
                        const y = l(this, P).getEditableAnnotations();
                        for (const B of y) {
                          const { id: M } = B.data;
                          e.has(M) ||
                            l(this, F).isDeletedAnnotationElement(M) ||
                            B.show();
                        }
                      }
                      (le(this, v, Kr).call(this),
                        this.isEmpty && (this.div.hidden = !0),
                        Se(this, u, !1));
                    }
                    getEditableAnnotation(e) {
                      var o;
                      return (
                        ((o = l(this, P)) == null
                          ? void 0
                          : o.getEditableAnnotation(e)) || null
                      );
                    }
                    setActiveEditor(e) {
                      l(this, F).getActive() !== e &&
                        l(this, F).setActiveEditor(e);
                    }
                    enableClick() {
                      (this.div.addEventListener("pointerdown", l(this, h)),
                        this.div.addEventListener("pointerup", l(this, _)));
                    }
                    disableClick() {
                      (this.div.removeEventListener("pointerdown", l(this, h)),
                        this.div.removeEventListener("pointerup", l(this, _)));
                    }
                    attach(e) {
                      l(this, r).set(e.id, e);
                      const { annotationElementId: o } = e;
                      o &&
                        l(this, F).isDeletedAnnotationElement(o) &&
                        l(this, F).removeDeletedAnnotationElement(e);
                    }
                    detach(e) {
                      var o;
                      (l(this, r).delete(e.id),
                        (o = l(this, k)) == null ||
                          o.removePointerInTextLayer(e.contentDiv),
                        !l(this, u) &&
                          e.annotationElementId &&
                          l(this, F).addDeletedAnnotationElement(e));
                    }
                    remove(e) {
                      (this.detach(e),
                        l(this, F).removeEditor(e),
                        e.div.contains(document.activeElement) &&
                          setTimeout(() => {
                            l(this, F).focusMainContainer();
                          }, 0),
                        e.div.remove(),
                        (e.isAttachedToDOM = !1),
                        l(this, p) || this.addInkEditorIfNeeded(!1));
                    }
                    changeParent(e) {
                      var o;
                      e.parent !== this &&
                        (e.annotationElementId &&
                          (l(this, F).addDeletedAnnotationElement(
                            e.annotationElementId,
                          ),
                          S.AnnotationEditor.deleteAnnotationElement(e),
                          (e.annotationElementId = null)),
                        this.attach(e),
                        (o = e.parent) == null || o.detach(e),
                        e.setParent(this),
                        e.div &&
                          e.isAttachedToDOM &&
                          (e.div.remove(), this.div.append(e.div)));
                    }
                    add(e) {
                      if (
                        (this.changeParent(e),
                        l(this, F).addEditor(e),
                        this.attach(e),
                        !e.isAttachedToDOM)
                      ) {
                        const o = e.render();
                        (this.div.append(o), (e.isAttachedToDOM = !0));
                      }
                      (e.fixAndSetPosition(),
                        e.onceAdded(),
                        l(this, F).addToAnnotationStorage(e));
                    }
                    moveEditorInDOM(e) {
                      var y;
                      if (!e.isAttachedToDOM) return;
                      const { activeElement: o } = document;
                      (e.div.contains(o) &&
                        ((e._focusEventsAllowed = !1),
                        setTimeout(() => {
                          e.div.contains(document.activeElement)
                            ? (e._focusEventsAllowed = !0)
                            : (e.div.addEventListener(
                                "focusin",
                                () => {
                                  e._focusEventsAllowed = !0;
                                },
                                { once: !0 },
                              ),
                              o.focus());
                        }, 0)),
                        (e._structTreeParentId =
                          (y = l(this, k)) == null
                            ? void 0
                            : y.moveElementInDOM(
                                this.div,
                                e.div,
                                e.contentDiv,
                                !0,
                              )));
                    }
                    addOrRebuild(e) {
                      e.needsToBeRebuilt() ? e.rebuild() : this.add(e);
                    }
                    addUndoableEditor(e) {
                      const o = () => e._uiManager.rebuild(e),
                        y = () => {
                          e.remove();
                        };
                      this.addCommands({ cmd: o, undo: y, mustExec: !1 });
                    }
                    getNextId() {
                      return l(this, F).getId();
                    }
                    pasteEditor(e, o) {
                      (l(this, F).updateToolbar(e), l(this, F).updateMode(e));
                      const { offsetX: y, offsetY: B } = le(this, v, Xr).call(
                          this,
                        ),
                        M = this.getNextId(),
                        D = le(this, v, Gr).call(this, {
                          parent: this,
                          id: M,
                          x: y,
                          y: B,
                          uiManager: l(this, F),
                          isCentered: !0,
                          ...o,
                        });
                      D && this.add(D);
                    }
                    deserialize(e) {
                      switch (e.annotationType ?? e.annotationEditorType) {
                        case w.AnnotationEditorType.FREETEXT:
                          return i.FreeTextEditor.deserialize(
                            e,
                            this,
                            l(this, F),
                          );
                        case w.AnnotationEditorType.INK:
                          return H.InkEditor.deserialize(e, this, l(this, F));
                        case w.AnnotationEditorType.STAMP:
                          return X.StampEditor.deserialize(e, this, l(this, F));
                      }
                      return null;
                    }
                    addNewEditor() {
                      le(this, v, lr).call(
                        this,
                        le(this, v, Xr).call(this),
                        !0,
                      );
                    }
                    setSelected(e) {
                      l(this, F).setSelected(e);
                    }
                    toggleSelected(e) {
                      l(this, F).toggleSelected(e);
                    }
                    isSelected(e) {
                      return l(this, F).isSelected(e);
                    }
                    unselect(e) {
                      l(this, F).unselect(e);
                    }
                    pointerup(e) {
                      const { isMac: o } = w.FeatureTest.platform;
                      if (
                        !(e.button !== 0 || (e.ctrlKey && o)) &&
                        e.target === this.div &&
                        l(this, d)
                      ) {
                        if ((Se(this, d, !1), !l(this, N))) {
                          Se(this, N, !0);
                          return;
                        }
                        if (
                          l(this, F).getMode() === w.AnnotationEditorType.STAMP
                        ) {
                          l(this, F).unselectAll();
                          return;
                        }
                        le(this, v, lr).call(this, e, !1);
                      }
                    }
                    pointerdown(e) {
                      if (l(this, d)) {
                        Se(this, d, !1);
                        return;
                      }
                      const { isMac: o } = w.FeatureTest.platform;
                      if (
                        e.button !== 0 ||
                        (e.ctrlKey && o) ||
                        e.target !== this.div
                      )
                        return;
                      Se(this, d, !0);
                      const y = l(this, F).getActive();
                      Se(this, N, !y || y.isEmpty());
                    }
                    findNewParent(e, o, y) {
                      const B = l(this, F).findParent(o, y);
                      return B === null || B === this
                        ? !1
                        : (B.changeParent(e), !0);
                    }
                    destroy() {
                      var e, o;
                      ((e = l(this, F).getActive()) == null
                        ? void 0
                        : e.parent) === this &&
                        (l(this, F).commitOrRemove(),
                        l(this, F).setActiveEditor(null));
                      for (const y of l(this, r).values())
                        ((o = l(this, k)) == null ||
                          o.removePointerInTextLayer(y.contentDiv),
                          y.setParent(null),
                          (y.isAttachedToDOM = !1),
                          y.div.remove());
                      ((this.div = null),
                        l(this, r).clear(),
                        l(this, F).removeLayer(this));
                    }
                    render({ viewport: e }) {
                      ((this.viewport = e),
                        (0, ee.setLayerDimensions)(this.div, e));
                      for (const o of l(this, F).getEditors(this.pageIndex))
                        this.add(o);
                      this.updateMode();
                    }
                    update({ viewport: e }) {
                      (l(this, F).commitOrRemove(),
                        (this.viewport = e),
                        (0, ee.setLayerDimensions)(this.div, {
                          rotation: e.rotation,
                        }),
                        this.updateMode());
                    }
                    get pageDimensions() {
                      const { pageWidth: e, pageHeight: o } =
                        this.viewport.rawDims;
                      return [e, o];
                    }
                  };
                  ((k = new WeakMap()),
                    (N = new WeakMap()),
                    (P = new WeakMap()),
                    (_ = new WeakMap()),
                    (h = new WeakMap()),
                    (r = new WeakMap()),
                    (d = new WeakMap()),
                    (p = new WeakMap()),
                    (u = new WeakMap()),
                    (F = new WeakMap()),
                    (v = new WeakSet()),
                    (Gr = function (e) {
                      switch (l(this, F).getMode()) {
                        case w.AnnotationEditorType.FREETEXT:
                          return new i.FreeTextEditor(e);
                        case w.AnnotationEditorType.INK:
                          return new H.InkEditor(e);
                        case w.AnnotationEditorType.STAMP:
                          return new X.StampEditor(e);
                      }
                      return null;
                    }),
                    (lr = function (e, o) {
                      const y = this.getNextId(),
                        B = le(this, v, Gr).call(this, {
                          parent: this,
                          id: y,
                          x: e.offsetX,
                          y: e.offsetY,
                          uiManager: l(this, F),
                          isCentered: o,
                        });
                      return (B && this.add(B), B);
                    }),
                    (Xr = function () {
                      const {
                          x: e,
                          y: o,
                          width: y,
                          height: B,
                        } = this.div.getBoundingClientRect(),
                        M = Math.max(0, e),
                        D = Math.max(0, o),
                        x = Math.min(window.innerWidth, e + y),
                        z = Math.min(window.innerHeight, o + B),
                        L = (M + x) / 2 - e,
                        V = (D + z) / 2 - o,
                        [Y, T] =
                          this.viewport.rotation % 180 === 0 ? [L, V] : [V, L];
                      return { offsetX: Y, offsetY: T };
                    }),
                    (Kr = function () {
                      Se(this, p, !0);
                      for (const e of l(this, r).values())
                        e.isEmpty() && e.remove();
                      Se(this, p, !1);
                    }),
                    $t(m, "_initialized", !1));
                  let W = m;
                  A.AnnotationEditorLayer = W;
                },
                (t, A, n) => {
                  var X, W, k, N, P, _, h, r, d, p, zi, Hi, qi, $n, Yr, Vi, Zr;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.FreeTextEditor = void 0));
                  var w = n(1),
                    S = n(5),
                    i = n(4),
                    H = n(29);
                  const m = class m extends i.AnnotationEditor {
                    constructor(o) {
                      super({ ...o, name: "freeTextEditor" });
                      ye(this, p);
                      ye(this, X, this.editorDivBlur.bind(this));
                      ye(this, W, this.editorDivFocus.bind(this));
                      ye(this, k, this.editorDivInput.bind(this));
                      ye(this, N, this.editorDivKeydown.bind(this));
                      ye(this, P);
                      ye(this, _, "");
                      ye(this, h, `${this.id}-editor`);
                      ye(this, r);
                      ye(this, d, null);
                      (Se(
                        this,
                        P,
                        o.color ||
                          m._defaultColor ||
                          i.AnnotationEditor._defaultLineColor,
                      ),
                        Se(this, r, o.fontSize || m._defaultFontSize));
                    }
                    static get _keyboardManager() {
                      const o = m.prototype,
                        y = (D) => D.isEmpty(),
                        B = S.AnnotationEditorUIManager.TRANSLATE_SMALL,
                        M = S.AnnotationEditorUIManager.TRANSLATE_BIG;
                      return (0, w.shadow)(
                        this,
                        "_keyboardManager",
                        new S.KeyboardManager([
                          [
                            ["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"],
                            o.commitOrRemove,
                            { bubbles: !0 },
                          ],
                          [
                            [
                              "ctrl+Enter",
                              "mac+meta+Enter",
                              "Escape",
                              "mac+Escape",
                            ],
                            o.commitOrRemove,
                          ],
                          [
                            ["ArrowLeft", "mac+ArrowLeft"],
                            o._translateEmpty,
                            { args: [-B, 0], checker: y },
                          ],
                          [
                            ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
                            o._translateEmpty,
                            { args: [-M, 0], checker: y },
                          ],
                          [
                            ["ArrowRight", "mac+ArrowRight"],
                            o._translateEmpty,
                            { args: [B, 0], checker: y },
                          ],
                          [
                            ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
                            o._translateEmpty,
                            { args: [M, 0], checker: y },
                          ],
                          [
                            ["ArrowUp", "mac+ArrowUp"],
                            o._translateEmpty,
                            { args: [0, -B], checker: y },
                          ],
                          [
                            ["ctrl+ArrowUp", "mac+shift+ArrowUp"],
                            o._translateEmpty,
                            { args: [0, -M], checker: y },
                          ],
                          [
                            ["ArrowDown", "mac+ArrowDown"],
                            o._translateEmpty,
                            { args: [0, B], checker: y },
                          ],
                          [
                            ["ctrl+ArrowDown", "mac+shift+ArrowDown"],
                            o._translateEmpty,
                            { args: [0, M], checker: y },
                          ],
                        ]),
                      );
                    }
                    static initialize(o) {
                      i.AnnotationEditor.initialize(o, {
                        strings: [
                          "free_text2_default_content",
                          "editor_free_text2_aria_label",
                        ],
                      });
                      const y = getComputedStyle(document.documentElement);
                      this._internalPadding = parseFloat(
                        y.getPropertyValue("--freetext-padding"),
                      );
                    }
                    static updateDefaultParams(o, y) {
                      switch (o) {
                        case w.AnnotationEditorParamsType.FREETEXT_SIZE:
                          m._defaultFontSize = y;
                          break;
                        case w.AnnotationEditorParamsType.FREETEXT_COLOR:
                          m._defaultColor = y;
                          break;
                      }
                    }
                    updateParams(o, y) {
                      switch (o) {
                        case w.AnnotationEditorParamsType.FREETEXT_SIZE:
                          le(this, p, zi).call(this, y);
                          break;
                        case w.AnnotationEditorParamsType.FREETEXT_COLOR:
                          le(this, p, Hi).call(this, y);
                          break;
                      }
                    }
                    static get defaultPropertiesToUpdate() {
                      return [
                        [
                          w.AnnotationEditorParamsType.FREETEXT_SIZE,
                          m._defaultFontSize,
                        ],
                        [
                          w.AnnotationEditorParamsType.FREETEXT_COLOR,
                          m._defaultColor ||
                            i.AnnotationEditor._defaultLineColor,
                        ],
                      ];
                    }
                    get propertiesToUpdate() {
                      return [
                        [
                          w.AnnotationEditorParamsType.FREETEXT_SIZE,
                          l(this, r),
                        ],
                        [
                          w.AnnotationEditorParamsType.FREETEXT_COLOR,
                          l(this, P),
                        ],
                      ];
                    }
                    _translateEmpty(o, y) {
                      this._uiManager.translateSelectedEditors(o, y, !0);
                    }
                    getInitialTranslation() {
                      const o = this.parentScale;
                      return [
                        -m._internalPadding * o,
                        -(m._internalPadding + l(this, r)) * o,
                      ];
                    }
                    rebuild() {
                      this.parent &&
                        (super.rebuild(),
                        this.div !== null &&
                          (this.isAttachedToDOM || this.parent.add(this)));
                    }
                    enableEditMode() {
                      this.isInEditMode() ||
                        (this.parent.setEditingState(!1),
                        this.parent.updateToolbar(
                          w.AnnotationEditorType.FREETEXT,
                        ),
                        super.enableEditMode(),
                        this.overlayDiv.classList.remove("enabled"),
                        (this.editorDiv.contentEditable = !0),
                        (this._isDraggable = !1),
                        this.div.removeAttribute("aria-activedescendant"),
                        this.editorDiv.addEventListener("keydown", l(this, N)),
                        this.editorDiv.addEventListener("focus", l(this, W)),
                        this.editorDiv.addEventListener("blur", l(this, X)),
                        this.editorDiv.addEventListener("input", l(this, k)));
                    }
                    disableEditMode() {
                      this.isInEditMode() &&
                        (this.parent.setEditingState(!0),
                        super.disableEditMode(),
                        this.overlayDiv.classList.add("enabled"),
                        (this.editorDiv.contentEditable = !1),
                        this.div.setAttribute(
                          "aria-activedescendant",
                          l(this, h),
                        ),
                        (this._isDraggable = !0),
                        this.editorDiv.removeEventListener(
                          "keydown",
                          l(this, N),
                        ),
                        this.editorDiv.removeEventListener("focus", l(this, W)),
                        this.editorDiv.removeEventListener("blur", l(this, X)),
                        this.editorDiv.removeEventListener("input", l(this, k)),
                        this.div.focus({ preventScroll: !0 }),
                        (this.isEditing = !1),
                        this.parent.div.classList.add("freeTextEditing"));
                    }
                    focusin(o) {
                      this._focusEventsAllowed &&
                        (super.focusin(o),
                        o.target !== this.editorDiv && this.editorDiv.focus());
                    }
                    onceAdded() {
                      var o;
                      if (this.width) {
                        le(this, p, Zr).call(this);
                        return;
                      }
                      (this.enableEditMode(),
                        this.editorDiv.focus(),
                        (o = this._initialOptions) != null &&
                          o.isCentered &&
                          this.center(),
                        (this._initialOptions = null));
                    }
                    isEmpty() {
                      return (
                        !this.editorDiv ||
                        this.editorDiv.innerText.trim() === ""
                      );
                    }
                    remove() {
                      ((this.isEditing = !1),
                        this.parent &&
                          (this.parent.setEditingState(!0),
                          this.parent.div.classList.add("freeTextEditing")),
                        super.remove());
                    }
                    commit() {
                      if (!this.isInEditMode()) return;
                      (super.commit(), this.disableEditMode());
                      const o = l(this, _),
                        y = Se(this, _, le(this, p, qi).call(this).trimEnd());
                      if (o === y) return;
                      const B = (M) => {
                        if ((Se(this, _, M), !M)) {
                          this.remove();
                          return;
                        }
                        (le(this, p, Yr).call(this),
                          this._uiManager.rebuild(this),
                          le(this, p, $n).call(this));
                      };
                      (this.addCommands({
                        cmd: () => {
                          B(y);
                        },
                        undo: () => {
                          B(o);
                        },
                        mustExec: !1,
                      }),
                        le(this, p, $n).call(this));
                    }
                    shouldGetKeyboardEvents() {
                      return this.isInEditMode();
                    }
                    enterInEditMode() {
                      (this.enableEditMode(), this.editorDiv.focus());
                    }
                    dblclick(o) {
                      this.enterInEditMode();
                    }
                    keydown(o) {
                      o.target === this.div &&
                        o.key === "Enter" &&
                        (this.enterInEditMode(), o.preventDefault());
                    }
                    editorDivKeydown(o) {
                      m._keyboardManager.exec(this, o);
                    }
                    editorDivFocus(o) {
                      this.isEditing = !0;
                    }
                    editorDivBlur(o) {
                      this.isEditing = !1;
                    }
                    editorDivInput(o) {
                      this.parent.div.classList.toggle(
                        "freeTextEditing",
                        this.isEmpty(),
                      );
                    }
                    disableEditing() {
                      (this.editorDiv.setAttribute("role", "comment"),
                        this.editorDiv.removeAttribute("aria-multiline"));
                    }
                    enableEditing() {
                      (this.editorDiv.setAttribute("role", "textbox"),
                        this.editorDiv.setAttribute("aria-multiline", !0));
                    }
                    render() {
                      if (this.div) return this.div;
                      let o, y;
                      (this.width && ((o = this.x), (y = this.y)),
                        super.render(),
                        (this.editorDiv = document.createElement("div")),
                        (this.editorDiv.className = "internal"),
                        this.editorDiv.setAttribute("id", l(this, h)),
                        this.enableEditing(),
                        i.AnnotationEditor._l10nPromise
                          .get("editor_free_text2_aria_label")
                          .then((M) => {
                            var D;
                            return (D = this.editorDiv) == null
                              ? void 0
                              : D.setAttribute("aria-label", M);
                          }),
                        i.AnnotationEditor._l10nPromise
                          .get("free_text2_default_content")
                          .then((M) => {
                            var D;
                            return (D = this.editorDiv) == null
                              ? void 0
                              : D.setAttribute("default-content", M);
                          }),
                        (this.editorDiv.contentEditable = !0));
                      const { style: B } = this.editorDiv;
                      if (
                        ((B.fontSize = `calc(${l(this, r)}px * var(--scale-factor))`),
                        (B.color = l(this, P)),
                        this.div.append(this.editorDiv),
                        (this.overlayDiv = document.createElement("div")),
                        this.overlayDiv.classList.add("overlay", "enabled"),
                        this.div.append(this.overlayDiv),
                        (0, S.bindEvents)(this, this.div, [
                          "dblclick",
                          "keydown",
                        ]),
                        this.width)
                      ) {
                        const [M, D] = this.parentDimensions;
                        if (this.annotationElementId) {
                          const { position: x } = l(this, d);
                          let [z, L] = this.getInitialTranslation();
                          [z, L] = this.pageTranslationToScreen(z, L);
                          const [V, Y] = this.pageDimensions,
                            [T, s] = this.pageTranslation;
                          let g, R;
                          switch (this.rotation) {
                            case 0:
                              ((g = o + (x[0] - T) / V),
                                (R = y + this.height - (x[1] - s) / Y));
                              break;
                            case 90:
                              ((g = o + (x[0] - T) / V),
                                (R = y - (x[1] - s) / Y),
                                ([z, L] = [L, -z]));
                              break;
                            case 180:
                              ((g = o - this.width + (x[0] - T) / V),
                                (R = y - (x[1] - s) / Y),
                                ([z, L] = [-z, -L]));
                              break;
                            case 270:
                              ((g = o + (x[0] - T - this.height * Y) / V),
                                (R = y + (x[1] - s - this.width * V) / Y),
                                ([z, L] = [-L, z]));
                              break;
                          }
                          this.setAt(g * M, R * D, z, L);
                        } else
                          this.setAt(
                            o * M,
                            y * D,
                            this.width * M,
                            this.height * D,
                          );
                        (le(this, p, Yr).call(this),
                          (this._isDraggable = !0),
                          (this.editorDiv.contentEditable = !1));
                      } else
                        ((this._isDraggable = !1),
                          (this.editorDiv.contentEditable = !0));
                      return this.div;
                    }
                    get contentDiv() {
                      return this.editorDiv;
                    }
                    static deserialize(o, y, B) {
                      let M = null;
                      if (o instanceof H.FreeTextAnnotationElement) {
                        const {
                          data: {
                            defaultAppearanceData: {
                              fontSize: x,
                              fontColor: z,
                            },
                            rect: L,
                            rotation: V,
                            id: Y,
                          },
                          textContent: T,
                          textPosition: s,
                          parent: {
                            page: { pageNumber: g },
                          },
                        } = o;
                        if (!T || T.length === 0) return null;
                        M = o = {
                          annotationType: w.AnnotationEditorType.FREETEXT,
                          color: Array.from(z),
                          fontSize: x,
                          value: T.join(`
`),
                          position: s,
                          pageIndex: g - 1,
                          rect: L,
                          rotation: V,
                          id: Y,
                          deleted: !1,
                        };
                      }
                      const D = super.deserialize(o, y, B);
                      return (
                        Se(D, r, o.fontSize),
                        Se(D, P, w.Util.makeHexColor(...o.color)),
                        Se(D, _, o.value),
                        (D.annotationElementId = o.id || null),
                        Se(D, d, M),
                        D
                      );
                    }
                    serialize(o = !1) {
                      if (this.isEmpty()) return null;
                      if (this.deleted)
                        return {
                          pageIndex: this.pageIndex,
                          id: this.annotationElementId,
                          deleted: !0,
                        };
                      const y = m._internalPadding * this.parentScale,
                        B = this.getRect(y, y),
                        M = i.AnnotationEditor._colorManager.convert(
                          this.isAttachedToDOM
                            ? getComputedStyle(this.editorDiv).color
                            : l(this, P),
                        ),
                        D = {
                          annotationType: w.AnnotationEditorType.FREETEXT,
                          color: M,
                          fontSize: l(this, r),
                          value: l(this, _),
                          pageIndex: this.pageIndex,
                          rect: B,
                          rotation: this.rotation,
                          structTreeParentId: this._structTreeParentId,
                        };
                      return o
                        ? D
                        : this.annotationElementId &&
                            !le(this, p, Vi).call(this, D)
                          ? null
                          : ((D.id = this.annotationElementId), D);
                    }
                  };
                  ((X = new WeakMap()),
                    (W = new WeakMap()),
                    (k = new WeakMap()),
                    (N = new WeakMap()),
                    (P = new WeakMap()),
                    (_ = new WeakMap()),
                    (h = new WeakMap()),
                    (r = new WeakMap()),
                    (d = new WeakMap()),
                    (p = new WeakSet()),
                    (zi = function (o) {
                      const y = (M) => {
                          ((this.editorDiv.style.fontSize = `calc(${M}px * var(--scale-factor))`),
                            this.translate(
                              0,
                              -(M - l(this, r)) * this.parentScale,
                            ),
                            Se(this, r, M),
                            le(this, p, $n).call(this));
                        },
                        B = l(this, r);
                      this.addCommands({
                        cmd: () => {
                          y(o);
                        },
                        undo: () => {
                          y(B);
                        },
                        mustExec: !0,
                        type: w.AnnotationEditorParamsType.FREETEXT_SIZE,
                        overwriteIfSameType: !0,
                        keepUndo: !0,
                      });
                    }),
                    (Hi = function (o) {
                      const y = l(this, P);
                      this.addCommands({
                        cmd: () => {
                          Se(this, P, (this.editorDiv.style.color = o));
                        },
                        undo: () => {
                          Se(this, P, (this.editorDiv.style.color = y));
                        },
                        mustExec: !0,
                        type: w.AnnotationEditorParamsType.FREETEXT_COLOR,
                        overwriteIfSameType: !0,
                        keepUndo: !0,
                      });
                    }),
                    (qi = function () {
                      const o = this.editorDiv.getElementsByTagName("div");
                      if (o.length === 0) return this.editorDiv.innerText;
                      const y = [];
                      for (const B of o)
                        y.push(B.innerText.replace(/\r\n?|\n/, ""));
                      return y.join(`
`);
                    }),
                    ($n = function () {
                      const [o, y] = this.parentDimensions;
                      let B;
                      if (this.isAttachedToDOM)
                        B = this.div.getBoundingClientRect();
                      else {
                        const { currentLayer: M, div: D } = this,
                          x = D.style.display;
                        ((D.style.display = "hidden"),
                          M.div.append(this.div),
                          (B = D.getBoundingClientRect()),
                          D.remove(),
                          (D.style.display = x));
                      }
                      (this.rotation % 180 === this.parentRotation % 180
                        ? ((this.width = B.width / o),
                          (this.height = B.height / y))
                        : ((this.width = B.height / o),
                          (this.height = B.width / y)),
                        this.fixAndSetPosition());
                    }),
                    (Yr = function () {
                      if ((this.editorDiv.replaceChildren(), !!l(this, _)))
                        for (const o of l(this, _).split(`
`)) {
                          const y = document.createElement("div");
                          (y.append(
                            o
                              ? document.createTextNode(o)
                              : document.createElement("br"),
                          ),
                            this.editorDiv.append(y));
                        }
                    }),
                    (Vi = function (o) {
                      const {
                        value: y,
                        fontSize: B,
                        color: M,
                        rect: D,
                        pageIndex: x,
                      } = l(this, d);
                      return (
                        o.value !== y ||
                        o.fontSize !== B ||
                        o.rect.some((z, L) => Math.abs(z - D[L]) >= 1) ||
                        o.color.some((z, L) => z !== M[L]) ||
                        o.pageIndex !== x
                      );
                    }),
                    (Zr = function (o = !1) {
                      if (!this.annotationElementId) return;
                      if (
                        (le(this, p, $n).call(this),
                        !o && (this.width === 0 || this.height === 0))
                      ) {
                        setTimeout(() => le(this, p, Zr).call(this, !0), 0);
                        return;
                      }
                      const y = m._internalPadding * this.parentScale;
                      l(this, d).rect = this.getRect(y, y);
                    }),
                    $t(m, "_freeTextDefaultContent", ""),
                    $t(m, "_internalPadding", 0),
                    $t(m, "_defaultColor", null),
                    $t(m, "_defaultFontSize", 10),
                    $t(m, "_type", "freetext"));
                  let ee = m;
                  A.FreeTextEditor = ee;
                },
                (t, A, n) => {
                  var R,
                    j,
                    xn,
                    Wi,
                    fe,
                    we,
                    Ee,
                    Ce,
                    xe,
                    Re,
                    ue,
                    de,
                    I,
                    q,
                    ie,
                    re,
                    he,
                    Pe,
                    Me,
                    se,
                    je,
                    Ie,
                    Ui,
                    ur,
                    Jr,
                    Qr,
                    Je,
                    st,
                    kt,
                    Le,
                    pe,
                    me,
                    Xe,
                    ei,
                    ot,
                    Z,
                    Te,
                    He,
                    $i,
                    ti;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.StampAnnotationElement =
                      A.InkAnnotationElement =
                      A.FreeTextAnnotationElement =
                      A.AnnotationLayer =
                        void 0));
                  var w = n(1),
                    S = n(6),
                    i = n(3),
                    H = n(30),
                    ee = n(31),
                    X = n(32);
                  const W = 1e3,
                    k = 9,
                    N = new WeakSet();
                  function P(Ge) {
                    return { width: Ge[2] - Ge[0], height: Ge[3] - Ge[1] };
                  }
                  class _ {
                    static create(K) {
                      switch (K.data.annotationType) {
                        case w.AnnotationType.LINK:
                          return new r(K);
                        case w.AnnotationType.TEXT:
                          return new d(K);
                        case w.AnnotationType.WIDGET:
                          switch (K.data.fieldType) {
                            case "Tx":
                              return new u(K);
                            case "Btn":
                              return K.data.radioButton
                                ? new f(K)
                                : K.data.checkBox
                                  ? new v(K)
                                  : new b(K);
                            case "Ch":
                              return new c(K);
                            case "Sig":
                              return new F(K);
                          }
                          return new p(K);
                        case w.AnnotationType.POPUP:
                          return new a(K);
                        case w.AnnotationType.FREETEXT:
                          return new C(K);
                        case w.AnnotationType.LINE:
                          return new e(K);
                        case w.AnnotationType.SQUARE:
                          return new o(K);
                        case w.AnnotationType.CIRCLE:
                          return new y(K);
                        case w.AnnotationType.POLYLINE:
                          return new B(K);
                        case w.AnnotationType.CARET:
                          return new D(K);
                        case w.AnnotationType.INK:
                          return new x(K);
                        case w.AnnotationType.POLYGON:
                          return new M(K);
                        case w.AnnotationType.HIGHLIGHT:
                          return new z(K);
                        case w.AnnotationType.UNDERLINE:
                          return new L(K);
                        case w.AnnotationType.SQUIGGLY:
                          return new V(K);
                        case w.AnnotationType.STRIKEOUT:
                          return new Y(K);
                        case w.AnnotationType.STAMP:
                          return new T(K);
                        case w.AnnotationType.FILEATTACHMENT:
                          return new s(K);
                        default:
                          return new h(K);
                      }
                    }
                  }
                  const $ = class $ {
                    constructor(
                      K,
                      {
                        isRenderable: G = !1,
                        ignoreBorder: ae = !1,
                        createQuadrilaterals: Ae = !1,
                      } = {},
                    ) {
                      ye(this, R, !1);
                      ((this.isRenderable = G),
                        (this.data = K.data),
                        (this.layer = K.layer),
                        (this.linkService = K.linkService),
                        (this.downloadManager = K.downloadManager),
                        (this.imageResourcesPath = K.imageResourcesPath),
                        (this.renderForms = K.renderForms),
                        (this.svgFactory = K.svgFactory),
                        (this.annotationStorage = K.annotationStorage),
                        (this.enableScripting = K.enableScripting),
                        (this.hasJSActions = K.hasJSActions),
                        (this._fieldObjects = K.fieldObjects),
                        (this.parent = K.parent),
                        G && (this.container = this._createContainer(ae)),
                        Ae && this._createQuadrilaterals());
                    }
                    static _hasPopupData({
                      titleObj: K,
                      contentsObj: G,
                      richText: ae,
                    }) {
                      return !!(
                        (K != null && K.str) ||
                        (G != null && G.str) ||
                        (ae != null && ae.str)
                      );
                    }
                    get hasPopupData() {
                      return $._hasPopupData(this.data);
                    }
                    _createContainer(K) {
                      const {
                          data: G,
                          parent: { page: ae, viewport: Ae },
                        } = this,
                        ke = document.createElement("section");
                      (ke.setAttribute("data-annotation-id", G.id),
                        this instanceof p || (ke.tabIndex = W),
                        (ke.style.zIndex = this.parent.zIndex++),
                        this.data.popupRef &&
                          ke.setAttribute("aria-haspopup", "dialog"),
                        G.noRotate && ke.classList.add("norotate"));
                      const {
                        pageWidth: Fe,
                        pageHeight: Ne,
                        pageX: Qe,
                        pageY: et,
                      } = Ae.rawDims;
                      if (!G.rect || this instanceof a) {
                        const { rotation: mt } = G;
                        return (
                          !G.hasOwnCanvas &&
                            mt !== 0 &&
                            this.setRotation(mt, ke),
                          ke
                        );
                      }
                      const { width: Ue, height: Et } = P(G.rect),
                        nt = w.Util.normalizeRect([
                          G.rect[0],
                          ae.view[3] - G.rect[1] + ae.view[1],
                          G.rect[2],
                          ae.view[3] - G.rect[3] + ae.view[1],
                        ]);
                      if (!K && G.borderStyle.width > 0) {
                        ke.style.borderWidth = `${G.borderStyle.width}px`;
                        const mt = G.borderStyle.horizontalCornerRadius,
                          At = G.borderStyle.verticalCornerRadius;
                        if (mt > 0 || At > 0) {
                          const zt = `calc(${mt}px * var(--scale-factor)) / calc(${At}px * var(--scale-factor))`;
                          ke.style.borderRadius = zt;
                        } else if (this instanceof f) {
                          const zt = `calc(${Ue}px * var(--scale-factor)) / calc(${Et}px * var(--scale-factor))`;
                          ke.style.borderRadius = zt;
                        }
                        switch (G.borderStyle.style) {
                          case w.AnnotationBorderStyleType.SOLID:
                            ke.style.borderStyle = "solid";
                            break;
                          case w.AnnotationBorderStyleType.DASHED:
                            ke.style.borderStyle = "dashed";
                            break;
                          case w.AnnotationBorderStyleType.BEVELED:
                            (0, w.warn)("Unimplemented border style: beveled");
                            break;
                          case w.AnnotationBorderStyleType.INSET:
                            (0, w.warn)("Unimplemented border style: inset");
                            break;
                          case w.AnnotationBorderStyleType.UNDERLINE:
                            ke.style.borderBottomStyle = "solid";
                            break;
                        }
                        const Lt = G.borderColor || null;
                        Lt
                          ? (Se(this, R, !0),
                            (ke.style.borderColor = w.Util.makeHexColor(
                              Lt[0] | 0,
                              Lt[1] | 0,
                              Lt[2] | 0,
                            )))
                          : (ke.style.borderWidth = 0);
                      }
                      ((ke.style.left = `${(100 * (nt[0] - Qe)) / Fe}%`),
                        (ke.style.top = `${(100 * (nt[1] - et)) / Ne}%`));
                      const { rotation: at } = G;
                      return (
                        G.hasOwnCanvas || at === 0
                          ? ((ke.style.width = `${(100 * Ue) / Fe}%`),
                            (ke.style.height = `${(100 * Et) / Ne}%`))
                          : this.setRotation(at, ke),
                        ke
                      );
                    }
                    setRotation(K, G = this.container) {
                      if (!this.data.rect) return;
                      const { pageWidth: ae, pageHeight: Ae } =
                          this.parent.viewport.rawDims,
                        { width: ke, height: Fe } = P(this.data.rect);
                      let Ne, Qe;
                      (K % 180 === 0
                        ? ((Ne = (100 * ke) / ae), (Qe = (100 * Fe) / Ae))
                        : ((Ne = (100 * Fe) / ae), (Qe = (100 * ke) / Ae)),
                        (G.style.width = `${Ne}%`),
                        (G.style.height = `${Qe}%`),
                        G.setAttribute("data-main-rotation", (360 - K) % 360));
                    }
                    get _commonActions() {
                      const K = (G, ae, Ae) => {
                        const ke = Ae.detail[G],
                          Fe = ke[0],
                          Ne = ke.slice(1);
                        ((Ae.target.style[ae] =
                          H.ColorConverters[`${Fe}_HTML`](Ne)),
                          this.annotationStorage.setValue(this.data.id, {
                            [ae]: H.ColorConverters[`${Fe}_rgb`](Ne),
                          }));
                      };
                      return (0, w.shadow)(this, "_commonActions", {
                        display: (G) => {
                          const { display: ae } = G.detail,
                            Ae = ae % 2 === 1;
                          ((this.container.style.visibility = Ae
                            ? "hidden"
                            : "visible"),
                            this.annotationStorage.setValue(this.data.id, {
                              noView: Ae,
                              noPrint: ae === 1 || ae === 2,
                            }));
                        },
                        print: (G) => {
                          this.annotationStorage.setValue(this.data.id, {
                            noPrint: !G.detail.print,
                          });
                        },
                        hidden: (G) => {
                          const { hidden: ae } = G.detail;
                          ((this.container.style.visibility = ae
                            ? "hidden"
                            : "visible"),
                            this.annotationStorage.setValue(this.data.id, {
                              noPrint: ae,
                              noView: ae,
                            }));
                        },
                        focus: (G) => {
                          setTimeout(
                            () => G.target.focus({ preventScroll: !1 }),
                            0,
                          );
                        },
                        userName: (G) => {
                          G.target.title = G.detail.userName;
                        },
                        readonly: (G) => {
                          G.target.disabled = G.detail.readonly;
                        },
                        required: (G) => {
                          this._setRequired(G.target, G.detail.required);
                        },
                        bgColor: (G) => {
                          K("bgColor", "backgroundColor", G);
                        },
                        fillColor: (G) => {
                          K("fillColor", "backgroundColor", G);
                        },
                        fgColor: (G) => {
                          K("fgColor", "color", G);
                        },
                        textColor: (G) => {
                          K("textColor", "color", G);
                        },
                        borderColor: (G) => {
                          K("borderColor", "borderColor", G);
                        },
                        strokeColor: (G) => {
                          K("strokeColor", "borderColor", G);
                        },
                        rotation: (G) => {
                          const ae = G.detail.rotation;
                          (this.setRotation(ae),
                            this.annotationStorage.setValue(this.data.id, {
                              rotation: ae,
                            }));
                        },
                      });
                    }
                    _dispatchEventFromSandbox(K, G) {
                      const ae = this._commonActions;
                      for (const Ae of Object.keys(G.detail)) {
                        const ke = K[Ae] || ae[Ae];
                        ke == null || ke(G);
                      }
                    }
                    _setDefaultPropertiesFromJS(K) {
                      if (!this.enableScripting) return;
                      const G = this.annotationStorage.getRawValue(
                        this.data.id,
                      );
                      if (!G) return;
                      const ae = this._commonActions;
                      for (const [Ae, ke] of Object.entries(G)) {
                        const Fe = ae[Ae];
                        if (Fe) {
                          const Ne = { detail: { [Ae]: ke }, target: K };
                          (Fe(Ne), delete G[Ae]);
                        }
                      }
                    }
                    _createQuadrilaterals() {
                      if (!this.container) return;
                      const { quadPoints: K } = this.data;
                      if (!K) return;
                      const [G, ae, Ae, ke] = this.data.rect;
                      if (K.length === 1) {
                        const [, { x: At, y: Lt }, { x: zt, y: an }] = K[0];
                        if (Ae === At && ke === Lt && G === zt && ae === an)
                          return;
                      }
                      const { style: Fe } = this.container;
                      let Ne;
                      if (l(this, R)) {
                        const { borderColor: At, borderWidth: Lt } = Fe;
                        ((Fe.borderWidth = 0),
                          (Ne = [
                            "url('data:image/svg+xml;utf8,",
                            '<svg xmlns="http://www.w3.org/2000/svg"',
                            ' preserveAspectRatio="none" viewBox="0 0 1 1">',
                            `<g fill="transparent" stroke="${At}" stroke-width="${Lt}">`,
                          ]),
                          this.container.classList.add("hasBorder"));
                      }
                      const Qe = Ae - G,
                        et = ke - ae,
                        { svgFactory: Ue } = this,
                        Et = Ue.createElement("svg");
                      (Et.classList.add("quadrilateralsContainer"),
                        Et.setAttribute("width", 0),
                        Et.setAttribute("height", 0));
                      const nt = Ue.createElement("defs");
                      Et.append(nt);
                      const at = Ue.createElement("clipPath"),
                        mt = `clippath_${this.data.id}`;
                      (at.setAttribute("id", mt),
                        at.setAttribute("clipPathUnits", "objectBoundingBox"),
                        nt.append(at));
                      for (const [, { x: At, y: Lt }, { x: zt, y: an }] of K) {
                        const Zt = Ue.createElement("rect"),
                          gn = (zt - G) / Qe,
                          bn = (ke - Lt) / et,
                          _n = (At - zt) / Qe,
                          Kn = (Lt - an) / et;
                        (Zt.setAttribute("x", gn),
                          Zt.setAttribute("y", bn),
                          Zt.setAttribute("width", _n),
                          Zt.setAttribute("height", Kn),
                          at.append(Zt),
                          Ne == null ||
                            Ne.push(
                              `<rect vector-effect="non-scaling-stroke" x="${gn}" y="${bn}" width="${_n}" height="${Kn}"/>`,
                            ));
                      }
                      (l(this, R) &&
                        (Ne.push("</g></svg>')"),
                        (Fe.backgroundImage = Ne.join(""))),
                        this.container.append(Et),
                        (this.container.style.clipPath = `url(#${mt})`));
                    }
                    _createPopup() {
                      const { container: K, data: G } = this;
                      K.setAttribute("aria-haspopup", "dialog");
                      const ae = new a({
                        data: {
                          color: G.color,
                          titleObj: G.titleObj,
                          modificationDate: G.modificationDate,
                          contentsObj: G.contentsObj,
                          richText: G.richText,
                          parentRect: G.rect,
                          borderStyle: 0,
                          id: `popup_${G.id}`,
                          rotation: G.rotation,
                        },
                        parent: this.parent,
                        elements: [this],
                      });
                      this.parent.div.append(ae.render());
                    }
                    render() {
                      (0, w.unreachable)(
                        "Abstract method `AnnotationElement.render` called",
                      );
                    }
                    _getElementsByName(K, G = null) {
                      const ae = [];
                      if (this._fieldObjects) {
                        const Ae = this._fieldObjects[K];
                        if (Ae)
                          for (const {
                            page: ke,
                            id: Fe,
                            exportValues: Ne,
                          } of Ae) {
                            if (ke === -1 || Fe === G) continue;
                            const Qe = typeof Ne == "string" ? Ne : null,
                              et = document.querySelector(
                                `[data-element-id="${Fe}"]`,
                              );
                            if (et && !N.has(et)) {
                              (0, w.warn)(
                                `_getElementsByName - element not allowed: ${Fe}`,
                              );
                              continue;
                            }
                            ae.push({
                              id: Fe,
                              exportValue: Qe,
                              domElement: et,
                            });
                          }
                        return ae;
                      }
                      for (const Ae of document.getElementsByName(K)) {
                        const { exportValue: ke } = Ae,
                          Fe = Ae.getAttribute("data-element-id");
                        Fe !== G &&
                          N.has(Ae) &&
                          ae.push({ id: Fe, exportValue: ke, domElement: Ae });
                      }
                      return ae;
                    }
                    show() {
                      var K;
                      (this.container && (this.container.hidden = !1),
                        (K = this.popup) == null || K.maybeShow());
                    }
                    hide() {
                      var K;
                      (this.container && (this.container.hidden = !0),
                        (K = this.popup) == null || K.forceHide());
                    }
                    getElementsToTriggerPopup() {
                      return this.container;
                    }
                    addHighlightArea() {
                      const K = this.getElementsToTriggerPopup();
                      if (Array.isArray(K))
                        for (const G of K) G.classList.add("highlightArea");
                      else K.classList.add("highlightArea");
                    }
                    _editOnDoubleClick() {
                      const {
                        annotationEditorType: K,
                        data: { id: G },
                      } = this;
                      this.container.addEventListener("dblclick", () => {
                        var ae;
                        (ae = this.linkService.eventBus) == null ||
                          ae.dispatch("switchannotationeditormode", {
                            source: this,
                            mode: K,
                            editId: G,
                          });
                      });
                    }
                  };
                  R = new WeakMap();
                  let h = $;
                  class r extends h {
                    constructor(G, ae = null) {
                      super(G, {
                        isRenderable: !0,
                        ignoreBorder: !!(ae != null && ae.ignoreBorder),
                        createQuadrilaterals: !0,
                      });
                      ye(this, j);
                      this.isTooltipOnly = G.data.isTooltipOnly;
                    }
                    render() {
                      const { data: G, linkService: ae } = this,
                        Ae = document.createElement("a");
                      Ae.setAttribute("data-element-id", G.id);
                      let ke = !1;
                      return (
                        G.url
                          ? (ae.addLinkAttributes(Ae, G.url, G.newWindow),
                            (ke = !0))
                          : G.action
                            ? (this._bindNamedAction(Ae, G.action), (ke = !0))
                            : G.attachment
                              ? (this._bindAttachment(Ae, G.attachment),
                                (ke = !0))
                              : G.setOCGState
                                ? (le(this, j, Wi).call(
                                    this,
                                    Ae,
                                    G.setOCGState,
                                  ),
                                  (ke = !0))
                                : G.dest
                                  ? (this._bindLink(Ae, G.dest), (ke = !0))
                                  : (G.actions &&
                                      (G.actions.Action ||
                                        G.actions["Mouse Up"] ||
                                        G.actions["Mouse Down"]) &&
                                      this.enableScripting &&
                                      this.hasJSActions &&
                                      (this._bindJSAction(Ae, G), (ke = !0)),
                                    G.resetForm
                                      ? (this._bindResetFormAction(
                                          Ae,
                                          G.resetForm,
                                        ),
                                        (ke = !0))
                                      : this.isTooltipOnly &&
                                        !ke &&
                                        (this._bindLink(Ae, ""), (ke = !0))),
                        this.container.classList.add("linkAnnotation"),
                        ke && this.container.append(Ae),
                        this.container
                      );
                    }
                    _bindLink(G, ae) {
                      ((G.href = this.linkService.getDestinationHash(ae)),
                        (G.onclick = () => (
                          ae && this.linkService.goToDestination(ae),
                          !1
                        )),
                        (ae || ae === "") && le(this, j, xn).call(this));
                    }
                    _bindNamedAction(G, ae) {
                      ((G.href = this.linkService.getAnchorUrl("")),
                        (G.onclick = () => (
                          this.linkService.executeNamedAction(ae),
                          !1
                        )),
                        le(this, j, xn).call(this));
                    }
                    _bindAttachment(G, ae) {
                      ((G.href = this.linkService.getAnchorUrl("")),
                        (G.onclick = () => {
                          var Ae;
                          return (
                            (Ae = this.downloadManager) == null ||
                              Ae.openOrDownloadData(
                                this.container,
                                ae.content,
                                ae.filename,
                              ),
                            !1
                          );
                        }),
                        le(this, j, xn).call(this));
                    }
                    _bindJSAction(G, ae) {
                      G.href = this.linkService.getAnchorUrl("");
                      const Ae = new Map([
                        ["Action", "onclick"],
                        ["Mouse Up", "onmouseup"],
                        ["Mouse Down", "onmousedown"],
                      ]);
                      for (const ke of Object.keys(ae.actions)) {
                        const Fe = Ae.get(ke);
                        Fe &&
                          (G[Fe] = () => {
                            var Ne;
                            return (
                              (Ne = this.linkService.eventBus) == null ||
                                Ne.dispatch("dispatcheventinsandbox", {
                                  source: this,
                                  detail: { id: ae.id, name: ke },
                                }),
                              !1
                            );
                          });
                      }
                      (G.onclick || (G.onclick = () => !1),
                        le(this, j, xn).call(this));
                    }
                    _bindResetFormAction(G, ae) {
                      const Ae = G.onclick;
                      if (
                        (Ae || (G.href = this.linkService.getAnchorUrl("")),
                        le(this, j, xn).call(this),
                        !this._fieldObjects)
                      ) {
                        ((0, w.warn)(
                          '_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.',
                        ),
                          Ae || (G.onclick = () => !1));
                        return;
                      }
                      G.onclick = () => {
                        var Et;
                        Ae == null || Ae();
                        const { fields: ke, refs: Fe, include: Ne } = ae,
                          Qe = [];
                        if (ke.length !== 0 || Fe.length !== 0) {
                          const nt = new Set(Fe);
                          for (const at of ke) {
                            const mt = this._fieldObjects[at] || [];
                            for (const { id: At } of mt) nt.add(At);
                          }
                          for (const at of Object.values(this._fieldObjects))
                            for (const mt of at)
                              nt.has(mt.id) === Ne && Qe.push(mt);
                        } else
                          for (const nt of Object.values(this._fieldObjects))
                            Qe.push(...nt);
                        const et = this.annotationStorage,
                          Ue = [];
                        for (const nt of Qe) {
                          const { id: at } = nt;
                          switch ((Ue.push(at), nt.type)) {
                            case "text": {
                              const At = nt.defaultValue || "";
                              et.setValue(at, { value: At });
                              break;
                            }
                            case "checkbox":
                            case "radiobutton": {
                              const At = nt.defaultValue === nt.exportValues;
                              et.setValue(at, { value: At });
                              break;
                            }
                            case "combobox":
                            case "listbox": {
                              const At = nt.defaultValue || "";
                              et.setValue(at, { value: At });
                              break;
                            }
                            default:
                              continue;
                          }
                          const mt = document.querySelector(
                            `[data-element-id="${at}"]`,
                          );
                          if (mt) {
                            if (!N.has(mt)) {
                              (0, w.warn)(
                                `_bindResetFormAction - element not allowed: ${at}`,
                              );
                              continue;
                            }
                          } else continue;
                          mt.dispatchEvent(new Event("resetform"));
                        }
                        return (
                          this.enableScripting &&
                            ((Et = this.linkService.eventBus) == null ||
                              Et.dispatch("dispatcheventinsandbox", {
                                source: this,
                                detail: {
                                  id: "app",
                                  ids: Ue,
                                  name: "ResetForm",
                                },
                              })),
                          !1
                        );
                      };
                    }
                  }
                  ((j = new WeakSet()),
                    (xn = function () {
                      this.container.setAttribute("data-internal-link", "");
                    }),
                    (Wi = function (G, ae) {
                      ((G.href = this.linkService.getAnchorUrl("")),
                        (G.onclick = () => (
                          this.linkService.executeSetOCGState(ae),
                          !1
                        )),
                        le(this, j, xn).call(this));
                    }));
                  class d extends h {
                    constructor(K) {
                      super(K, { isRenderable: !0 });
                    }
                    render() {
                      this.container.classList.add("textAnnotation");
                      const K = document.createElement("img");
                      return (
                        (K.src =
                          this.imageResourcesPath +
                          "annotation-" +
                          this.data.name.toLowerCase() +
                          ".svg"),
                        (K.alt = "[{{type}} Annotation]"),
                        (K.dataset.l10nId = "text_annotation_type"),
                        (K.dataset.l10nArgs = JSON.stringify({
                          type: this.data.name,
                        })),
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this.container.append(K),
                        this.container
                      );
                    }
                  }
                  class p extends h {
                    render() {
                      return (
                        this.data.alternativeText &&
                          (this.container.title = this.data.alternativeText),
                        this.container
                      );
                    }
                    showElementAndHideCanvas(K) {
                      var G;
                      this.data.hasOwnCanvas &&
                        (((G = K.previousSibling) == null
                          ? void 0
                          : G.nodeName) === "CANVAS" &&
                          (K.previousSibling.hidden = !0),
                        (K.hidden = !1));
                    }
                    _getKeyModifier(K) {
                      const { isWin: G, isMac: ae } = w.FeatureTest.platform;
                      return (G && K.ctrlKey) || (ae && K.metaKey);
                    }
                    _setEventListener(K, G, ae, Ae, ke) {
                      ae.includes("mouse")
                        ? K.addEventListener(ae, (Fe) => {
                            var Ne;
                            (Ne = this.linkService.eventBus) == null ||
                              Ne.dispatch("dispatcheventinsandbox", {
                                source: this,
                                detail: {
                                  id: this.data.id,
                                  name: Ae,
                                  value: ke(Fe),
                                  shift: Fe.shiftKey,
                                  modifier: this._getKeyModifier(Fe),
                                },
                              });
                          })
                        : K.addEventListener(ae, (Fe) => {
                            var Ne;
                            if (ae === "blur") {
                              if (!G.focused || !Fe.relatedTarget) return;
                              G.focused = !1;
                            } else if (ae === "focus") {
                              if (G.focused) return;
                              G.focused = !0;
                            }
                            ke &&
                              ((Ne = this.linkService.eventBus) == null ||
                                Ne.dispatch("dispatcheventinsandbox", {
                                  source: this,
                                  detail: {
                                    id: this.data.id,
                                    name: Ae,
                                    value: ke(Fe),
                                  },
                                }));
                          });
                    }
                    _setEventListeners(K, G, ae, Ae) {
                      var ke, Fe, Ne;
                      for (const [Qe, et] of ae)
                        (et === "Action" ||
                          ((ke = this.data.actions) != null && ke[et])) &&
                          ((et === "Focus" || et === "Blur") &&
                            (G || (G = { focused: !1 })),
                          this._setEventListener(K, G, Qe, et, Ae),
                          et === "Focus" &&
                          !((Fe = this.data.actions) != null && Fe.Blur)
                            ? this._setEventListener(K, G, "blur", "Blur", null)
                            : et === "Blur" &&
                              !((Ne = this.data.actions) != null && Ne.Focus) &&
                              this._setEventListener(
                                K,
                                G,
                                "focus",
                                "Focus",
                                null,
                              ));
                    }
                    _setBackgroundColor(K) {
                      const G = this.data.backgroundColor || null;
                      K.style.backgroundColor =
                        G === null
                          ? "transparent"
                          : w.Util.makeHexColor(G[0], G[1], G[2]);
                    }
                    _setTextStyle(K) {
                      const G = ["left", "center", "right"],
                        { fontColor: ae } = this.data.defaultAppearanceData,
                        Ae = this.data.defaultAppearanceData.fontSize || k,
                        ke = K.style;
                      let Fe;
                      const Ne = 2,
                        Qe = (et) => Math.round(10 * et) / 10;
                      if (this.data.multiLine) {
                        const et = Math.abs(
                            this.data.rect[3] - this.data.rect[1] - Ne,
                          ),
                          Ue = Math.round(et / (w.LINE_FACTOR * Ae)) || 1,
                          Et = et / Ue;
                        Fe = Math.min(Ae, Qe(Et / w.LINE_FACTOR));
                      } else {
                        const et = Math.abs(
                          this.data.rect[3] - this.data.rect[1] - Ne,
                        );
                        Fe = Math.min(Ae, Qe(et / w.LINE_FACTOR));
                      }
                      ((ke.fontSize = `calc(${Fe}px * var(--scale-factor))`),
                        (ke.color = w.Util.makeHexColor(ae[0], ae[1], ae[2])),
                        this.data.textAlignment !== null &&
                          (ke.textAlign = G[this.data.textAlignment]));
                    }
                    _setRequired(K, G) {
                      (G
                        ? K.setAttribute("required", !0)
                        : K.removeAttribute("required"),
                        K.setAttribute("aria-required", G));
                    }
                  }
                  class u extends p {
                    constructor(K) {
                      const G =
                        K.renderForms ||
                        (!K.data.hasAppearance && !!K.data.fieldValue);
                      super(K, { isRenderable: G });
                    }
                    setPropertyOnSiblings(K, G, ae, Ae) {
                      const ke = this.annotationStorage;
                      for (const Fe of this._getElementsByName(K.name, K.id))
                        (Fe.domElement && (Fe.domElement[G] = ae),
                          ke.setValue(Fe.id, { [Ae]: ae }));
                    }
                    render() {
                      var Ae, ke;
                      const K = this.annotationStorage,
                        G = this.data.id;
                      this.container.classList.add("textWidgetAnnotation");
                      let ae = null;
                      if (this.renderForms) {
                        const Fe = K.getValue(G, {
                          value: this.data.fieldValue,
                        });
                        let Ne = Fe.value || "";
                        const Qe = K.getValue(G, {
                          charLimit: this.data.maxLen,
                        }).charLimit;
                        Qe && Ne.length > Qe && (Ne = Ne.slice(0, Qe));
                        let et =
                          Fe.formattedValue ||
                          ((Ae = this.data.textContent) == null
                            ? void 0
                            : Ae.join(`
`)) ||
                          null;
                        et &&
                          this.data.comb &&
                          (et = et.replaceAll(/\s+/g, ""));
                        const Ue = {
                          userValue: Ne,
                          formattedValue: et,
                          lastCommittedValue: null,
                          commitKey: 1,
                          focused: !1,
                        };
                        (this.data.multiLine
                          ? ((ae = document.createElement("textarea")),
                            (ae.textContent = et ?? Ne),
                            this.data.doNotScroll &&
                              (ae.style.overflowY = "hidden"))
                          : ((ae = document.createElement("input")),
                            (ae.type = "text"),
                            ae.setAttribute("value", et ?? Ne),
                            this.data.doNotScroll &&
                              (ae.style.overflowX = "hidden")),
                          this.data.hasOwnCanvas && (ae.hidden = !0),
                          N.add(ae),
                          ae.setAttribute("data-element-id", G),
                          (ae.disabled = this.data.readOnly),
                          (ae.name = this.data.fieldName),
                          (ae.tabIndex = W),
                          this._setRequired(ae, this.data.required),
                          Qe && (ae.maxLength = Qe),
                          ae.addEventListener("input", (nt) => {
                            (K.setValue(G, { value: nt.target.value }),
                              this.setPropertyOnSiblings(
                                ae,
                                "value",
                                nt.target.value,
                                "value",
                              ),
                              (Ue.formattedValue = null));
                          }),
                          ae.addEventListener("resetform", (nt) => {
                            const at = this.data.defaultFieldValue ?? "";
                            ((ae.value = Ue.userValue = at),
                              (Ue.formattedValue = null));
                          }));
                        let Et = (nt) => {
                          const { formattedValue: at } = Ue;
                          (at != null && (nt.target.value = at),
                            (nt.target.scrollLeft = 0));
                        };
                        if (this.enableScripting && this.hasJSActions) {
                          (ae.addEventListener("focus", (at) => {
                            if (Ue.focused) return;
                            const { target: mt } = at;
                            (Ue.userValue && (mt.value = Ue.userValue),
                              (Ue.lastCommittedValue = mt.value),
                              (Ue.commitKey = 1),
                              (Ue.focused = !0));
                          }),
                            ae.addEventListener("updatefromsandbox", (at) => {
                              this.showElementAndHideCanvas(at.target);
                              const mt = {
                                value(At) {
                                  ((Ue.userValue = At.detail.value ?? ""),
                                    K.setValue(G, {
                                      value: Ue.userValue.toString(),
                                    }),
                                    (At.target.value = Ue.userValue));
                                },
                                formattedValue(At) {
                                  const { formattedValue: Lt } = At.detail;
                                  ((Ue.formattedValue = Lt),
                                    Lt != null &&
                                      At.target !== document.activeElement &&
                                      (At.target.value = Lt),
                                    K.setValue(G, { formattedValue: Lt }));
                                },
                                selRange(At) {
                                  At.target.setSelectionRange(
                                    ...At.detail.selRange,
                                  );
                                },
                                charLimit: (At) => {
                                  var Zt;
                                  const { charLimit: Lt } = At.detail,
                                    { target: zt } = At;
                                  if (Lt === 0) {
                                    zt.removeAttribute("maxLength");
                                    return;
                                  }
                                  zt.setAttribute("maxLength", Lt);
                                  let an = Ue.userValue;
                                  !an ||
                                    an.length <= Lt ||
                                    ((an = an.slice(0, Lt)),
                                    (zt.value = Ue.userValue = an),
                                    K.setValue(G, { value: an }),
                                    (Zt = this.linkService.eventBus) == null ||
                                      Zt.dispatch("dispatcheventinsandbox", {
                                        source: this,
                                        detail: {
                                          id: G,
                                          name: "Keystroke",
                                          value: an,
                                          willCommit: !0,
                                          commitKey: 1,
                                          selStart: zt.selectionStart,
                                          selEnd: zt.selectionEnd,
                                        },
                                      }));
                                },
                              };
                              this._dispatchEventFromSandbox(mt, at);
                            }),
                            ae.addEventListener("keydown", (at) => {
                              var Lt;
                              Ue.commitKey = 1;
                              let mt = -1;
                              if (
                                (at.key === "Escape"
                                  ? (mt = 0)
                                  : at.key === "Enter" && !this.data.multiLine
                                    ? (mt = 2)
                                    : at.key === "Tab" && (Ue.commitKey = 3),
                                mt === -1)
                              )
                                return;
                              const { value: At } = at.target;
                              Ue.lastCommittedValue !== At &&
                                ((Ue.lastCommittedValue = At),
                                (Ue.userValue = At),
                                (Lt = this.linkService.eventBus) == null ||
                                  Lt.dispatch("dispatcheventinsandbox", {
                                    source: this,
                                    detail: {
                                      id: G,
                                      name: "Keystroke",
                                      value: At,
                                      willCommit: !0,
                                      commitKey: mt,
                                      selStart: at.target.selectionStart,
                                      selEnd: at.target.selectionEnd,
                                    },
                                  }));
                            }));
                          const nt = Et;
                          ((Et = null),
                            ae.addEventListener("blur", (at) => {
                              var At;
                              if (!Ue.focused || !at.relatedTarget) return;
                              Ue.focused = !1;
                              const { value: mt } = at.target;
                              ((Ue.userValue = mt),
                                Ue.lastCommittedValue !== mt &&
                                  ((At = this.linkService.eventBus) == null ||
                                    At.dispatch("dispatcheventinsandbox", {
                                      source: this,
                                      detail: {
                                        id: G,
                                        name: "Keystroke",
                                        value: mt,
                                        willCommit: !0,
                                        commitKey: Ue.commitKey,
                                        selStart: at.target.selectionStart,
                                        selEnd: at.target.selectionEnd,
                                      },
                                    })),
                                nt(at));
                            }),
                            (ke = this.data.actions) != null &&
                              ke.Keystroke &&
                              ae.addEventListener("beforeinput", (at) => {
                                var bn;
                                Ue.lastCommittedValue = null;
                                const { data: mt, target: At } = at,
                                  {
                                    value: Lt,
                                    selectionStart: zt,
                                    selectionEnd: an,
                                  } = At;
                                let Zt = zt,
                                  gn = an;
                                switch (at.inputType) {
                                  case "deleteWordBackward": {
                                    const _n = Lt.substring(0, zt).match(
                                      /\w*[^\w]*$/,
                                    );
                                    _n && (Zt -= _n[0].length);
                                    break;
                                  }
                                  case "deleteWordForward": {
                                    const _n =
                                      Lt.substring(zt).match(/^[^\w]*\w*/);
                                    _n && (gn += _n[0].length);
                                    break;
                                  }
                                  case "deleteContentBackward":
                                    zt === an && (Zt -= 1);
                                    break;
                                  case "deleteContentForward":
                                    zt === an && (gn += 1);
                                    break;
                                }
                                (at.preventDefault(),
                                  (bn = this.linkService.eventBus) == null ||
                                    bn.dispatch("dispatcheventinsandbox", {
                                      source: this,
                                      detail: {
                                        id: G,
                                        name: "Keystroke",
                                        value: Lt,
                                        change: mt || "",
                                        willCommit: !1,
                                        selStart: Zt,
                                        selEnd: gn,
                                      },
                                    }));
                              }),
                            this._setEventListeners(
                              ae,
                              Ue,
                              [
                                ["focus", "Focus"],
                                ["blur", "Blur"],
                                ["mousedown", "Mouse Down"],
                                ["mouseenter", "Mouse Enter"],
                                ["mouseleave", "Mouse Exit"],
                                ["mouseup", "Mouse Up"],
                              ],
                              (at) => at.target.value,
                            ));
                        }
                        if (
                          (Et && ae.addEventListener("blur", Et),
                          this.data.comb)
                        ) {
                          const at =
                            (this.data.rect[2] - this.data.rect[0]) / Qe;
                          (ae.classList.add("comb"),
                            (ae.style.letterSpacing = `calc(${at}px * var(--scale-factor) - 1ch)`));
                        }
                      } else
                        ((ae = document.createElement("div")),
                          (ae.textContent = this.data.fieldValue),
                          (ae.style.verticalAlign = "middle"),
                          (ae.style.display = "table-cell"));
                      return (
                        this._setTextStyle(ae),
                        this._setBackgroundColor(ae),
                        this._setDefaultPropertiesFromJS(ae),
                        this.container.append(ae),
                        this.container
                      );
                    }
                  }
                  class F extends p {
                    constructor(K) {
                      super(K, { isRenderable: !!K.data.hasOwnCanvas });
                    }
                  }
                  class v extends p {
                    constructor(K) {
                      super(K, { isRenderable: K.renderForms });
                    }
                    render() {
                      const K = this.annotationStorage,
                        G = this.data,
                        ae = G.id;
                      let Ae = K.getValue(ae, {
                        value: G.exportValue === G.fieldValue,
                      }).value;
                      (typeof Ae == "string" &&
                        ((Ae = Ae !== "Off"), K.setValue(ae, { value: Ae })),
                        this.container.classList.add(
                          "buttonWidgetAnnotation",
                          "checkBox",
                        ));
                      const ke = document.createElement("input");
                      return (
                        N.add(ke),
                        ke.setAttribute("data-element-id", ae),
                        (ke.disabled = G.readOnly),
                        this._setRequired(ke, this.data.required),
                        (ke.type = "checkbox"),
                        (ke.name = G.fieldName),
                        Ae && ke.setAttribute("checked", !0),
                        ke.setAttribute("exportValue", G.exportValue),
                        (ke.tabIndex = W),
                        ke.addEventListener("change", (Fe) => {
                          const { name: Ne, checked: Qe } = Fe.target;
                          for (const et of this._getElementsByName(Ne, ae)) {
                            const Ue = Qe && et.exportValue === G.exportValue;
                            (et.domElement && (et.domElement.checked = Ue),
                              K.setValue(et.id, { value: Ue }));
                          }
                          K.setValue(ae, { value: Qe });
                        }),
                        ke.addEventListener("resetform", (Fe) => {
                          const Ne = G.defaultFieldValue || "Off";
                          Fe.target.checked = Ne === G.exportValue;
                        }),
                        this.enableScripting &&
                          this.hasJSActions &&
                          (ke.addEventListener("updatefromsandbox", (Fe) => {
                            const Ne = {
                              value(Qe) {
                                ((Qe.target.checked =
                                  Qe.detail.value !== "Off"),
                                  K.setValue(ae, { value: Qe.target.checked }));
                              },
                            };
                            this._dispatchEventFromSandbox(Ne, Fe);
                          }),
                          this._setEventListeners(
                            ke,
                            null,
                            [
                              ["change", "Validate"],
                              ["change", "Action"],
                              ["focus", "Focus"],
                              ["blur", "Blur"],
                              ["mousedown", "Mouse Down"],
                              ["mouseenter", "Mouse Enter"],
                              ["mouseleave", "Mouse Exit"],
                              ["mouseup", "Mouse Up"],
                            ],
                            (Fe) => Fe.target.checked,
                          )),
                        this._setBackgroundColor(ke),
                        this._setDefaultPropertiesFromJS(ke),
                        this.container.append(ke),
                        this.container
                      );
                    }
                  }
                  class f extends p {
                    constructor(K) {
                      super(K, { isRenderable: K.renderForms });
                    }
                    render() {
                      this.container.classList.add(
                        "buttonWidgetAnnotation",
                        "radioButton",
                      );
                      const K = this.annotationStorage,
                        G = this.data,
                        ae = G.id;
                      let Ae = K.getValue(ae, {
                        value: G.fieldValue === G.buttonValue,
                      }).value;
                      typeof Ae == "string" &&
                        ((Ae = Ae !== G.buttonValue),
                        K.setValue(ae, { value: Ae }));
                      const ke = document.createElement("input");
                      if (
                        (N.add(ke),
                        ke.setAttribute("data-element-id", ae),
                        (ke.disabled = G.readOnly),
                        this._setRequired(ke, this.data.required),
                        (ke.type = "radio"),
                        (ke.name = G.fieldName),
                        Ae && ke.setAttribute("checked", !0),
                        (ke.tabIndex = W),
                        ke.addEventListener("change", (Fe) => {
                          const { name: Ne, checked: Qe } = Fe.target;
                          for (const et of this._getElementsByName(Ne, ae))
                            K.setValue(et.id, { value: !1 });
                          K.setValue(ae, { value: Qe });
                        }),
                        ke.addEventListener("resetform", (Fe) => {
                          const Ne = G.defaultFieldValue;
                          Fe.target.checked =
                            Ne != null && Ne === G.buttonValue;
                        }),
                        this.enableScripting && this.hasJSActions)
                      ) {
                        const Fe = G.buttonValue;
                        (ke.addEventListener("updatefromsandbox", (Ne) => {
                          const Qe = {
                            value: (et) => {
                              const Ue = Fe === et.detail.value;
                              for (const Et of this._getElementsByName(
                                et.target.name,
                              )) {
                                const nt = Ue && Et.id === ae;
                                (Et.domElement && (Et.domElement.checked = nt),
                                  K.setValue(Et.id, { value: nt }));
                              }
                            },
                          };
                          this._dispatchEventFromSandbox(Qe, Ne);
                        }),
                          this._setEventListeners(
                            ke,
                            null,
                            [
                              ["change", "Validate"],
                              ["change", "Action"],
                              ["focus", "Focus"],
                              ["blur", "Blur"],
                              ["mousedown", "Mouse Down"],
                              ["mouseenter", "Mouse Enter"],
                              ["mouseleave", "Mouse Exit"],
                              ["mouseup", "Mouse Up"],
                            ],
                            (Ne) => Ne.target.checked,
                          ));
                      }
                      return (
                        this._setBackgroundColor(ke),
                        this._setDefaultPropertiesFromJS(ke),
                        this.container.append(ke),
                        this.container
                      );
                    }
                  }
                  class b extends r {
                    constructor(K) {
                      super(K, { ignoreBorder: K.data.hasAppearance });
                    }
                    render() {
                      const K = super.render();
                      (K.classList.add("buttonWidgetAnnotation", "pushButton"),
                        this.data.alternativeText &&
                          (K.title = this.data.alternativeText));
                      const G = K.lastChild;
                      return (
                        this.enableScripting &&
                          this.hasJSActions &&
                          G &&
                          (this._setDefaultPropertiesFromJS(G),
                          G.addEventListener("updatefromsandbox", (ae) => {
                            this._dispatchEventFromSandbox({}, ae);
                          })),
                        K
                      );
                    }
                  }
                  class c extends p {
                    constructor(K) {
                      super(K, { isRenderable: K.renderForms });
                    }
                    render() {
                      this.container.classList.add("choiceWidgetAnnotation");
                      const K = this.annotationStorage,
                        G = this.data.id,
                        ae = K.getValue(G, { value: this.data.fieldValue }),
                        Ae = document.createElement("select");
                      (N.add(Ae),
                        Ae.setAttribute("data-element-id", G),
                        (Ae.disabled = this.data.readOnly),
                        this._setRequired(Ae, this.data.required),
                        (Ae.name = this.data.fieldName),
                        (Ae.tabIndex = W));
                      let ke = this.data.combo && this.data.options.length > 0;
                      (this.data.combo ||
                        ((Ae.size = this.data.options.length),
                        this.data.multiSelect && (Ae.multiple = !0)),
                        Ae.addEventListener("resetform", (Ue) => {
                          const Et = this.data.defaultFieldValue;
                          for (const nt of Ae.options)
                            nt.selected = nt.value === Et;
                        }));
                      for (const Ue of this.data.options) {
                        const Et = document.createElement("option");
                        ((Et.textContent = Ue.displayValue),
                          (Et.value = Ue.exportValue),
                          ae.value.includes(Ue.exportValue) &&
                            (Et.setAttribute("selected", !0), (ke = !1)),
                          Ae.append(Et));
                      }
                      let Fe = null;
                      if (ke) {
                        const Ue = document.createElement("option");
                        ((Ue.value = " "),
                          Ue.setAttribute("hidden", !0),
                          Ue.setAttribute("selected", !0),
                          Ae.prepend(Ue),
                          (Fe = () => {
                            (Ue.remove(),
                              Ae.removeEventListener("input", Fe),
                              (Fe = null));
                          }),
                          Ae.addEventListener("input", Fe));
                      }
                      const Ne = (Ue) => {
                        const Et = Ue ? "value" : "textContent",
                          { options: nt, multiple: at } = Ae;
                        return at
                          ? Array.prototype.filter
                              .call(nt, (mt) => mt.selected)
                              .map((mt) => mt[Et])
                          : nt.selectedIndex === -1
                            ? null
                            : nt[nt.selectedIndex][Et];
                      };
                      let Qe = Ne(!1);
                      const et = (Ue) => {
                        const Et = Ue.target.options;
                        return Array.prototype.map.call(Et, (nt) => ({
                          displayValue: nt.textContent,
                          exportValue: nt.value,
                        }));
                      };
                      return (
                        this.enableScripting && this.hasJSActions
                          ? (Ae.addEventListener("updatefromsandbox", (Ue) => {
                              const Et = {
                                value(nt) {
                                  Fe == null || Fe();
                                  const at = nt.detail.value,
                                    mt = new Set(Array.isArray(at) ? at : [at]);
                                  for (const At of Ae.options)
                                    At.selected = mt.has(At.value);
                                  (K.setValue(G, { value: Ne(!0) }),
                                    (Qe = Ne(!1)));
                                },
                                multipleSelection(nt) {
                                  Ae.multiple = !0;
                                },
                                remove(nt) {
                                  const at = Ae.options,
                                    mt = nt.detail.remove;
                                  ((at[mt].selected = !1),
                                    Ae.remove(mt),
                                    at.length > 0 &&
                                      Array.prototype.findIndex.call(
                                        at,
                                        (Lt) => Lt.selected,
                                      ) === -1 &&
                                      (at[0].selected = !0),
                                    K.setValue(G, {
                                      value: Ne(!0),
                                      items: et(nt),
                                    }),
                                    (Qe = Ne(!1)));
                                },
                                clear(nt) {
                                  for (; Ae.length !== 0; ) Ae.remove(0);
                                  (K.setValue(G, { value: null, items: [] }),
                                    (Qe = Ne(!1)));
                                },
                                insert(nt) {
                                  const {
                                      index: at,
                                      displayValue: mt,
                                      exportValue: At,
                                    } = nt.detail.insert,
                                    Lt = Ae.children[at],
                                    zt = document.createElement("option");
                                  ((zt.textContent = mt),
                                    (zt.value = At),
                                    Lt ? Lt.before(zt) : Ae.append(zt),
                                    K.setValue(G, {
                                      value: Ne(!0),
                                      items: et(nt),
                                    }),
                                    (Qe = Ne(!1)));
                                },
                                items(nt) {
                                  const { items: at } = nt.detail;
                                  for (; Ae.length !== 0; ) Ae.remove(0);
                                  for (const mt of at) {
                                    const {
                                        displayValue: At,
                                        exportValue: Lt,
                                      } = mt,
                                      zt = document.createElement("option");
                                    ((zt.textContent = At),
                                      (zt.value = Lt),
                                      Ae.append(zt));
                                  }
                                  (Ae.options.length > 0 &&
                                    (Ae.options[0].selected = !0),
                                    K.setValue(G, {
                                      value: Ne(!0),
                                      items: et(nt),
                                    }),
                                    (Qe = Ne(!1)));
                                },
                                indices(nt) {
                                  const at = new Set(nt.detail.indices);
                                  for (const mt of nt.target.options)
                                    mt.selected = at.has(mt.index);
                                  (K.setValue(G, { value: Ne(!0) }),
                                    (Qe = Ne(!1)));
                                },
                                editable(nt) {
                                  nt.target.disabled = !nt.detail.editable;
                                },
                              };
                              this._dispatchEventFromSandbox(Et, Ue);
                            }),
                            Ae.addEventListener("input", (Ue) => {
                              var nt;
                              const Et = Ne(!0);
                              (K.setValue(G, { value: Et }),
                                Ue.preventDefault(),
                                (nt = this.linkService.eventBus) == null ||
                                  nt.dispatch("dispatcheventinsandbox", {
                                    source: this,
                                    detail: {
                                      id: G,
                                      name: "Keystroke",
                                      value: Qe,
                                      changeEx: Et,
                                      willCommit: !1,
                                      commitKey: 1,
                                      keyDown: !1,
                                    },
                                  }));
                            }),
                            this._setEventListeners(
                              Ae,
                              null,
                              [
                                ["focus", "Focus"],
                                ["blur", "Blur"],
                                ["mousedown", "Mouse Down"],
                                ["mouseenter", "Mouse Enter"],
                                ["mouseleave", "Mouse Exit"],
                                ["mouseup", "Mouse Up"],
                                ["input", "Action"],
                                ["input", "Validate"],
                              ],
                              (Ue) => Ue.target.value,
                            ))
                          : Ae.addEventListener("input", function (Ue) {
                              K.setValue(G, { value: Ne(!0) });
                            }),
                        this.data.combo && this._setTextStyle(Ae),
                        this._setBackgroundColor(Ae),
                        this._setDefaultPropertiesFromJS(Ae),
                        this.container.append(Ae),
                        this.container
                      );
                    }
                  }
                  class a extends h {
                    constructor(K) {
                      const { data: G, elements: ae } = K;
                      (super(K, { isRenderable: h._hasPopupData(G) }),
                        (this.elements = ae));
                    }
                    render() {
                      this.container.classList.add("popupAnnotation");
                      const K = new m({
                          container: this.container,
                          color: this.data.color,
                          titleObj: this.data.titleObj,
                          modificationDate: this.data.modificationDate,
                          contentsObj: this.data.contentsObj,
                          richText: this.data.richText,
                          rect: this.data.rect,
                          parentRect: this.data.parentRect || null,
                          parent: this.parent,
                          elements: this.elements,
                          open: this.data.open,
                        }),
                        G = [];
                      for (const ae of this.elements)
                        ((ae.popup = K),
                          G.push(ae.data.id),
                          ae.addHighlightArea());
                      return (
                        this.container.setAttribute(
                          "aria-controls",
                          G.map((ae) => `${w.AnnotationPrefix}${ae}`).join(","),
                        ),
                        this.container
                      );
                    }
                  }
                  class m {
                    constructor({
                      container: K,
                      color: G,
                      elements: ae,
                      titleObj: Ae,
                      modificationDate: ke,
                      contentsObj: Fe,
                      richText: Ne,
                      parent: Qe,
                      rect: et,
                      parentRect: Ue,
                      open: Et,
                    }) {
                      ye(this, Ie);
                      ye(this, fe, null);
                      ye(this, we, le(this, Ie, Ui).bind(this));
                      ye(this, Ee, le(this, Ie, Qr).bind(this));
                      ye(this, Ce, le(this, Ie, Jr).bind(this));
                      ye(this, xe, le(this, Ie, ur).bind(this));
                      ye(this, Re, null);
                      ye(this, ue, null);
                      ye(this, de, null);
                      ye(this, I, null);
                      ye(this, q, null);
                      ye(this, ie, null);
                      ye(this, re, !1);
                      ye(this, he, null);
                      ye(this, Pe, null);
                      ye(this, Me, null);
                      ye(this, se, null);
                      ye(this, je, !1);
                      var at;
                      (Se(this, ue, K),
                        Se(this, se, Ae),
                        Se(this, de, Fe),
                        Se(this, Me, Ne),
                        Se(this, q, Qe),
                        Se(this, Re, G),
                        Se(this, Pe, et),
                        Se(this, ie, Ue),
                        Se(this, I, ae));
                      const nt = S.PDFDateString.toDateObject(ke);
                      (nt &&
                        Se(
                          this,
                          fe,
                          Qe.l10n.get("annotation_date_string", {
                            date: nt.toLocaleDateString(),
                            time: nt.toLocaleTimeString(),
                          }),
                        ),
                        (this.trigger = ae.flatMap((mt) =>
                          mt.getElementsToTriggerPopup(),
                        )));
                      for (const mt of this.trigger)
                        (mt.addEventListener("click", l(this, xe)),
                          mt.addEventListener("mouseenter", l(this, Ce)),
                          mt.addEventListener("mouseleave", l(this, Ee)),
                          mt.classList.add("popupTriggerArea"));
                      for (const mt of ae)
                        (at = mt.container) == null ||
                          at.addEventListener("keydown", l(this, we));
                      ((l(this, ue).hidden = !0),
                        Et && le(this, Ie, ur).call(this));
                    }
                    render() {
                      if (l(this, he)) return;
                      const {
                          page: { view: K },
                          viewport: {
                            rawDims: {
                              pageWidth: G,
                              pageHeight: ae,
                              pageX: Ae,
                              pageY: ke,
                            },
                          },
                        } = l(this, q),
                        Fe = Se(this, he, document.createElement("div"));
                      if (((Fe.className = "popup"), l(this, Re))) {
                        const Zt = (Fe.style.outlineColor = w.Util.makeHexColor(
                          ...l(this, Re),
                        ));
                        CSS.supports(
                          "background-color",
                          "color-mix(in srgb, red 30%, white)",
                        )
                          ? (Fe.style.backgroundColor = `color-mix(in srgb, ${Zt} 30%, white)`)
                          : (Fe.style.backgroundColor = w.Util.makeHexColor(
                              ...l(this, Re).map((bn) =>
                                Math.floor(0.7 * (255 - bn) + bn),
                              ),
                            ));
                      }
                      const Ne = document.createElement("span");
                      Ne.className = "header";
                      const Qe = document.createElement("h1");
                      if (
                        (Ne.append(Qe),
                        ({ dir: Qe.dir, str: Qe.textContent } = l(this, se)),
                        Fe.append(Ne),
                        l(this, fe))
                      ) {
                        const Zt = document.createElement("span");
                        (Zt.classList.add("popupDate"),
                          l(this, fe).then((gn) => {
                            Zt.textContent = gn;
                          }),
                          Ne.append(Zt));
                      }
                      const et = l(this, de),
                        Ue = l(this, Me);
                      if (
                        Ue != null &&
                        Ue.str &&
                        (!(et != null && et.str) || et.str === Ue.str)
                      )
                        (X.XfaLayer.render({
                          xfaHtml: Ue.html,
                          intent: "richText",
                          div: Fe,
                        }),
                          Fe.lastChild.classList.add(
                            "richText",
                            "popupContent",
                          ));
                      else {
                        const Zt = this._formatContents(et);
                        Fe.append(Zt);
                      }
                      let Et = !!l(this, ie),
                        nt = Et ? l(this, ie) : l(this, Pe);
                      for (const Zt of l(this, I))
                        if (
                          !nt ||
                          w.Util.intersect(Zt.data.rect, nt) !== null
                        ) {
                          ((nt = Zt.data.rect), (Et = !0));
                          break;
                        }
                      const at = w.Util.normalizeRect([
                          nt[0],
                          K[3] - nt[1] + K[1],
                          nt[2],
                          K[3] - nt[3] + K[1],
                        ]),
                        At = Et ? nt[2] - nt[0] + 5 : 0,
                        Lt = at[0] + At,
                        zt = at[1],
                        { style: an } = l(this, ue);
                      ((an.left = `${(100 * (Lt - Ae)) / G}%`),
                        (an.top = `${(100 * (zt - ke)) / ae}%`),
                        l(this, ue).append(Fe));
                    }
                    _formatContents({ str: K, dir: G }) {
                      const ae = document.createElement("p");
                      (ae.classList.add("popupContent"), (ae.dir = G));
                      const Ae = K.split(/(?:\r\n?|\n)/);
                      for (let ke = 0, Fe = Ae.length; ke < Fe; ++ke) {
                        const Ne = Ae[ke];
                        (ae.append(document.createTextNode(Ne)),
                          ke < Fe - 1 &&
                            ae.append(document.createElement("br")));
                      }
                      return ae;
                    }
                    forceHide() {
                      (Se(this, je, this.isVisible),
                        l(this, je) && (l(this, ue).hidden = !0));
                    }
                    maybeShow() {
                      l(this, je) &&
                        (Se(this, je, !1), (l(this, ue).hidden = !1));
                    }
                    get isVisible() {
                      return l(this, ue).hidden === !1;
                    }
                  }
                  ((fe = new WeakMap()),
                    (we = new WeakMap()),
                    (Ee = new WeakMap()),
                    (Ce = new WeakMap()),
                    (xe = new WeakMap()),
                    (Re = new WeakMap()),
                    (ue = new WeakMap()),
                    (de = new WeakMap()),
                    (I = new WeakMap()),
                    (q = new WeakMap()),
                    (ie = new WeakMap()),
                    (re = new WeakMap()),
                    (he = new WeakMap()),
                    (Pe = new WeakMap()),
                    (Me = new WeakMap()),
                    (se = new WeakMap()),
                    (je = new WeakMap()),
                    (Ie = new WeakSet()),
                    (Ui = function (K) {
                      K.altKey ||
                        K.shiftKey ||
                        K.ctrlKey ||
                        K.metaKey ||
                        ((K.key === "Enter" ||
                          (K.key === "Escape" && l(this, re))) &&
                          le(this, Ie, ur).call(this));
                    }),
                    (ur = function () {
                      (Se(this, re, !l(this, re)),
                        l(this, re)
                          ? (le(this, Ie, Jr).call(this),
                            l(this, ue).addEventListener("click", l(this, xe)),
                            l(this, ue).addEventListener(
                              "keydown",
                              l(this, we),
                            ))
                          : (le(this, Ie, Qr).call(this),
                            l(this, ue).removeEventListener(
                              "click",
                              l(this, xe),
                            ),
                            l(this, ue).removeEventListener(
                              "keydown",
                              l(this, we),
                            )));
                    }),
                    (Jr = function () {
                      (l(this, he) || this.render(),
                        this.isVisible
                          ? l(this, re) && l(this, ue).classList.add("focused")
                          : ((l(this, ue).hidden = !1),
                            (l(this, ue).style.zIndex =
                              parseInt(l(this, ue).style.zIndex) + 1e3)));
                    }),
                    (Qr = function () {
                      (l(this, ue).classList.remove("focused"),
                        !(l(this, re) || !this.isVisible) &&
                          ((l(this, ue).hidden = !0),
                          (l(this, ue).style.zIndex =
                            parseInt(l(this, ue).style.zIndex) - 1e3)));
                    }));
                  class C extends h {
                    constructor(K) {
                      (super(K, { isRenderable: !0, ignoreBorder: !0 }),
                        (this.textContent = K.data.textContent),
                        (this.textPosition = K.data.textPosition),
                        (this.annotationEditorType =
                          w.AnnotationEditorType.FREETEXT));
                    }
                    render() {
                      if (
                        (this.container.classList.add("freeTextAnnotation"),
                        this.textContent)
                      ) {
                        const K = document.createElement("div");
                        (K.classList.add("annotationTextContent"),
                          K.setAttribute("role", "comment"));
                        for (const G of this.textContent) {
                          const ae = document.createElement("span");
                          ((ae.textContent = G), K.append(ae));
                        }
                        this.container.append(K);
                      }
                      return (
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this._editOnDoubleClick(),
                        this.container
                      );
                    }
                  }
                  A.FreeTextAnnotationElement = C;
                  class e extends h {
                    constructor(G) {
                      super(G, { isRenderable: !0, ignoreBorder: !0 });
                      ye(this, Je, null);
                    }
                    render() {
                      this.container.classList.add("lineAnnotation");
                      const G = this.data,
                        { width: ae, height: Ae } = P(G.rect),
                        ke = this.svgFactory.create(ae, Ae, !0),
                        Fe = Se(
                          this,
                          Je,
                          this.svgFactory.createElement("svg:line"),
                        );
                      return (
                        Fe.setAttribute("x1", G.rect[2] - G.lineCoordinates[0]),
                        Fe.setAttribute("y1", G.rect[3] - G.lineCoordinates[1]),
                        Fe.setAttribute("x2", G.rect[2] - G.lineCoordinates[2]),
                        Fe.setAttribute("y2", G.rect[3] - G.lineCoordinates[3]),
                        Fe.setAttribute(
                          "stroke-width",
                          G.borderStyle.width || 1,
                        ),
                        Fe.setAttribute("stroke", "transparent"),
                        Fe.setAttribute("fill", "transparent"),
                        ke.append(Fe),
                        this.container.append(ke),
                        !G.popupRef && this.hasPopupData && this._createPopup(),
                        this.container
                      );
                    }
                    getElementsToTriggerPopup() {
                      return l(this, Je);
                    }
                    addHighlightArea() {
                      this.container.classList.add("highlightArea");
                    }
                  }
                  Je = new WeakMap();
                  class o extends h {
                    constructor(G) {
                      super(G, { isRenderable: !0, ignoreBorder: !0 });
                      ye(this, st, null);
                    }
                    render() {
                      this.container.classList.add("squareAnnotation");
                      const G = this.data,
                        { width: ae, height: Ae } = P(G.rect),
                        ke = this.svgFactory.create(ae, Ae, !0),
                        Fe = G.borderStyle.width,
                        Ne = Se(
                          this,
                          st,
                          this.svgFactory.createElement("svg:rect"),
                        );
                      return (
                        Ne.setAttribute("x", Fe / 2),
                        Ne.setAttribute("y", Fe / 2),
                        Ne.setAttribute("width", ae - Fe),
                        Ne.setAttribute("height", Ae - Fe),
                        Ne.setAttribute("stroke-width", Fe || 1),
                        Ne.setAttribute("stroke", "transparent"),
                        Ne.setAttribute("fill", "transparent"),
                        ke.append(Ne),
                        this.container.append(ke),
                        !G.popupRef && this.hasPopupData && this._createPopup(),
                        this.container
                      );
                    }
                    getElementsToTriggerPopup() {
                      return l(this, st);
                    }
                    addHighlightArea() {
                      this.container.classList.add("highlightArea");
                    }
                  }
                  st = new WeakMap();
                  class y extends h {
                    constructor(G) {
                      super(G, { isRenderable: !0, ignoreBorder: !0 });
                      ye(this, kt, null);
                    }
                    render() {
                      this.container.classList.add("circleAnnotation");
                      const G = this.data,
                        { width: ae, height: Ae } = P(G.rect),
                        ke = this.svgFactory.create(ae, Ae, !0),
                        Fe = G.borderStyle.width,
                        Ne = Se(
                          this,
                          kt,
                          this.svgFactory.createElement("svg:ellipse"),
                        );
                      return (
                        Ne.setAttribute("cx", ae / 2),
                        Ne.setAttribute("cy", Ae / 2),
                        Ne.setAttribute("rx", ae / 2 - Fe / 2),
                        Ne.setAttribute("ry", Ae / 2 - Fe / 2),
                        Ne.setAttribute("stroke-width", Fe || 1),
                        Ne.setAttribute("stroke", "transparent"),
                        Ne.setAttribute("fill", "transparent"),
                        ke.append(Ne),
                        this.container.append(ke),
                        !G.popupRef && this.hasPopupData && this._createPopup(),
                        this.container
                      );
                    }
                    getElementsToTriggerPopup() {
                      return l(this, kt);
                    }
                    addHighlightArea() {
                      this.container.classList.add("highlightArea");
                    }
                  }
                  kt = new WeakMap();
                  class B extends h {
                    constructor(G) {
                      super(G, { isRenderable: !0, ignoreBorder: !0 });
                      ye(this, Le, null);
                      ((this.containerClassName = "polylineAnnotation"),
                        (this.svgElementName = "svg:polyline"));
                    }
                    render() {
                      this.container.classList.add(this.containerClassName);
                      const G = this.data,
                        { width: ae, height: Ae } = P(G.rect),
                        ke = this.svgFactory.create(ae, Ae, !0);
                      let Fe = [];
                      for (const Qe of G.vertices) {
                        const et = Qe.x - G.rect[0],
                          Ue = G.rect[3] - Qe.y;
                        Fe.push(et + "," + Ue);
                      }
                      Fe = Fe.join(" ");
                      const Ne = Se(
                        this,
                        Le,
                        this.svgFactory.createElement(this.svgElementName),
                      );
                      return (
                        Ne.setAttribute("points", Fe),
                        Ne.setAttribute(
                          "stroke-width",
                          G.borderStyle.width || 1,
                        ),
                        Ne.setAttribute("stroke", "transparent"),
                        Ne.setAttribute("fill", "transparent"),
                        ke.append(Ne),
                        this.container.append(ke),
                        !G.popupRef && this.hasPopupData && this._createPopup(),
                        this.container
                      );
                    }
                    getElementsToTriggerPopup() {
                      return l(this, Le);
                    }
                    addHighlightArea() {
                      this.container.classList.add("highlightArea");
                    }
                  }
                  Le = new WeakMap();
                  class M extends B {
                    constructor(K) {
                      (super(K),
                        (this.containerClassName = "polygonAnnotation"),
                        (this.svgElementName = "svg:polygon"));
                    }
                  }
                  class D extends h {
                    constructor(K) {
                      super(K, { isRenderable: !0, ignoreBorder: !0 });
                    }
                    render() {
                      return (
                        this.container.classList.add("caretAnnotation"),
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this.container
                      );
                    }
                  }
                  class x extends h {
                    constructor(G) {
                      super(G, { isRenderable: !0, ignoreBorder: !0 });
                      ye(this, pe, []);
                      ((this.containerClassName = "inkAnnotation"),
                        (this.svgElementName = "svg:polyline"),
                        (this.annotationEditorType =
                          w.AnnotationEditorType.INK));
                    }
                    render() {
                      this.container.classList.add(this.containerClassName);
                      const G = this.data,
                        { width: ae, height: Ae } = P(G.rect),
                        ke = this.svgFactory.create(ae, Ae, !0);
                      for (const Fe of G.inkLists) {
                        let Ne = [];
                        for (const et of Fe) {
                          const Ue = et.x - G.rect[0],
                            Et = G.rect[3] - et.y;
                          Ne.push(`${Ue},${Et}`);
                        }
                        Ne = Ne.join(" ");
                        const Qe = this.svgFactory.createElement(
                          this.svgElementName,
                        );
                        (l(this, pe).push(Qe),
                          Qe.setAttribute("points", Ne),
                          Qe.setAttribute(
                            "stroke-width",
                            G.borderStyle.width || 1,
                          ),
                          Qe.setAttribute("stroke", "transparent"),
                          Qe.setAttribute("fill", "transparent"),
                          !G.popupRef &&
                            this.hasPopupData &&
                            this._createPopup(),
                          ke.append(Qe));
                      }
                      return (this.container.append(ke), this.container);
                    }
                    getElementsToTriggerPopup() {
                      return l(this, pe);
                    }
                    addHighlightArea() {
                      this.container.classList.add("highlightArea");
                    }
                  }
                  ((pe = new WeakMap()), (A.InkAnnotationElement = x));
                  class z extends h {
                    constructor(K) {
                      super(K, {
                        isRenderable: !0,
                        ignoreBorder: !0,
                        createQuadrilaterals: !0,
                      });
                    }
                    render() {
                      return (
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this.container.classList.add("highlightAnnotation"),
                        this.container
                      );
                    }
                  }
                  class L extends h {
                    constructor(K) {
                      super(K, {
                        isRenderable: !0,
                        ignoreBorder: !0,
                        createQuadrilaterals: !0,
                      });
                    }
                    render() {
                      return (
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this.container.classList.add("underlineAnnotation"),
                        this.container
                      );
                    }
                  }
                  class V extends h {
                    constructor(K) {
                      super(K, {
                        isRenderable: !0,
                        ignoreBorder: !0,
                        createQuadrilaterals: !0,
                      });
                    }
                    render() {
                      return (
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this.container.classList.add("squigglyAnnotation"),
                        this.container
                      );
                    }
                  }
                  class Y extends h {
                    constructor(K) {
                      super(K, {
                        isRenderable: !0,
                        ignoreBorder: !0,
                        createQuadrilaterals: !0,
                      });
                    }
                    render() {
                      return (
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this.container.classList.add("strikeoutAnnotation"),
                        this.container
                      );
                    }
                  }
                  class T extends h {
                    constructor(K) {
                      super(K, { isRenderable: !0, ignoreBorder: !0 });
                    }
                    render() {
                      return (
                        this.container.classList.add("stampAnnotation"),
                        !this.data.popupRef &&
                          this.hasPopupData &&
                          this._createPopup(),
                        this.container
                      );
                    }
                  }
                  A.StampAnnotationElement = T;
                  class s extends h {
                    constructor(G) {
                      var ke;
                      super(G, { isRenderable: !0 });
                      ye(this, Xe);
                      ye(this, me, null);
                      const { filename: ae, content: Ae } = this.data.file;
                      ((this.filename = (0, S.getFilenameFromUrl)(ae, !0)),
                        (this.content = Ae),
                        (ke = this.linkService.eventBus) == null ||
                          ke.dispatch("fileattachmentannotation", {
                            source: this,
                            filename: ae,
                            content: Ae,
                          }));
                    }
                    render() {
                      this.container.classList.add("fileAttachmentAnnotation");
                      const { container: G, data: ae } = this;
                      let Ae;
                      (ae.hasAppearance || ae.fillAlpha === 0
                        ? (Ae = document.createElement("div"))
                        : ((Ae = document.createElement("img")),
                          (Ae.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(ae.name) ? "paperclip" : "pushpin"}.svg`),
                          ae.fillAlpha &&
                            ae.fillAlpha < 1 &&
                            (Ae.style = `filter: opacity(${Math.round(ae.fillAlpha * 100)}%);`)),
                        Ae.addEventListener(
                          "dblclick",
                          le(this, Xe, ei).bind(this),
                        ),
                        Se(this, me, Ae));
                      const { isMac: ke } = w.FeatureTest.platform;
                      return (
                        G.addEventListener("keydown", (Fe) => {
                          Fe.key === "Enter" &&
                            (ke ? Fe.metaKey : Fe.ctrlKey) &&
                            le(this, Xe, ei).call(this);
                        }),
                        !ae.popupRef && this.hasPopupData
                          ? this._createPopup()
                          : Ae.classList.add("popupTriggerArea"),
                        G.append(Ae),
                        G
                      );
                    }
                    getElementsToTriggerPopup() {
                      return l(this, me);
                    }
                    addHighlightArea() {
                      this.container.classList.add("highlightArea");
                    }
                  }
                  ((me = new WeakMap()),
                    (Xe = new WeakSet()),
                    (ei = function () {
                      var G;
                      (G = this.downloadManager) == null ||
                        G.openOrDownloadData(
                          this.container,
                          this.content,
                          this.filename,
                        );
                    }));
                  class g {
                    constructor({
                      div: K,
                      accessibilityManager: G,
                      annotationCanvasMap: ae,
                      l10n: Ae,
                      page: ke,
                      viewport: Fe,
                    }) {
                      ye(this, He);
                      ye(this, ot, null);
                      ye(this, Z, null);
                      ye(this, Te, new Map());
                      ((this.div = K),
                        Se(this, ot, G),
                        Se(this, Z, ae),
                        (this.l10n = Ae),
                        (this.page = ke),
                        (this.viewport = Fe),
                        (this.zIndex = 0),
                        this.l10n || (this.l10n = ee.NullL10n));
                    }
                    async render(K) {
                      const { annotations: G } = K,
                        ae = this.div;
                      (0, S.setLayerDimensions)(ae, this.viewport);
                      const Ae = new Map(),
                        ke = {
                          data: null,
                          layer: ae,
                          linkService: K.linkService,
                          downloadManager: K.downloadManager,
                          imageResourcesPath: K.imageResourcesPath || "",
                          renderForms: K.renderForms !== !1,
                          svgFactory: new S.DOMSVGFactory(),
                          annotationStorage:
                            K.annotationStorage || new i.AnnotationStorage(),
                          enableScripting: K.enableScripting === !0,
                          hasJSActions: K.hasJSActions,
                          fieldObjects: K.fieldObjects,
                          parent: this,
                          elements: null,
                        };
                      for (const Fe of G) {
                        if (Fe.noHTML) continue;
                        const Ne = Fe.annotationType === w.AnnotationType.POPUP;
                        if (Ne) {
                          const Ue = Ae.get(Fe.id);
                          if (!Ue) continue;
                          ke.elements = Ue;
                        } else {
                          const { width: Ue, height: Et } = P(Fe.rect);
                          if (Ue <= 0 || Et <= 0) continue;
                        }
                        ke.data = Fe;
                        const Qe = _.create(ke);
                        if (!Qe.isRenderable) continue;
                        if (!Ne && Fe.popupRef) {
                          const Ue = Ae.get(Fe.popupRef);
                          Ue ? Ue.push(Qe) : Ae.set(Fe.popupRef, [Qe]);
                        }
                        Qe.annotationEditorType > 0 &&
                          l(this, Te).set(Qe.data.id, Qe);
                        const et = Qe.render();
                        (Fe.hidden && (et.style.visibility = "hidden"),
                          le(this, He, $i).call(this, et, Fe.id));
                      }
                      (le(this, He, ti).call(this),
                        await this.l10n.translate(ae));
                    }
                    update({ viewport: K }) {
                      const G = this.div;
                      ((this.viewport = K),
                        (0, S.setLayerDimensions)(G, { rotation: K.rotation }),
                        le(this, He, ti).call(this),
                        (G.hidden = !1));
                    }
                    getEditableAnnotations() {
                      return Array.from(l(this, Te).values());
                    }
                    getEditableAnnotation(K) {
                      return l(this, Te).get(K);
                    }
                  }
                  ((ot = new WeakMap()),
                    (Z = new WeakMap()),
                    (Te = new WeakMap()),
                    (He = new WeakSet()),
                    ($i = function (K, G) {
                      var Ae;
                      const ae = K.firstChild || K;
                      ((ae.id = `${w.AnnotationPrefix}${G}`),
                        this.div.append(K),
                        (Ae = l(this, ot)) == null ||
                          Ae.moveElementInDOM(this.div, K, ae, !1));
                    }),
                    (ti = function () {
                      if (!l(this, Z)) return;
                      const K = this.div;
                      for (const [G, ae] of l(this, Z)) {
                        const Ae = K.querySelector(
                          `[data-annotation-id="${G}"]`,
                        );
                        if (!Ae) continue;
                        const { firstChild: ke } = Ae;
                        ke
                          ? ke.nodeName === "CANVAS"
                            ? ke.replaceWith(ae)
                            : ke.before(ae)
                          : Ae.append(ae);
                      }
                      l(this, Z).clear();
                    }),
                    (A.AnnotationLayer = g));
                },
                (t, A) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.ColorConverters = void 0));
                  function n(i) {
                    return Math.floor(Math.max(0, Math.min(1, i)) * 255)
                      .toString(16)
                      .padStart(2, "0");
                  }
                  function w(i) {
                    return Math.max(0, Math.min(255, 255 * i));
                  }
                  class S {
                    static CMYK_G([H, ee, X, W]) {
                      return [
                        "G",
                        1 - Math.min(1, 0.3 * H + 0.59 * X + 0.11 * ee + W),
                      ];
                    }
                    static G_CMYK([H]) {
                      return ["CMYK", 0, 0, 0, 1 - H];
                    }
                    static G_RGB([H]) {
                      return ["RGB", H, H, H];
                    }
                    static G_rgb([H]) {
                      return ((H = w(H)), [H, H, H]);
                    }
                    static G_HTML([H]) {
                      const ee = n(H);
                      return `#${ee}${ee}${ee}`;
                    }
                    static RGB_G([H, ee, X]) {
                      return ["G", 0.3 * H + 0.59 * ee + 0.11 * X];
                    }
                    static RGB_rgb(H) {
                      return H.map(w);
                    }
                    static RGB_HTML(H) {
                      return `#${H.map(n).join("")}`;
                    }
                    static T_HTML() {
                      return "#00000000";
                    }
                    static T_rgb() {
                      return [null];
                    }
                    static CMYK_RGB([H, ee, X, W]) {
                      return [
                        "RGB",
                        1 - Math.min(1, H + W),
                        1 - Math.min(1, X + W),
                        1 - Math.min(1, ee + W),
                      ];
                    }
                    static CMYK_rgb([H, ee, X, W]) {
                      return [
                        w(1 - Math.min(1, H + W)),
                        w(1 - Math.min(1, X + W)),
                        w(1 - Math.min(1, ee + W)),
                      ];
                    }
                    static CMYK_HTML(H) {
                      const ee = this.CMYK_RGB(H).slice(1);
                      return this.RGB_HTML(ee);
                    }
                    static RGB_CMYK([H, ee, X]) {
                      const W = 1 - H,
                        k = 1 - ee,
                        N = 1 - X,
                        P = Math.min(W, k, N);
                      return ["CMYK", W, k, N, P];
                    }
                  }
                  A.ColorConverters = S;
                },
                (t, A) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.NullL10n = void 0),
                    (A.getL10nFallback = w));
                  const n = {
                    of_pages: "of {{pagesCount}}",
                    page_of_pages: "({{pageNumber}} of {{pagesCount}})",
                    document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
                    document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
                    document_properties_date_string: "{{date}}, {{time}}",
                    document_properties_page_size_unit_inches: "in",
                    document_properties_page_size_unit_millimeters: "mm",
                    document_properties_page_size_orientation_portrait:
                      "portrait",
                    document_properties_page_size_orientation_landscape:
                      "landscape",
                    document_properties_page_size_name_a3: "A3",
                    document_properties_page_size_name_a4: "A4",
                    document_properties_page_size_name_letter: "Letter",
                    document_properties_page_size_name_legal: "Legal",
                    document_properties_page_size_dimension_string:
                      "{{width}} × {{height}} {{unit}} ({{orientation}})",
                    document_properties_page_size_dimension_name_string:
                      "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
                    document_properties_linearized_yes: "Yes",
                    document_properties_linearized_no: "No",
                    additional_layers: "Additional Layers",
                    page_landmark: "Page {{page}}",
                    thumb_page_title: "Page {{page}}",
                    thumb_page_canvas: "Thumbnail of Page {{page}}",
                    find_reached_top:
                      "Reached top of document, continued from bottom",
                    find_reached_bottom:
                      "Reached end of document, continued from top",
                    "find_match_count[one]": "{{current}} of {{total}} match",
                    "find_match_count[other]":
                      "{{current}} of {{total}} matches",
                    "find_match_count_limit[one]": "More than {{limit}} match",
                    "find_match_count_limit[other]":
                      "More than {{limit}} matches",
                    find_not_found: "Phrase not found",
                    page_scale_width: "Page Width",
                    page_scale_fit: "Page Fit",
                    page_scale_auto: "Automatic Zoom",
                    page_scale_actual: "Actual Size",
                    page_scale_percent: "{{scale}}%",
                    loading_error: "An error occurred while loading the PDF.",
                    invalid_file_error: "Invalid or corrupted PDF file.",
                    missing_file_error: "Missing PDF file.",
                    unexpected_response_error: "Unexpected server response.",
                    rendering_error:
                      "An error occurred while rendering the page.",
                    annotation_date_string: "{{date}}, {{time}}",
                    printing_not_supported:
                      "Warning: Printing is not fully supported by this browser.",
                    printing_not_ready:
                      "Warning: The PDF is not fully loaded for printing.",
                    web_fonts_disabled:
                      "Web fonts are disabled: unable to use embedded PDF fonts.",
                    free_text2_default_content: "Start typing…",
                    editor_free_text2_aria_label: "Text Editor",
                    editor_ink2_aria_label: "Draw Editor",
                    editor_ink_canvas_aria_label: "User-created image",
                    editor_alt_text_button_label: "Alt text",
                    editor_alt_text_edit_button_label: "Edit alt text",
                    editor_alt_text_decorative_tooltip: "Marked as decorative",
                  };
                  n.print_progress_percent = "{{progress}}%";
                  function w(H, ee) {
                    switch (H) {
                      case "find_match_count":
                        H = `find_match_count[${ee.total === 1 ? "one" : "other"}]`;
                        break;
                      case "find_match_count_limit":
                        H = `find_match_count_limit[${ee.limit === 1 ? "one" : "other"}]`;
                        break;
                    }
                    return n[H] || "";
                  }
                  function S(H, ee) {
                    return ee
                      ? H.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (X, W) =>
                          W in ee ? ee[W] : "{{" + W + "}}",
                        )
                      : H;
                  }
                  const i = {
                    async getLanguage() {
                      return "en-us";
                    },
                    async getDirection() {
                      return "ltr";
                    },
                    async get(H, ee = null, X = w(H, ee)) {
                      return S(X, ee);
                    },
                    async translate(H) {},
                  };
                  A.NullL10n = i;
                },
                (t, A, n) => {
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.XfaLayer = void 0));
                  var w = n(25);
                  class S {
                    static setupStorage(H, ee, X, W, k) {
                      const N = W.getValue(ee, { value: null });
                      switch (X.name) {
                        case "textarea":
                          if (
                            (N.value !== null && (H.textContent = N.value),
                            k === "print")
                          )
                            break;
                          H.addEventListener("input", (P) => {
                            W.setValue(ee, { value: P.target.value });
                          });
                          break;
                        case "input":
                          if (
                            X.attributes.type === "radio" ||
                            X.attributes.type === "checkbox"
                          ) {
                            if (
                              (N.value === X.attributes.xfaOn
                                ? H.setAttribute("checked", !0)
                                : N.value === X.attributes.xfaOff &&
                                  H.removeAttribute("checked"),
                              k === "print")
                            )
                              break;
                            H.addEventListener("change", (P) => {
                              W.setValue(ee, {
                                value: P.target.checked
                                  ? P.target.getAttribute("xfaOn")
                                  : P.target.getAttribute("xfaOff"),
                              });
                            });
                          } else {
                            if (
                              (N.value !== null &&
                                H.setAttribute("value", N.value),
                              k === "print")
                            )
                              break;
                            H.addEventListener("input", (P) => {
                              W.setValue(ee, { value: P.target.value });
                            });
                          }
                          break;
                        case "select":
                          if (N.value !== null) {
                            H.setAttribute("value", N.value);
                            for (const P of X.children)
                              P.attributes.value === N.value
                                ? (P.attributes.selected = !0)
                                : P.attributes.hasOwnProperty("selected") &&
                                  delete P.attributes.selected;
                          }
                          H.addEventListener("input", (P) => {
                            const _ = P.target.options,
                              h =
                                _.selectedIndex === -1
                                  ? ""
                                  : _[_.selectedIndex].value;
                            W.setValue(ee, { value: h });
                          });
                          break;
                      }
                    }
                    static setAttributes({
                      html: H,
                      element: ee,
                      storage: X = null,
                      intent: W,
                      linkService: k,
                    }) {
                      const { attributes: N } = ee,
                        P = H instanceof HTMLAnchorElement;
                      N.type === "radio" && (N.name = `${N.name}-${W}`);
                      for (const [_, h] of Object.entries(N))
                        if (h != null)
                          switch (_) {
                            case "class":
                              h.length && H.setAttribute(_, h.join(" "));
                              break;
                            case "dataId":
                              break;
                            case "id":
                              H.setAttribute("data-element-id", h);
                              break;
                            case "style":
                              Object.assign(H.style, h);
                              break;
                            case "textContent":
                              H.textContent = h;
                              break;
                            default:
                              (!P || (_ !== "href" && _ !== "newWindow")) &&
                                H.setAttribute(_, h);
                          }
                      (P && k.addLinkAttributes(H, N.href, N.newWindow),
                        X && N.dataId && this.setupStorage(H, N.dataId, ee, X));
                    }
                    static render(H) {
                      var r;
                      const ee = H.annotationStorage,
                        X = H.linkService,
                        W = H.xfaHtml,
                        k = H.intent || "display",
                        N = document.createElement(W.name);
                      W.attributes &&
                        this.setAttributes({
                          html: N,
                          element: W,
                          intent: k,
                          linkService: X,
                        });
                      const P = [[W, -1, N]],
                        _ = H.div;
                      if ((_.append(N), H.viewport)) {
                        const d = `matrix(${H.viewport.transform.join(",")})`;
                        _.style.transform = d;
                      }
                      k !== "richText" &&
                        _.setAttribute("class", "xfaLayer xfaFont");
                      const h = [];
                      for (; P.length > 0; ) {
                        const [d, p, u] = P.at(-1);
                        if (p + 1 === d.children.length) {
                          P.pop();
                          continue;
                        }
                        const F = d.children[++P.at(-1)[1]];
                        if (F === null) continue;
                        const { name: v } = F;
                        if (v === "#text") {
                          const b = document.createTextNode(F.value);
                          (h.push(b), u.append(b));
                          continue;
                        }
                        const f =
                          (r = F == null ? void 0 : F.attributes) != null &&
                          r.xmlns
                            ? document.createElementNS(F.attributes.xmlns, v)
                            : document.createElement(v);
                        if (
                          (u.append(f),
                          F.attributes &&
                            this.setAttributes({
                              html: f,
                              element: F,
                              storage: ee,
                              intent: k,
                              linkService: X,
                            }),
                          F.children && F.children.length > 0)
                        )
                          P.push([F, -1, f]);
                        else if (F.value) {
                          const b = document.createTextNode(F.value);
                          (w.XfaText.shouldBuildText(v) && h.push(b),
                            f.append(b));
                        }
                      }
                      for (const d of _.querySelectorAll(
                        ".xfaNonInteractive input, .xfaNonInteractive textarea",
                      ))
                        d.setAttribute("readOnly", !0);
                      return { textDivs: h };
                    }
                    static update(H) {
                      const ee = `matrix(${H.viewport.transform.join(",")})`;
                      ((H.div.style.transform = ee), (H.div.hidden = !1));
                    }
                  }
                  A.XfaLayer = S;
                },
                (t, A, n) => {
                  var W,
                    k,
                    N,
                    P,
                    _,
                    h,
                    r,
                    d,
                    p,
                    u,
                    F,
                    v,
                    f,
                    b,
                    c,
                    Gi,
                    Xi,
                    Ki,
                    Yi,
                    ni,
                    Zi,
                    ri,
                    Ji,
                    Qi,
                    ea,
                    ta,
                    na,
                    Sn,
                    ii,
                    dr,
                    hr,
                    Nn,
                    ai,
                    fr,
                    j,
                    ra,
                    oi,
                    ia,
                    aa,
                    si,
                    pr,
                    Bn;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.InkEditor = void 0));
                  var w = n(1),
                    S = n(4),
                    i = n(29),
                    H = n(6),
                    ee = n(5);
                  const Re = class Re extends S.AnnotationEditor {
                    constructor(I) {
                      super({ ...I, name: "inkEditor" });
                      ye(this, c);
                      ye(this, W, 0);
                      ye(this, k, 0);
                      ye(this, N, this.canvasPointermove.bind(this));
                      ye(this, P, this.canvasPointerleave.bind(this));
                      ye(this, _, this.canvasPointerup.bind(this));
                      ye(this, h, this.canvasPointerdown.bind(this));
                      ye(this, r, new Path2D());
                      ye(this, d, !1);
                      ye(this, p, !1);
                      ye(this, u, !1);
                      ye(this, F, null);
                      ye(this, v, 0);
                      ye(this, f, 0);
                      ye(this, b, null);
                      ((this.color = I.color || null),
                        (this.thickness = I.thickness || null),
                        (this.opacity = I.opacity || null),
                        (this.paths = []),
                        (this.bezierPath2D = []),
                        (this.allRawPaths = []),
                        (this.currentPath = []),
                        (this.scaleFactor = 1),
                        (this.translationX = this.translationY = 0),
                        (this.x = 0),
                        (this.y = 0),
                        (this._willKeepAspectRatio = !0));
                    }
                    static initialize(I) {
                      S.AnnotationEditor.initialize(I, {
                        strings: [
                          "editor_ink_canvas_aria_label",
                          "editor_ink2_aria_label",
                        ],
                      });
                    }
                    static updateDefaultParams(I, q) {
                      switch (I) {
                        case w.AnnotationEditorParamsType.INK_THICKNESS:
                          Re._defaultThickness = q;
                          break;
                        case w.AnnotationEditorParamsType.INK_COLOR:
                          Re._defaultColor = q;
                          break;
                        case w.AnnotationEditorParamsType.INK_OPACITY:
                          Re._defaultOpacity = q / 100;
                          break;
                      }
                    }
                    updateParams(I, q) {
                      switch (I) {
                        case w.AnnotationEditorParamsType.INK_THICKNESS:
                          le(this, c, Gi).call(this, q);
                          break;
                        case w.AnnotationEditorParamsType.INK_COLOR:
                          le(this, c, Xi).call(this, q);
                          break;
                        case w.AnnotationEditorParamsType.INK_OPACITY:
                          le(this, c, Ki).call(this, q);
                          break;
                      }
                    }
                    static get defaultPropertiesToUpdate() {
                      return [
                        [
                          w.AnnotationEditorParamsType.INK_THICKNESS,
                          Re._defaultThickness,
                        ],
                        [
                          w.AnnotationEditorParamsType.INK_COLOR,
                          Re._defaultColor ||
                            S.AnnotationEditor._defaultLineColor,
                        ],
                        [
                          w.AnnotationEditorParamsType.INK_OPACITY,
                          Math.round(Re._defaultOpacity * 100),
                        ],
                      ];
                    }
                    get propertiesToUpdate() {
                      return [
                        [
                          w.AnnotationEditorParamsType.INK_THICKNESS,
                          this.thickness || Re._defaultThickness,
                        ],
                        [
                          w.AnnotationEditorParamsType.INK_COLOR,
                          this.color ||
                            Re._defaultColor ||
                            S.AnnotationEditor._defaultLineColor,
                        ],
                        [
                          w.AnnotationEditorParamsType.INK_OPACITY,
                          Math.round(
                            100 * (this.opacity ?? Re._defaultOpacity),
                          ),
                        ],
                      ];
                    }
                    rebuild() {
                      this.parent &&
                        (super.rebuild(),
                        this.div !== null &&
                          (this.canvas ||
                            (le(this, c, dr).call(this),
                            le(this, c, hr).call(this)),
                          this.isAttachedToDOM ||
                            (this.parent.add(this), le(this, c, Nn).call(this)),
                          le(this, c, Bn).call(this)));
                    }
                    remove() {
                      this.canvas !== null &&
                        (this.isEmpty() || this.commit(),
                        (this.canvas.width = this.canvas.height = 0),
                        this.canvas.remove(),
                        (this.canvas = null),
                        l(this, F).disconnect(),
                        Se(this, F, null),
                        super.remove());
                    }
                    setParent(I) {
                      (!this.parent && I
                        ? this._uiManager.removeShouldRescale(this)
                        : this.parent &&
                          I === null &&
                          this._uiManager.addShouldRescale(this),
                        super.setParent(I));
                    }
                    onScaleChanging() {
                      const [I, q] = this.parentDimensions,
                        ie = this.width * I,
                        re = this.height * q;
                      this.setDimensions(ie, re);
                    }
                    enableEditMode() {
                      l(this, d) ||
                        this.canvas === null ||
                        (super.enableEditMode(),
                        (this._isDraggable = !1),
                        this.canvas.addEventListener(
                          "pointerdown",
                          l(this, h),
                        ));
                    }
                    disableEditMode() {
                      !this.isInEditMode() ||
                        this.canvas === null ||
                        (super.disableEditMode(),
                        (this._isDraggable = !this.isEmpty()),
                        this.div.classList.remove("editing"),
                        this.canvas.removeEventListener(
                          "pointerdown",
                          l(this, h),
                        ));
                    }
                    onceAdded() {
                      this._isDraggable = !this.isEmpty();
                    }
                    isEmpty() {
                      return (
                        this.paths.length === 0 ||
                        (this.paths.length === 1 && this.paths[0].length === 0)
                      );
                    }
                    commit() {
                      l(this, d) ||
                        (super.commit(),
                        (this.isEditing = !1),
                        this.disableEditMode(),
                        this.setInForeground(),
                        Se(this, d, !0),
                        this.div.classList.add("disabled"),
                        le(this, c, Bn).call(this, !0),
                        this.makeResizable(),
                        this.parent.addInkEditorIfNeeded(!0),
                        this.moveInDOM(),
                        this.div.focus({ preventScroll: !0 }));
                    }
                    focusin(I) {
                      this._focusEventsAllowed &&
                        (super.focusin(I), this.enableEditMode());
                    }
                    canvasPointerdown(I) {
                      I.button !== 0 ||
                        !this.isInEditMode() ||
                        l(this, d) ||
                        (this.setInForeground(),
                        I.preventDefault(),
                        I.type !== "mouse" && this.div.focus(),
                        le(this, c, Zi).call(this, I.offsetX, I.offsetY));
                    }
                    canvasPointermove(I) {
                      (I.preventDefault(),
                        le(this, c, ri).call(this, I.offsetX, I.offsetY));
                    }
                    canvasPointerup(I) {
                      (I.preventDefault(), le(this, c, ii).call(this, I));
                    }
                    canvasPointerleave(I) {
                      le(this, c, ii).call(this, I);
                    }
                    get isResizable() {
                      return !this.isEmpty() && l(this, d);
                    }
                    render() {
                      if (this.div) return this.div;
                      let I, q;
                      (this.width && ((I = this.x), (q = this.y)),
                        super.render(),
                        S.AnnotationEditor._l10nPromise
                          .get("editor_ink2_aria_label")
                          .then((Me) => {
                            var se;
                            return (se = this.div) == null
                              ? void 0
                              : se.setAttribute("aria-label", Me);
                          }));
                      const [ie, re, he, Pe] = le(this, c, Yi).call(this);
                      if (
                        (this.setAt(ie, re, 0, 0),
                        this.setDims(he, Pe),
                        le(this, c, dr).call(this),
                        this.width)
                      ) {
                        const [Me, se] = this.parentDimensions;
                        (this.setAspectRatio(this.width * Me, this.height * se),
                          this.setAt(
                            I * Me,
                            q * se,
                            this.width * Me,
                            this.height * se,
                          ),
                          Se(this, u, !0),
                          le(this, c, Nn).call(this),
                          this.setDims(this.width * Me, this.height * se),
                          le(this, c, Sn).call(this),
                          this.div.classList.add("disabled"));
                      } else
                        (this.div.classList.add("editing"),
                          this.enableEditMode());
                      return (le(this, c, hr).call(this), this.div);
                    }
                    setDimensions(I, q) {
                      const ie = Math.round(I),
                        re = Math.round(q);
                      if (l(this, v) === ie && l(this, f) === re) return;
                      (Se(this, v, ie),
                        Se(this, f, re),
                        (this.canvas.style.visibility = "hidden"));
                      const [he, Pe] = this.parentDimensions;
                      ((this.width = I / he),
                        (this.height = q / Pe),
                        this.fixAndSetPosition(),
                        l(this, d) && le(this, c, ai).call(this, I, q),
                        le(this, c, Nn).call(this),
                        le(this, c, Sn).call(this),
                        (this.canvas.style.visibility = "visible"),
                        this.fixDims());
                    }
                    static deserialize(I, q, ie) {
                      var Je, st, kt;
                      if (I instanceof i.InkAnnotationElement) return null;
                      const re = super.deserialize(I, q, ie);
                      ((re.thickness = I.thickness),
                        (re.color = w.Util.makeHexColor(...I.color)),
                        (re.opacity = I.opacity));
                      const [he, Pe] = re.pageDimensions,
                        Me = re.width * he,
                        se = re.height * Pe,
                        je = re.parentScale,
                        Ie = I.thickness / 2;
                      (Se(re, d, !0),
                        Se(re, v, Math.round(Me)),
                        Se(re, f, Math.round(se)));
                      const { paths: it, rect: Ke, rotation: dt } = I;
                      for (let { bezier: Le } of it) {
                        Le = le((Je = Re), j, ia).call(Je, Le, Ke, dt);
                        const pe = [];
                        re.paths.push(pe);
                        let me = je * (Le[0] - Ie),
                          Xe = je * (Le[1] - Ie);
                        for (let ot = 2, Z = Le.length; ot < Z; ot += 6) {
                          const Te = je * (Le[ot] - Ie),
                            He = je * (Le[ot + 1] - Ie),
                            Ze = je * (Le[ot + 2] - Ie),
                            tt = je * (Le[ot + 3] - Ie),
                            Ge = je * (Le[ot + 4] - Ie),
                            K = je * (Le[ot + 5] - Ie);
                          (pe.push([
                            [me, Xe],
                            [Te, He],
                            [Ze, tt],
                            [Ge, K],
                          ]),
                            (me = Ge),
                            (Xe = K));
                        }
                        const Ye = le(this, j, ra).call(this, pe);
                        re.bezierPath2D.push(Ye);
                      }
                      const ze = le((st = re), c, si).call(st);
                      return (
                        Se(
                          re,
                          k,
                          Math.max(S.AnnotationEditor.MIN_SIZE, ze[2] - ze[0]),
                        ),
                        Se(
                          re,
                          W,
                          Math.max(S.AnnotationEditor.MIN_SIZE, ze[3] - ze[1]),
                        ),
                        le((kt = re), c, ai).call(kt, Me, se),
                        re
                      );
                    }
                    serialize() {
                      if (this.isEmpty()) return null;
                      const I = this.getRect(0, 0),
                        q = S.AnnotationEditor._colorManager.convert(
                          this.ctx.strokeStyle,
                        );
                      return {
                        annotationType: w.AnnotationEditorType.INK,
                        color: q,
                        thickness: this.thickness,
                        opacity: this.opacity,
                        paths: le(this, c, aa).call(
                          this,
                          this.scaleFactor / this.parentScale,
                          this.translationX,
                          this.translationY,
                          I,
                        ),
                        pageIndex: this.pageIndex,
                        rect: I,
                        rotation: this.rotation,
                        structTreeParentId: this._structTreeParentId,
                      };
                    }
                  };
                  ((W = new WeakMap()),
                    (k = new WeakMap()),
                    (N = new WeakMap()),
                    (P = new WeakMap()),
                    (_ = new WeakMap()),
                    (h = new WeakMap()),
                    (r = new WeakMap()),
                    (d = new WeakMap()),
                    (p = new WeakMap()),
                    (u = new WeakMap()),
                    (F = new WeakMap()),
                    (v = new WeakMap()),
                    (f = new WeakMap()),
                    (b = new WeakMap()),
                    (c = new WeakSet()),
                    (Gi = function (I) {
                      const q = this.thickness;
                      this.addCommands({
                        cmd: () => {
                          ((this.thickness = I), le(this, c, Bn).call(this));
                        },
                        undo: () => {
                          ((this.thickness = q), le(this, c, Bn).call(this));
                        },
                        mustExec: !0,
                        type: w.AnnotationEditorParamsType.INK_THICKNESS,
                        overwriteIfSameType: !0,
                        keepUndo: !0,
                      });
                    }),
                    (Xi = function (I) {
                      const q = this.color;
                      this.addCommands({
                        cmd: () => {
                          ((this.color = I), le(this, c, Sn).call(this));
                        },
                        undo: () => {
                          ((this.color = q), le(this, c, Sn).call(this));
                        },
                        mustExec: !0,
                        type: w.AnnotationEditorParamsType.INK_COLOR,
                        overwriteIfSameType: !0,
                        keepUndo: !0,
                      });
                    }),
                    (Ki = function (I) {
                      I /= 100;
                      const q = this.opacity;
                      this.addCommands({
                        cmd: () => {
                          ((this.opacity = I), le(this, c, Sn).call(this));
                        },
                        undo: () => {
                          ((this.opacity = q), le(this, c, Sn).call(this));
                        },
                        mustExec: !0,
                        type: w.AnnotationEditorParamsType.INK_OPACITY,
                        overwriteIfSameType: !0,
                        keepUndo: !0,
                      });
                    }),
                    (Yi = function () {
                      const {
                        parentRotation: I,
                        parentDimensions: [q, ie],
                      } = this;
                      switch (I) {
                        case 90:
                          return [0, ie, ie, q];
                        case 180:
                          return [q, ie, q, ie];
                        case 270:
                          return [q, 0, ie, q];
                        default:
                          return [0, 0, q, ie];
                      }
                    }),
                    (ni = function () {
                      const {
                        ctx: I,
                        color: q,
                        opacity: ie,
                        thickness: re,
                        parentScale: he,
                        scaleFactor: Pe,
                      } = this;
                      ((I.lineWidth = (re * he) / Pe),
                        (I.lineCap = "round"),
                        (I.lineJoin = "round"),
                        (I.miterLimit = 10),
                        (I.strokeStyle = `${q}${(0, ee.opacityToHex)(ie)}`));
                    }),
                    (Zi = function (I, q) {
                      (this.canvas.addEventListener(
                        "contextmenu",
                        H.noContextMenu,
                      ),
                        this.canvas.addEventListener(
                          "pointerleave",
                          l(this, P),
                        ),
                        this.canvas.addEventListener("pointermove", l(this, N)),
                        this.canvas.addEventListener("pointerup", l(this, _)),
                        this.canvas.removeEventListener(
                          "pointerdown",
                          l(this, h),
                        ),
                        (this.isEditing = !0),
                        l(this, u) ||
                          (Se(this, u, !0),
                          le(this, c, Nn).call(this),
                          this.thickness ||
                            (this.thickness = Re._defaultThickness),
                          this.color ||
                            (this.color =
                              Re._defaultColor ||
                              S.AnnotationEditor._defaultLineColor),
                          this.opacity ?? (this.opacity = Re._defaultOpacity)),
                        this.currentPath.push([I, q]),
                        Se(this, p, !1),
                        le(this, c, ni).call(this),
                        Se(this, b, () => {
                          (le(this, c, ea).call(this),
                            l(this, b) &&
                              window.requestAnimationFrame(l(this, b)));
                        }),
                        window.requestAnimationFrame(l(this, b)));
                    }),
                    (ri = function (I, q) {
                      const [ie, re] = this.currentPath.at(-1);
                      if (this.currentPath.length > 1 && I === ie && q === re)
                        return;
                      const he = this.currentPath;
                      let Pe = l(this, r);
                      if ((he.push([I, q]), Se(this, p, !0), he.length <= 2)) {
                        (Pe.moveTo(...he[0]), Pe.lineTo(I, q));
                        return;
                      }
                      (he.length === 3 &&
                        (Se(this, r, (Pe = new Path2D())), Pe.moveTo(...he[0])),
                        le(this, c, ta).call(
                          this,
                          Pe,
                          ...he.at(-3),
                          ...he.at(-2),
                          I,
                          q,
                        ));
                    }),
                    (Ji = function () {
                      if (this.currentPath.length === 0) return;
                      const I = this.currentPath.at(-1);
                      l(this, r).lineTo(...I);
                    }),
                    (Qi = function (I, q) {
                      (Se(this, b, null),
                        (I = Math.min(Math.max(I, 0), this.canvas.width)),
                        (q = Math.min(Math.max(q, 0), this.canvas.height)),
                        le(this, c, ri).call(this, I, q),
                        le(this, c, Ji).call(this));
                      let ie;
                      if (this.currentPath.length !== 1)
                        ie = le(this, c, na).call(this);
                      else {
                        const se = [I, q];
                        ie = [[se, se.slice(), se.slice(), se]];
                      }
                      const re = l(this, r),
                        he = this.currentPath;
                      ((this.currentPath = []), Se(this, r, new Path2D()));
                      const Pe = () => {
                          (this.allRawPaths.push(he),
                            this.paths.push(ie),
                            this.bezierPath2D.push(re),
                            this.rebuild());
                        },
                        Me = () => {
                          (this.allRawPaths.pop(),
                            this.paths.pop(),
                            this.bezierPath2D.pop(),
                            this.paths.length === 0
                              ? this.remove()
                              : (this.canvas ||
                                  (le(this, c, dr).call(this),
                                  le(this, c, hr).call(this)),
                                le(this, c, Bn).call(this)));
                        };
                      this.addCommands({ cmd: Pe, undo: Me, mustExec: !0 });
                    }),
                    (ea = function () {
                      if (!l(this, p)) return;
                      Se(this, p, !1);
                      const I = Math.ceil(this.thickness * this.parentScale),
                        q = this.currentPath.slice(-3),
                        ie = q.map((Pe) => Pe[0]),
                        re = q.map((Pe) => Pe[1]);
                      (Math.min(...ie) - I,
                        Math.max(...ie) + I,
                        Math.min(...re) - I,
                        Math.max(...re) + I);
                      const { ctx: he } = this;
                      (he.save(),
                        he.clearRect(
                          0,
                          0,
                          this.canvas.width,
                          this.canvas.height,
                        ));
                      for (const Pe of this.bezierPath2D) he.stroke(Pe);
                      (he.stroke(l(this, r)), he.restore());
                    }),
                    (ta = function (I, q, ie, re, he, Pe, Me) {
                      const se = (q + re) / 2,
                        je = (ie + he) / 2,
                        Ie = (re + Pe) / 2,
                        it = (he + Me) / 2;
                      I.bezierCurveTo(
                        se + (2 * (re - se)) / 3,
                        je + (2 * (he - je)) / 3,
                        Ie + (2 * (re - Ie)) / 3,
                        it + (2 * (he - it)) / 3,
                        Ie,
                        it,
                      );
                    }),
                    (na = function () {
                      const I = this.currentPath;
                      if (I.length <= 2)
                        return [[I[0], I[0], I.at(-1), I.at(-1)]];
                      const q = [];
                      let ie,
                        [re, he] = I[0];
                      for (ie = 1; ie < I.length - 2; ie++) {
                        const [Ke, dt] = I[ie],
                          [ze, Je] = I[ie + 1],
                          st = (Ke + ze) / 2,
                          kt = (dt + Je) / 2,
                          Le = [
                            re + (2 * (Ke - re)) / 3,
                            he + (2 * (dt - he)) / 3,
                          ],
                          pe = [
                            st + (2 * (Ke - st)) / 3,
                            kt + (2 * (dt - kt)) / 3,
                          ];
                        (q.push([[re, he], Le, pe, [st, kt]]),
                          ([re, he] = [st, kt]));
                      }
                      const [Pe, Me] = I[ie],
                        [se, je] = I[ie + 1],
                        Ie = [
                          re + (2 * (Pe - re)) / 3,
                          he + (2 * (Me - he)) / 3,
                        ],
                        it = [
                          se + (2 * (Pe - se)) / 3,
                          je + (2 * (Me - je)) / 3,
                        ];
                      return (q.push([[re, he], Ie, it, [se, je]]), q);
                    }),
                    (Sn = function () {
                      if (this.isEmpty()) {
                        le(this, c, fr).call(this);
                        return;
                      }
                      le(this, c, ni).call(this);
                      const { canvas: I, ctx: q } = this;
                      (q.setTransform(1, 0, 0, 1, 0, 0),
                        q.clearRect(0, 0, I.width, I.height),
                        le(this, c, fr).call(this));
                      for (const ie of this.bezierPath2D) q.stroke(ie);
                    }),
                    (ii = function (I) {
                      (this.canvas.removeEventListener(
                        "pointerleave",
                        l(this, P),
                      ),
                        this.canvas.removeEventListener(
                          "pointermove",
                          l(this, N),
                        ),
                        this.canvas.removeEventListener(
                          "pointerup",
                          l(this, _),
                        ),
                        this.canvas.addEventListener("pointerdown", l(this, h)),
                        setTimeout(() => {
                          this.canvas.removeEventListener(
                            "contextmenu",
                            H.noContextMenu,
                          );
                        }, 10),
                        le(this, c, Qi).call(this, I.offsetX, I.offsetY),
                        this.addToAnnotationStorage(),
                        this.setInBackground());
                    }),
                    (dr = function () {
                      ((this.canvas = document.createElement("canvas")),
                        (this.canvas.width = this.canvas.height = 0),
                        (this.canvas.className = "inkEditorCanvas"),
                        S.AnnotationEditor._l10nPromise
                          .get("editor_ink_canvas_aria_label")
                          .then((I) => {
                            var q;
                            return (q = this.canvas) == null
                              ? void 0
                              : q.setAttribute("aria-label", I);
                          }),
                        this.div.append(this.canvas),
                        (this.ctx = this.canvas.getContext("2d")));
                    }),
                    (hr = function () {
                      (Se(
                        this,
                        F,
                        new ResizeObserver((I) => {
                          const q = I[0].contentRect;
                          q.width &&
                            q.height &&
                            this.setDimensions(q.width, q.height);
                        }),
                      ),
                        l(this, F).observe(this.div));
                    }),
                    (Nn = function () {
                      if (!l(this, u)) return;
                      const [I, q] = this.parentDimensions;
                      ((this.canvas.width = Math.ceil(this.width * I)),
                        (this.canvas.height = Math.ceil(this.height * q)),
                        le(this, c, fr).call(this));
                    }),
                    (ai = function (I, q) {
                      const ie = le(this, c, pr).call(this),
                        re = (I - ie) / l(this, k),
                        he = (q - ie) / l(this, W);
                      this.scaleFactor = Math.min(re, he);
                    }),
                    (fr = function () {
                      const I = le(this, c, pr).call(this) / 2;
                      this.ctx.setTransform(
                        this.scaleFactor,
                        0,
                        0,
                        this.scaleFactor,
                        this.translationX * this.scaleFactor + I,
                        this.translationY * this.scaleFactor + I,
                      );
                    }),
                    (j = new WeakSet()),
                    (ra = function (I) {
                      const q = new Path2D();
                      for (let ie = 0, re = I.length; ie < re; ie++) {
                        const [he, Pe, Me, se] = I[ie];
                        (ie === 0 && q.moveTo(...he),
                          q.bezierCurveTo(
                            Pe[0],
                            Pe[1],
                            Me[0],
                            Me[1],
                            se[0],
                            se[1],
                          ));
                      }
                      return q;
                    }),
                    (oi = function (I, q, ie) {
                      const [re, he, Pe, Me] = q;
                      switch (ie) {
                        case 0:
                          for (let se = 0, je = I.length; se < je; se += 2)
                            ((I[se] += re), (I[se + 1] = Me - I[se + 1]));
                          break;
                        case 90:
                          for (let se = 0, je = I.length; se < je; se += 2) {
                            const Ie = I[se];
                            ((I[se] = I[se + 1] + re), (I[se + 1] = Ie + he));
                          }
                          break;
                        case 180:
                          for (let se = 0, je = I.length; se < je; se += 2)
                            ((I[se] = Pe - I[se]), (I[se + 1] += he));
                          break;
                        case 270:
                          for (let se = 0, je = I.length; se < je; se += 2) {
                            const Ie = I[se];
                            ((I[se] = Pe - I[se + 1]), (I[se + 1] = Me - Ie));
                          }
                          break;
                        default:
                          throw new Error("Invalid rotation");
                      }
                      return I;
                    }),
                    (ia = function (I, q, ie) {
                      const [re, he, Pe, Me] = q;
                      switch (ie) {
                        case 0:
                          for (let se = 0, je = I.length; se < je; se += 2)
                            ((I[se] -= re), (I[se + 1] = Me - I[se + 1]));
                          break;
                        case 90:
                          for (let se = 0, je = I.length; se < je; se += 2) {
                            const Ie = I[se];
                            ((I[se] = I[se + 1] - he), (I[se + 1] = Ie - re));
                          }
                          break;
                        case 180:
                          for (let se = 0, je = I.length; se < je; se += 2)
                            ((I[se] = Pe - I[se]), (I[se + 1] -= he));
                          break;
                        case 270:
                          for (let se = 0, je = I.length; se < je; se += 2) {
                            const Ie = I[se];
                            ((I[se] = Me - I[se + 1]), (I[se + 1] = Pe - Ie));
                          }
                          break;
                        default:
                          throw new Error("Invalid rotation");
                      }
                      return I;
                    }),
                    (aa = function (I, q, ie, re) {
                      var je, Ie;
                      const he = [],
                        Pe = this.thickness / 2,
                        Me = I * q + Pe,
                        se = I * ie + Pe;
                      for (const it of this.paths) {
                        const Ke = [],
                          dt = [];
                        for (let ze = 0, Je = it.length; ze < Je; ze++) {
                          const [st, kt, Le, pe] = it[ze],
                            me = I * st[0] + Me,
                            Xe = I * st[1] + se,
                            Ye = I * kt[0] + Me,
                            ot = I * kt[1] + se,
                            Z = I * Le[0] + Me,
                            Te = I * Le[1] + se,
                            He = I * pe[0] + Me,
                            Ze = I * pe[1] + se;
                          (ze === 0 && (Ke.push(me, Xe), dt.push(me, Xe)),
                            Ke.push(Ye, ot, Z, Te, He, Ze),
                            dt.push(Ye, ot),
                            ze === Je - 1 && dt.push(He, Ze));
                        }
                        he.push({
                          bezier: le((je = Re), j, oi).call(
                            je,
                            Ke,
                            re,
                            this.rotation,
                          ),
                          points: le((Ie = Re), j, oi).call(
                            Ie,
                            dt,
                            re,
                            this.rotation,
                          ),
                        });
                      }
                      return he;
                    }),
                    (si = function () {
                      let I = 1 / 0,
                        q = -1 / 0,
                        ie = 1 / 0,
                        re = -1 / 0;
                      for (const he of this.paths)
                        for (const [Pe, Me, se, je] of he) {
                          const Ie = w.Util.bezierBoundingBox(
                            ...Pe,
                            ...Me,
                            ...se,
                            ...je,
                          );
                          ((I = Math.min(I, Ie[0])),
                            (ie = Math.min(ie, Ie[1])),
                            (q = Math.max(q, Ie[2])),
                            (re = Math.max(re, Ie[3])));
                        }
                      return [I, ie, q, re];
                    }),
                    (pr = function () {
                      return l(this, d)
                        ? Math.ceil(this.thickness * this.parentScale)
                        : 0;
                    }),
                    (Bn = function (I = !1) {
                      if (this.isEmpty()) return;
                      if (!l(this, d)) {
                        le(this, c, Sn).call(this);
                        return;
                      }
                      const q = le(this, c, si).call(this),
                        ie = le(this, c, pr).call(this);
                      (Se(
                        this,
                        k,
                        Math.max(S.AnnotationEditor.MIN_SIZE, q[2] - q[0]),
                      ),
                        Se(
                          this,
                          W,
                          Math.max(S.AnnotationEditor.MIN_SIZE, q[3] - q[1]),
                        ));
                      const re = Math.ceil(ie + l(this, k) * this.scaleFactor),
                        he = Math.ceil(ie + l(this, W) * this.scaleFactor),
                        [Pe, Me] = this.parentDimensions;
                      ((this.width = re / Pe),
                        (this.height = he / Me),
                        this.setAspectRatio(re, he));
                      const se = this.translationX,
                        je = this.translationY;
                      ((this.translationX = -q[0]),
                        (this.translationY = -q[1]),
                        le(this, c, Nn).call(this),
                        le(this, c, Sn).call(this),
                        Se(this, v, re),
                        Se(this, f, he),
                        this.setDims(re, he));
                      const Ie = I ? ie / this.scaleFactor / 2 : 0;
                      this.translate(
                        se - this.translationX - Ie,
                        je - this.translationY - Ie,
                      );
                    }),
                    ye(Re, j),
                    $t(Re, "_defaultColor", null),
                    $t(Re, "_defaultOpacity", 1),
                    $t(Re, "_defaultThickness", 1),
                    $t(Re, "_type", "ink"));
                  let X = Re;
                  A.InkEditor = X;
                },
                (t, A, n) => {
                  var X,
                    W,
                    k,
                    N,
                    P,
                    _,
                    h,
                    r,
                    d,
                    p,
                    u,
                    Gn,
                    Xn,
                    mr,
                    ci,
                    oa,
                    sa,
                    li,
                    gr,
                    ca;
                  (Object.defineProperty(A, "__esModule", { value: !0 }),
                    (A.StampEditor = void 0));
                  var w = n(1),
                    S = n(4),
                    i = n(6),
                    H = n(29);
                  const o = class o extends S.AnnotationEditor {
                    constructor(M) {
                      super({ ...M, name: "stampEditor" });
                      ye(this, u);
                      ye(this, X, null);
                      ye(this, W, null);
                      ye(this, k, null);
                      ye(this, N, null);
                      ye(this, P, null);
                      ye(this, _, null);
                      ye(this, h, null);
                      ye(this, r, null);
                      ye(this, d, !1);
                      ye(this, p, !1);
                      (Se(this, N, M.bitmapUrl), Se(this, P, M.bitmapFile));
                    }
                    static initialize(M) {
                      S.AnnotationEditor.initialize(M);
                    }
                    static get supportedTypes() {
                      const M = [
                        "apng",
                        "avif",
                        "bmp",
                        "gif",
                        "jpeg",
                        "png",
                        "svg+xml",
                        "webp",
                        "x-icon",
                      ];
                      return (0, w.shadow)(
                        this,
                        "supportedTypes",
                        M.map((D) => `image/${D}`),
                      );
                    }
                    static get supportedTypesStr() {
                      return (0, w.shadow)(
                        this,
                        "supportedTypesStr",
                        this.supportedTypes.join(","),
                      );
                    }
                    static isHandlingMimeForPasting(M) {
                      return this.supportedTypes.includes(M);
                    }
                    static paste(M, D) {
                      D.pasteEditor(w.AnnotationEditorType.STAMP, {
                        bitmapFile: M.getAsFile(),
                      });
                    }
                    remove() {
                      var M, D;
                      (l(this, W) &&
                        (Se(this, X, null),
                        this._uiManager.imageManager.deleteId(l(this, W)),
                        (M = l(this, _)) == null || M.remove(),
                        Se(this, _, null),
                        (D = l(this, h)) == null || D.disconnect(),
                        Se(this, h, null)),
                        super.remove());
                    }
                    rebuild() {
                      if (!this.parent) {
                        l(this, W) && le(this, u, mr).call(this);
                        return;
                      }
                      (super.rebuild(),
                        this.div !== null &&
                          (l(this, W) && le(this, u, mr).call(this),
                          this.isAttachedToDOM || this.parent.add(this)));
                    }
                    onceAdded() {
                      ((this._isDraggable = !0), this.div.focus());
                    }
                    isEmpty() {
                      return !(
                        l(this, k) ||
                        l(this, X) ||
                        l(this, N) ||
                        l(this, P)
                      );
                    }
                    get isResizable() {
                      return !0;
                    }
                    render() {
                      if (this.div) return this.div;
                      let M, D;
                      if (
                        (this.width && ((M = this.x), (D = this.y)),
                        super.render(),
                        (this.div.hidden = !0),
                        l(this, X)
                          ? le(this, u, ci).call(this)
                          : le(this, u, mr).call(this),
                        this.width)
                      ) {
                        const [x, z] = this.parentDimensions;
                        this.setAt(
                          M * x,
                          D * z,
                          this.width * x,
                          this.height * z,
                        );
                      }
                      return this.div;
                    }
                    static deserialize(M, D, x) {
                      if (M instanceof H.StampAnnotationElement) return null;
                      const z = super.deserialize(M, D, x),
                        {
                          rect: L,
                          bitmapUrl: V,
                          bitmapId: Y,
                          isSvg: T,
                          accessibilityData: s,
                        } = M;
                      (Y && x.imageManager.isValidId(Y)
                        ? Se(z, W, Y)
                        : Se(z, N, V),
                        Se(z, d, T));
                      const [g, R] = z.pageDimensions;
                      return (
                        (z.width = (L[2] - L[0]) / g),
                        (z.height = (L[3] - L[1]) / R),
                        s && (z.altTextData = s),
                        z
                      );
                    }
                    serialize(M = !1, D = null) {
                      if (this.isEmpty()) return null;
                      const x = {
                        annotationType: w.AnnotationEditorType.STAMP,
                        bitmapId: l(this, W),
                        pageIndex: this.pageIndex,
                        rect: this.getRect(0, 0),
                        rotation: this.rotation,
                        isSvg: l(this, d),
                        structTreeParentId: this._structTreeParentId,
                      };
                      if (M)
                        return (
                          (x.bitmapUrl = le(this, u, gr).call(this, !0)),
                          (x.accessibilityData = this.altTextData),
                          x
                        );
                      const { decorative: z, altText: L } = this.altTextData;
                      if (
                        (!z &&
                          L &&
                          (x.accessibilityData = { type: "Figure", alt: L }),
                        D === null)
                      )
                        return x;
                      D.stamps || (D.stamps = new Map());
                      const V = l(this, d)
                        ? (x.rect[2] - x.rect[0]) * (x.rect[3] - x.rect[1])
                        : null;
                      if (!D.stamps.has(l(this, W)))
                        (D.stamps.set(l(this, W), { area: V, serialized: x }),
                          (x.bitmap = le(this, u, gr).call(this, !1)));
                      else if (l(this, d)) {
                        const Y = D.stamps.get(l(this, W));
                        V > Y.area &&
                          ((Y.area = V),
                          Y.serialized.bitmap.close(),
                          (Y.serialized.bitmap = le(this, u, gr).call(
                            this,
                            !1,
                          )));
                      }
                      return x;
                    }
                  };
                  ((X = new WeakMap()),
                    (W = new WeakMap()),
                    (k = new WeakMap()),
                    (N = new WeakMap()),
                    (P = new WeakMap()),
                    (_ = new WeakMap()),
                    (h = new WeakMap()),
                    (r = new WeakMap()),
                    (d = new WeakMap()),
                    (p = new WeakMap()),
                    (u = new WeakSet()),
                    (Gn = function (M, D = !1) {
                      if (!M) {
                        this.remove();
                        return;
                      }
                      (Se(this, X, M.bitmap),
                        D || (Se(this, W, M.id), Se(this, d, M.isSvg)),
                        le(this, u, ci).call(this));
                    }),
                    (Xn = function () {
                      (Se(this, k, null),
                        this._uiManager.enableWaiting(!1),
                        l(this, _) && this.div.focus());
                    }),
                    (mr = function () {
                      if (l(this, W)) {
                        (this._uiManager.enableWaiting(!0),
                          this._uiManager.imageManager
                            .getFromId(l(this, W))
                            .then((D) => le(this, u, Gn).call(this, D, !0))
                            .finally(() => le(this, u, Xn).call(this)));
                        return;
                      }
                      if (l(this, N)) {
                        const D = l(this, N);
                        (Se(this, N, null),
                          this._uiManager.enableWaiting(!0),
                          Se(
                            this,
                            k,
                            this._uiManager.imageManager
                              .getFromUrl(D)
                              .then((x) => le(this, u, Gn).call(this, x))
                              .finally(() => le(this, u, Xn).call(this)),
                          ));
                        return;
                      }
                      if (l(this, P)) {
                        const D = l(this, P);
                        (Se(this, P, null),
                          this._uiManager.enableWaiting(!0),
                          Se(
                            this,
                            k,
                            this._uiManager.imageManager
                              .getFromFile(D)
                              .then((x) => le(this, u, Gn).call(this, x))
                              .finally(() => le(this, u, Xn).call(this)),
                          ));
                        return;
                      }
                      const M = document.createElement("input");
                      ((M.type = "file"),
                        (M.accept = o.supportedTypesStr),
                        Se(
                          this,
                          k,
                          new Promise((D) => {
                            (M.addEventListener("change", async () => {
                              if (!M.files || M.files.length === 0)
                                this.remove();
                              else {
                                this._uiManager.enableWaiting(!0);
                                const x =
                                  await this._uiManager.imageManager.getFromFile(
                                    M.files[0],
                                  );
                                le(this, u, Gn).call(this, x);
                              }
                              D();
                            }),
                              M.addEventListener("cancel", () => {
                                (this.remove(), D());
                              }));
                          }).finally(() => le(this, u, Xn).call(this)),
                        ),
                        M.click());
                    }),
                    (ci = function () {
                      const { div: M } = this;
                      let { width: D, height: x } = l(this, X);
                      const [z, L] = this.pageDimensions,
                        V = 0.75;
                      if (this.width)
                        ((D = this.width * z), (x = this.height * L));
                      else if (D > V * z || x > V * L) {
                        const g = Math.min((V * z) / D, (V * L) / x);
                        ((D *= g), (x *= g));
                      }
                      const [Y, T] = this.parentDimensions;
                      (this.setDims((D * Y) / z, (x * T) / L),
                        this._uiManager.enableWaiting(!1));
                      const s = Se(this, _, document.createElement("canvas"));
                      (M.append(s),
                        (M.hidden = !1),
                        le(this, u, li).call(this, D, x),
                        le(this, u, ca).call(this),
                        l(this, p) ||
                          (this.parent.addUndoableEditor(this),
                          Se(this, p, !0)),
                        this._uiManager._eventBus.dispatch("reporttelemetry", {
                          source: this,
                          details: {
                            type: "editing",
                            subtype: this.editorType,
                            data: { action: "inserted_image" },
                          },
                        }),
                        this.addAltTextButton());
                    }),
                    (oa = function (M, D) {
                      var V;
                      const [x, z] = this.parentDimensions;
                      ((this.width = M / x),
                        (this.height = D / z),
                        this.setDims(M, D),
                        (V = this._initialOptions) != null && V.isCentered
                          ? this.center()
                          : this.fixAndSetPosition(),
                        (this._initialOptions = null),
                        l(this, r) !== null && clearTimeout(l(this, r)),
                        Se(
                          this,
                          r,
                          setTimeout(() => {
                            (Se(this, r, null),
                              le(this, u, li).call(this, M, D));
                          }, 200),
                        ));
                    }),
                    (sa = function (M, D) {
                      const { width: x, height: z } = l(this, X);
                      let L = x,
                        V = z,
                        Y = l(this, X);
                      for (; L > 2 * M || V > 2 * D; ) {
                        const T = L,
                          s = V;
                        (L > 2 * M &&
                          (L =
                            L >= 16384
                              ? Math.floor(L / 2) - 1
                              : Math.ceil(L / 2)),
                          V > 2 * D &&
                            (V =
                              V >= 16384
                                ? Math.floor(V / 2) - 1
                                : Math.ceil(V / 2)));
                        const g = new OffscreenCanvas(L, V);
                        (g
                          .getContext("2d")
                          .drawImage(Y, 0, 0, T, s, 0, 0, L, V),
                          (Y = g.transferToImageBitmap()));
                      }
                      return Y;
                    }),
                    (li = function (M, D) {
                      ((M = Math.ceil(M)), (D = Math.ceil(D)));
                      const x = l(this, _);
                      if (!x || (x.width === M && x.height === D)) return;
                      ((x.width = M), (x.height = D));
                      const z = l(this, d)
                          ? l(this, X)
                          : le(this, u, sa).call(this, M, D),
                        L = x.getContext("2d");
                      ((L.filter = this._uiManager.hcmFilter),
                        L.drawImage(z, 0, 0, z.width, z.height, 0, 0, M, D));
                    }),
                    (gr = function (M) {
                      if (M) {
                        if (l(this, d)) {
                          const z = this._uiManager.imageManager.getSvgUrl(
                            l(this, W),
                          );
                          if (z) return z;
                        }
                        const D = document.createElement("canvas");
                        return (
                          ({ width: D.width, height: D.height } = l(this, X)),
                          D.getContext("2d").drawImage(l(this, X), 0, 0),
                          D.toDataURL()
                        );
                      }
                      if (l(this, d)) {
                        const [D, x] = this.pageDimensions,
                          z = Math.round(
                            this.width * D * i.PixelsPerInch.PDF_TO_CSS_UNITS,
                          ),
                          L = Math.round(
                            this.height * x * i.PixelsPerInch.PDF_TO_CSS_UNITS,
                          ),
                          V = new OffscreenCanvas(z, L);
                        return (
                          V.getContext("2d").drawImage(
                            l(this, X),
                            0,
                            0,
                            l(this, X).width,
                            l(this, X).height,
                            0,
                            0,
                            z,
                            L,
                          ),
                          V.transferToImageBitmap()
                        );
                      }
                      return structuredClone(l(this, X));
                    }),
                    (ca = function () {
                      (Se(
                        this,
                        h,
                        new ResizeObserver((M) => {
                          const D = M[0].contentRect;
                          D.width &&
                            D.height &&
                            le(this, u, oa).call(this, D.width, D.height);
                        }),
                      ),
                        l(this, h).observe(this.div));
                    }),
                    $t(o, "_type", "stamp"));
                  let ee = o;
                  A.StampEditor = ee;
                },
              ],
              __webpack_module_cache__ = {};
            function __w_pdfjs_require__(t) {
              var A = __webpack_module_cache__[t];
              if (A !== void 0) return A.exports;
              var n = (__webpack_module_cache__[t] = { exports: {} });
              return (
                __webpack_modules__[t](n, n.exports, __w_pdfjs_require__),
                n.exports
              );
            }
            var __webpack_exports__ = {};
            return (
              (() => {
                var t = __webpack_exports__;
                (Object.defineProperty(t, "__esModule", { value: !0 }),
                  Object.defineProperty(t, "AbortException", {
                    enumerable: !0,
                    get: function () {
                      return A.AbortException;
                    },
                  }),
                  Object.defineProperty(t, "AnnotationEditorLayer", {
                    enumerable: !0,
                    get: function () {
                      return i.AnnotationEditorLayer;
                    },
                  }),
                  Object.defineProperty(t, "AnnotationEditorParamsType", {
                    enumerable: !0,
                    get: function () {
                      return A.AnnotationEditorParamsType;
                    },
                  }),
                  Object.defineProperty(t, "AnnotationEditorType", {
                    enumerable: !0,
                    get: function () {
                      return A.AnnotationEditorType;
                    },
                  }),
                  Object.defineProperty(t, "AnnotationEditorUIManager", {
                    enumerable: !0,
                    get: function () {
                      return H.AnnotationEditorUIManager;
                    },
                  }),
                  Object.defineProperty(t, "AnnotationLayer", {
                    enumerable: !0,
                    get: function () {
                      return ee.AnnotationLayer;
                    },
                  }),
                  Object.defineProperty(t, "AnnotationMode", {
                    enumerable: !0,
                    get: function () {
                      return A.AnnotationMode;
                    },
                  }),
                  Object.defineProperty(t, "CMapCompressionType", {
                    enumerable: !0,
                    get: function () {
                      return A.CMapCompressionType;
                    },
                  }),
                  Object.defineProperty(t, "DOMSVGFactory", {
                    enumerable: !0,
                    get: function () {
                      return w.DOMSVGFactory;
                    },
                  }),
                  Object.defineProperty(t, "FeatureTest", {
                    enumerable: !0,
                    get: function () {
                      return A.FeatureTest;
                    },
                  }),
                  Object.defineProperty(t, "GlobalWorkerOptions", {
                    enumerable: !0,
                    get: function () {
                      return X.GlobalWorkerOptions;
                    },
                  }),
                  Object.defineProperty(t, "ImageKind", {
                    enumerable: !0,
                    get: function () {
                      return A.ImageKind;
                    },
                  }),
                  Object.defineProperty(t, "InvalidPDFException", {
                    enumerable: !0,
                    get: function () {
                      return A.InvalidPDFException;
                    },
                  }),
                  Object.defineProperty(t, "MissingPDFException", {
                    enumerable: !0,
                    get: function () {
                      return A.MissingPDFException;
                    },
                  }),
                  Object.defineProperty(t, "OPS", {
                    enumerable: !0,
                    get: function () {
                      return A.OPS;
                    },
                  }),
                  Object.defineProperty(t, "PDFDataRangeTransport", {
                    enumerable: !0,
                    get: function () {
                      return n.PDFDataRangeTransport;
                    },
                  }),
                  Object.defineProperty(t, "PDFDateString", {
                    enumerable: !0,
                    get: function () {
                      return w.PDFDateString;
                    },
                  }),
                  Object.defineProperty(t, "PDFWorker", {
                    enumerable: !0,
                    get: function () {
                      return n.PDFWorker;
                    },
                  }),
                  Object.defineProperty(t, "PasswordResponses", {
                    enumerable: !0,
                    get: function () {
                      return A.PasswordResponses;
                    },
                  }),
                  Object.defineProperty(t, "PermissionFlag", {
                    enumerable: !0,
                    get: function () {
                      return A.PermissionFlag;
                    },
                  }),
                  Object.defineProperty(t, "PixelsPerInch", {
                    enumerable: !0,
                    get: function () {
                      return w.PixelsPerInch;
                    },
                  }),
                  Object.defineProperty(t, "PromiseCapability", {
                    enumerable: !0,
                    get: function () {
                      return A.PromiseCapability;
                    },
                  }),
                  Object.defineProperty(t, "RenderingCancelledException", {
                    enumerable: !0,
                    get: function () {
                      return w.RenderingCancelledException;
                    },
                  }),
                  Object.defineProperty(t, "SVGGraphics", {
                    enumerable: !0,
                    get: function () {
                      return n.SVGGraphics;
                    },
                  }),
                  Object.defineProperty(t, "UnexpectedResponseException", {
                    enumerable: !0,
                    get: function () {
                      return A.UnexpectedResponseException;
                    },
                  }),
                  Object.defineProperty(t, "Util", {
                    enumerable: !0,
                    get: function () {
                      return A.Util;
                    },
                  }),
                  Object.defineProperty(t, "VerbosityLevel", {
                    enumerable: !0,
                    get: function () {
                      return A.VerbosityLevel;
                    },
                  }),
                  Object.defineProperty(t, "XfaLayer", {
                    enumerable: !0,
                    get: function () {
                      return W.XfaLayer;
                    },
                  }),
                  Object.defineProperty(t, "build", {
                    enumerable: !0,
                    get: function () {
                      return n.build;
                    },
                  }),
                  Object.defineProperty(t, "createValidAbsoluteUrl", {
                    enumerable: !0,
                    get: function () {
                      return A.createValidAbsoluteUrl;
                    },
                  }),
                  Object.defineProperty(t, "getDocument", {
                    enumerable: !0,
                    get: function () {
                      return n.getDocument;
                    },
                  }),
                  Object.defineProperty(t, "getFilenameFromUrl", {
                    enumerable: !0,
                    get: function () {
                      return w.getFilenameFromUrl;
                    },
                  }),
                  Object.defineProperty(t, "getPdfFilenameFromUrl", {
                    enumerable: !0,
                    get: function () {
                      return w.getPdfFilenameFromUrl;
                    },
                  }),
                  Object.defineProperty(t, "getXfaPageViewport", {
                    enumerable: !0,
                    get: function () {
                      return w.getXfaPageViewport;
                    },
                  }),
                  Object.defineProperty(t, "isDataScheme", {
                    enumerable: !0,
                    get: function () {
                      return w.isDataScheme;
                    },
                  }),
                  Object.defineProperty(t, "isPdfFile", {
                    enumerable: !0,
                    get: function () {
                      return w.isPdfFile;
                    },
                  }),
                  Object.defineProperty(t, "loadScript", {
                    enumerable: !0,
                    get: function () {
                      return w.loadScript;
                    },
                  }),
                  Object.defineProperty(t, "noContextMenu", {
                    enumerable: !0,
                    get: function () {
                      return w.noContextMenu;
                    },
                  }),
                  Object.defineProperty(t, "normalizeUnicode", {
                    enumerable: !0,
                    get: function () {
                      return A.normalizeUnicode;
                    },
                  }),
                  Object.defineProperty(t, "renderTextLayer", {
                    enumerable: !0,
                    get: function () {
                      return S.renderTextLayer;
                    },
                  }),
                  Object.defineProperty(t, "setLayerDimensions", {
                    enumerable: !0,
                    get: function () {
                      return w.setLayerDimensions;
                    },
                  }),
                  Object.defineProperty(t, "shadow", {
                    enumerable: !0,
                    get: function () {
                      return A.shadow;
                    },
                  }),
                  Object.defineProperty(t, "updateTextLayer", {
                    enumerable: !0,
                    get: function () {
                      return S.updateTextLayer;
                    },
                  }),
                  Object.defineProperty(t, "version", {
                    enumerable: !0,
                    get: function () {
                      return n.version;
                    },
                  }));
                var A = __w_pdfjs_require__(1),
                  n = __w_pdfjs_require__(2),
                  w = __w_pdfjs_require__(6),
                  S = __w_pdfjs_require__(26),
                  i = __w_pdfjs_require__(27),
                  H = __w_pdfjs_require__(5),
                  ee = __w_pdfjs_require__(29),
                  X = __w_pdfjs_require__(14),
                  W = __w_pdfjs_require__(32);
              })(),
              __webpack_exports__
            );
          })(),
        );
      })(pdf)),
    pdf.exports
  );
}
var hasRequiredCore_min;
function requireCore_min() {
  return (
    hasRequiredCore_min ||
      ((hasRequiredCore_min = 1),
      (function (t) {
        var A = requireReact(),
          n = requirePdf();
        function w(E) {
          var O = Object.create(null);
          return (
            E &&
              Object.keys(E).forEach(function (J) {
                if (J !== "default") {
                  var te = Object.getOwnPropertyDescriptor(E, J);
                  Object.defineProperty(
                    O,
                    J,
                    te.get
                      ? te
                      : {
                          enumerable: !0,
                          get: function () {
                            return E[J];
                          },
                        },
                  );
                }
              }),
            (O.default = E),
            Object.freeze(O)
          );
        }
        var S,
          i = w(A),
          H = w(n);
        ((t.AnnotationType = void 0),
          ((S = t.AnnotationType || (t.AnnotationType = {}))[(S.Text = 1)] =
            "Text"),
          (S[(S.Link = 2)] = "Link"),
          (S[(S.FreeText = 3)] = "FreeText"),
          (S[(S.Line = 4)] = "Line"),
          (S[(S.Square = 5)] = "Square"),
          (S[(S.Circle = 6)] = "Circle"),
          (S[(S.Polygon = 7)] = "Polygon"),
          (S[(S.Polyline = 8)] = "Polyline"),
          (S[(S.Highlight = 9)] = "Highlight"),
          (S[(S.Underline = 10)] = "Underline"),
          (S[(S.Squiggly = 11)] = "Squiggly"),
          (S[(S.StrikeOut = 12)] = "StrikeOut"),
          (S[(S.Stamp = 13)] = "Stamp"),
          (S[(S.Caret = 14)] = "Caret"),
          (S[(S.Ink = 15)] = "Ink"),
          (S[(S.Popup = 16)] = "Popup"),
          (S[(S.FileAttachment = 17)] = "FileAttachment"));
        var ee = function (E, O) {
          return (
            (ee =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (J, te) {
                  J.__proto__ = te;
                }) ||
              function (J, te) {
                for (var oe in te)
                  Object.prototype.hasOwnProperty.call(te, oe) &&
                    (J[oe] = te[oe]);
              }),
            ee(E, O)
          );
        };
        function X(E, O) {
          if (typeof O != "function" && O !== null)
            throw new TypeError(
              "Class extends value " +
                String(O) +
                " is not a constructor or null",
            );
          function J() {
            this.constructor = E;
          }
          (ee(E, O),
            (E.prototype =
              O === null
                ? Object.create(O)
                : ((J.prototype = O.prototype), new J())));
        }
        var W,
          k = function () {
            return (
              (k =
                Object.assign ||
                function (E) {
                  for (var O, J = 1, te = arguments.length; J < te; J++)
                    for (var oe in (O = arguments[J]))
                      Object.prototype.hasOwnProperty.call(O, oe) &&
                        (E[oe] = O[oe]);
                  return E;
                }),
              k.apply(this, arguments)
            );
          };
        ((t.TextDirection = void 0),
          ((W = t.TextDirection || (t.TextDirection = {})).RightToLeft = "RTL"),
          (W.LeftToRight = "LTR"));
        var N,
          P = i.createContext({
            currentTheme: "light",
            direction: t.TextDirection.LeftToRight,
            setCurrentTheme: function () {},
          }),
          _ = function (E) {
            var O = [];
            return (
              Object.keys(E).forEach(function (J) {
                J && E[J] && O.push(J);
              }),
              O.join(" ")
            );
          },
          h = typeof window < "u" ? i.useLayoutEffect : i.useEffect,
          r = function (E) {
            var O = i.useRef(null),
              J = E.once,
              te = E.threshold,
              oe = E.onVisibilityChanged;
            return (
              h(function () {
                var ce = O.current;
                if (ce) {
                  var _e = new IntersectionObserver(
                    function (ge) {
                      ge.forEach(function (ne) {
                        var be = ne.isIntersecting,
                          ve = ne.intersectionRatio;
                        (oe({ isVisible: be, ratio: ve }),
                          be && J && (_e.unobserve(ce), _e.disconnect()));
                      });
                    },
                    { threshold: te || 0 },
                  );
                  return (
                    _e.observe(ce),
                    function () {
                      (_e.unobserve(ce), _e.disconnect());
                    }
                  );
                }
              }, []),
              O
            );
          },
          d = function (E) {
            var O = E.children,
              J = E.ignoreDirection,
              te = J !== void 0 && J,
              oe = E.size,
              ce = oe === void 0 ? 24 : oe,
              _e = i.useContext(P).direction,
              ge = !te && _e === t.TextDirection.RightToLeft,
              ne = "".concat(ce || 24, "px");
            return i.createElement(
              "svg",
              {
                "aria-hidden": "true",
                className: _({
                  "rpv-core__icon": !0,
                  "rpv-core__icon--rtl": ge,
                }),
                focusable: "false",
                height: ne,
                viewBox: "0 0 24 24",
                width: ne,
              },
              O,
            );
          },
          p = function () {
            return i.createElement(
              d,
              { size: 16 },
              i.createElement("path", { d: "M23.5,0.499l-16.5,23l-6.5-6.5" }),
            );
          },
          u = function (E) {
            var O = E.children,
              J = E.testId,
              te = E.onClick,
              oe = i.useContext(P).direction === t.TextDirection.RightToLeft,
              ce = J ? { "data-testid": J } : {};
            return i.createElement(
              "button",
              k(
                {
                  className: _({
                    "rpv-core__primary-button": !0,
                    "rpv-core__primary-button--rtl": oe,
                  }),
                  type: "button",
                  onClick: te,
                },
                ce,
              ),
              O,
            );
          },
          F = function (E) {
            var O = E.size,
              J = O === void 0 ? "4rem" : O,
              te = E.testId,
              oe = i.useState(!1),
              ce = oe[0],
              _e = oe[1],
              ge = te ? { "data-testid": te } : {},
              ne = r({
                onVisibilityChanged: function (be) {
                  _e(be.isVisible);
                },
              });
            return i.createElement(
              "div",
              k({}, ge, {
                className: _({
                  "rpv-core__spinner": !0,
                  "rpv-core__spinner--animating": ce,
                }),
                ref: ne,
                style: { height: J, width: J },
              }),
            );
          },
          v = function (E) {
            var O = E.ariaLabel,
              J = O === void 0 ? "" : O,
              te = E.autoFocus,
              oe = te !== void 0 && te,
              ce = E.placeholder,
              _e = ce === void 0 ? "" : ce,
              ge = E.testId,
              ne = E.type,
              be = ne === void 0 ? "text" : ne,
              ve = E.value,
              Be = ve === void 0 ? "" : ve,
              Oe = E.onChange,
              De = E.onKeyDown,
              $e = De === void 0 ? function () {} : De,
              We = i.useContext(P).direction,
              Ve = i.useRef(),
              xt = We === t.TextDirection.RightToLeft,
              pt = {
                ref: Ve,
                "data-testid": "",
                "aria-label": J,
                className: _({
                  "rpv-core__textbox": !0,
                  "rpv-core__textbox--rtl": xt,
                }),
                placeholder: _e,
                value: Be,
                onChange: function (gt) {
                  return Oe(gt.target.value);
                },
                onKeyDown: $e,
              };
            return (
              ge && (pt["data-testid"] = ge),
              h(function () {
                if (oe) {
                  var gt = Ve.current;
                  if (gt) {
                    var yt = window.scrollX,
                      ct = window.scrollY;
                    (gt.focus(), window.scrollTo(yt, ct));
                  }
                }
              }, []),
              be === "text"
                ? i.createElement("input", k({ type: "text" }, pt))
                : i.createElement("input", k({ type: "password" }, pt))
            );
          };
        (function (E) {
          ((E[(E.ExitFullScreen = 0)] = "ExitFullScreen"),
            (E[(E.FullScreenChange = 1)] = "FullScreenChange"),
            (E[(E.FullScreenElement = 2)] = "FullScreenElement"),
            (E[(E.FullScreenEnabled = 3)] = "FullScreenEnabled"),
            (E[(E.RequestFullScreen = 4)] = "RequestFullScreen"));
        })(N || (N = {}));
        var f,
          b = {
            ExitFullScreen: "exitFullscreen",
            FullScreenChange: "fullscreenchange",
            FullScreenElement: "fullscreenElement",
            FullScreenEnabled: "fullscreenEnabled",
            RequestFullScreen: "requestFullscreen",
          },
          c = {
            ExitFullScreen: "webkitExitFullscreen",
            FullScreenChange: "webkitfullscreenchange",
            FullScreenElement: "webkitFullscreenElement",
            FullScreenEnabled: "webkitFullscreenEnabled",
            RequestFullScreen: "webkitRequestFullscreen",
          },
          a = {
            ExitFullScreen: "msExitFullscreen",
            FullScreenChange: "msFullscreenChange",
            FullScreenElement: "msFullscreenElement",
            FullScreenEnabled: "msFullscreenEnabled",
            RequestFullScreen: "msRequestFullscreen",
          },
          m = typeof window < "u",
          C =
            (m &&
              ((N.FullScreenEnabled in document && b) ||
                (c.FullScreenEnabled in document && c) ||
                (a.FullScreenEnabled in document && a))) ||
            b,
          e = function () {
            return (
              m &&
              C.FullScreenEnabled in document &&
              document[C.FullScreenEnabled] === !0
            );
          },
          o = function (E) {
            return m ? E[C.ExitFullScreen]() : Promise.resolve({});
          },
          y = function () {
            return m ? document[C.FullScreenElement] : null;
          },
          B = function (E, O) {
            var J = i.useRef(),
              te = function () {
                J.current && clearTimeout(J.current);
              };
            return (
              i.useEffect(function () {
                return function () {
                  return te();
                };
              }, []),
              i.useCallback(
                function () {
                  for (var oe = [], ce = 0; ce < arguments.length; ce++)
                    oe[ce] = arguments[ce];
                  (te(),
                    (J.current = setTimeout(function () {
                      E.apply(void 0, oe);
                    }, O)));
                },
                [E, O],
              )
            );
          },
          M = function () {
            var E = i.useRef(!1);
            return (
              i.useEffect(function () {
                return (
                  (E.current = !0),
                  function () {
                    E.current = !1;
                  }
                );
              }, []),
              E
            );
          },
          D = function (E) {
            var O = i.useRef(E);
            return (
              i.useEffect(
                function () {
                  O.current = E;
                },
                [E],
              ),
              O.current
            );
          };
        (function (E) {
          ((E.NotRenderedYet = "NotRenderedYet"),
            (E.Rendering = "Rendering"),
            (E.Rendered = "Rendered"));
        })(f || (f = {}));
        var x,
          z = -9999,
          L = function (E) {
            var O = E.doc,
              J = O.numPages,
              te = O.loadingTask.docId,
              oe = i.useMemo(
                function () {
                  return Array(J)
                    .fill(null)
                    .map(function (ge, ne) {
                      return {
                        pageIndex: ne,
                        renderStatus: f.NotRenderedYet,
                        visibility: z,
                      };
                    });
                },
                [te],
              ),
              ce = i.useRef({
                currentRenderingPage: -1,
                startRange: 0,
                endRange: J - 1,
                visibilities: oe,
              }),
              _e = function (ge, ne) {
                ce.current.visibilities[ge].visibility = ne;
              };
            return {
              getHighestPriorityPage: function () {
                var ge = ce.current.visibilities
                  .slice(ce.current.startRange, ce.current.endRange + 1)
                  .filter(function (Oe) {
                    return Oe.visibility > z;
                  });
                if (!ge.length) return -1;
                for (
                  var ne = ge[0].pageIndex,
                    be = ge[ge.length - 1].pageIndex,
                    ve = ge.length,
                    Be = 0;
                  Be < ve;
                  Be++
                ) {
                  if (ge[Be].renderStatus === f.Rendering) return -1;
                  if (ge[Be].renderStatus === f.NotRenderedYet)
                    return ge[Be].pageIndex;
                }
                return be + 1 < J &&
                  ce.current.visibilities[be + 1].renderStatus !== f.Rendered
                  ? be + 1
                  : ne - 1 >= 0 &&
                      ce.current.visibilities[ne - 1].renderStatus !==
                        f.Rendered
                    ? ne - 1
                    : -1;
              },
              isInRange: function (ge) {
                return ge >= ce.current.startRange && ge <= ce.current.endRange;
              },
              markNotRendered: function () {
                for (var ge = 0; ge < J; ge++)
                  ce.current.visibilities[ge].renderStatus = f.NotRenderedYet;
              },
              markRendered: function (ge) {
                ce.current.visibilities[ge].renderStatus = f.Rendered;
              },
              markRendering: function (ge) {
                (ce.current.currentRenderingPage !== -1 &&
                  ce.current.currentRenderingPage !== ge &&
                  ce.current.visibilities[ce.current.currentRenderingPage]
                    .renderStatus === f.Rendering &&
                  (ce.current.visibilities[
                    ce.current.currentRenderingPage
                  ].renderStatus = f.NotRenderedYet),
                  (ce.current.visibilities[ge].renderStatus = f.Rendering),
                  (ce.current.currentRenderingPage = ge));
              },
              setOutOfRange: function (ge) {
                _e(ge, z);
              },
              setRange: function (ge, ne) {
                ((ce.current.startRange = ge), (ce.current.endRange = ne));
                for (var be = 0; be < J; be++)
                  (be < ge || be > ne) &&
                    ((ce.current.visibilities[be].visibility = z),
                    (ce.current.visibilities[be].renderStatus =
                      f.NotRenderedYet));
              },
              setVisibility: _e,
            };
          },
          V = {
            core: {
              askingPassword: {
                requirePasswordToOpen:
                  "This document requires a password to open",
                submit: "Submit",
              },
              wrongPassword: {
                tryAgain: "The password is wrong. Please try again",
              },
              pageLabel: "Page {{pageIndex}}",
            },
          },
          Y = i.createContext({ l10n: V, setL10n: function () {} }),
          T = 0,
          s = function () {
            return T++;
          },
          g = function (E, O, J) {
            var te = function (oe) {
              var ce = O.current;
              if (ce) {
                var _e = oe.target;
                if (_e instanceof Element && _e.shadowRoot) {
                  var ge = oe.composedPath();
                  ge.length > 0 && !ce.contains(ge[0]) && J();
                } else ce.contains(_e) || J();
              }
            };
            i.useEffect(function () {
              if (E) {
                var oe = { capture: !0 };
                return (
                  document.addEventListener("click", te, oe),
                  function () {
                    document.removeEventListener("click", te, oe);
                  }
                );
              }
            }, []);
          },
          R = function (E) {
            var O = function (J) {
              J.key === "Escape" && E();
            };
            i.useEffect(function () {
              return (
                document.addEventListener("keyup", O),
                function () {
                  document.removeEventListener("keyup", O);
                }
              );
            }, []);
          },
          $ = function (E) {
            var O = E.ariaControlsSuffix,
              J = E.children,
              te = E.closeOnClickOutside,
              oe = E.closeOnEscape,
              ce = E.onToggle,
              _e = i.useRef(),
              ge = i.useContext(P).direction === t.TextDirection.RightToLeft;
            return (
              i.useEffect(function () {
                var ne = window.getComputedStyle(document.body).overflow;
                return (
                  (document.body.style.overflow = "hidden"),
                  function () {
                    document.body.style.overflow = ne;
                  }
                );
              }, []),
              R(function () {
                _e.current && oe && ce();
              }),
              g(te, _e, ce),
              h(function () {
                var ne = _e.current;
                if (ne) {
                  var be = 0.75 * document.body.clientHeight;
                  ne.getBoundingClientRect().height >= be &&
                    ((ne.style.overflow = "auto"),
                    (ne.style.maxHeight = "".concat(be, "px")));
                }
              }, []),
              i.createElement(
                "div",
                {
                  "aria-modal": "true",
                  className: _({
                    "rpv-core__modal-body": !0,
                    "rpv-core__modal-body--rtl": ge,
                  }),
                  id: "rpv-core__modal-body-".concat(O),
                  ref: _e,
                  role: "dialog",
                  tabIndex: -1,
                },
                J,
              )
            );
          },
          j = function (E) {
            var O = E.children;
            return i.createElement(
              "div",
              { className: "rpv-core__modal-overlay" },
              O,
            );
          };
        ((t.ToggleStatus = void 0),
          ((x = t.ToggleStatus || (t.ToggleStatus = {})).Close = "Close"),
          (x.Open = "Open"),
          (x.Toggle = "Toggle"));
        var U,
          Q = function (E) {
            var O = i.useState(E),
              J = O[0],
              te = O[1];
            return {
              opened: J,
              toggle: function (oe) {
                switch (oe) {
                  case t.ToggleStatus.Close:
                    te(!1);
                    break;
                  case t.ToggleStatus.Open:
                    te(!0);
                    break;
                  case t.ToggleStatus.Toggle:
                  default:
                    te(function (ce) {
                      return !ce;
                    });
                }
              },
            };
          },
          fe = function (E) {
            var O = E.content,
              J = E.isOpened,
              te = J !== void 0 && J,
              oe = E.target,
              ce = Q(te),
              _e = ce.opened,
              ge = ce.toggle;
            return i.createElement(
              i.Fragment,
              null,
              oe && oe(ge, _e),
              _e && O(ge),
            );
          };
        ((t.Position = void 0),
          ((U = t.Position || (t.Position = {})).TopLeft = "TOP_LEFT"),
          (U.TopCenter = "TOP_CENTER"),
          (U.TopRight = "TOP_RIGHT"),
          (U.RightTop = "RIGHT_TOP"),
          (U.RightCenter = "RIGHT_CENTER"),
          (U.RightBottom = "RIGHT_BOTTOM"),
          (U.BottomLeft = "BOTTOM_LEFT"),
          (U.BottomCenter = "BOTTOM_CENTER"),
          (U.BottomRight = "BOTTOM_RIGHT"),
          (U.LeftTop = "LEFT_TOP"),
          (U.LeftCenter = "LEFT_CENTER"),
          (U.LeftBottom = "LEFT_BOTTOM"));
        var we,
          Ee,
          Ce,
          xe,
          Re,
          ue,
          de,
          I,
          q = function (E, O, J, te, oe) {
            h(function () {
              var ce = O.current,
                _e = E.current,
                ge = J.current;
              if (_e && ce && ge) {
                var ne = ge.getBoundingClientRect(),
                  be = (function (Oe, De, $e, We) {
                    var Ve = De.getBoundingClientRect(),
                      xt = Oe.getBoundingClientRect(),
                      pt = xt.height,
                      gt = xt.width,
                      yt = 0,
                      ct = 0;
                    switch ($e) {
                      case t.Position.TopLeft:
                        ((yt = Ve.top - pt), (ct = Ve.left));
                        break;
                      case t.Position.TopCenter:
                        ((yt = Ve.top - pt),
                          (ct = Ve.left + Ve.width / 2 - gt / 2));
                        break;
                      case t.Position.TopRight:
                        ((yt = Ve.top - pt), (ct = Ve.left + Ve.width - gt));
                        break;
                      case t.Position.RightTop:
                        ((yt = Ve.top), (ct = Ve.left + Ve.width));
                        break;
                      case t.Position.RightCenter:
                        ((yt = Ve.top + Ve.height / 2 - pt / 2),
                          (ct = Ve.left + Ve.width));
                        break;
                      case t.Position.RightBottom:
                        ((yt = Ve.top + Ve.height - pt),
                          (ct = Ve.left + Ve.width));
                        break;
                      case t.Position.BottomLeft:
                        ((yt = Ve.top + Ve.height), (ct = Ve.left));
                        break;
                      case t.Position.BottomCenter:
                        ((yt = Ve.top + Ve.height),
                          (ct = Ve.left + Ve.width / 2 - gt / 2));
                        break;
                      case t.Position.BottomRight:
                        ((yt = Ve.top + Ve.height),
                          (ct = Ve.left + Ve.width - gt));
                        break;
                      case t.Position.LeftTop:
                        ((yt = Ve.top), (ct = Ve.left - gt));
                        break;
                      case t.Position.LeftCenter:
                        ((yt = Ve.top + Ve.height / 2 - pt / 2),
                          (ct = Ve.left - gt));
                        break;
                      case t.Position.LeftBottom:
                        ((yt = Ve.top + Ve.height - pt), (ct = Ve.left - gt));
                    }
                    return {
                      left: ct + (We.left || 0),
                      top: yt + (We.top || 0),
                    };
                  })(_e, ce, te, oe),
                  ve = be.top,
                  Be = be.left;
                ((_e.style.top = "".concat(ve - ne.top, "px")),
                  (_e.style.left = "".concat(Be - ne.left, "px")));
              }
            }, []);
          },
          ie = function (E) {
            var O,
              J = E.customClassName,
              te = E.position;
            return i.createElement("div", {
              className: _(
                ((O = {
                  "rpv-core__arrow": !0,
                  "rpv-core__arrow--tl": te === t.Position.TopLeft,
                  "rpv-core__arrow--tc": te === t.Position.TopCenter,
                  "rpv-core__arrow--tr": te === t.Position.TopRight,
                  "rpv-core__arrow--rt": te === t.Position.RightTop,
                  "rpv-core__arrow--rc": te === t.Position.RightCenter,
                  "rpv-core__arrow--rb": te === t.Position.RightBottom,
                  "rpv-core__arrow--bl": te === t.Position.BottomLeft,
                  "rpv-core__arrow--bc": te === t.Position.BottomCenter,
                  "rpv-core__arrow--br": te === t.Position.BottomRight,
                  "rpv-core__arrow--lt": te === t.Position.LeftTop,
                  "rpv-core__arrow--lc": te === t.Position.LeftCenter,
                  "rpv-core__arrow--lb": te === t.Position.LeftBottom,
                }),
                (O["".concat(J)] = J !== ""),
                O),
              ),
            });
          },
          re = function (E) {
            var O = E.ariaControlsSuffix,
              J = E.children,
              te = E.closeOnClickOutside,
              oe = E.offset,
              ce = E.position,
              _e = E.targetRef,
              ge = E.onClose,
              ne = i.useRef(),
              be = i.useRef(),
              ve = i.useRef(),
              Be = i.useContext(P).direction === t.TextDirection.RightToLeft;
            (g(te, ne, ge),
              q(ne, _e, ve, ce, oe),
              h(function () {
                var De = be.current;
                if (De) {
                  var $e = 0.75 * document.body.clientHeight;
                  De.getBoundingClientRect().height >= $e &&
                    ((De.style.overflow = "auto"),
                    (De.style.maxHeight = "".concat($e, "px")));
                }
              }, []));
            var Oe = "rpv-core__popover-body-inner-".concat(O);
            return i.createElement(
              i.Fragment,
              null,
              i.createElement("div", {
                ref: ve,
                style: { left: 0, position: "absolute", top: 0 },
              }),
              i.createElement(
                "div",
                {
                  "aria-describedby": Oe,
                  className: _({
                    "rpv-core__popover-body": !0,
                    "rpv-core__popover-body--rtl": Be,
                  }),
                  id: "rpv-core__popover-body-".concat(O),
                  ref: ne,
                  role: "dialog",
                  tabIndex: -1,
                },
                i.createElement(ie, {
                  customClassName: "rpv-core__popover-body-arrow",
                  position: ce,
                }),
                i.createElement("div", { id: Oe, ref: be }, J),
              ),
            );
          },
          he = function (E) {
            var O = E.closeOnEscape,
              J = E.onClose,
              te = i.useRef();
            return (
              R(function () {
                te.current && O && J();
              }),
              i.createElement("div", {
                className: "rpv-core__popover-overlay",
                ref: te,
              })
            );
          },
          Pe = function (E) {
            var O = E.ariaControlsSuffix,
              J = E.children,
              te = E.contentRef,
              oe = E.offset,
              ce = E.position,
              _e = E.targetRef,
              ge = i.useRef(),
              ne = i.useContext(P).direction === t.TextDirection.RightToLeft;
            return (
              q(te, _e, ge, ce, oe),
              i.createElement(
                i.Fragment,
                null,
                i.createElement("div", {
                  ref: ge,
                  style: { left: 0, position: "absolute", top: 0 },
                }),
                i.createElement(
                  "div",
                  {
                    className: _({
                      "rpv-core__tooltip-body": !0,
                      "rpv-core__tooltip-body--rtl": ne,
                    }),
                    id: "rpv-core__tooltip-body-".concat(O),
                    ref: te,
                    role: "tooltip",
                  },
                  i.createElement(ie, {
                    customClassName: "rpv-core__tooltip-body-arrow",
                    position: ce,
                  }),
                  i.createElement(
                    "div",
                    { className: "rpv-core__tooltip-body-content" },
                    J,
                  ),
                ),
              )
            );
          };
        ((t.FullScreenMode = void 0),
          ((we = t.FullScreenMode || (t.FullScreenMode = {})).Normal =
            "Normal"),
          (we.Entering = "Entering"),
          (we.Entered = "Entered"),
          (we.EnteredCompletely = "EnteredCompletely"),
          (we.Exitting = "Exitting"),
          (we.Exited = "Exited"),
          (t.LayerRenderStatus = void 0),
          ((Ee = t.LayerRenderStatus || (t.LayerRenderStatus = {}))[
            (Ee.PreRender = 0)
          ] = "PreRender"),
          (Ee[(Ee.DidRender = 1)] = "DidRender"),
          (t.PageMode = void 0),
          ((Ce = t.PageMode || (t.PageMode = {})).Attachments =
            "UseAttachments"),
          (Ce.Bookmarks = "UseOutlines"),
          (Ce.ContentGroup = "UseOC"),
          (Ce.Default = "UserNone"),
          (Ce.FullScreen = "FullScreen"),
          (Ce.Thumbnails = "UseThumbs"),
          (t.PasswordStatus = void 0),
          ((xe = t.PasswordStatus || (t.PasswordStatus = {})).RequiredPassword =
            "RequiredPassword"),
          (xe.WrongPassword = "WrongPassword"),
          (t.RotateDirection = void 0),
          ((Re = t.RotateDirection || (t.RotateDirection = {})).Backward =
            "Backward"),
          (Re.Forward = "Forward"),
          (t.ScrollMode = void 0),
          ((ue = t.ScrollMode || (t.ScrollMode = {})).Page = "Page"),
          (ue.Horizontal = "Horizontal"),
          (ue.Vertical = "Vertical"),
          (ue.Wrapped = "Wrapped"),
          (t.SpecialZoomLevel = void 0),
          ((de = t.SpecialZoomLevel || (t.SpecialZoomLevel = {})).ActualSize =
            "ActualSize"),
          (de.PageFit = "PageFit"),
          (de.PageWidth = "PageWidth"),
          (t.ViewMode = void 0),
          ((I = t.ViewMode || (t.ViewMode = {})).DualPage = "DualPage"),
          (I.DualPageWithCover = "DualPageWithCover"),
          (I.SinglePage = "SinglePage"));
        var Me,
          se = function (E, O) {
            return E.reduce(function (J, te, oe) {
              return (oe % O ? J[J.length - 1].push(te) : J.push([te]), J);
            }, []);
          },
          je = function (E, O) {
            switch (O[1].name) {
              case "XYZ":
                return {
                  bottomOffset: function (J, te) {
                    return O[3] === null ? te : O[3];
                  },
                  leftOffset: function (J, te) {
                    return O[2] === null ? 0 : O[2];
                  },
                  pageIndex: E,
                  scaleTo: O[4],
                };
              case "Fit":
              case "FitB":
                return {
                  bottomOffset: 0,
                  leftOffset: 0,
                  pageIndex: E,
                  scaleTo: t.SpecialZoomLevel.PageFit,
                };
              case "FitH":
              case "FitBH":
                return {
                  bottomOffset: O[2],
                  leftOffset: 0,
                  pageIndex: E,
                  scaleTo: t.SpecialZoomLevel.PageWidth,
                };
              default:
                return {
                  bottomOffset: 0,
                  leftOffset: 0,
                  pageIndex: E,
                  scaleTo: 1,
                };
            }
          },
          Ie = new Map(),
          it = new Map(),
          Ke = function (E, O) {
            return ""
              .concat(E.loadingTask.docId, "___")
              .concat(O.num, "R")
              .concat(O.gen === 0 ? "" : O.gen);
          },
          dt = function (E, O, J) {
            Ie.set(Ke(E, O), J);
          },
          ze = function (E, O) {
            if (!E) return Promise.reject("The document is not loaded yet");
            var J = "".concat(E.loadingTask.docId, "___").concat(O),
              te = it.get(J);
            return te
              ? Promise.resolve(te)
              : new Promise(function (oe, ce) {
                  E.getPage(O + 1).then(function (_e) {
                    (it.set(J, _e), _e.ref && dt(E, _e.ref, O), oe(_e));
                  });
                });
          },
          Je = function (E, O) {
            return new Promise(function (J) {
              new Promise(function (te) {
                typeof O == "string"
                  ? E.getDestination(O).then(function (oe) {
                      te(oe);
                    })
                  : te(O);
              }).then(function (te) {
                if (typeof te[0] == "object" && te[0] !== null) {
                  var oe = te[0],
                    ce = (function (ge, ne) {
                      var be = Ke(ge, ne);
                      return Ie.has(be) ? Ie.get(be) : null;
                    })(E, oe);
                  ce === null
                    ? E.getPageIndex(oe).then(function (ge) {
                        (dt(E, oe, ge),
                          Je(E, O).then(function (ne) {
                            return J(ne);
                          }));
                      })
                    : J(je(ce, te));
                } else {
                  var _e = je(te[0], te);
                  J(_e);
                }
              });
            });
          };
        (function (E) {
          ((E[(E.Solid = 1)] = "Solid"),
            (E[(E.Dashed = 2)] = "Dashed"),
            (E[(E.Beveled = 3)] = "Beveled"),
            (E[(E.Inset = 4)] = "Inset"),
            (E[(E.Underline = 5)] = "Underline"));
        })(Me || (Me = {}));
        var st,
          kt = new RegExp(
            "^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?",
          ),
          Le = function (E, O, J, te) {
            var oe = parseInt(E, 10);
            return oe >= O && oe <= J ? oe : te;
          },
          pe = function (E) {
            return E.contentsObj ? E.contentsObj.str : E.contents || "";
          },
          me = function (E) {
            return E.titleObj ? E.titleObj.str : E.title || "";
          },
          Xe = function (E) {
            var O = E.annotation,
              J = i.useContext(P).direction,
              te = me(O),
              oe = pe(O),
              ce = J === t.TextDirection.RightToLeft,
              _e = i.useRef(),
              ge = "";
            if (O.modificationDate) {
              var ne = (function (be) {
                var ve = kt.exec(be);
                if (!ve) return null;
                var Be = parseInt(ve[1], 10),
                  Oe = Le(ve[2], 1, 12, 1) - 1,
                  De = Le(ve[3], 1, 31, 1),
                  $e = Le(ve[4], 0, 23, 0),
                  We = Le(ve[5], 0, 59, 0),
                  Ve = Le(ve[6], 0, 59, 0),
                  xt = ve[7] || "Z",
                  pt = Le(ve[8], 0, 23, 0),
                  gt = Le(ve[9], 0, 59, 0);
                switch (xt) {
                  case "-":
                    (($e += pt), (We += gt));
                    break;
                  case "+":
                    (($e -= pt), (We -= gt));
                }
                return new Date(Date.UTC(Be, Oe, De, $e, We, Ve));
              })(O.modificationDate);
              ge = ne
                ? ""
                    .concat(ne.toLocaleDateString(), ", ")
                    .concat(ne.toLocaleTimeString())
                : "";
            }
            return (
              i.useLayoutEffect(function () {
                if (_e.current) {
                  var be = document.querySelector(
                    '[data-annotation-id="'.concat(O.id, '"]'),
                  );
                  if (be) {
                    var ve = be;
                    return (
                      (ve.style.zIndex += 1),
                      function () {
                        ve.style.zIndex = "".concat(
                          parseInt(ve.style.zIndex, 10) - 1,
                        );
                      }
                    );
                  }
                }
              }, []),
              i.createElement(
                "div",
                {
                  ref: _e,
                  className: _({
                    "rpv-core__annotation-popup-wrapper": !0,
                    "rpv-core__annotation-popup-wrapper--rtl": ce,
                  }),
                  style: {
                    top:
                      O.annotationType === t.AnnotationType.Popup ? "" : "100%",
                  },
                },
                te &&
                  i.createElement(
                    i.Fragment,
                    null,
                    i.createElement(
                      "div",
                      {
                        className: _({
                          "rpv-core__annotation-popup-title": !0,
                          "rpv-core__annotation-popup-title--ltr": !ce,
                          "rpv-core__annotation-popup-title--rtl": ce,
                        }),
                      },
                      te,
                    ),
                    i.createElement(
                      "div",
                      { className: "rpv-core__annotation-popup-date" },
                      ge,
                    ),
                  ),
                oe &&
                  i.createElement(
                    "div",
                    { className: "rpv-core__annotation-popup-content" },
                    oe
                      .split(
                        `
`,
                      )
                      .map(function (be, ve) {
                        return i.createElement(
                          i.Fragment,
                          { key: ve },
                          be,
                          i.createElement("br", null),
                        );
                      }),
                  ),
              )
            );
          };
        (function (E) {
          ((E.Click = "Click"), (E.Hover = "Hover"));
        })(st || (st = {}));
        var Ye,
          ot = function (E) {
            var O,
              J = E.annotation,
              te = E.children,
              oe = E.ignoreBorder,
              ce = E.hasPopup,
              _e = E.isRenderable,
              ge = E.page,
              ne = E.viewport,
              be = J.rect,
              ve = (function () {
                var bt = Q(!1),
                  Ot = bt.opened,
                  Dt = bt.toggle,
                  Nt = i.useState(st.Hover),
                  Bt = Nt[0],
                  Ht = Nt[1];
                return {
                  opened: Ot,
                  closeOnHover: function () {
                    Bt === st.Hover && Dt(t.ToggleStatus.Close);
                  },
                  openOnHover: function () {
                    Bt === st.Hover && Dt(t.ToggleStatus.Open);
                  },
                  toggleOnClick: function () {
                    switch (Bt) {
                      case st.Click:
                        (Ot && Ht(st.Hover), Dt(t.ToggleStatus.Toggle));
                        break;
                      case st.Hover:
                        (Ht(st.Click), Dt(t.ToggleStatus.Open));
                    }
                  },
                };
              })(),
              Be = ve.closeOnHover,
              Oe = ve.opened,
              De = ve.openOnHover,
              $e = ve.toggleOnClick,
              We =
                ((O = [
                  be[0],
                  ge.view[3] + ge.view[1] - be[1],
                  be[2],
                  ge.view[3] + ge.view[1] - be[3],
                ]),
                [
                  Math.min(O[0], O[2]),
                  Math.min(O[1], O[3]),
                  Math.max(O[0], O[2]),
                  Math.max(O[1], O[3]),
                ]),
              Ve = be[2] - be[0],
              xt = be[3] - be[1],
              pt = {
                borderColor: "",
                borderRadius: "",
                borderStyle: "",
                borderWidth: "",
              };
            if (!oe && J.borderStyle.width > 0) {
              switch (J.borderStyle.style) {
                case Me.Dashed:
                  pt.borderStyle = "dashed";
                  break;
                case Me.Solid:
                  pt.borderStyle = "solid";
                  break;
                case Me.Underline:
                  pt = Object.assign({ borderBottomStyle: "solid" }, pt);
                case Me.Beveled:
                case Me.Inset:
              }
              var gt = J.borderStyle.width;
              ((pt.borderWidth = "".concat(gt, "px")),
                J.borderStyle.style !== Me.Underline &&
                  ((Ve -= 2 * gt), (xt -= 2 * gt)));
              var yt = J.borderStyle,
                ct = yt.horizontalCornerRadius,
                St = yt.verticalCornerRadius;
              ((ct > 0 || St > 0) &&
                (pt.borderRadius = "".concat(ct, "px / ").concat(St, "px")),
                J.color
                  ? (pt.borderColor = "rgb("
                      .concat(0 | J.color[0], ", ")
                      .concat(0 | J.color[1], ", ")
                      .concat(0 | J.color[2], ")"))
                  : (pt.borderWidth = "0"));
            }
            return i.createElement(
              i.Fragment,
              null,
              _e &&
                te({
                  popup: {
                    opened: Oe,
                    closeOnHover: Be,
                    openOnHover: De,
                    toggleOnClick: $e,
                  },
                  slot: {
                    attrs: {
                      style: Object.assign(
                        {
                          height: "".concat(xt, "px"),
                          left: "".concat(We[0], "px"),
                          top: "".concat(We[1], "px"),
                          transform: "matrix(".concat(
                            ne.transform.join(","),
                            ")",
                          ),
                          transformOrigin: "-"
                            .concat(We[0], "px -")
                            .concat(We[1], "px"),
                          width: "".concat(Ve, "px"),
                        },
                        pt,
                      ),
                    },
                    children: i.createElement(
                      i.Fragment,
                      null,
                      ce && Oe && i.createElement(Xe, { annotation: J }),
                    ),
                  },
                }),
            );
          },
          Z = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e);
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (ne) {
                return i.createElement(
                  "div",
                  k({}, ne.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--caret",
                    "data-annotation-id": O.id,
                    onClick: ne.popup.toggleOnClick,
                    onMouseEnter: ne.popup.openOnHover,
                    onMouseLeave: ne.popup.closeOnHover,
                  }),
                  ne.slot.children,
                );
              },
            );
          },
          Te = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e),
              ne = O.rect,
              be = ne[2] - ne[0],
              ve = ne[3] - ne[1],
              Be = O.borderStyle.width;
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (Oe) {
                return i.createElement(
                  "div",
                  k({}, Oe.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--circle",
                    "data-annotation-id": O.id,
                    onClick: Oe.popup.toggleOnClick,
                    onMouseEnter: Oe.popup.openOnHover,
                    onMouseLeave: Oe.popup.closeOnHover,
                  }),
                  i.createElement(
                    "svg",
                    {
                      height: "".concat(ve, "px"),
                      preserveAspectRatio: "none",
                      version: "1.1",
                      viewBox: "0 0 ".concat(be, " ").concat(ve),
                      width: "".concat(be, "px"),
                    },
                    i.createElement("circle", {
                      cy: ve / 2,
                      fill: "none",
                      rx: be / 2 - Be / 2,
                      ry: ve / 2 - Be / 2,
                      stroke: "transparent",
                      strokeWidth: Be || 1,
                    }),
                  ),
                  Oe.slot.children,
                );
              },
            );
          },
          He = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = me(O),
              ce = pe(O),
              _e = !(O.hasPopup !== !1 || (!oe && !ce)),
              ge = function () {
                var ne,
                  be,
                  ve,
                  Be,
                  Oe = O.file;
                Oe &&
                  ((ne = Oe.filename),
                  (be = Oe.content),
                  (ve =
                    typeof be == "string"
                      ? ""
                      : URL.createObjectURL(new Blob([be], { type: "" }))),
                  ((Be = document.createElement("a")).style.display = "none"),
                  (Be.href = ve || ne),
                  Be.setAttribute(
                    "download",
                    (function (De) {
                      var $e = De.split("/").pop();
                      return $e ? $e.split("#")[0].split("?")[0] : De;
                    })(ne),
                  ),
                  document.body.appendChild(Be),
                  Be.click(),
                  document.body.removeChild(Be),
                  ve && URL.revokeObjectURL(ve));
              };
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: _e,
                ignoreBorder: !0,
                isRenderable: !0,
                page: J,
                viewport: te,
              },
              function (ne) {
                return i.createElement(
                  "div",
                  k({}, ne.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--file-attachment",
                    "data-annotation-id": O.id,
                    onClick: ne.popup.toggleOnClick,
                    onDoubleClick: ge,
                    onMouseEnter: ne.popup.openOnHover,
                    onMouseLeave: ne.popup.closeOnHover,
                  }),
                  ne.slot.children,
                );
              },
            );
          },
          Ze = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e);
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (ne) {
                return i.createElement(
                  "div",
                  k({}, ne.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--free-text",
                    "data-annotation-id": O.id,
                    onClick: ne.popup.toggleOnClick,
                    onMouseEnter: ne.popup.openOnHover,
                    onMouseLeave: ne.popup.closeOnHover,
                  }),
                  ne.slot.children,
                );
              },
            );
          },
          tt = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = me(O),
              ce = pe(O),
              _e = !(!oe && !ce),
              ge =
                !O.parentType ||
                [
                  "Circle",
                  "Ink",
                  "Line",
                  "Polygon",
                  "PolyLine",
                  "Square",
                ].indexOf(O.parentType) !== -1;
            return (
              h(function () {
                if (O.parentId) {
                  var ne = document.querySelector(
                      '[data-annotation-id="'.concat(O.parentId, '"]'),
                    ),
                    be = document.querySelector(
                      '[data-annotation-id="'.concat(O.id, '"]'),
                    );
                  if (ne && be) {
                    var ve = parseFloat(ne.style.left),
                      Be =
                        parseFloat(ne.style.top) + parseFloat(ne.style.height);
                    ((be.style.left = "".concat(ve, "px")),
                      (be.style.top = "".concat(Be, "px")),
                      (be.style.transformOrigin = "-"
                        .concat(ve, "px -")
                        .concat(Be, "px")));
                  }
                }
              }, []),
              i.createElement(
                ot,
                {
                  annotation: O,
                  hasPopup: ge,
                  ignoreBorder: !1,
                  isRenderable: _e,
                  page: J,
                  viewport: te,
                },
                function (ne) {
                  return i.createElement(
                    "div",
                    k({}, ne.slot.attrs, {
                      className:
                        "rpv-core__annotation rpv-core__annotation--popup",
                      "data-annotation-id": O.id,
                    }),
                    i.createElement(Xe, { annotation: O }),
                  );
                },
              )
            );
          },
          Ge = function (E) {
            var O = E.annotation,
              J = E.childAnnotation,
              te = E.page,
              oe = E.viewport,
              ce = O.hasPopup === !1,
              _e = me(O),
              ge = pe(O),
              ne = !!(O.hasPopup || _e || ge);
            if (O.quadPoints && O.quadPoints.length > 0) {
              var be = O.quadPoints.map(function (ve) {
                return Object.assign({}, O, {
                  rect: [ve[2].x, ve[2].y, ve[1].x, ve[1].y],
                  quadPoints: [],
                });
              });
              return i.createElement(
                i.Fragment,
                null,
                be.map(function (ve, Be) {
                  return i.createElement(Ge, {
                    key: Be,
                    annotation: ve,
                    childAnnotation: J,
                    page: te,
                    viewport: oe,
                  });
                }),
              );
            }
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: ce,
                ignoreBorder: !0,
                isRenderable: ne,
                page: te,
                viewport: oe,
              },
              function (ve) {
                return i.createElement(
                  i.Fragment,
                  null,
                  i.createElement(
                    "div",
                    k({}, ve.slot.attrs, {
                      className:
                        "rpv-core__annotation rpv-core__annotation--highlight",
                      "data-annotation-id": O.id,
                      onClick: ve.popup.toggleOnClick,
                      onMouseEnter: ve.popup.openOnHover,
                      onMouseLeave: ve.popup.closeOnHover,
                    }),
                    ve.slot.children,
                  ),
                  J &&
                    J.annotationType === t.AnnotationType.Popup &&
                    ve.popup.opened &&
                    i.createElement(tt, {
                      annotation: J,
                      page: te,
                      viewport: oe,
                    }),
                );
              },
            );
          },
          K = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e),
              ne = O.rect,
              be = ne[2] - ne[0],
              ve = ne[3] - ne[1],
              Be = O.borderStyle.width;
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (Oe) {
                return i.createElement(
                  "div",
                  k({}, Oe.slot.attrs, {
                    className: "rpv-core__annotation rpv-core__annotation--ink",
                    "data-annotation-id": O.id,
                    onClick: Oe.popup.toggleOnClick,
                    onMouseEnter: Oe.popup.openOnHover,
                    onMouseLeave: Oe.popup.closeOnHover,
                  }),
                  O.inkLists &&
                    O.inkLists.length &&
                    i.createElement(
                      "svg",
                      {
                        height: "".concat(ve, "px"),
                        preserveAspectRatio: "none",
                        version: "1.1",
                        viewBox: "0 0 ".concat(be, " ").concat(ve),
                        width: "".concat(be, "px"),
                      },
                      O.inkLists.map(function (De, $e) {
                        return i.createElement("polyline", {
                          key: $e,
                          fill: "none",
                          stroke: "transparent",
                          strokeWidth: Be || 1,
                          points: De.map(function (We) {
                            return ""
                              .concat(We.x - ne[0], ",")
                              .concat(ne[3] - We.y);
                          }).join(" "),
                        });
                      }),
                    ),
                  Oe.slot.children,
                );
              },
            );
          },
          G = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e),
              ne = O.rect,
              be = ne[2] - ne[0],
              ve = ne[3] - ne[1],
              Be = O.borderStyle.width;
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (Oe) {
                return i.createElement(
                  "div",
                  k({}, Oe.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--line",
                    "data-annotation-id": O.id,
                    onClick: Oe.popup.toggleOnClick,
                    onMouseEnter: Oe.popup.openOnHover,
                    onMouseLeave: Oe.popup.closeOnHover,
                  }),
                  i.createElement(
                    "svg",
                    {
                      height: "".concat(ve, "px"),
                      preserveAspectRatio: "none",
                      version: "1.1",
                      viewBox: "0 0 ".concat(be, " ").concat(ve),
                      width: "".concat(be, "px"),
                    },
                    i.createElement("line", {
                      stroke: "transparent",
                      strokeWidth: Be || 1,
                      x1: ne[2] - O.lineCoordinates[0],
                      x2: ne[2] - O.lineCoordinates[2],
                      y1: ne[3] - O.lineCoordinates[1],
                      y2: ne[3] - O.lineCoordinates[3],
                    }),
                  ),
                  Oe.slot.children,
                );
              },
            );
          },
          ae = /^([^\w]*)(javascript|data|vbscript)/im,
          Ae = /&#(\w+)(^\w|;)?/g,
          ke = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim,
          Fe = /^([^:]+):/gm,
          Ne = function (E, O) {
            var J,
              te = ((J = E || ""),
              J.replace(Ae, function (ge, ne) {
                return String.fromCharCode(ne);
              }))
                .replace(ke, "")
                .trim();
            if (!te) return O;
            var oe = te[0];
            if (oe === "." || oe === "/") return te;
            var ce = te.match(Fe);
            if (!ce) return te;
            var _e = ce[0];
            return ae.test(_e) ? O : te;
          },
          Qe = function (E) {
            var O,
              J = E.annotation,
              te = E.annotationContainerRef,
              oe = E.doc,
              ce = E.outlines,
              _e = E.page,
              ge = E.pageIndex,
              ne = E.scale,
              be = E.viewport,
              ve = E.onExecuteNamedAction,
              Be = E.onJumpFromLinkAnnotation,
              Oe = E.onJumpToDest,
              De = i.useRef(),
              $e =
                ce && ce.length && J.dest && typeof J.dest == "string"
                  ? (O = ce.find(function (pt) {
                      return pt.dest === J.dest;
                    })) === null || O === void 0
                    ? void 0
                    : O.title
                  : "",
              We = !!(J.url || J.dest || J.action || J.unsafeUrl),
              Ve = {};
            if (J.url || J.unsafeUrl) {
              var xt = Ne(J.url || J.unsafeUrl, "");
              xt
                ? (Ve = {
                    "data-target": "external",
                    href: xt,
                    rel: "noopener noreferrer nofollow",
                    target: J.newWindow ? "_blank" : "",
                    title: xt,
                  })
                : (We = !1);
            } else
              Ve = {
                href: "",
                "data-annotation-link": J.id,
                onClick: function (pt) {
                  (pt.preventDefault(),
                    J.action
                      ? ve(J.action)
                      : Je(oe, J.dest).then(function (gt) {
                          var yt = De.current,
                            ct = te.current;
                          if (yt && ct) {
                            var St = yt.getBoundingClientRect();
                            (ct.style.setProperty("height", "100%"),
                              ct.style.setProperty("width", "100%"));
                            var bt = ct.getBoundingClientRect();
                            (ct.style.removeProperty("height"),
                              ct.style.removeProperty("width"));
                            var Ot = (St.left - bt.left) / ne,
                              Dt = (bt.bottom - St.bottom + St.height) / ne;
                            Be({
                              bottomOffset: Dt,
                              label: $e,
                              leftOffset: Ot,
                              pageIndex: ge,
                            });
                          }
                          Oe(gt);
                        }));
                },
              };
            return (
              $e &&
                (Ve = Object.assign({}, Ve, { title: $e, "aria-label": $e })),
              i.createElement(
                ot,
                {
                  annotation: J,
                  hasPopup: !1,
                  ignoreBorder: !1,
                  isRenderable: We,
                  page: _e,
                  viewport: be,
                },
                function (pt) {
                  return i.createElement(
                    "div",
                    k({}, pt.slot.attrs, {
                      className:
                        "rpv-core__annotation rpv-core__annotation--link",
                      "data-annotation-id": J.id,
                      "data-testid": "core__annotation--link-".concat(J.id),
                    }),
                    i.createElement("a", k({ ref: De }, Ve)),
                  );
                },
              )
            );
          },
          et = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e),
              ne = O.rect,
              be = ne[2] - ne[0],
              ve = ne[3] - ne[1],
              Be = O.borderStyle.width;
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (Oe) {
                return i.createElement(
                  "div",
                  k({}, Oe.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--polygon",
                    "data-annotation-id": O.id,
                    onClick: Oe.popup.toggleOnClick,
                    onMouseEnter: Oe.popup.openOnHover,
                    onMouseLeave: Oe.popup.closeOnHover,
                  }),
                  O.vertices &&
                    O.vertices.length &&
                    i.createElement(
                      "svg",
                      {
                        height: "".concat(ve, "px"),
                        preserveAspectRatio: "none",
                        version: "1.1",
                        viewBox: "0 0 ".concat(be, " ").concat(ve),
                        width: "".concat(be, "px"),
                      },
                      i.createElement("polygon", {
                        fill: "none",
                        stroke: "transparent",
                        strokeWidth: Be || 1,
                        points: O.vertices
                          .map(function (De) {
                            return ""
                              .concat(De.x - ne[0], ",")
                              .concat(ne[3] - De.y);
                          })
                          .join(" "),
                      }),
                    ),
                  Oe.slot.children,
                );
              },
            );
          },
          Ue = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e),
              ne = O.rect,
              be = ne[2] - ne[0],
              ve = ne[3] - ne[1],
              Be = O.borderStyle.width;
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (Oe) {
                return i.createElement(
                  "div",
                  k({}, Oe.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--polyline",
                    "data-annotation-id": O.id,
                    onClick: Oe.popup.toggleOnClick,
                    onMouseEnter: Oe.popup.openOnHover,
                    onMouseLeave: Oe.popup.closeOnHover,
                  }),
                  O.vertices &&
                    O.vertices.length &&
                    i.createElement(
                      "svg",
                      {
                        height: "".concat(ve, "px"),
                        preserveAspectRatio: "none",
                        version: "1.1",
                        viewBox: "0 0 ".concat(be, " ").concat(ve),
                        width: "".concat(be, "px"),
                      },
                      i.createElement("polyline", {
                        fill: "none",
                        stroke: "transparent",
                        strokeWidth: Be || 1,
                        points: O.vertices
                          .map(function (De) {
                            return ""
                              .concat(De.x - ne[0], ",")
                              .concat(ne[3] - De.y);
                          })
                          .join(" "),
                      }),
                    ),
                  Oe.slot.children,
                );
              },
            );
          },
          Et = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e),
              ne = O.rect,
              be = ne[2] - ne[0],
              ve = ne[3] - ne[1],
              Be = O.borderStyle.width;
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (Oe) {
                return i.createElement(
                  "div",
                  k({}, Oe.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--square",
                    "data-annotation-id": O.id,
                    onClick: Oe.popup.toggleOnClick,
                    onMouseEnter: Oe.popup.openOnHover,
                    onMouseLeave: Oe.popup.closeOnHover,
                  }),
                  i.createElement(
                    "svg",
                    {
                      height: "".concat(ve, "px"),
                      preserveAspectRatio: "none",
                      version: "1.1",
                      viewBox: "0 0 ".concat(be, " ").concat(ve),
                      width: "".concat(be, "px"),
                    },
                    i.createElement("rect", {
                      height: ve - Be,
                      fill: "none",
                      stroke: "transparent",
                      strokeWidth: Be || 1,
                      x: Be / 2,
                      y: Be / 2,
                      width: be - Be,
                    }),
                  ),
                  Oe.slot.children,
                );
              },
            );
          },
          nt = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e);
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (ne) {
                return i.createElement(
                  "div",
                  k({}, ne.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--squiggly",
                    "data-annotation-id": O.id,
                    onClick: ne.popup.toggleOnClick,
                    onMouseEnter: ne.popup.openOnHover,
                    onMouseLeave: ne.popup.closeOnHover,
                  }),
                  ne.slot.children,
                );
              },
            );
          },
          at = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e);
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (ne) {
                return i.createElement(
                  "div",
                  k({}, ne.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--stamp",
                    "data-annotation-id": O.id,
                    onClick: ne.popup.toggleOnClick,
                    onMouseEnter: ne.popup.openOnHover,
                    onMouseLeave: ne.popup.closeOnHover,
                  }),
                  ne.slot.children,
                );
              },
            );
          },
          mt = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e);
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (ne) {
                return i.createElement(
                  "div",
                  k({}, ne.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--strike-out",
                    "data-annotation-id": O.id,
                    onClick: ne.popup.toggleOnClick,
                    onMouseEnter: ne.popup.openOnHover,
                    onMouseLeave: ne.popup.closeOnHover,
                  }),
                  ne.slot.children,
                );
              },
            );
          },
          At = function () {
            return i.createElement(
              d,
              { size: 16 },
              i.createElement("path", {
                d: "M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z",
              }),
              i.createElement("path", {
                d: "M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25",
              }),
              i.createElement("path", {
                d: "M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75",
              }),
              i.createElement("path", {
                d: "M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25",
              }),
            );
          },
          Lt = function () {
            return i.createElement(
              d,
              { size: 16 },
              i.createElement("path", {
                d: "M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z",
              }),
              i.createElement("path", {
                d: "M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z",
              }),
              i.createElement("path", { d: "M21.423 5.406L17.415 9.414" }),
              i.createElement("path", { d: "M14.587 6.585L18.607 2.565" }),
              i.createElement("path", { d: "M5.405 21.424L9.413 17.416" }),
              i.createElement("path", { d: "M6.585 14.588L2.577 18.596" }),
              i.createElement("path", { d: "M18.602 21.419L14.595 17.412" }),
              i.createElement("path", { d: "M17.419 14.58L21.428 18.589" }),
              i.createElement("path", { d: "M2.582 5.399L6.588 9.406" }),
              i.createElement("path", { d: "M9.421 6.581L5.412 2.572" }),
            );
          },
          zt = function () {
            return i.createElement(
              d,
              { size: 16 },
              i.createElement("path", {
                d: "M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z",
              }),
              i.createElement("path", {
                d: "M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z",
              }),
            );
          },
          an = function () {
            return i.createElement(
              d,
              { size: 16 },
              i.createElement("path", {
                d: "M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z",
              }),
              i.createElement("path", { d: "M6 4.5L6 0.5" }),
              i.createElement("path", { d: "M18 4.5L18 0.5" }),
              i.createElement("path", { d: "M10 4.5L10 0.5" }),
              i.createElement("path", { d: "M14 4.5L14 0.5" }),
            );
          },
          Zt = function () {
            return i.createElement(
              d,
              { size: 16 },
              i.createElement("path", { d: "M17.5 0.498L17.5 23.498" }),
              i.createElement("path", { d: "M10.5 0.498L10.5 23.498" }),
              i.createElement("path", { d: "M23.5.5H6.5a6,6,0,0,0,0,12h4" }),
            );
          },
          gn = function () {
            return i.createElement(
              d,
              { size: 16 },
              i.createElement("path", {
                d: "M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z",
              }),
            );
          },
          bn = function (E) {
            var O = E.annotation,
              J = E.childAnnotation,
              te = E.page,
              oe = E.viewport,
              ce = O.hasPopup === !1,
              _e = me(O),
              ge = pe(O),
              ne = !!(O.hasPopup || _e || ge),
              be = O.name ? O.name.toLowerCase() : "";
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: ce,
                ignoreBorder: !1,
                isRenderable: ne,
                page: te,
                viewport: oe,
              },
              function (ve) {
                return i.createElement(
                  i.Fragment,
                  null,
                  i.createElement(
                    "div",
                    k({}, ve.slot.attrs, {
                      className:
                        "rpv-core__annotation rpv-core__annotation--text",
                      "data-annotation-id": O.id,
                      onClick: ve.popup.toggleOnClick,
                      onMouseEnter: ve.popup.openOnHover,
                      onMouseLeave: ve.popup.closeOnHover,
                    }),
                    be &&
                      i.createElement(
                        "div",
                        { className: "rpv-core__annotation-text-icon" },
                        be === "check" && i.createElement(p, null),
                        be === "comment" && i.createElement(At, null),
                        be === "help" && i.createElement(Lt, null),
                        be === "insert" && i.createElement(gn, null),
                        be === "key" && i.createElement(zt, null),
                        be === "note" && i.createElement(an, null),
                        (be === "newparagraph" || be === "paragraph") &&
                          i.createElement(Zt, null),
                      ),
                    ve.slot.children,
                  ),
                  J &&
                    J.annotationType === t.AnnotationType.Popup &&
                    ve.popup.opened &&
                    i.createElement(tt, {
                      annotation: J,
                      page: te,
                      viewport: oe,
                    }),
                );
              },
            );
          },
          _n = function (E) {
            var O = E.annotation,
              J = E.page,
              te = E.viewport,
              oe = O.hasPopup === !1,
              ce = me(O),
              _e = pe(O),
              ge = !!(O.hasPopup || ce || _e);
            return i.createElement(
              ot,
              {
                annotation: O,
                hasPopup: oe,
                ignoreBorder: !0,
                isRenderable: ge,
                page: J,
                viewport: te,
              },
              function (ne) {
                return i.createElement(
                  "div",
                  k({}, ne.slot.attrs, {
                    className:
                      "rpv-core__annotation rpv-core__annotation--underline",
                    "data-annotation-id": O.id,
                    onClick: ne.popup.toggleOnClick,
                    onMouseEnter: ne.popup.openOnHover,
                    onMouseLeave: ne.popup.closeOnHover,
                  }),
                  ne.slot.children,
                );
              },
            );
          },
          Kn = function (E) {
            var O = E.annotations,
              J = E.doc,
              te = E.outlines,
              oe = E.page,
              ce = E.pageIndex,
              _e = E.plugins,
              ge = E.rotation,
              ne = E.scale,
              be = E.onExecuteNamedAction,
              ve = E.onJumpFromLinkAnnotation,
              Be = E.onJumpToDest,
              Oe = i.useRef(),
              De = oe
                .getViewport({ rotation: ge, scale: ne })
                .clone({ dontFlip: !0 }),
              $e = O.filter(function (We) {
                return !We.parentId;
              });
            return (
              h(function () {
                var We = Oe.current;
                We &&
                  _e.forEach(function (Ve) {
                    Ve.onAnnotationLayerRender &&
                      Ve.onAnnotationLayerRender({
                        annotations: $e,
                        container: We,
                        pageIndex: ce,
                        rotation: ge,
                        scale: ne,
                      });
                  });
              }, []),
              i.createElement(
                "div",
                {
                  ref: Oe,
                  className: "rpv-core__annotation-layer",
                  "data-testid": "core__annotation-layer-".concat(ce),
                },
                $e.map(function (We) {
                  var Ve = O.find(function (xt) {
                    return xt.parentId === We.id;
                  });
                  switch (We.annotationType) {
                    case t.AnnotationType.Caret:
                      return i.createElement(Z, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Circle:
                      return i.createElement(Te, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.FileAttachment:
                      return i.createElement(He, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.FreeText:
                      return i.createElement(Ze, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Highlight:
                      return i.createElement(Ge, {
                        key: We.id,
                        annotation: We,
                        childAnnotation: Ve,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Ink:
                      return i.createElement(K, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Line:
                      return i.createElement(G, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Link:
                      return i.createElement(Qe, {
                        key: We.id,
                        annotation: We,
                        annotationContainerRef: Oe,
                        doc: J,
                        outlines: te,
                        page: oe,
                        pageIndex: ce,
                        scale: ne,
                        viewport: De,
                        onExecuteNamedAction: be,
                        onJumpFromLinkAnnotation: ve,
                        onJumpToDest: Be,
                      });
                    case t.AnnotationType.Polygon:
                      return i.createElement(et, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Polyline:
                      return i.createElement(Ue, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Popup:
                      return i.createElement(tt, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Square:
                      return i.createElement(Et, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Squiggly:
                      return i.createElement(nt, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Stamp:
                      return i.createElement(at, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.StrikeOut:
                      return i.createElement(mt, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Text:
                      return i.createElement(bn, {
                        key: We.id,
                        annotation: We,
                        childAnnotation: Ve,
                        page: oe,
                        viewport: De,
                      });
                    case t.AnnotationType.Underline:
                      return i.createElement(_n, {
                        key: We.id,
                        annotation: We,
                        page: oe,
                        viewport: De,
                      });
                    default:
                      return i.createElement(i.Fragment, { key: We.id });
                  }
                }),
              )
            );
          },
          la = function (E) {
            var O = E.page,
              J = E.renderAnnotations,
              te = M(),
              oe = i.useState({ loading: !0, annotations: [] }),
              ce = oe[0],
              _e = oe[1];
            return (
              i.useEffect(function () {
                O.getAnnotations({ intent: "display" }).then(function (ge) {
                  te.current && _e({ loading: !1, annotations: ge });
                });
              }, []),
              ce.loading ? i.createElement(i.Fragment, null) : J(ce.annotations)
            );
          },
          ua = function (E) {
            var O = E.doc,
              J = E.outlines,
              te = E.page,
              oe = E.pageIndex,
              ce = E.plugins,
              _e = E.rotation,
              ge = E.scale,
              ne = E.onExecuteNamedAction,
              be = E.onJumpFromLinkAnnotation,
              ve = E.onJumpToDest;
            return i.createElement(la, {
              page: te,
              renderAnnotations: function (Be) {
                return i.createElement(Kn, {
                  annotations: Be,
                  doc: O,
                  outlines: J,
                  page: te,
                  pageIndex: oe,
                  plugins: ce,
                  rotation: _e,
                  scale: ge,
                  onExecuteNamedAction: ne,
                  onJumpFromLinkAnnotation: be,
                  onJumpToDest: ve,
                });
              },
            });
          },
          Yn = function (E, O) {
            var J = E % O;
            return J === 0 ? E : Math.floor(E - J);
          },
          da = function (E) {
            var O = E.canvasLayerRef,
              J = E.height,
              te = E.page,
              oe = E.pageIndex,
              ce = E.plugins,
              _e = E.rotation,
              ge = E.scale,
              ne = E.width,
              be = E.onRenderCanvasCompleted,
              ve = i.useRef();
            return (
              h(function () {
                var Be = ve.current;
                Be && Be.cancel();
                var Oe = O.current;
                (Oe.removeAttribute("data-testid"),
                  ce.forEach(function (bt) {
                    bt.onCanvasLayerRender &&
                      bt.onCanvasLayerRender({
                        ele: Oe,
                        pageIndex: oe,
                        rotation: _e,
                        scale: ge,
                        status: t.LayerRenderStatus.PreRender,
                      });
                  }));
                var De = te.getViewport({ rotation: _e, scale: ge }),
                  $e = window.devicePixelRatio || 1,
                  We = Math.sqrt(16777216 / (De.width * De.height)),
                  Ve = $e > We;
                Ve
                  ? (Oe.style.transform = "scale(1, 1)")
                  : Oe.style.removeProperty("transform");
                var xt = Math.min(We, $e),
                  pt = (function (bt, Ot) {
                    var Dt, Nt;
                    if (Math.floor(bt) === bt) return [bt, 1];
                    var Bt = 1 / bt;
                    if (Bt > Ot) return [1, Ot];
                    if (Math.floor(Bt) === Bt) return [1, Bt];
                    for (
                      var Ht = bt > 1 ? Bt : bt, nn = 0, Kt = 1, rn = 1, Jt = 1;
                      ;

                    ) {
                      var en = nn + rn,
                        tn = Kt + Jt;
                      if (tn > Ot) break;
                      Ht <= en / tn
                        ? ((rn = (Dt = [en, tn])[0]), (Jt = Dt[1]))
                        : ((nn = (Nt = [en, tn])[0]), (Kt = Nt[1]));
                    }
                    return Ht < (nn / Kt + rn / Jt) / 2
                      ? Ht === bt
                        ? [nn, Kt]
                        : [Kt, nn]
                      : Ht === bt
                        ? [rn, Jt]
                        : [Jt, rn];
                  })(xt, 8),
                  gt = pt[0],
                  yt = pt[1];
                ((Oe.width = Yn(De.width * xt, gt)),
                  (Oe.height = Yn(De.height * xt, gt)),
                  (Oe.style.width = "".concat(Yn(De.width, yt), "px")),
                  (Oe.style.height = "".concat(Yn(De.height, yt), "px")),
                  (Oe.hidden = !0));
                var ct = Oe.getContext("2d", { alpha: !1 }),
                  St = Ve || $e !== 1 ? [xt, 0, 0, xt, 0, 0] : null;
                return (
                  (ve.current = te.render({
                    canvasContext: ct,
                    transform: St,
                    viewport: De,
                  })),
                  ve.current.promise.then(
                    function () {
                      ((Oe.hidden = !1),
                        Oe.setAttribute(
                          "data-testid",
                          "core__canvas-layer-".concat(oe),
                        ),
                        ce.forEach(function (bt) {
                          bt.onCanvasLayerRender &&
                            bt.onCanvasLayerRender({
                              ele: Oe,
                              pageIndex: oe,
                              rotation: _e,
                              scale: ge,
                              status: t.LayerRenderStatus.DidRender,
                            });
                        }),
                        be());
                    },
                    function () {
                      be();
                    },
                  ),
                  function () {
                    Oe && ((Oe.width = 0), (Oe.height = 0));
                  }
                );
              }, []),
              i.createElement(
                "div",
                {
                  className: "rpv-core__canvas-layer",
                  style: {
                    height: "".concat(J, "px"),
                    width: "".concat(ne, "px"),
                  },
                },
                i.createElement("canvas", { ref: O }),
              )
            );
          },
          ha = function (E) {
            var O = E.height,
              J = E.page,
              te = E.rotation,
              oe = E.scale,
              ce = E.width,
              _e = i.useRef();
            return (
              h(function () {
                var ge = _e.current,
                  ne = J.getViewport({ rotation: te, scale: oe });
                J.getOperatorList().then(function (be) {
                  ((function () {
                    var ve = _e.current;
                    ve && (ve.innerHTML = "");
                  })(),
                    new H.SVGGraphics(J.commonObjs, J.objs)
                      .getSVG(be, ne)
                      .then(function (ve) {
                        ((ve.style.height = "".concat(O, "px")),
                          (ve.style.width = "".concat(ce, "px")),
                          ge.appendChild(ve));
                      }));
                });
              }, []),
              i.createElement("div", {
                className: "rpv-core__svg-layer",
                ref: _e,
              })
            );
          },
          fa = function (E) {
            var O = E.containerRef,
              J = E.page,
              te = E.pageIndex,
              oe = E.plugins,
              ce = E.rotation,
              _e = E.scale,
              ge = E.onRenderTextCompleted,
              ne = i.useRef(),
              be = function () {
                var ve = O.current;
                ve &&
                  ([].slice
                    .call(ve.querySelectorAll(".rpv-core__text-layer-text"))
                    .forEach(function (Be) {
                      return ve.removeChild(Be);
                    }),
                  [].slice
                    .call(ve.querySelectorAll('br[role="presentation"]'))
                    .forEach(function (Be) {
                      return ve.removeChild(Be);
                    }));
              };
            return (
              h(function () {
                var ve = ne.current;
                ve && ve.cancel();
                var Be = O.current;
                if (Be) {
                  Be.removeAttribute("data-testid");
                  var Oe = J.getViewport({ rotation: ce, scale: _e });
                  return (
                    oe.forEach(function (De) {
                      De.onTextLayerRender &&
                        De.onTextLayerRender({
                          ele: Be,
                          pageIndex: te,
                          scale: _e,
                          status: t.LayerRenderStatus.PreRender,
                        });
                    }),
                    J.getTextContent().then(function (De) {
                      (be(),
                        (ne.current = H.renderTextLayer({
                          container: Be,
                          textContent: De,
                          textContentSource: De,
                          viewport: Oe,
                        })),
                        ne.current.promise.then(
                          function () {
                            (Be.setAttribute(
                              "data-testid",
                              "core__text-layer-".concat(te),
                            ),
                              [].slice.call(Be.children).forEach(function ($e) {
                                $e.classList.contains(
                                  "rpv-core__text-layer-text--not",
                                ) ||
                                  $e.classList.add("rpv-core__text-layer-text");
                              }),
                              oe.forEach(function ($e) {
                                $e.onTextLayerRender &&
                                  $e.onTextLayerRender({
                                    ele: Be,
                                    pageIndex: te,
                                    scale: _e,
                                    status: t.LayerRenderStatus.DidRender,
                                  });
                              }),
                              ge());
                          },
                          function () {
                            (Be.removeAttribute("data-testid"), ge());
                          },
                        ));
                    }),
                    function () {
                      var De;
                      (be(),
                        (De = ne.current) === null ||
                          De === void 0 ||
                          De.cancel());
                    }
                  );
                }
              }, []),
              i.createElement("div", {
                className: "rpv-core__text-layer",
                ref: O,
              })
            );
          },
          pa = function (E) {
            var O = E.doc,
              J = E.measureRef,
              te = E.outlines,
              oe = E.pageIndex,
              ce = E.pageRotation,
              _e = E.pageSize,
              ge = E.plugins,
              ne = E.renderPage,
              be = E.renderQueueKey,
              ve = E.rotation,
              Be = E.scale,
              Oe = E.shouldRender,
              De = E.viewMode,
              $e = E.onExecuteNamedAction,
              We = E.onJumpFromLinkAnnotation,
              Ve = E.onJumpToDest,
              xt = E.onRenderCompleted,
              pt = E.onRotatePage,
              gt = M(),
              yt = i.useState(null),
              ct = yt[0],
              St = yt[1],
              bt = i.useState(!1),
              Ot = bt[0],
              Dt = bt[1],
              Nt = i.useState(!1),
              Bt = Nt[0],
              Ht = Nt[1],
              nn = i.useRef(),
              Kt = i.useRef(),
              rn = Math.abs(ve + ce) % 180 == 0,
              Jt = _e.pageWidth * Be,
              en = _e.pageHeight * Be,
              tn = rn ? Jt : en,
              Qt = rn ? en : Jt,
              dn = (_e.rotation + ve + ce) % 360,
              En = i.useRef(0),
              vn =
                ne ||
                function (cn) {
                  return i.createElement(
                    i.Fragment,
                    null,
                    cn.canvasLayer.children,
                    cn.textLayer.children,
                    cn.annotationLayer.children,
                  );
                };
            return (
              i.useEffect(
                function () {
                  (St(null), Dt(!1), Ht(!1));
                },
                [ce, ve, Be],
              ),
              i.useEffect(
                function () {
                  Oe &&
                    gt.current &&
                    !ct &&
                    ze(O, oe).then(function (cn) {
                      gt.current && ((En.current = be), St(cn));
                    });
                },
                [Oe, ct],
              ),
              i.useEffect(
                function () {
                  Ot &&
                    Bt &&
                    (be !== En.current ? (St(null), Dt(!1), Ht(!1)) : xt(oe));
                },
                [Ot, Bt],
              ),
              i.createElement(
                "div",
                {
                  className: _({
                    "rpv-core__page-layer": !0,
                    "rpv-core__page-layer--dual": De === t.ViewMode.DualPage,
                    "rpv-core__page-layer--dual-cover":
                      De === t.ViewMode.DualPageWithCover,
                    "rpv-core__page-layer--single":
                      De === t.ViewMode.SinglePage,
                  }),
                  "data-testid": "core__page-layer-".concat(oe),
                  ref: J,
                  style: {
                    height: "".concat(Qt, "px"),
                    width: "".concat(tn, "px"),
                  },
                },
                ct
                  ? i.createElement(
                      i.Fragment,
                      null,
                      vn({
                        annotationLayer: {
                          attrs: {},
                          children: i.createElement(ua, {
                            doc: O,
                            outlines: te,
                            page: ct,
                            pageIndex: oe,
                            plugins: ge,
                            rotation: dn,
                            scale: Be,
                            onExecuteNamedAction: $e,
                            onJumpFromLinkAnnotation: We,
                            onJumpToDest: Ve,
                          }),
                        },
                        canvasLayer: {
                          attrs: {},
                          children: i.createElement(da, {
                            canvasLayerRef: nn,
                            height: Qt,
                            page: ct,
                            pageIndex: oe,
                            plugins: ge,
                            rotation: dn,
                            scale: Be,
                            width: tn,
                            onRenderCanvasCompleted: function () {
                              gt.current && Dt(!0);
                            },
                          }),
                        },
                        canvasLayerRendered: Ot,
                        doc: O,
                        height: Qt,
                        pageIndex: oe,
                        rotation: dn,
                        scale: Be,
                        svgLayer: {
                          attrs: {},
                          children: i.createElement(ha, {
                            height: Qt,
                            page: ct,
                            rotation: dn,
                            scale: Be,
                            width: tn,
                          }),
                        },
                        textLayer: {
                          attrs: {},
                          children: i.createElement(fa, {
                            containerRef: Kt,
                            page: ct,
                            pageIndex: oe,
                            plugins: ge,
                            rotation: dn,
                            scale: Be,
                            onRenderTextCompleted: function () {
                              gt.current && Ht(!0);
                            },
                          }),
                        },
                        textLayerRendered: Bt,
                        width: tn,
                        markRendered: xt,
                        onRotatePage: function (cn) {
                          return pt(oe, cn);
                        },
                      }),
                      ge.map(function (cn, hn) {
                        return cn.renderPageLayer
                          ? i.createElement(
                              i.Fragment,
                              { key: hn },
                              cn.renderPageLayer({
                                canvasLayerRef: nn,
                                canvasLayerRendered: Ot,
                                doc: O,
                                height: Qt,
                                pageIndex: oe,
                                rotation: dn,
                                scale: Be,
                                textLayerRef: Kt,
                                textLayerRendered: Bt,
                                width: tn,
                              }),
                            )
                          : i.createElement(i.Fragment, { key: hn });
                      }),
                    )
                  : i.createElement(F, {
                      testId: "core__page-layer-loading-".concat(oe),
                    }),
              )
            );
          },
          ma = function (E, O) {
            var J = O.rect;
            return E.height !== J.height || E.width !== J.width ? J : E;
          };
        (function (E) {
          ((E.Horizontal = "Horizontal"),
            (E.Vertical = "Vertical"),
            (E.Both = "Both"));
        })(Ye || (Ye = {}));
        var ga = function (E) {
            return 1 - Math.pow(1 - E, 4);
          },
          Zn = 1e-4,
          ui = { left: 0, top: 0 },
          di = { capture: !1, passive: !0 },
          va = function (E) {
            var O = E.elementRef,
              J = E.enableSmoothScroll,
              te = E.isRtl,
              oe = E.scrollDirection,
              ce = E.onSmoothScroll,
              _e = i.useState(ui),
              ge = _e[0],
              ne = _e[1],
              be = i.useState(O.current),
              ve = be[0],
              Be = be[1],
              Oe = te ? -1 : 1,
              De = i.useRef(oe);
            De.current = oe;
            var $e = i.useRef(ui),
              We = i.useRef(!0),
              Ve = i.useCallback(function () {
                ((We.current = !0), J && ne($e.current), ce(!1));
              }, []),
              xt = i.useCallback(
                function () {
                  if (ve) {
                    switch (De.current) {
                      case Ye.Horizontal:
                        $e.current = { left: Oe * ve.scrollLeft, top: 0 };
                        break;
                      case Ye.Both:
                        $e.current = {
                          left: Oe * ve.scrollLeft,
                          top: ve.scrollTop,
                        };
                        break;
                      case Ye.Vertical:
                      default:
                        $e.current = { left: 0, top: ve.scrollTop };
                    }
                    (J && !We.current) || ne($e.current);
                  }
                },
                [ve],
              );
            (h(function () {
              Be(O.current);
            }),
              h(
                function () {
                  if (ve)
                    return (
                      ve.addEventListener("scroll", xt, di),
                      function () {
                        ve.removeEventListener("scroll", xt, di);
                      }
                    );
                },
                [ve],
              ));
            var pt = i.useCallback(
              function (gt, yt) {
                var ct = O.current;
                if (!ct) return Promise.resolve();
                var St = { left: 0, top: 0 };
                switch (De.current) {
                  case Ye.Horizontal:
                    St.left = Oe * gt.left;
                    break;
                  case Ye.Both:
                    ((St.left = Oe * gt.left), (St.top = gt.top));
                    break;
                  case Ye.Vertical:
                  default:
                    St.top = gt.top;
                }
                return yt
                  ? ((We.current = !1),
                    ce(!0),
                    new Promise(function (bt, Ot) {
                      (function (Dt, Nt, Bt, Ht, nn, Kt) {
                        (nn === void 0 &&
                          (nn = function (hn) {
                            return hn;
                          }),
                          Kt === void 0 && (Kt = function () {}));
                        var rn = 0,
                          Jt = 0,
                          en = !1;
                        switch (Nt) {
                          case Ye.Horizontal:
                            ((Jt = Dt.scrollLeft), (rn = 0));
                          case Ye.Both:
                            ((Jt = Dt.scrollLeft), (rn = Dt.scrollTop));
                            break;
                          case Ye.Vertical:
                          default:
                            ((Jt = 0), (rn = Dt.scrollTop));
                        }
                        var tn = function () {
                          en ||
                            ((en = !0),
                            (Dt.scrollLeft = Bt.left),
                            (Dt.scrollTop = Bt.top),
                            Kt());
                        };
                        if (Math.abs(rn - Bt.top) <= Zn && Nt === Ye.Vertical)
                          tn();
                        else if (
                          Math.abs(Jt - Bt.left) <= Zn &&
                          Nt === Ye.Horizontal
                        )
                          tn();
                        else {
                          var Qt,
                            dn = -1,
                            En = Jt - Bt.left,
                            vn = rn - Bt.top,
                            cn = function (hn) {
                              dn === -1 && (dn = hn);
                              var yn = hn - dn,
                                _t = Math.min(yn / Ht, 1),
                                vt = nn(_t),
                                lt = { left: Jt - En * vt, top: rn - vn * vt };
                              switch (Nt) {
                                case Ye.Horizontal:
                                  Dt.scrollLeft = lt.left;
                                  break;
                                case Ye.Both:
                                  ((Dt.scrollLeft = lt.left),
                                    (Dt.scrollTop = lt.top));
                                  break;
                                case Ye.Vertical:
                                default:
                                  Dt.scrollTop = lt.top;
                              }
                              (Math.abs(lt.top - Bt.top) <= Zn &&
                                Math.abs(lt.left - Bt.left) <= Zn &&
                                !en &&
                                (window.cancelAnimationFrame(Qt), tn()),
                                yn < Ht
                                  ? (Qt = window.requestAnimationFrame(cn))
                                  : window.cancelAnimationFrame(Qt));
                            };
                          Qt = window.requestAnimationFrame(cn);
                        }
                      })(ct, De.current, St, 400, ga, function () {
                        (Ve(), bt());
                      });
                    }))
                  : new Promise(function (bt, Ot) {
                      switch (De.current) {
                        case Ye.Horizontal:
                          ct.scrollLeft = St.left;
                          break;
                        case Ye.Both:
                          ((ct.scrollLeft = St.left), (ct.scrollTop = St.top));
                          break;
                        case Ye.Vertical:
                        default:
                          ct.scrollTop = St.top;
                      }
                      bt();
                    });
              },
              [O],
            );
            return { scrollOffset: ge, scrollTo: pt };
          },
          jn = function (E, O, J) {
            return Math.max(E, Math.min(J, O));
          },
          ba = function (E, O) {
            if (O !== t.ViewMode.DualPageWithCover) return 0;
            if (
              !(function (oe) {
                var ce = oe.length;
                if (ce === 1) return !1;
                for (var _e = 1; _e < ce; _e++)
                  if (
                    oe[_e].height !== oe[0].height ||
                    oe[_e].width !== oe[0].width
                  )
                    return !0;
                return !1;
              })(E)
            )
              return 2 * E[0].width;
            var J = se(E.slice(1), 2).map(function (oe) {
                return oe.length === 2
                  ? oe[0].width + oe[1].width
                  : oe[0].width;
              }),
              te = [E[0].width].concat(J);
            return Math.max.apply(Math, te);
          },
          _a = { left: 0, top: 0 },
          Ea = { left: 0, top: 0 },
          vr = { left: 0, top: 0 },
          ya = { left: 0, top: 0 },
          Sa = { height: 0, width: 0 },
          hi = { left: 0, top: 0 },
          fi = "data-virtual-index",
          wa = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],
          Aa = function (E) {
            var O = E.enableSmoothScroll,
              J = E.isRtl,
              te = E.numberOfItems,
              oe = E.parentRef,
              ce = E.setRenderRange,
              _e = E.sizes,
              ge = E.scrollMode,
              ne = E.viewMode,
              be = i.useState(!1),
              ve = be[0],
              Be = be[1],
              Oe = i.useCallback(function (_t) {
                return Be(_t);
              }, []),
              De = i.useRef(ge);
            De.current = ge;
            var $e = i.useRef(ne);
            $e.current = ne;
            var We =
                ge === t.ScrollMode.Wrapped ||
                ne === t.ViewMode.DualPageWithCover ||
                ne === t.ViewMode.DualPage
                  ? Ye.Both
                  : ge === t.ScrollMode.Horizontal
                    ? Ye.Horizontal
                    : Ye.Vertical,
              Ve = va({
                elementRef: oe,
                enableSmoothScroll: O,
                isRtl: J,
                scrollDirection: We,
                onSmoothScroll: Oe,
              }),
              xt = Ve.scrollOffset,
              pt = Ve.scrollTo,
              gt = (function (_t) {
                var vt = _t.elementRef,
                  lt = i.useState(vt.current),
                  ht = lt[0],
                  ut = lt[1],
                  wt = i.useRef(!1),
                  Ct = i.useReducer(ma, { height: 0, width: 0 }),
                  ft = Ct[0],
                  rt = Ct[1];
                return (
                  h(function () {
                    vt.current !== ht && ut(vt.current);
                  }),
                  h(
                    function () {
                      if (ht && !wt.current) {
                        wt.current = !0;
                        var Mt = ht.getBoundingClientRect(),
                          Rt = Mt.height,
                          Gt = Mt.width;
                        rt({ rect: { height: Rt, width: Gt } });
                      }
                    },
                    [ht],
                  ),
                  i.useEffect(
                    function () {
                      if (ht) {
                        var Mt = new ResizeObserver(function (Rt, Gt) {
                          Rt.forEach(function (Wt) {
                            if (Wt.target === ht) {
                              var ln = Wt.contentRect,
                                fn = ln.height,
                                Tt = ln.width;
                              rt({ rect: { height: fn, width: Tt } });
                            }
                          });
                        });
                        return (
                          Mt.observe(ht),
                          function () {
                            Mt.unobserve(ht);
                          }
                        );
                      }
                    },
                    [ht],
                  ),
                  ft
                );
              })({ elementRef: oe }),
              yt = i.useRef({ scrollOffset: hi, measurements: [] });
            yt.current.scrollOffset = xt;
            var ct = i.useMemo(function () {
                return Array(te).fill(-1);
              }, []),
              St = i.useState(ct),
              bt = St[0],
              Ot = St[1],
              Dt = i.useMemo(function () {
                var _t = new IntersectionObserver(
                  function (vt) {
                    vt.forEach(function (lt) {
                      var ht = lt.isIntersecting ? lt.intersectionRatio : -1,
                        ut = lt.target.getAttribute(fi);
                      if (ut) {
                        var wt = parseInt(ut, 10);
                        0 <= wt &&
                          wt < te &&
                          Ot(function (Ct) {
                            return (
                              (Ct[wt] = ht),
                              (function (ft, rt, Mt) {
                                for (
                                  var Rt, Gt = 0, Wt = rt.length;
                                  Gt < Wt;
                                  Gt++
                                )
                                  (!Rt && Gt in rt) ||
                                    (Rt ||
                                      (Rt = Array.prototype.slice.call(
                                        rt,
                                        0,
                                        Gt,
                                      )),
                                    (Rt[Gt] = rt[Gt]));
                                return ft.concat(
                                  Rt || Array.prototype.slice.call(rt),
                                );
                              })([], Ct)
                            );
                          });
                      }
                    });
                  },
                  { threshold: wa },
                );
                return _t;
              }, []),
              Nt = i.useMemo(
                function () {
                  return ge === t.ScrollMode.Page &&
                    ne === t.ViewMode.SinglePage
                    ? (function (_t, vt, lt) {
                        for (var ht = [], ut = 0; ut < _t; ut++) {
                          var wt = {
                              height: Math.max(vt.height, lt[ut].height),
                              width: Math.max(vt.width, lt[ut].width),
                            },
                            Ct = ut === 0 ? ya : ht[ut - 1].end,
                            ft = {
                              left: Ct.left + wt.width,
                              top: Ct.top + wt.height,
                            };
                          ht[ut] = {
                            index: ut,
                            start: Ct,
                            size: wt,
                            end: ft,
                            visibility: -1,
                          };
                        }
                        return ht;
                      })(te, gt, _e)
                    : ne === t.ViewMode.DualPageWithCover
                      ? (function (_t, vt, lt, ht) {
                          for (
                            var ut = [], wt = 0, Ct = 0, ft = vr, rt = 0;
                            rt < _t;
                            rt++
                          ) {
                            var Mt =
                              rt === 0
                                ? {
                                    height:
                                      ht === t.ScrollMode.Page
                                        ? Math.max(vt.height, lt[rt].height)
                                        : lt[rt].height,
                                    width:
                                      ht === t.ScrollMode.Page
                                        ? Math.max(vt.width, lt[rt].width)
                                        : lt[rt].width,
                                  }
                                : {
                                    height:
                                      ht === t.ScrollMode.Page
                                        ? Math.max(vt.height, lt[rt].height)
                                        : lt[rt].height,
                                    width: Math.max(vt.width / 2, lt[rt].width),
                                  };
                            ht === t.ScrollMode.Page
                              ? (ft =
                                  rt === 0
                                    ? vr
                                    : {
                                        left: rt % 2 == 0 ? Mt.width : 0,
                                        top:
                                          Math.floor((rt - 1) / 2) * Mt.height +
                                          ut[0].end.top,
                                      })
                              : rt === 0
                                ? ((ft = vr), (wt = lt[0].height), (Ct = 0))
                                : rt % 2 == 1
                                  ? ((ft = { left: 0, top: (wt += Ct) }),
                                    (Ct =
                                      rt === _t - 1
                                        ? lt[rt].height
                                        : Math.max(
                                            lt[rt].height,
                                            lt[rt + 1].height,
                                          )))
                                  : (ft = {
                                      left: ut[rt - 1].end.left,
                                      top: wt,
                                    });
                            var Rt = {
                              left: ft.left + Mt.width,
                              top: ft.top + Mt.height,
                            };
                            ut[rt] = {
                              index: rt,
                              start: ft,
                              size: Mt,
                              end: Rt,
                              visibility: -1,
                            };
                          }
                          return ut;
                        })(te, gt, _e, ge)
                      : ne === t.ViewMode.DualPage
                        ? (function (_t, vt, lt, ht) {
                            for (
                              var ut = [], wt = 0, Ct = 0, ft = Ea, rt = 0;
                              rt < _t;
                              rt++
                            ) {
                              var Mt = {
                                height:
                                  ht === t.ScrollMode.Page
                                    ? Math.max(vt.height, lt[rt].height)
                                    : lt[rt].height,
                                width: Math.max(vt.width / 2, lt[rt].width),
                              };
                              ht === t.ScrollMode.Page
                                ? (ft = {
                                    left: rt % 2 == 0 ? 0 : Mt.width,
                                    top: Math.floor(rt / 2) * Mt.height,
                                  })
                                : rt % 2 == 0
                                  ? ((ft = { left: 0, top: (wt += Ct) }),
                                    (Ct =
                                      rt === _t - 1
                                        ? lt[rt].height
                                        : Math.max(
                                            lt[rt].height,
                                            lt[rt + 1].height,
                                          )))
                                  : (ft = {
                                      left: ut[rt - 1].end.left,
                                      top: wt,
                                    });
                              var Rt = {
                                left: ft.left + Mt.width,
                                top: ft.top + Mt.height,
                              };
                              ut[rt] = {
                                index: rt,
                                start: ft,
                                size: Mt,
                                end: Rt,
                                visibility: -1,
                              };
                            }
                            return ut;
                          })(te, gt, _e, ge)
                        : (function (_t, vt, lt, ht) {
                            for (
                              var ut = [],
                                wt = 0,
                                Ct = { left: 0, top: 0 },
                                ft = 0,
                                rt = _a,
                                Mt = 0;
                              Mt < _t;
                              Mt++
                            ) {
                              var Rt = lt[Mt];
                              if (Mt === 0)
                                ((wt = Rt.width),
                                  (Ct = { left: 0, top: 0 }),
                                  (ft = Rt.height));
                              else
                                switch (ht) {
                                  case t.ScrollMode.Wrapped:
                                    (wt += Rt.width) < vt.width
                                      ? ((rt = {
                                          left: ut[Mt - 1].end.left,
                                          top: Ct.top,
                                        }),
                                        (ft = Math.max(ft, Rt.height)))
                                      : ((wt = Rt.width),
                                        (Ct = {
                                          left: (rt = {
                                            left: Ct.left,
                                            top: Ct.top + ft,
                                          }).left,
                                          top: rt.top,
                                        }),
                                        (ft = Rt.height));
                                    break;
                                  case t.ScrollMode.Horizontal:
                                  case t.ScrollMode.Vertical:
                                  default:
                                    rt = ut[Mt - 1].end;
                                }
                              var Gt = {
                                left: rt.left + Rt.width,
                                top: rt.top + Rt.height,
                              };
                              ut[Mt] = {
                                index: Mt,
                                start: rt,
                                size: Rt,
                                end: Gt,
                                visibility: -1,
                              };
                            }
                            return ut;
                          })(te, gt, _e, ge);
                },
                [ge, _e, ne, gt],
              ),
              Bt = Nt[te - 1]
                ? { height: Nt[te - 1].end.top, width: Nt[te - 1].end.left }
                : Sa;
            yt.current.measurements = Nt;
            var Ht = i.useMemo(
                function () {
                  var _t = (function (Mt, Rt, Gt, Wt) {
                      var ln = 0;
                      switch (Mt) {
                        case Ye.Horizontal:
                          ln = Wt.left;
                          break;
                        case Ye.Vertical:
                        default:
                          ln = Wt.top;
                      }
                      var fn = Rt.length - 1,
                        Tt = (function (Vt, wn, Ln, Qn) {
                          for (; Vt <= wn; ) {
                            var Mn = ((Vt + wn) / 2) | 0,
                              zn = Qn(Mn);
                            if (zn < Ln) Vt = Mn + 1;
                            else {
                              if (!(zn > Ln)) return Mn;
                              wn = Mn - 1;
                            }
                          }
                          return Vt > 0 ? Vt - 1 : 0;
                        })(0, fn, ln, function (Vt) {
                          switch (Mt) {
                            case Ye.Horizontal:
                              return Rt[Vt].start.left;
                            case Ye.Both:
                            case Ye.Vertical:
                            default:
                              return Rt[Vt].start.top;
                          }
                        });
                      if (Mt === Ye.Both)
                        for (
                          var un = Rt[Tt].start.top;
                          Tt - 1 >= 0 &&
                          Rt[Tt - 1].start.top === un &&
                          Rt[Tt - 1].start.left >= Wt.left;

                        )
                          Tt--;
                      for (var Xt = Tt; Xt <= fn; ) {
                        var Yt = {
                            top: Rt[Xt].start.top - Wt.top,
                            left: Rt[Xt].start.left - Wt.left,
                          },
                          on = {
                            height: Gt.height - Yt.top,
                            width: Gt.width - Yt.left,
                          };
                        if (
                          (Mt === Ye.Horizontal && on.width < 0) ||
                          (Mt === Ye.Vertical && on.height < 0) ||
                          (Mt === Ye.Both && (on.width < 0 || on.height < 0))
                        )
                          break;
                        Xt++;
                      }
                      return { start: Tt, end: Xt };
                    })(We, Nt, gt, xt),
                    vt = _t.start,
                    lt = _t.end,
                    ht = bt.slice(jn(0, te, vt), jn(0, te, lt)),
                    ut =
                      vt +
                      ht.reduce(function (Mt, Rt, Gt, Wt) {
                        return Rt > Wt[Mt] ? Gt : Mt;
                      }, 0),
                    wt = (ut = jn(0, te - 1, ut)),
                    Ct = ce({ endPage: lt, numPages: te, startPage: vt }),
                    ft = Ct.startPage,
                    rt = Ct.endPage;
                  switch (
                    ((ft = Math.max(ft, 0)), (rt = Math.min(rt, te - 1)), ne)
                  ) {
                    case t.ViewMode.DualPageWithCover:
                      (ut > 0 && (wt = ut % 2 == 1 ? ut : ut - 1),
                        (ft = ft === 0 ? 0 : ft % 2 == 1 ? ft : ft - 1),
                        te - (rt = rt % 2 == 1 ? rt - 1 : rt) <= 2 &&
                          (rt = te - 1));
                      break;
                    case t.ViewMode.DualPage:
                      ((wt = ut % 2 == 0 ? ut : ut - 1),
                        (ft = ft % 2 == 0 ? ft : ft - 1),
                        (rt = rt % 2 == 1 ? rt : rt - 1));
                      break;
                    case t.ViewMode.SinglePage:
                    default:
                      wt = ut;
                  }
                  return { startPage: ft, endPage: rt, maxVisbilityIndex: wt };
                },
                [Nt, gt, xt, ne, bt],
              ),
              nn = Ht.startPage,
              Kt = Ht.endPage,
              rn = Ht.maxVisbilityIndex,
              Jt = i.useMemo(
                function () {
                  for (
                    var _t = [],
                      vt = function (ht) {
                        var ut = Nt[ht],
                          wt = k(k({}, ut), {
                            visibility: bt[ht] !== void 0 ? bt[ht] : -1,
                            measureRef: function (Ct) {
                              Ct &&
                                (Ct.setAttribute(fi, "".concat(ht)),
                                Dt.observe(Ct));
                            },
                          });
                        _t.push(wt);
                      },
                      lt = nn;
                    lt <= Kt;
                    lt++
                  )
                    vt(lt);
                  return _t;
                },
                [nn, Kt, bt, Nt],
              ),
              en = i.useCallback(
                function (_t, vt) {
                  var lt = yt.current.measurements[jn(0, te - 1, _t)],
                    ht = De.current === t.ScrollMode.Page ? hi : vt;
                  return lt
                    ? pt(
                        {
                          left: ht.left + lt.start.left,
                          top: ht.top + lt.start.top,
                        },
                        O,
                      )
                    : Promise.resolve();
                },
                [pt, O],
              ),
              tn = i.useCallback(function (_t, vt) {
                var lt = yt.current.measurements,
                  ht = lt[_t].start,
                  ut = lt.find(function (Ct) {
                    return Ct.start.top - ht.top > 1e-12;
                  });
                if (!ut) return Promise.resolve();
                var wt = ut.index;
                switch ($e.current) {
                  case t.ViewMode.DualPage:
                    wt = wt % 2 == 0 ? wt : wt + 1;
                    break;
                  case t.ViewMode.DualPageWithCover:
                    wt = wt % 2 == 1 ? wt : wt + 1;
                }
                return en(wt, vt);
              }, []),
              Qt = i.useCallback(function (_t, vt) {
                for (
                  var lt = yt.current.measurements,
                    ht = lt[_t].start,
                    ut = _t,
                    wt = !1,
                    Ct = te - 1;
                  Ct >= 0;
                  Ct--
                )
                  if (ht.top - lt[Ct].start.top > 1e-12) {
                    ((wt = !0), (ut = lt[Ct].index));
                    break;
                  }
                if (!wt) return Promise.resolve();
                switch ($e.current) {
                  case t.ViewMode.DualPage:
                    ut = ut % 2 == 0 ? ut : ut - 1;
                    break;
                  case t.ViewMode.DualPageWithCover:
                    ut = ut % 2 == 0 ? ut - 1 : ut;
                }
                return (ut === _t && (ut = _t - 1), en(ut, vt));
              }, []),
              dn = i.useCallback(function (_t, vt) {
                if (
                  $e.current === t.ViewMode.DualPageWithCover ||
                  $e.current === t.ViewMode.DualPage
                )
                  return tn(_t, vt);
                switch (De.current) {
                  case t.ScrollMode.Wrapped:
                    return tn(_t, vt);
                  case t.ScrollMode.Horizontal:
                  case t.ScrollMode.Vertical:
                  default:
                    return en(_t + 1, vt);
                }
              }, []),
              En = i.useCallback(function (_t, vt) {
                if (
                  $e.current === t.ViewMode.DualPageWithCover ||
                  $e.current === t.ViewMode.DualPage
                )
                  return Qt(_t, vt);
                switch (De.current) {
                  case t.ScrollMode.Wrapped:
                    return Qt(_t, vt);
                  case t.ScrollMode.Horizontal:
                  case t.ScrollMode.Vertical:
                  default:
                    return en(_t - 1, vt);
                }
              }, []),
              vn = i.useCallback(
                function () {
                  return (function (_t, vt) {
                    switch (vt) {
                      case t.ScrollMode.Horizontal:
                        return {
                          position: "relative",
                          height: "100%",
                          width: "".concat(_t.width, "px"),
                        };
                      case t.ScrollMode.Vertical:
                      default:
                        return {
                          position: "relative",
                          height: "".concat(_t.height, "px"),
                          width: "100%",
                        };
                    }
                  })(Bt, De.current);
                },
                [Bt],
              ),
              cn = i.useCallback(
                function (_t) {
                  return (function (vt, lt, ht) {
                    return ht !== t.ScrollMode.Page
                      ? {}
                      : {
                          height: "".concat(lt.height, "px"),
                          width: "100%",
                          position: "absolute",
                          top: 0,
                          transform: "translateY(".concat(vt.start.top, "px)"),
                        };
                  })(_t, gt, De.current);
                },
                [gt],
              ),
              hn = i.useCallback(
                function (_t) {
                  return (function (vt, lt, ht, ut, wt) {
                    var Ct,
                      ft,
                      rt,
                      Mt,
                      Rt,
                      Gt,
                      Wt,
                      ln = lt ? "right" : "left",
                      fn = lt ? -1 : 1,
                      Tt = ht.length,
                      un = vt.start.left * fn,
                      Xt = vt.size,
                      Yt = Xt.height,
                      on = Xt.width;
                    if (ut === t.ViewMode.DualPageWithCover) {
                      var Vt = wt === t.ScrollMode.Page ? 0 : vt.start.top;
                      return vt.index === 0 ||
                        (Tt % 2 == 0 && vt.index === Tt - 1)
                        ? (((Ct = {
                            height: "".concat(Yt, "px"),
                            minWidth: "".concat(ba(ht, ut), "px"),
                            width: "100%",
                          })[ln] = 0),
                          (Ct.position = "absolute"),
                          (Ct.top = 0),
                          (Ct.transform = "translate("
                            .concat(un, "px, ")
                            .concat(Vt, "px)")),
                          Ct)
                        : (((ft = {
                            height: "".concat(Yt, "px"),
                            width: "".concat(on, "px"),
                          })[ln] = 0),
                          (ft.position = "absolute"),
                          (ft.top = 0),
                          (ft.transform = "translate("
                            .concat(un, "px, ")
                            .concat(Vt, "px)")),
                          ft);
                    }
                    if (ut === t.ViewMode.DualPage)
                      return (
                        ((rt = {
                          height: "".concat(Yt, "px"),
                          width: "".concat(on, "px"),
                        })[ln] = 0),
                        (rt.position = "absolute"),
                        (rt.top = 0),
                        (rt.transform = "translate("
                          .concat(un, "px, ")
                          .concat(
                            wt === t.ScrollMode.Page ? 0 : vt.start.top,
                            "px)",
                          )),
                        rt
                      );
                    switch (wt) {
                      case t.ScrollMode.Horizontal:
                        return (
                          ((Mt = {
                            height: "100%",
                            width: "".concat(on, "px"),
                          })[ln] = 0),
                          (Mt.position = "absolute"),
                          (Mt.top = 0),
                          (Mt.transform = "translateX(".concat(un, "px)")),
                          Mt
                        );
                      case t.ScrollMode.Page:
                        return (
                          ((Rt = {
                            height: "".concat(Yt, "px"),
                            width: "".concat(on, "px"),
                          })[ln] = 0),
                          (Rt.position = "absolute"),
                          (Rt.top = 0),
                          Rt
                        );
                      case t.ScrollMode.Wrapped:
                        return (
                          ((Gt = {
                            height: "".concat(Yt, "px"),
                            width: "".concat(on, "px"),
                          })[ln] = 0),
                          (Gt.position = "absolute"),
                          (Gt.top = 0),
                          (Gt.transform = "translate("
                            .concat(un, "px, ")
                            .concat(vt.start.top, "px)")),
                          Gt
                        );
                      case t.ScrollMode.Vertical:
                      default:
                        return (
                          ((Wt = {
                            height: "".concat(Yt, "px"),
                            width: "100%",
                          })[ln] = 0),
                          (Wt.position = "absolute"),
                          (Wt.top = 0),
                          (Wt.transform = "translateY(".concat(
                            vt.start.top,
                            "px)",
                          )),
                          Wt
                        );
                    }
                  })(_t, J, _e, $e.current, De.current);
                },
                [J, _e],
              ),
              yn = i.useCallback(function (_t, vt) {
                var lt = yt.current,
                  ht = lt.measurements,
                  ut = lt.scrollOffset,
                  wt = ht[jn(0, te - 1, vt)];
                if (wt) {
                  var Ct =
                    De.current === t.ScrollMode.Page
                      ? { left: wt.start.left, top: wt.start.top }
                      : { left: ut.left * _t, top: ut.top * _t };
                  return pt(Ct, !1);
                }
                return Promise.resolve();
              }, []);
            return (
              i.useEffect(function () {
                return function () {
                  Dt.disconnect();
                };
              }, []),
              {
                boundingClientRect: gt,
                isSmoothScrolling: ve,
                startPage: nn,
                endPage: Kt,
                maxVisbilityIndex: rn,
                virtualItems: Jt,
                getContainerStyles: vn,
                getItemContainerStyles: cn,
                getItemStyles: hn,
                scrollToItem: en,
                scrollToNextItem: dn,
                scrollToPreviousItem: En,
                zoom: yn,
              }
            );
          },
          br = function (E, O, J, te, oe, ce) {
            var _e = J;
            switch (!0) {
              case oe === t.ViewMode.DualPageWithCover && ce >= 3:
              case oe === t.ViewMode.DualPage && ce >= 3:
                _e = 2 * J;
                break;
              default:
                _e = J;
            }
            switch (te) {
              case t.SpecialZoomLevel.ActualSize:
                return 1;
              case t.SpecialZoomLevel.PageFit:
                return Math.min(
                  (E.clientWidth - 17) / _e,
                  (E.clientHeight - 16) / O,
                );
              case t.SpecialZoomLevel.PageWidth:
                return (E.clientWidth - 17) / _e;
            }
          },
          Ca = function (E) {
            var O,
              J,
              te = E.getCurrentPage,
              oe =
                ((O = 50),
                (J = i.useRef([])),
                i.useEffect(function () {
                  return function () {
                    J.current = [];
                  };
                }, []),
                {
                  push: function (be) {
                    var ve = J.current;
                    (ve.length + 1 > O && ve.shift(),
                      ve.push(be),
                      (J.current = ve));
                  },
                  map: function (be) {
                    return J.current.map(function (ve) {
                      return be(ve);
                    });
                  },
                  pop: function () {
                    var be = J.current;
                    if (be.length === 0) return null;
                    var ve = be.pop();
                    return ((J.current = be), ve);
                  },
                }),
              ce = (function (be) {
                var ve = i.useRef([]);
                return (
                  i.useEffect(function () {
                    return function () {
                      ve.current = [];
                    };
                  }, []),
                  {
                    dequeue: function () {
                      var Be = ve.current;
                      if (Be.length === 0) return null;
                      var Oe = Be.shift();
                      return ((ve.current = Be), Oe || null);
                    },
                    enqueue: function (Be) {
                      var Oe = ve.current;
                      (Oe.length + 1 > be && Oe.pop(),
                        (ve.current = [Be].concat(Oe)));
                    },
                    map: function (Be) {
                      return ve.current.map(function (Oe) {
                        return Be(Oe);
                      });
                    },
                  }
                );
              })(50),
              _e = function () {
                var be = ce.dequeue();
                return (
                  be && oe.push(be),
                  be && be.pageIndex === te() ? _e() : be
                );
              },
              ge = function () {
                var be = oe.pop();
                return (
                  be && ce.enqueue(be),
                  be && be.pageIndex === te() ? ge() : be
                );
              },
              ne = i.useCallback(function (be) {
                oe.push(be);
              }, []);
            return {
              getNextDestination: _e,
              getPreviousDestination: ge,
              markVisitedDestination: ne,
            };
          },
          pi = function (E) {
            var O = [];
            return (
              E.map(function (J) {
                O = O.concat(J).concat(
                  (function (te) {
                    var oe = [];
                    return (
                      te.items &&
                        te.items.length > 0 &&
                        (oe = oe.concat(pi(te.items))),
                      oe
                    );
                  })(J),
                );
              }),
              O
            );
          },
          mi = { capture: !1, passive: !0 },
          Pa = { height: 0, width: 0 },
          _r = { height: 0, width: 0 },
          ka = function (E) {
            var O = E.getCurrentPage,
              J = E.getCurrentScrollMode,
              te = E.jumpToPage,
              oe = E.targetRef,
              ce = i.useState(t.FullScreenMode.Normal),
              _e = ce[0],
              ge = ce[1],
              ne = (function () {
                var bt = i.useState(Pa),
                  Ot = bt[0],
                  Dt = bt[1],
                  Nt = B(function () {
                    Dt({
                      height: window.innerHeight,
                      width: window.innerWidth,
                    });
                  }, 100);
                return (
                  h(function () {
                    return (
                      window.addEventListener("resize", Nt, mi),
                      function () {
                        window.removeEventListener("resize", Nt, mi);
                      }
                    );
                  }, []),
                  Ot
                );
              })(),
              be = i.useState(_r),
              ve = be[0],
              Be = be[1],
              Oe = i.useRef(_r),
              De = i.useRef(O()),
              $e = i.useRef(_r),
              We = i.useState(oe.current),
              Ve = We[0],
              xt = We[1],
              pt = i.useRef();
            (h(function () {
              oe.current !== Ve && xt(oe.current);
            }, []),
              h(
                function () {
                  if (Ve) {
                    var bt = new ResizeObserver(function (Ot) {
                      Ot.forEach(function (Dt) {
                        var Nt = Dt.target.getBoundingClientRect(),
                          Bt = Nt.height,
                          Ht = Nt.width;
                        Be({ height: Bt, width: Ht });
                      });
                    });
                    return (
                      bt.observe(Ve),
                      function () {
                        (bt.unobserve(Ve), bt.disconnect());
                      }
                    );
                  }
                },
                [Ve],
              ));
            var gt = i.useCallback(function (bt) {
                var Ot = y();
                return Ot && Ot !== bt
                  ? (ge(t.FullScreenMode.Normal), o(Ot))
                  : Promise.resolve();
              }, []),
              yt = i.useCallback(function (bt) {
                bt &&
                  e() &&
                  (xt(bt),
                  gt(bt).then(function () {
                    ((pt.current = bt),
                      ge(t.FullScreenMode.Entering),
                      (function (Ot) {
                        m && Ot[C.RequestFullScreen]();
                      })(bt));
                  }));
              }, []),
              ct = i.useCallback(function () {
                y() && (ge(t.FullScreenMode.Exitting), o(document));
              }, []),
              St = i.useCallback(
                function () {
                  Ve && y() !== Ve && ge(t.FullScreenMode.Exitting);
                },
                [Ve],
              );
            return (
              i.useEffect(
                function () {
                  switch (_e) {
                    case t.FullScreenMode.Entering:
                      (pt.current &&
                        (pt.current.style.backgroundColor =
                          "var(--rpv-core__full-screen-target-background-color)"),
                        (De.current = O()),
                        (Oe.current = {
                          height: window.innerHeight,
                          width: window.innerWidth,
                        }));
                      break;
                    case t.FullScreenMode.Entered:
                      J() === t.ScrollMode.Page
                        ? te(De.current).then(function () {
                            ge(t.FullScreenMode.EnteredCompletely);
                          })
                        : ge(t.FullScreenMode.EnteredCompletely);
                      break;
                    case t.FullScreenMode.Exitting:
                      (pt.current &&
                        ((pt.current.style.backgroundColor = ""),
                        (pt.current = null)),
                        (De.current = O()));
                      break;
                    case t.FullScreenMode.Exited:
                      (ge(t.FullScreenMode.Normal),
                        J() === t.ScrollMode.Page && te(De.current));
                  }
                },
                [_e],
              ),
              i.useEffect(
                function () {
                  if (_e !== t.FullScreenMode.Normal)
                    return _e === t.FullScreenMode.Entering &&
                      ne.height === ve.height &&
                      ne.width === ve.width &&
                      ne.height > 0 &&
                      ne.width > 0 &&
                      ($e.current.height === 0 ||
                        ne.height == $e.current.height)
                      ? (($e.current = {
                          height: window.innerHeight,
                          width: window.innerWidth,
                        }),
                        void ge(t.FullScreenMode.Entered))
                      : void (
                          _e === t.FullScreenMode.Exitting &&
                          Oe.current.height === ne.height &&
                          Oe.current.width === ne.width &&
                          ne.height > 0 &&
                          ne.width > 0 &&
                          ge(t.FullScreenMode.Exited)
                        );
                },
                [_e, ne, ve],
              ),
              i.useEffect(
                function () {
                  var bt;
                  return (
                    (bt = St),
                    m && document.addEventListener(C.FullScreenChange, bt),
                    function () {
                      (function (Ot) {
                        m &&
                          document.removeEventListener(C.FullScreenChange, Ot);
                      })(St);
                    }
                  );
                },
                [Ve],
              ),
              {
                enterFullScreenMode: yt,
                exitFullScreenMode: ct,
                fullScreenMode: _e,
              }
            );
          },
          Ma = {
            buildPageStyles: function () {
              return {};
            },
            transformSize: function (E) {
              return E.size;
            },
          },
          Rn = { left: 0, top: 0 },
          Ta = function (E) {
            var O = E.currentFile,
              J = E.defaultScale,
              te = E.doc,
              oe = E.enableSmoothScroll,
              ce = E.initialPage,
              _e = E.initialRotation,
              ge = E.initialScale,
              ne = E.pageLayout,
              be = E.pageSizes,
              ve = E.plugins,
              Be = E.renderPage,
              Oe = E.scrollMode,
              De = E.setRenderRange,
              $e = E.viewMode,
              We = E.viewerState,
              Ve = E.onDocumentLoad,
              xt = E.onOpenFile,
              pt = E.onPageChange,
              gt = E.onRotate,
              yt = E.onRotatePage,
              ct = E.onZoom,
              St = te.numPages,
              bt = te.loadingTask.docId,
              Ot = i.useContext(Y).l10n,
              Dt = i.useContext(P),
              Nt = Dt.direction === t.TextDirection.RightToLeft,
              Bt = i.useRef(),
              Ht = i.useRef(),
              nn = i.useState(ce),
              Kt = nn[0],
              rn = nn[1],
              Jt = i.useRef(null),
              en = Ca({
                getCurrentPage: function () {
                  return Tt.current.pageIndex;
                },
              }),
              tn = i.useState(_e),
              Qt = tn[0],
              dn = tn[1],
              En = D(Qt),
              vn = i.useState(!1),
              cn = vn[0],
              hn = vn[1],
              yn = i.useState(new Map()),
              _t = yn[0],
              vt = yn[1],
              lt = i.useState(Oe),
              ht = lt[0],
              ut = lt[1],
              wt = D(ht),
              Ct = i.useState($e),
              ft = Ct[0],
              rt = Ct[1],
              Mt = D(ft),
              Rt = (function (qe) {
                var Pt = M(),
                  Ft = i.useState([]),
                  qt = Ft[0],
                  jt = Ft[1];
                return (
                  i.useEffect(function () {
                    qe.getOutline().then(function (It) {
                      if (Pt.current && It !== null) {
                        var sn = pi(It);
                        jt(sn);
                      }
                    });
                  }, []),
                  qt
                );
              })(te),
              Gt = i.useState(ge),
              Wt = Gt[0],
              ln = Gt[1],
              fn = D(Wt),
              Tt = i.useRef(We),
              un = i.useRef(typeof J == "string" ? J : null),
              Xt = i.useRef(-1),
              Yt = i.useRef(-1),
              on = i.useRef(ce),
              Vt = ka({
                getCurrentPage: function () {
                  return Tt.current.pageIndex;
                },
                getCurrentScrollMode: function () {
                  return Tt.current.scrollMode;
                },
                jumpToPage: function (qe) {
                  return Cn(qe);
                },
                targetRef: Ht,
              }),
              wn = i.useState(-1),
              Ln = wn[0],
              Qn = wn[1],
              Mn = i.useState(0),
              zn = Mn[0],
              Da = Mn[1],
              pn = L({ doc: te });
            i.useEffect(
              function () {
                return function () {
                  (Ie.clear(), it.clear());
                };
              },
              [bt],
            );
            var _i = i.useMemo(function () {
                return Object.assign({}, Ma, ne);
              }, []),
              Oa = i.useMemo(
                function () {
                  return Array(St)
                    .fill(0)
                    .map(function (qe, Pt) {
                      var Ft = [be[Pt].pageHeight, be[Pt].pageWidth],
                        qt =
                          Math.abs(Qt) % 180 == 0
                            ? { height: Ft[0], width: Ft[1] }
                            : { height: Ft[1], width: Ft[0] },
                        jt = { height: qt.height * Wt, width: qt.width * Wt };
                      return _i.transformSize({
                        numPages: St,
                        pageIndex: Pt,
                        size: jt,
                      });
                    });
                },
                [Qt, Wt],
              ),
              Ut = Aa({
                enableSmoothScroll: oe,
                isRtl: Nt,
                numberOfItems: St,
                parentRef: Ht,
                scrollMode: ht,
                setRenderRange: De,
                sizes: Oa,
                viewMode: ft,
              }),
              Na = B(function () {
                !un.current ||
                  Tt.current.fullScreenMode !== t.FullScreenMode.Normal ||
                  (ce > 0 && on.current === ce) ||
                  Tn(un.current);
              }, 200);
            (function (qe) {
              var Pt = qe.targetRef,
                Ft = qe.onResize;
              h(function () {
                var qt = new ResizeObserver(function (It) {
                    It.forEach(function (sn) {
                      Ft(sn.target);
                    });
                  }),
                  jt = Pt.current;
                if (jt)
                  return (
                    qt.observe(jt),
                    function () {
                      qt.unobserve(jt);
                    }
                  );
              }, []);
            })({ targetRef: Ht, onResize: Na });
            var An = function (qe) {
                var Pt = qe;
                (ve.forEach(function (Ft) {
                  Ft.onViewerStateChange && (Pt = Ft.onViewerStateChange(Pt));
                }),
                  (Tt.current = Pt));
              },
              Ba = function () {
                return Ht.current;
              },
              ja = function () {
                return Tt.current;
              },
              za = i.useCallback(function (qe) {
                en.markVisitedDestination(qe);
              }, []),
              Sr = i.useCallback(function (qe) {
                var Pt = qe.pageIndex,
                  Ft = qe.bottomOffset,
                  qt = qe.leftOffset,
                  jt = qe.scaleTo,
                  It = Ht.current,
                  sn = Tt.current;
                return It && sn
                  ? new Promise(function (Pn, Mr) {
                      ze(te, Pt).then(function (er) {
                        var kn = er.getViewport({ scale: 1 }),
                          tr = 0,
                          ki =
                            (typeof Ft == "function"
                              ? Ft(kn.width, kn.height)
                              : Ft) || 0,
                          nr =
                            (typeof qt == "function"
                              ? qt(kn.width, kn.height)
                              : qt) || 0,
                          Fn = sn.scale;
                        switch (jt) {
                          case t.SpecialZoomLevel.PageFit:
                            ((tr = 0),
                              (nr = 0),
                              Tn(t.SpecialZoomLevel.PageFit));
                            break;
                          case t.SpecialZoomLevel.PageWidth:
                            ((Fn = br(
                              It,
                              be[Pt].pageHeight,
                              be[Pt].pageWidth,
                              t.SpecialZoomLevel.PageWidth,
                              $e,
                              St,
                            )),
                              (tr = (kn.height - ki) * Fn),
                              (nr *= Fn),
                              Tn(Fn));
                            break;
                          default:
                            ((tr = (kn.height - ki) * Fn), (nr *= Fn));
                        }
                        switch (sn.scrollMode) {
                          case t.ScrollMode.Horizontal:
                            Ut.scrollToItem(Pt, { left: nr, top: 0 }).then(
                              function () {
                                Pn();
                              },
                            );
                            break;
                          case t.ScrollMode.Vertical:
                          default:
                            Ut.scrollToItem(Pt, { left: 0, top: tr }).then(
                              function () {
                                Pn();
                              },
                            );
                        }
                      });
                    })
                  : Promise.resolve();
              }, []),
              Ei = i.useCallback(function (qe) {
                return (en.markVisitedDestination(qe), Sr(qe));
              }, []),
              Ha = i.useCallback(function () {
                var qe = en.getNextDestination();
                return qe ? Sr(qe) : Promise.resolve();
              }, []),
              qa = i.useCallback(function () {
                var qe = en.getPreviousDestination();
                return qe ? Sr(qe) : Promise.resolve();
              }, []),
              Va = i.useCallback(function () {
                return Ut.scrollToNextItem(Tt.current.pageIndex, Rn);
              }, []),
              Cn = i.useCallback(function (qe) {
                return 0 <= qe && qe < St
                  ? Ut.scrollToItem(qe, Rn)
                  : Promise.resolve();
              }, []),
              Wa = i.useCallback(function () {
                return Ut.scrollToPreviousItem(Tt.current.pageIndex, Rn);
              }, []),
              yi = i.useCallback(
                function (qe) {
                  var Pt, Ft;
                  ((Pt = qe.name),
                  (Ft = Pt.split(/\./).pop()),
                  Ft ? Ft.toLowerCase() : "").toLowerCase() === "pdf" &&
                    new Promise(function (qt) {
                      var jt = new FileReader();
                      (jt.readAsArrayBuffer(qe),
                        (jt.onload = function () {
                          var It = new Uint8Array(jt.result);
                          qt(It);
                        }));
                    }).then(function (qt) {
                      xt(qe.name, qt);
                    });
                },
                [xt],
              ),
              Si = i.useCallback(function (qe) {
                var Pt = qe === t.RotateDirection.Backward ? -90 : 90,
                  Ft = Tt.current.rotation,
                  qt = Ft === 360 || Ft === -360 ? Pt : Ft + Pt;
                (pn.markNotRendered(),
                  dn(qt),
                  An(k(k({}, Tt.current), { rotation: qt })),
                  gt({ direction: qe, doc: te, rotation: qt }));
              }, []),
              wr = i.useCallback(function (qe, Pt) {
                var Ft = Pt === t.RotateDirection.Backward ? -90 : 90,
                  qt = Tt.current.pagesRotation,
                  jt = (qt.has(qe) ? qt.get(qe) : _e) + Ft,
                  It = qt.set(qe, jt);
                (vt(It),
                  hn(function (sn) {
                    return !sn;
                  }),
                  An(
                    k(k({}, Tt.current), {
                      pagesRotation: It,
                      rotatedPage: qe,
                    }),
                  ),
                  yt({ direction: Pt, doc: te, pageIndex: qe, rotation: jt }),
                  pn.markRendering(qe),
                  Qn(qe));
              }, []),
              wi = i.useCallback(function (qe) {
                (An(k(k({}, Tt.current), { scrollMode: qe })), ut(qe));
              }, []),
              Ai = i.useCallback(function (qe) {
                (An(k(k({}, Tt.current), { viewMode: qe })), rt(qe));
              }, []),
              Tn = i.useCallback(function (qe) {
                var Pt = Ht.current,
                  Ft = Tt.current.pageIndex;
                if (!(Ft < 0 || Ft >= St)) {
                  var qt = be[Ft].pageHeight,
                    jt = be[Ft].pageWidth,
                    It = Pt
                      ? typeof qe == "string"
                        ? br(Pt, qt, jt, qe, Tt.current.viewMode, St)
                        : qe
                      : 1;
                  ((un.current = typeof qe == "string" ? qe : null),
                    It !== Tt.current.scale &&
                      (Da(function (sn) {
                        return sn + 1;
                      }),
                      pn.markNotRendered(),
                      ln(It),
                      ct({ doc: te, scale: It }),
                      An(k(k({}, Tt.current), { scale: It }))));
                }
              }, []),
              Ua = i.useCallback(function (qe) {
                Vt.enterFullScreenMode(qe);
              }, []),
              $a = i.useCallback(function () {
                Vt.exitFullScreenMode();
              }, []);
            (i.useEffect(
              function () {
                An(k(k({}, Tt.current), { fullScreenMode: Vt.fullScreenMode }));
              },
              [Vt.fullScreenMode],
            ),
              i.useEffect(
                function () {
                  var qe = {
                    enterFullScreenMode: Ua,
                    exitFullScreenMode: $a,
                    getPagesContainer: Ba,
                    getViewerState: ja,
                    jumpToDestination: Ei,
                    jumpToNextDestination: Ha,
                    jumpToPreviousDestination: qa,
                    jumpToNextPage: Va,
                    jumpToPreviousPage: Wa,
                    jumpToPage: Cn,
                    openFile: yi,
                    rotate: Si,
                    rotatePage: wr,
                    setViewerState: An,
                    switchScrollMode: wi,
                    switchViewMode: Ai,
                    zoom: Tn,
                  };
                  return (
                    ve.forEach(function (Pt) {
                      Pt.install && Pt.install(qe);
                    }),
                    function () {
                      ve.forEach(function (Pt) {
                        Pt.uninstall && Pt.uninstall(qe);
                      });
                    }
                  );
                },
                [bt],
              ),
              i.useEffect(
                function () {
                  (Ve({ doc: te, file: O }),
                    ve.forEach(function (qe) {
                      qe.onDocumentLoad &&
                        qe.onDocumentLoad({ doc: te, file: O });
                    }));
                },
                [bt],
              ));
            var Ar,
              Cr,
              Pr,
              Ci = Ut.boundingClientRect;
            ((Ar = function () {
              ce && Cn(ce);
            }),
              (Cr = Ci.height > 0 && Ci.width > 0),
              (Pr = i.useRef(!1)),
              h(
                function () {
                  Cr && !Pr.current && ((Pr.current = !0), Ar());
                },
                [Ar, Cr],
              ),
              h(
                function () {
                  var qe = Tt.current.pageIndex;
                  qe > -1 &&
                    wt !== ht &&
                    Ut.scrollToItem(qe, Rn).then(function () {
                      Vt.fullScreenMode ===
                        t.FullScreenMode.EnteredCompletely &&
                        (oe || pn.markNotRendered(), (Xt.current = -1));
                    });
                },
                [ht],
              ),
              h(
                function () {
                  var qe = Tt.current.pageIndex;
                  qe > -1 && En !== Qt && Ut.scrollToItem(qe, Rn);
                },
                [Qt],
              ),
              h(
                function () {
                  fn != 0 &&
                    fn != Tt.current.scale &&
                    Ut.zoom(Tt.current.scale / fn, Tt.current.pageIndex).then(
                      function () {
                        Vt.fullScreenMode ===
                          t.FullScreenMode.EnteredCompletely &&
                          (Yt.current = -1);
                      },
                    );
                },
                [Wt],
              ),
              h(
                function () {
                  if (Mt !== Tt.current.viewMode) {
                    var qe = Ut.startPage,
                      Pt = Ut.endPage,
                      Ft = Ut.virtualItems;
                    (pn.markNotRendered(), pn.setRange(qe, Pt));
                    for (
                      var qt = function (It) {
                          var sn = Ft.find(function (Pn) {
                            return Pn.index === It;
                          });
                          sn && pn.setVisibility(It, sn.visibility);
                        },
                        jt = qe;
                      jt <= Pt;
                      jt++
                    )
                      qt(jt);
                    kr();
                  }
                },
                [ft],
              ),
              h(
                function () {
                  var qe = Tt.current.pageIndex;
                  qe > -1 && Mt !== ft && Ut.scrollToItem(qe, Rn);
                },
                [ft],
              ),
              h(
                function () {
                  var qe = Tt.current.pageIndex;
                  qe > 0 &&
                    qe === ce &&
                    on.current === ce &&
                    un.current &&
                    ((on.current = -1), Tn(un.current));
                },
                [Kt],
              ),
              i.useEffect(
                function () {
                  Ut.isSmoothScrolling ||
                    (Jt.current !== null && Jt.current === Kt) ||
                    ((Jt.current = Kt), pt({ currentPage: Kt, doc: te }));
                },
                [Kt, Ut.isSmoothScrolling],
              ),
              i.useEffect(
                function () {
                  (Vt.fullScreenMode === t.FullScreenMode.Entering &&
                    Tt.current.scrollMode === t.ScrollMode.Page &&
                    (Xt.current = Tt.current.pageIndex),
                    Vt.fullScreenMode === t.FullScreenMode.EnteredCompletely &&
                      Tt.current.scrollMode === t.ScrollMode.Page &&
                      oe &&
                      (Xt.current = -1),
                    Vt.fullScreenMode === t.FullScreenMode.EnteredCompletely &&
                      un.current &&
                      ((Yt.current = Tt.current.pageIndex), Tn(un.current)));
                },
                [Vt.fullScreenMode],
              ),
              i.useEffect(
                function () {
                  if (
                    Vt.fullScreenMode !== t.FullScreenMode.Entering &&
                    Vt.fullScreenMode !== t.FullScreenMode.Exitting &&
                    !Ut.isSmoothScrolling
                  ) {
                    var qe = Ut.startPage,
                      Pt = Ut.endPage,
                      Ft = Ut.maxVisbilityIndex,
                      qt = Ut.virtualItems,
                      jt = Ft,
                      It =
                        Vt.fullScreenMode === t.FullScreenMode.Entered ||
                        Vt.fullScreenMode ===
                          t.FullScreenMode.EnteredCompletely;
                    if (
                      !(
                        (It && jt !== Xt.current && Xt.current > -1) ||
                        (It && jt !== Yt.current && Yt.current > -1)
                      )
                    ) {
                      (rn(jt),
                        An(k(k({}, Tt.current), { pageIndex: jt })),
                        pn.setRange(qe, Pt));
                      for (
                        var sn = function (Mr) {
                            var er = qt.find(function (kn) {
                              return kn.index === Mr;
                            });
                            er && pn.setVisibility(Mr, er.visibility);
                          },
                          Pn = qe;
                        Pn <= Pt;
                        Pn++
                      )
                        sn(Pn);
                      kr();
                    }
                  }
                },
                [
                  Ut.startPage,
                  Ut.endPage,
                  Ut.isSmoothScrolling,
                  Ut.maxVisbilityIndex,
                  Vt.fullScreenMode,
                  cn,
                  Qt,
                  Wt,
                ],
              ));
            var Ga = i.useCallback(
                function (qe) {
                  (pn.markRendered(qe), kr());
                },
                [zn],
              ),
              kr = function () {
                var qe = pn.getHighestPriorityPage();
                qe > -1 && pn.isInRange(qe) && (pn.markRendering(qe), Qn(qe));
              },
              Xa = function (qe) {
                var Pt = Kt - 1,
                  Ft = Kt + 1;
                switch (qe) {
                  case "FirstPage":
                    Cn(0);
                    break;
                  case "LastPage":
                    Cn(St - 1);
                    break;
                  case "NextPage":
                    Ft < St && Cn(Ft);
                    break;
                  case "PrevPage":
                    Pt >= 0 && Cn(Pt);
                }
              },
              Ka = i.useCallback(
                function () {
                  var qe = Ut.virtualItems,
                    Pt = [];
                  switch (ft) {
                    case t.ViewMode.DualPage:
                      Pt = se(qe, 2);
                      break;
                    case t.ViewMode.DualPageWithCover:
                      qe.length &&
                        (Pt =
                          qe[0].index === 0
                            ? [[qe[0]]].concat(se(qe.slice(1), 2))
                            : se(qe, 2));
                      break;
                    case t.ViewMode.SinglePage:
                    default:
                      Pt = se(qe, 1);
                  }
                  var Ft =
                      Ot && Ot.core ? Ot.core.pageLabel : "Page {{pageIndex}}",
                    qt = {
                      attrs: {
                        className: "rpv-core__inner-container",
                        "data-testid": "core__inner-container",
                        ref: Bt,
                        style: { height: "100%" },
                      },
                      children: i.createElement(i.Fragment, null),
                      subSlot: {
                        attrs: {
                          "data-testid": "core__inner-pages",
                          className: _({
                            "rpv-core__inner-pages": !0,
                            "rpv-core__inner-pages--horizontal":
                              ht === t.ScrollMode.Horizontal,
                            "rpv-core__inner-pages--rtl": Nt,
                            "rpv-core__inner-pages--single":
                              ht === t.ScrollMode.Page,
                            "rpv-core__inner-pages--vertical":
                              ht === t.ScrollMode.Vertical,
                            "rpv-core__inner-pages--wrapped":
                              ht === t.ScrollMode.Wrapped,
                          }),
                          ref: Ht,
                          style: { height: "100%", position: "relative" },
                        },
                        children: i.createElement(
                          "div",
                          {
                            "data-testid": "core__inner-current-page-".concat(
                              Kt,
                            ),
                            style: Object.assign(
                              { "--scale-factor": Wt },
                              Ut.getContainerStyles(),
                            ),
                          },
                          Pt.map(function (jt) {
                            return i.createElement(
                              "div",
                              {
                                className: _({
                                  "rpv-core__inner-page-container": !0,
                                  "rpv-core__inner-page-container--single":
                                    ht === t.ScrollMode.Page,
                                }),
                                style: Ut.getItemContainerStyles(jt[0]),
                                key: "".concat(jt[0].index, "-").concat(ft),
                              },
                              jt.map(function (It) {
                                var sn =
                                  ft === t.ViewMode.DualPageWithCover &&
                                  (It.index === 0 ||
                                    (St % 2 == 0 && It.index === St - 1));
                                return i.createElement(
                                  "div",
                                  {
                                    "aria-label": Ft.replace(
                                      "{{pageIndex}}",
                                      "".concat(It.index + 1),
                                    ),
                                    className: _({
                                      "rpv-core__inner-page": !0,
                                      "rpv-core__inner-page--dual-even":
                                        ft === t.ViewMode.DualPage &&
                                        It.index % 2 == 0,
                                      "rpv-core__inner-page--dual-odd":
                                        ft === t.ViewMode.DualPage &&
                                        It.index % 2 == 1,
                                      "rpv-core__inner-page--dual-cover": sn,
                                      "rpv-core__inner-page--dual-cover-even":
                                        ft === t.ViewMode.DualPageWithCover &&
                                        !sn &&
                                        It.index % 2 == 0,
                                      "rpv-core__inner-page--dual-cover-odd":
                                        ft === t.ViewMode.DualPageWithCover &&
                                        !sn &&
                                        It.index % 2 == 1,
                                      "rpv-core__inner-page--single":
                                        ft === t.ViewMode.SinglePage &&
                                        ht === t.ScrollMode.Page,
                                    }),
                                    role: "region",
                                    key: "".concat(It.index, "-").concat(ft),
                                    style: Object.assign(
                                      {},
                                      Ut.getItemStyles(It),
                                      _i.buildPageStyles({
                                        numPages: St,
                                        pageIndex: It.index,
                                        scrollMode: ht,
                                        viewMode: ft,
                                      }),
                                    ),
                                  },
                                  i.createElement(pa, {
                                    doc: te,
                                    measureRef: It.measureRef,
                                    outlines: Rt,
                                    pageIndex: It.index,
                                    pageRotation: _t.has(It.index)
                                      ? _t.get(It.index)
                                      : 0,
                                    pageSize: be[It.index],
                                    plugins: ve,
                                    renderPage: Be,
                                    renderQueueKey: zn,
                                    rotation: Qt,
                                    scale: Wt,
                                    shouldRender: Ln === It.index,
                                    viewMode: ft,
                                    onExecuteNamedAction: Xa,
                                    onJumpFromLinkAnnotation: za,
                                    onJumpToDest: Ei,
                                    onRenderCompleted: Ga,
                                    onRotatePage: wr,
                                  }),
                                );
                              }),
                            );
                          }),
                        ),
                      },
                    };
                  return (
                    ve.forEach(function (jt) {
                      jt.renderViewer &&
                        (qt = jt.renderViewer({
                          containerRef: Bt,
                          doc: te,
                          pagesContainerRef: Ht,
                          pagesRotation: _t,
                          pageSizes: be,
                          rotation: Qt,
                          slot: qt,
                          themeContext: Dt,
                          jumpToPage: Cn,
                          openFile: yi,
                          rotate: Si,
                          rotatePage: wr,
                          switchScrollMode: wi,
                          switchViewMode: Ai,
                          zoom: Tn,
                        }));
                    }),
                    qt
                  );
                },
                [ve, Ut],
              ),
              Pi = i.useCallback(function (qe) {
                return i.createElement(
                  "div",
                  k({}, qe.attrs, {
                    style: qe.attrs && qe.attrs.style ? qe.attrs.style : {},
                  }),
                  qe.children,
                  qe.subSlot && Pi(qe.subSlot),
                );
              }, []);
            return Pi(Ka());
          },
          gi = [
            0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7,
            1.9, 2.1, 2.4, 2.7, 3, 3.3, 3.7, 4.1, 4.6, 5.1, 5.7, 6.3, 7, 7.7,
            8.5, 9.4, 10,
          ],
          xa = function (E) {
            var O = E.defaultScale,
              J = E.doc,
              te = E.render,
              oe = E.scrollMode,
              ce = E.viewMode,
              _e = i.useRef(),
              ge = i.useState({ pageSizes: [], scale: 0 }),
              ne = ge[0],
              be = ge[1];
            return (
              i.useLayoutEffect(
                function () {
                  var ve = Array(J.numPages)
                    .fill(0)
                    .map(function (Be, Oe) {
                      return new Promise(function (De, $e) {
                        ze(J, Oe).then(function (We) {
                          var Ve = We.getViewport({ scale: 1 });
                          De({
                            pageHeight: Ve.height,
                            pageWidth: Ve.width,
                            rotation: Ve.rotation,
                          });
                        });
                      });
                    });
                  Promise.all(ve).then(function (Be) {
                    var Oe = _e.current;
                    if (Oe && Be.length !== 0) {
                      var De = Be[0].pageWidth,
                        $e = Be[0].pageHeight,
                        We = Oe.parentElement,
                        Ve = (We.clientWidth - 45) / De,
                        xt = (We.clientHeight - 45) / $e,
                        pt = Ve;
                      switch (oe) {
                        case t.ScrollMode.Horizontal:
                          pt = Math.min(Ve, xt);
                          break;
                        case t.ScrollMode.Vertical:
                        default:
                          pt = Ve;
                      }
                      var gt,
                        yt,
                        ct = O
                          ? typeof O == "string"
                            ? br(We, $e, De, O, ce, J.numPages)
                            : O
                          : ((gt = pt),
                            (yt = gi.findIndex(function (St) {
                              return St >= gt;
                            })) === -1 || yt === 0
                              ? gt
                              : gi[yt - 1]);
                      be({ pageSizes: Be, scale: ct });
                    }
                  });
                },
                [J.loadingTask.docId],
              ),
              ne.pageSizes.length === 0 || ne.scale === 0
                ? i.createElement(
                    "div",
                    {
                      className: "rpv-core__page-size-calculator",
                      "data-testid": "core__page-size-calculating",
                      ref: _e,
                    },
                    i.createElement(F, null),
                  )
                : te(ne.pageSizes, ne.scale)
            );
          },
          Jn = function () {},
          Er = (function (E) {
            function O(J, te) {
              var oe = E.call(this) || this;
              return ((oe.verifyPassword = J), (oe.passwordStatus = te), oe);
            }
            return (X(O, E), O);
          })(Jn),
          Ra = function (E) {
            var O = E.passwordStatus,
              J = E.renderProtectedView,
              te = E.verifyPassword,
              oe = E.onDocumentAskPassword,
              ce = i.useContext(Y).l10n,
              _e = i.useState(""),
              ge = _e[0],
              ne = _e[1],
              be = i.useContext(P).direction === t.TextDirection.RightToLeft,
              ve = function () {
                return te(ge);
              };
            return (
              i.useEffect(function () {
                oe && oe({ verifyPassword: te });
              }, []),
              J
                ? J({ passwordStatus: O, verifyPassword: te })
                : i.createElement(
                    "div",
                    { className: "rpv-core__asking-password-wrapper" },
                    i.createElement(
                      "div",
                      {
                        className: _({
                          "rpv-core__asking-password": !0,
                          "rpv-core__asking-password--rtl": be,
                        }),
                      },
                      i.createElement(
                        "div",
                        { className: "rpv-core__asking-password-message" },
                        O === t.PasswordStatus.RequiredPassword &&
                          ce.core.askingPassword.requirePasswordToOpen,
                        O === t.PasswordStatus.WrongPassword &&
                          ce.core.wrongPassword.tryAgain,
                      ),
                      i.createElement(
                        "div",
                        { className: "rpv-core__asking-password-body" },
                        i.createElement(
                          "div",
                          {
                            className: _({
                              "rpv-core__asking-password-input": !0,
                              "rpv-core__asking-password-input--ltr": !be,
                              "rpv-core__asking-password-input--rtl": be,
                            }),
                          },
                          i.createElement(v, {
                            testId: "core__asking-password-input",
                            type: "password",
                            value: ge,
                            onChange: ne,
                            onKeyDown: function (Be) {
                              Be.key === "Enter" && ve();
                            },
                          }),
                        ),
                        i.createElement(
                          u,
                          { onClick: ve },
                          ce.core.askingPassword.submit,
                        ),
                      ),
                    ),
                  )
            );
          },
          vi = (function (E) {
            function O(J) {
              var te = E.call(this) || this;
              return ((te.doc = J), te);
            }
            return (X(O, E), O);
          })(Jn),
          bi = (function (E) {
            function O(J) {
              var te = E.call(this) || this;
              return ((te.error = J), te);
            }
            return (X(O, E), O);
          })(Jn),
          yr = (function (E) {
            function O(J) {
              var te = E.call(this) || this;
              return ((te.percentages = J), te);
            }
            return (X(O, E), O);
          })(Jn),
          La = function (E) {
            var O = E.characterMap,
              J = E.file,
              te = E.httpHeaders,
              oe = E.render,
              ce = E.renderError,
              _e = E.renderLoader,
              ge = E.renderProtectedView,
              ne = E.transformGetDocumentParams,
              be = E.withCredentials,
              ve = E.onDocumentAskPassword,
              Be = i.useContext(P).direction === t.TextDirection.RightToLeft,
              Oe = i.useState(new yr(0)),
              De = Oe[0],
              $e = Oe[1],
              We = i.useRef(""),
              Ve = M();
            return (
              i.useEffect(
                function () {
                  ((We.current = ""), $e(new yr(0)));
                  var xt = new H.PDFWorker({
                      name: "PDFWorker_".concat(Date.now()),
                    }),
                    pt = Object.assign(
                      { httpHeaders: te, withCredentials: be, worker: xt },
                      typeof J == "string" ? { url: J } : { data: J },
                      O ? { cMapUrl: O.url, cMapPacked: O.isCompressed } : {},
                    ),
                    gt = ne ? ne(pt) : pt,
                    yt = H.getDocument(gt);
                  return (
                    (yt.onPassword = function (ct, St) {
                      switch (St) {
                        case H.PasswordResponses.NEED_PASSWORD:
                          Ve.current &&
                            $e(new Er(ct, t.PasswordStatus.RequiredPassword));
                          break;
                        case H.PasswordResponses.INCORRECT_PASSWORD:
                          Ve.current &&
                            $e(new Er(ct, t.PasswordStatus.WrongPassword));
                      }
                    }),
                    (yt.onProgress = function (ct) {
                      var St =
                        ct.total > 0
                          ? Math.min(100, (100 * ct.loaded) / ct.total)
                          : 100;
                      Ve.current && We.current === "" && $e(new yr(St));
                    }),
                    yt.promise.then(
                      function (ct) {
                        ((We.current = ct.loadingTask.docId),
                          Ve.current && $e(new vi(ct)));
                      },
                      function (ct) {
                        return (
                          Ve.current &&
                          !xt.destroyed &&
                          $e(
                            new bi({
                              message: ct.message || "Cannot load document",
                              name: ct.name,
                            }),
                          )
                        );
                      },
                    ),
                    function () {
                      (yt.destroy(), xt.destroy());
                    }
                  );
                },
                [J],
              ),
              De instanceof Er
                ? i.createElement(Ra, {
                    passwordStatus: De.passwordStatus,
                    renderProtectedView: ge,
                    verifyPassword: De.verifyPassword,
                    onDocumentAskPassword: ve,
                  })
                : De instanceof vi
                  ? oe(De.doc)
                  : De instanceof bi
                    ? ce
                      ? ce(De.error)
                      : i.createElement(
                          "div",
                          {
                            className: _({
                              "rpv-core__doc-error": !0,
                              "rpv-core__doc-error--rtl": Be,
                            }),
                          },
                          i.createElement(
                            "div",
                            { className: "rpv-core__doc-error-text" },
                            De.error.message,
                          ),
                        )
                    : i.createElement(
                        "div",
                        {
                          "data-testid": "core__doc-loading",
                          className: _({
                            "rpv-core__doc-loading": !0,
                            "rpv-core__doc-loading--rtl": Be,
                          }),
                        },
                        _e ? _e(De.percentages) : i.createElement(F, null),
                      )
            );
          },
          Fa = function (E, O) {
            var J = i.useMemo(function () {
                return E === "auto"
                  ? typeof window < "u" &&
                    window.matchMedia &&
                    window.matchMedia("(prefers-color-scheme: dark)").matches
                    ? "dark"
                    : "light"
                  : E;
              }, []),
              te = i.useState(J),
              oe = te[0],
              ce = te[1],
              _e = D(oe);
            return (
              i.useEffect(function () {
                if (E === "auto") {
                  var ge = window.matchMedia("(prefers-color-scheme: dark)"),
                    ne = function (be) {
                      ce(be.matches ? "dark" : "light");
                    };
                  return (
                    ge.addEventListener("change", ne),
                    function () {
                      return ge.removeEventListener("change", ne);
                    }
                  );
                }
              }, []),
              i.useEffect(
                function () {
                  oe !== _e && O && O(oe);
                },
                [oe],
              ),
              i.useEffect(
                function () {
                  E !== oe && ce(E);
                },
                [E],
              ),
              { currentTheme: oe, setCurrentTheme: ce }
            );
          },
          Ia = function (E) {
            return { startPage: E.startPage - 3, endPage: E.endPage + 3 };
          };
        ((t.Button = function (E) {
          var O = E.children,
            J = E.testId,
            te = E.onClick,
            oe = i.useContext(P).direction === t.TextDirection.RightToLeft,
            ce = J ? { "data-testid": J } : {};
          return i.createElement(
            "button",
            k(
              {
                className: _({
                  "rpv-core__button": !0,
                  "rpv-core__button--rtl": oe,
                }),
                type: "button",
                onClick: te,
              },
              ce,
            ),
            O,
          );
        }),
          (t.Icon = d),
          (t.LazyRender = function (E) {
            var O = E.attrs,
              J = E.children,
              te = E.testId,
              oe = i.useState(!1),
              ce = oe[0],
              _e = oe[1],
              ge = te ? k(k({}, O), { "data-testid": te }) : O,
              ne = r({
                once: !0,
                onVisibilityChanged: function (be) {
                  be.isVisible && _e(!0);
                },
              });
            return i.createElement("div", k({ ref: ne }, ge), ce && J);
          }),
          (t.LocalizationContext = Y),
          (t.Menu = function (E) {
            var O = E.children,
              J = i.useRef(),
              te = i.useRef([]),
              oe = i.useContext(P).direction === t.TextDirection.RightToLeft,
              ce = function (ge) {
                if (J.current)
                  switch (ge.key) {
                    case "Tab":
                      ge.preventDefault();
                      break;
                    case "ArrowDown":
                      (ge.preventDefault(),
                        _e(function (ne, be) {
                          return be + 1;
                        }));
                      break;
                    case "ArrowUp":
                      (ge.preventDefault(),
                        _e(function (ne, be) {
                          return be - 1;
                        }));
                      break;
                    case "End":
                      (ge.preventDefault(),
                        _e(function (ne, be) {
                          return ne.length - 1;
                        }));
                      break;
                    case "Home":
                      (ge.preventDefault(),
                        _e(function (ne, be) {
                          return 0;
                        }));
                  }
              },
              _e = function (ge) {
                if (J.current) {
                  var ne = te.current,
                    be = ne.findIndex(function (Be) {
                      return Be.getAttribute("tabindex") === "0";
                    }),
                    ve = Math.min(ne.length - 1, Math.max(0, ge(ne, be)));
                  (be >= 0 &&
                    be <= ne.length - 1 &&
                    ne[be].setAttribute("tabindex", "-1"),
                    ne[ve].setAttribute("tabindex", "0"),
                    ne[ve].focus());
                }
              };
            return (
              h(function () {
                var ge = J.current;
                if (ge) {
                  var ne = (function (be) {
                    var ve = [];
                    return (
                      be
                        .querySelectorAll(
                          '.rpv-core__menu-item[role="menuitem"]',
                        )
                        .forEach(function (Be) {
                          if (Be instanceof HTMLElement) {
                            var Oe = Be.parentElement;
                            (Oe === be ||
                              window.getComputedStyle(Oe).display !== "none") &&
                              ve.push(Be);
                          }
                        }),
                      ve
                    );
                  })(ge);
                  te.current = ne;
                }
              }, []),
              h(function () {
                return (
                  document.addEventListener("keydown", ce),
                  function () {
                    document.removeEventListener("keydown", ce);
                  }
                );
              }, []),
              i.createElement(
                "div",
                {
                  ref: J,
                  "aria-orientation": "vertical",
                  className: _({
                    "rpv-core__menu": !0,
                    "rpv-core__menu--rtl": oe,
                  }),
                  role: "menu",
                  tabIndex: 0,
                },
                O,
              )
            );
          }),
          (t.MenuDivider = function () {
            return i.createElement("div", {
              "aria-orientation": "horizontal",
              className: "rpv-core__menu-divider",
              role: "separator",
            });
          }),
          (t.MenuItem = function (E) {
            var O = E.checked,
              J = O !== void 0 && O,
              te = E.children,
              oe = E.icon,
              ce = oe === void 0 ? null : oe,
              _e = E.isDisabled,
              ge = _e !== void 0 && _e,
              ne = E.testId,
              be = E.onClick,
              ve = i.useContext(P).direction === t.TextDirection.RightToLeft,
              Be = ne ? { "data-testid": ne } : {};
            return i.createElement(
              "button",
              k(
                {
                  className: _({
                    "rpv-core__menu-item": !0,
                    "rpv-core__menu-item--disabled": ge,
                    "rpv-core__menu-item--ltr": !ve,
                    "rpv-core__menu-item--rtl": ve,
                  }),
                  role: "menuitem",
                  tabIndex: -1,
                  type: "button",
                  onClick: be,
                },
                Be,
              ),
              i.createElement(
                "div",
                {
                  className: _({
                    "rpv-core__menu-item-icon": !0,
                    "rpv-core__menu-item-icon--ltr": !ve,
                    "rpv-core__menu-item-icon--rtl": ve,
                  }),
                },
                ce,
              ),
              i.createElement(
                "div",
                {
                  className: _({
                    "rpv-core__menu-item-label": !0,
                    "rpv-core__menu-item-label--ltr": !ve,
                    "rpv-core__menu-item-label--rtl": ve,
                  }),
                },
                te,
              ),
              i.createElement(
                "div",
                {
                  className: _({
                    "rpv-core__menu-item-check": !0,
                    "rpv-core__menu-item-check--ltr": !ve,
                    "rpv-core__menu-item-check--rtl": ve,
                  }),
                },
                J && i.createElement(p, null),
              ),
            );
          }),
          (t.MinimalButton = function (E) {
            var O = E.ariaLabel,
              J = O === void 0 ? "" : O,
              te = E.ariaKeyShortcuts,
              oe = te === void 0 ? "" : te,
              ce = E.children,
              _e = E.isDisabled,
              ge = _e !== void 0 && _e,
              ne = E.isSelected,
              be = ne !== void 0 && ne,
              ve = E.testId,
              Be = E.onClick,
              Oe = i.useContext(P).direction === t.TextDirection.RightToLeft,
              De = ve ? { "data-testid": ve } : {};
            return i.createElement(
              "button",
              k(
                { "aria-label": J },
                oe && { "aria-keyshortcuts": oe },
                ge && { "aria-disabled": !0 },
                {
                  className: _({
                    "rpv-core__minimal-button": !0,
                    "rpv-core__minimal-button--disabled": ge,
                    "rpv-core__minimal-button--rtl": Oe,
                    "rpv-core__minimal-button--selected": be,
                  }),
                  type: "button",
                  onClick: Be,
                },
                De,
              ),
              ce,
            );
          }),
          (t.Modal = function (E) {
            var O = E.ariaControlsSuffix,
              J = E.closeOnClickOutside,
              te = E.closeOnEscape,
              oe = E.content,
              ce = E.isOpened,
              _e = ce !== void 0 && ce,
              ge = E.target,
              ne = O || "".concat(s());
            return i.createElement(fe, {
              target: ge
                ? function (be, ve) {
                    return i.createElement(
                      "div",
                      {
                        "aria-expanded": ve ? "true" : "false",
                        "aria-haspopup": "dialog",
                        "aria-controls": "rpv-core__modal-body-".concat(ne),
                      },
                      ge(be, ve),
                    );
                  }
                : null,
              content: function (be) {
                return i.createElement(
                  j,
                  null,
                  i.createElement(
                    $,
                    {
                      ariaControlsSuffix: ne,
                      closeOnClickOutside: J,
                      closeOnEscape: te,
                      onToggle: be,
                    },
                    oe(be),
                  ),
                );
              },
              isOpened: _e,
            });
          }),
          (t.Popover = function (E) {
            var O = E.ariaHasPopup,
              J = O === void 0 ? "dialog" : O,
              te = E.ariaControlsSuffix,
              oe = E.closeOnClickOutside,
              ce = E.closeOnEscape,
              _e = E.content,
              ge = E.lockScroll,
              ne = ge === void 0 || ge,
              be = E.offset,
              ve = E.position,
              Be = E.target,
              Oe = Q(!1),
              De = Oe.opened,
              $e = Oe.toggle,
              We = i.useRef(),
              Ve = i.useMemo(function () {
                return te || "".concat(s());
              }, []);
            return i.createElement(
              "div",
              {
                ref: We,
                "aria-expanded": De ? "true" : "false",
                "aria-haspopup": J,
                "aria-controls": "rpv-core__popver-body-".concat(Ve),
              },
              Be($e, De),
              De &&
                i.createElement(
                  i.Fragment,
                  null,
                  ne && i.createElement(he, { closeOnEscape: ce, onClose: $e }),
                  i.createElement(
                    re,
                    {
                      ariaControlsSuffix: Ve,
                      closeOnClickOutside: oe,
                      offset: be,
                      position: ve,
                      targetRef: We,
                      onClose: $e,
                    },
                    _e($e),
                  ),
                ),
            );
          }),
          (t.PrimaryButton = u),
          (t.ProgressBar = function (E) {
            var O = E.progress,
              J = i.useContext(P).direction === t.TextDirection.RightToLeft;
            return i.createElement(
              "div",
              {
                className: _({
                  "rpv-core__progress-bar": !0,
                  "rpv-core__progress-bar--rtl": J,
                }),
              },
              i.createElement(
                "div",
                {
                  className: "rpv-core__progress-bar-progress",
                  style: { width: "".concat(O, "%") },
                },
                O,
                "%",
              ),
            );
          }),
          (t.Separator = function () {
            return i.createElement("div", { className: "rpv-core__separator" });
          }),
          (t.Spinner = F),
          (t.Splitter = function (E) {
            var O = E.constrain,
              J = i.useContext(P).direction === t.TextDirection.RightToLeft,
              te = i.useRef(),
              oe = i.useRef(),
              ce = i.useRef(),
              _e = i.useRef(0),
              ge = i.useRef(0),
              ne = i.useRef(0),
              be = i.useRef(0),
              ve = { capture: !0 },
              Be = function (De) {
                var $e = te.current,
                  We = oe.current,
                  Ve = ce.current;
                if ($e && We && Ve) {
                  var xt = be.current,
                    pt = De.clientX - _e.current,
                    gt = ne.current + (J ? -pt : pt),
                    yt = $e.parentElement.getBoundingClientRect().width,
                    ct = (100 * gt) / yt;
                  if (($e.classList.add("rpv-core__splitter--resizing"), O)) {
                    var St = yt - gt - xt;
                    if (
                      !O({
                        firstHalfPercentage: ct,
                        firstHalfSize: gt,
                        secondHalfPercentage: (100 * St) / yt,
                        secondHalfSize: St,
                      })
                    )
                      return;
                  }
                  ((We.style.width = "".concat(ct, "%")),
                    document.body.classList.add(
                      "rpv-core__splitter-body--resizing",
                    ),
                    We.classList.add("rpv-core__splitter-sibling--resizing"),
                    Ve.classList.add("rpv-core__splitter-sibling--resizing"));
                }
              },
              Oe = function (De) {
                var $e = te.current,
                  We = oe.current,
                  Ve = ce.current;
                $e &&
                  We &&
                  Ve &&
                  (document.body.classList.remove(
                    "rpv-core__splitter-body--resizing",
                  ),
                  $e.classList.remove("rpv-core__splitter--resizing"),
                  We.classList.remove("rpv-core__splitter-sibling--resizing"),
                  Ve.classList.remove("rpv-core__splitter-sibling--resizing"),
                  document.removeEventListener("mousemove", Be, ve),
                  document.removeEventListener("mouseup", Oe, ve));
              };
            return (
              i.useEffect(function () {
                var De = te.current;
                De &&
                  ((be.current = De.getBoundingClientRect().width),
                  (oe.current = De.previousElementSibling),
                  (ce.current = De.nextElementSibling));
              }, []),
              i.createElement("div", {
                ref: te,
                className: "rpv-core__splitter",
                onMouseDown: function (De) {
                  var $e = oe.current;
                  $e &&
                    ((_e.current = De.clientX),
                    (ge.current = De.clientY),
                    (ne.current = $e.getBoundingClientRect().width),
                    document.addEventListener("mousemove", Be, ve),
                    document.addEventListener("mouseup", Oe, ve));
                },
              })
            );
          }),
          (t.TextBox = v),
          (t.ThemeContext = P),
          (t.Tooltip = function (E) {
            var O = E.ariaControlsSuffix,
              J = E.content,
              te = E.offset,
              oe = E.position,
              ce = E.target,
              _e = Q(!1),
              ge = _e.opened,
              ne = _e.toggle,
              be = i.useRef(),
              ve = i.useRef(),
              Be = i.useMemo(function () {
                return O || "".concat(s());
              }, []);
            R(function () {
              be.current &&
                document.activeElement &&
                be.current.contains(document.activeElement) &&
                De();
            });
            var Oe = function () {
                ne(t.ToggleStatus.Open);
              },
              De = function () {
                ne(t.ToggleStatus.Close);
              };
            return i.createElement(
              i.Fragment,
              null,
              i.createElement(
                "div",
                {
                  ref: be,
                  "aria-describedby": "rpv-core__tooltip-body-".concat(Be),
                  onBlur: function ($e) {
                    $e.relatedTarget instanceof HTMLElement &&
                    $e.currentTarget.parentElement &&
                    $e.currentTarget.parentElement.contains($e.relatedTarget)
                      ? ve.current && (ve.current.style.display = "none")
                      : De();
                  },
                  onFocus: Oe,
                  onMouseEnter: Oe,
                  onMouseLeave: De,
                },
                ce,
              ),
              ge &&
                i.createElement(
                  Pe,
                  {
                    ariaControlsSuffix: Be,
                    contentRef: ve,
                    offset: te,
                    position: oe,
                    targetRef: be,
                  },
                  J(),
                ),
            );
          }),
          (t.Viewer = function (E) {
            var O = E.characterMap,
              J = E.defaultScale,
              te = E.enableSmoothScroll,
              oe = te === void 0 || te,
              ce = E.fileUrl,
              _e = E.httpHeaders,
              ge = _e === void 0 ? {} : _e,
              ne = E.initialPage,
              be = ne === void 0 ? 0 : ne,
              ve = E.pageLayout,
              Be = E.initialRotation,
              Oe = Be === void 0 ? 0 : Be,
              De = E.localization,
              $e = E.plugins,
              We = $e === void 0 ? [] : $e,
              Ve = E.renderError,
              xt = E.renderLoader,
              pt = E.renderPage,
              gt = E.renderProtectedView,
              yt = E.scrollMode,
              ct = yt === void 0 ? t.ScrollMode.Vertical : yt,
              St = E.setRenderRange,
              bt = St === void 0 ? Ia : St,
              Ot = E.transformGetDocumentParams,
              Dt = E.theme,
              Nt =
                Dt === void 0
                  ? { direction: t.TextDirection.LeftToRight, theme: "light" }
                  : Dt,
              Bt = E.viewMode,
              Ht = Bt === void 0 ? t.ViewMode.SinglePage : Bt,
              nn = E.withCredentials,
              Kt = nn !== void 0 && nn,
              rn = E.onDocumentAskPassword,
              Jt = E.onDocumentLoad,
              en = Jt === void 0 ? function () {} : Jt,
              tn = E.onPageChange,
              Qt = tn === void 0 ? function () {} : tn,
              dn = E.onRotate,
              En = dn === void 0 ? function () {} : dn,
              vn = E.onRotatePage,
              cn = vn === void 0 ? function () {} : vn,
              hn = E.onSwitchTheme,
              yn = hn === void 0 ? function () {} : hn,
              _t = E.onZoom,
              vt = _t === void 0 ? function () {} : _t,
              lt = i.useState({
                data: ce,
                name: typeof ce == "string" ? ce : "",
                shouldLoad: !1,
              }),
              ht = lt[0],
              ut = lt[1],
              wt = function (Xt, Yt) {
                ut({ data: Yt, name: Xt, shouldLoad: !0 });
              },
              Ct = i.useState(!1),
              ft = Ct[0],
              rt = Ct[1],
              Mt = D(ht);
            i.useEffect(
              function () {
                var Xt, Yt, on, Vt;
                ((Xt = Mt.data),
                  (Vt = typeof (Yt = ce)),
                  ((on = typeof Xt) == "string" &&
                    Vt === "string" &&
                    Xt === Yt) ||
                    (on === "object" &&
                      Vt === "object" &&
                      Xt.length === Yt.length &&
                      Xt.every(function (wn, Ln) {
                        return wn === Yt[Ln];
                      })) ||
                    ut({
                      data: ce,
                      name: typeof ce == "string" ? ce : "",
                      shouldLoad: ft,
                    }));
              },
              [ce, ft],
            );
            var Rt = r({
                onVisibilityChanged: function (Xt) {
                  (rt(Xt.isVisible),
                    Xt.isVisible &&
                      ut(function (Yt) {
                        return Object.assign({}, Yt, { shouldLoad: !0 });
                      }));
                },
              }),
              Gt =
                typeof Nt == "string"
                  ? { direction: t.TextDirection.LeftToRight, theme: Nt }
                  : Nt,
              Wt = i.useState(De || V),
              ln = Wt[0],
              fn = Wt[1],
              Tt = { l10n: ln, setL10n: fn },
              un = Object.assign(
                {},
                { direction: Gt.direction },
                Fa(Gt.theme || "light", yn),
              );
            return (
              i.useEffect(
                function () {
                  De && fn(De);
                },
                [De],
              ),
              i.createElement(
                Y.Provider,
                { value: Tt },
                i.createElement(
                  P.Provider,
                  { value: un },
                  i.createElement(
                    "div",
                    {
                      ref: Rt,
                      className: "rpv-core__viewer rpv-core__viewer--".concat(
                        un.currentTheme,
                      ),
                      "data-testid": "core__viewer",
                      style: { height: "100%", width: "100%" },
                    },
                    ht.shouldLoad &&
                      i.createElement(La, {
                        characterMap: O,
                        file: ht.data,
                        httpHeaders: ge,
                        render: function (Xt) {
                          return i.createElement(xa, {
                            defaultScale: J,
                            doc: Xt,
                            render: function (Yt, on) {
                              return i.createElement(Ta, {
                                currentFile: { data: ht.data, name: ht.name },
                                defaultScale: J,
                                doc: Xt,
                                enableSmoothScroll: oe,
                                initialPage: be,
                                initialRotation: Oe,
                                initialScale: on,
                                pageLayout: ve,
                                pageSizes: Yt,
                                plugins: We,
                                renderPage: pt,
                                scrollMode: ct,
                                setRenderRange: bt,
                                viewMode: Ht,
                                viewerState: {
                                  file: ht,
                                  fullScreenMode: t.FullScreenMode.Normal,
                                  pageIndex: -1,
                                  pageHeight: Yt[0].pageHeight,
                                  pageWidth: Yt[0].pageWidth,
                                  pagesRotation: new Map(),
                                  rotation: Oe,
                                  scale: on,
                                  scrollMode: ct,
                                  viewMode: Ht,
                                },
                                onDocumentLoad: en,
                                onOpenFile: wt,
                                onPageChange: Qt,
                                onRotate: En,
                                onRotatePage: cn,
                                onZoom: vt,
                              });
                            },
                            scrollMode: ct,
                            viewMode: Ht,
                          });
                        },
                        renderError: Ve,
                        renderLoader: xt,
                        renderProtectedView: gt,
                        transformGetDocumentParams: Ot,
                        withCredentials: Kt,
                        onDocumentAskPassword: rn,
                      }),
                  ),
                ),
              )
            );
          }),
          (t.Worker = function (E) {
            var O = E.children,
              J = E.workerUrl;
            return (
              (H.GlobalWorkerOptions.workerSrc = J),
              i.createElement(i.Fragment, null, O)
            );
          }),
          (t.chunk = se),
          (t.classNames = _),
          (t.createStore = function (E) {
            var O = E || {},
              J = {},
              te = function (ce, _e) {
                var ge;
                ((O = k(k({}, O), (((ge = {})[ce] = _e), ge))),
                  (J[ce] || []).forEach(function (ne) {
                    return ne(O[ce]);
                  }));
              },
              oe = function (ce) {
                return O[ce];
              };
            return {
              subscribe: function (ce, _e) {
                J[ce] = (J[ce] || []).concat(_e);
              },
              unsubscribe: function (ce, _e) {
                J[ce] = (J[ce] || []).filter(function (ge) {
                  return ge !== _e;
                });
              },
              update: function (ce, _e) {
                te(ce, _e);
              },
              updateCurrentValue: function (ce, _e) {
                var ge = oe(ce);
                ge !== void 0 && te(ce, _e(ge));
              },
              get: function (ce) {
                return oe(ce);
              },
            };
          }),
          (t.getDestination = Je),
          (t.getPage = ze),
          (t.isFullScreenEnabled = e),
          (t.isMac = function () {
            return (
              typeof window < "u" &&
              /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)
            );
          }),
          (t.useDebounceCallback = B),
          (t.useIntersectionObserver = r),
          (t.useIsMounted = M),
          (t.useIsomorphicLayoutEffect = h),
          (t.usePrevious = D),
          (t.useRenderQueue = L));
      })(core_min)),
    core_min
  );
}
var hasRequiredLib$h;
function requireLib$h() {
  if (hasRequiredLib$h) return lib$h.exports;
  hasRequiredLib$h = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$h.exports = requireCore_min()), lib$h.exports);
}
var libExports$1 = requireLib$h(),
  lib$g = { exports: {} },
  defaultLayout_min = {},
  lib$f = { exports: {} },
  attachment_min = {},
  hasRequiredAttachment_min;
function requireAttachment_min() {
  if (hasRequiredAttachment_min) return attachment_min;
  hasRequiredAttachment_min = 1;
  var t = requireLib$h();
  function A(H) {
    var ee = Object.create(null);
    return (
      H &&
        Object.keys(H).forEach(function (X) {
          if (X !== "default") {
            var W = Object.getOwnPropertyDescriptor(H, X);
            Object.defineProperty(
              ee,
              X,
              W.get
                ? W
                : {
                    enumerable: !0,
                    get: function () {
                      return H[X];
                    },
                  },
            );
          }
        }),
      (ee.default = H),
      Object.freeze(ee)
    );
  }
  var n = A(requireReact()),
    w = function (H) {
      var ee = H.files,
        X = n.useRef(),
        W = n.useContext(t.LocalizationContext).l10n,
        k =
          n.useContext(t.ThemeContext).direction ===
          t.TextDirection.RightToLeft,
        N = n.useRef([]),
        P =
          W && W.attachment
            ? W.attachment.clickToDownload
            : "Click to download",
        _ = function (h) {
          var r = X.current,
            d = [].slice.call(r.getElementsByClassName("rpv-attachment__item"));
          if (d.length !== 0) {
            d.forEach(function (F) {
              return F.setAttribute("tabindex", "-1");
            });
            var p = document.activeElement,
              u = d[Math.min(d.length - 1, Math.max(0, h(d, p)))];
            (u.setAttribute("tabindex", "0"), u.focus());
          }
        };
      return (
        t.useIsomorphicLayoutEffect(function () {
          var h = X.current;
          if (h) {
            var r = [].slice.call(
              h.getElementsByClassName("rpv-attachment__item"),
            );
            if (((N.current = r), r.length > 0)) {
              var d = r[0];
              (d.focus(), d.setAttribute("tabindex", "0"));
            }
          }
        }, []),
        n.createElement(
          "div",
          {
            "data-testid": "attachment__list",
            className: t.classNames({
              "rpv-attachment__list": !0,
              "rpv-attachment__list--rtl": k,
            }),
            ref: X,
            tabIndex: -1,
            onKeyDown: function (h) {
              switch (h.key) {
                case "ArrowDown":
                  (h.preventDefault(),
                    _(function (r, d) {
                      return r.indexOf(d) + 1;
                    }));
                  break;
                case "ArrowUp":
                  (h.preventDefault(),
                    _(function (r, d) {
                      return r.indexOf(d) - 1;
                    }));
                  break;
                case "End":
                  (h.preventDefault(),
                    _(function (r, d) {
                      return r.length - 1;
                    }));
                  break;
                case "Home":
                  (h.preventDefault(),
                    _(function (r, d) {
                      return 0;
                    }));
              }
            },
          },
          ee.map(function (h) {
            return n.createElement(
              "button",
              {
                className: "rpv-attachment__item",
                key: h.fileName,
                tabIndex: -1,
                title: P,
                type: "button",
                onClick: function () {
                  return (
                    (r = h.fileName),
                    (d = h.data),
                    (p =
                      typeof d == "string"
                        ? ""
                        : URL.createObjectURL(new Blob([d], { type: "" }))),
                    ((u = document.createElement("a")).style.display = "none"),
                    (u.href = p || r),
                    u.setAttribute(
                      "download",
                      (function (F) {
                        var v = F.split("/").pop();
                        return v ? v.split("#")[0].split("?")[0] : F;
                      })(r),
                    ),
                    document.body.appendChild(u),
                    u.click(),
                    document.body.removeChild(u),
                    void (p && URL.revokeObjectURL(p))
                  );
                  var r, d, p, u;
                },
              },
              h.fileName,
            );
          }),
        )
      );
    },
    S = function (H) {
      var ee = H.doc,
        X = n.useContext(t.LocalizationContext).l10n,
        W =
          n.useContext(t.ThemeContext).direction ===
          t.TextDirection.RightToLeft,
        k =
          X && X.attachment
            ? X.attachment.noAttachment
            : "There is no attachment",
        N = n.useState({ files: [], isLoaded: !1 }),
        P = N[0],
        _ = N[1];
      return (
        n.useEffect(
          function () {
            ee.getAttachments().then(function (h) {
              var r = h
                ? Object.keys(h).map(function (d) {
                    return { data: h[d].content, fileName: h[d].filename };
                  })
                : [];
              _({ files: r, isLoaded: !0 });
            });
          },
          [ee],
        ),
        P.isLoaded
          ? P.files.length === 0
            ? n.createElement(
                "div",
                {
                  "data-testid": "attachment__empty",
                  className: t.classNames({
                    "rpv-attachment__empty": !0,
                    "rpv-attachment__empty--rtl": W,
                  }),
                },
                k,
              )
            : n.createElement(w, { files: P.files })
          : n.createElement(t.Spinner, null)
      );
    },
    i = function (H) {
      var ee = H.store,
        X = n.useState(ee.get("doc")),
        W = X[0],
        k = X[1],
        N = function (P) {
          k(P);
        };
      return (
        n.useEffect(function () {
          return (
            ee.subscribe("doc", N),
            function () {
              ee.unsubscribe("doc", N);
            }
          );
        }, []),
        W
          ? n.createElement(S, { doc: W })
          : n.createElement(
              "div",
              { className: "rpv-attachment__loader" },
              n.createElement(t.Spinner, null),
            )
      );
    };
  return (
    (attachment_min.attachmentPlugin = function () {
      var H = n.useMemo(function () {
        return t.createStore({});
      }, []);
      return {
        onDocumentLoad: function (ee) {
          H.update("doc", ee.doc);
        },
        Attachments: function () {
          return n.createElement(i, { store: H });
        },
      };
    }),
    attachment_min
  );
}
var hasRequiredLib$g;
function requireLib$g() {
  if (hasRequiredLib$g) return lib$f.exports;
  hasRequiredLib$g = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$f.exports = requireAttachment_min()), lib$f.exports);
}
var lib$e = { exports: {} },
  bookmark_min = {},
  hasRequiredBookmark_min;
function requireBookmark_min() {
  if (hasRequiredBookmark_min) return bookmark_min;
  hasRequiredBookmark_min = 1;
  var t = requireLib$h();
  function A(P) {
    var _ = Object.create(null);
    return (
      P &&
        Object.keys(P).forEach(function (h) {
          if (h !== "default") {
            var r = Object.getOwnPropertyDescriptor(P, h);
            Object.defineProperty(
              _,
              h,
              r.get
                ? r
                : {
                    enumerable: !0,
                    get: function () {
                      return P[h];
                    },
                  },
            );
          }
        }),
      (_.default = P),
      Object.freeze(_)
    );
  }
  var n,
    w = A(requireReact()),
    S = function () {
      return (
        (S =
          Object.assign ||
          function (P) {
            for (var _, h = 1, r = arguments.length; h < r; h++)
              for (var d in (_ = arguments[h]))
                Object.prototype.hasOwnProperty.call(_, d) && (P[d] = _[d]);
            return P;
          }),
        S.apply(this, arguments)
      );
    },
    i = function () {
      return w.createElement(
        t.Icon,
        { size: 16 },
        w.createElement("path", {
          d: "M6.427,8.245A.5.5,0,0,1,6.862,7.5H17.138a.5.5,0,0,1,.435.749l-5.139,9a.5.5,0,0,1-.868,0Z",
        }),
      );
    },
    H = function () {
      return w.createElement(
        t.Icon,
        { size: 16 },
        w.createElement("path", {
          d: "M9.248,17.572a.5.5,0,0,1-.748-.434V6.862a.5.5,0,0,1,.748-.434l8.992,5.138a.5.5,0,0,1,0,.868Z",
        }),
      );
    },
    ee = function (P) {
      var _ = P.bookmark,
        h = P.depth,
        r = P.doc,
        d = P.index,
        p = P.isBookmarkExpanded,
        u = P.numberOfSiblings,
        F = P.pathFromRoot,
        v = P.renderBookmarkItem,
        f = P.store,
        b = F ? "".concat(F, ".").concat(d) : "".concat(d),
        c = w.useMemo(
          function () {
            return (function (Y) {
              var T = Y.count,
                s = Y.items;
              if (T >= 0) return !1;
              var g = s.length;
              if (g === 0) return !1;
              for (var R = s.concat([]); R.length > 0; ) {
                var $ = R.shift(),
                  j = $.items;
                $.count &&
                  j &&
                  $.count > 0 &&
                  j.length > 0 &&
                  ((g += j.length), (R = R.concat(j)));
              }
              return Math.abs(T) === g;
            })(_);
          },
          [_],
        ),
        a = f.get("bookmarkExpandedMap"),
        m = p
          ? p({ bookmark: _, doc: r, depth: h, index: d })
          : a.has(b)
            ? a.get(b)
            : !c,
        C = w.useState(m),
        e = C[0],
        o = C[1],
        y = _.items && _.items.length > 0,
        B = function () {
          var Y = !e;
          (f.updateCurrentValue("bookmarkExpandedMap", function (T) {
            return T.set(b, Y);
          }),
            o(Y));
        },
        M = function () {
          var Y = _.dest,
            T = f.get("jumpToDestination");
          t.getDestination(r, Y).then(function (s) {
            T && T(S({ label: _.title }, s));
          });
        },
        D = function () {
          y && _.dest && M();
        },
        x = function () {
          !y && _.dest && M();
        },
        z = function (Y, T) {
          return w.createElement(
            "div",
            {
              className: "rpv-bookmark__item",
              style: { paddingLeft: "".concat(1.25 * h, "rem") },
              onClick: Y,
            },
            T,
          );
        },
        L = function (Y, T) {
          return y
            ? w.createElement(
                "span",
                {
                  className: "rpv-bookmark__toggle",
                  "data-testid": "bookmark__toggle-".concat(h, "-").concat(d),
                  onClick: B,
                },
                e ? Y : T,
              )
            : w.createElement("span", { className: "rpv-bookmark__toggle" });
        },
        V = function (Y) {
          return _.url
            ? w.createElement(
                "a",
                {
                  className: "rpv-bookmark__title",
                  href: _.url,
                  rel: "noopener noreferrer nofollow",
                  target: _.newWindow ? "_blank" : "",
                },
                _.title,
              )
            : w.createElement(
                "div",
                {
                  className: "rpv-bookmark__title",
                  "aria-label": _.title,
                  onClick: Y,
                },
                _.title,
              );
        };
      return w.createElement(
        "li",
        {
          "aria-expanded": e ? "true" : "false",
          "aria-label": _.title,
          "aria-level": h + 1,
          "aria-posinset": d + 1,
          "aria-setsize": u,
          role: "treeitem",
          tabIndex: -1,
        },
        v
          ? v({
              bookmark: _,
              depth: h,
              hasSubItems: y,
              index: d,
              isExpanded: e,
              path: b,
              defaultRenderItem: z,
              defaultRenderTitle: V,
              defaultRenderToggle: L,
              onClickItem: x,
              onClickTitle: D,
              onToggleSubItems: B,
            })
          : z(
              x,
              w.createElement(
                w.Fragment,
                null,
                L(w.createElement(i, null), w.createElement(H, null)),
                V(D),
              ),
            ),
        y &&
          e &&
          w.createElement(X, {
            bookmarks: _.items,
            depth: h + 1,
            doc: r,
            isBookmarkExpanded: p,
            isRoot: !1,
            pathFromRoot: b,
            renderBookmarkItem: v,
            store: f,
          }),
      );
    },
    X = function (P) {
      var _ = P.bookmarks,
        h = P.depth,
        r = h === void 0 ? 0 : h,
        d = P.doc,
        p = P.isBookmarkExpanded,
        u = P.isRoot,
        F = P.pathFromRoot,
        v = P.renderBookmarkItem,
        f = P.store;
      return w.createElement(
        "ul",
        {
          className: "rpv-bookmark__list",
          role: u ? "tree" : "group",
          tabIndex: -1,
        },
        _.map(function (b, c) {
          return w.createElement(ee, {
            bookmark: b,
            depth: r,
            doc: d,
            index: c,
            isBookmarkExpanded: p,
            key: c,
            numberOfSiblings: _.length,
            pathFromRoot: F,
            renderBookmarkItem: v,
            store: f,
          });
        }),
      );
    };
  (function (P) {
    ((P[(P.Collapse = 0)] = "Collapse"), (P[(P.Expand = 1)] = "Expand"));
  })(n || (n = {}));
  var W = function (P) {
      var _ = P.bookmarks,
        h = P.doc,
        r = P.isBookmarkExpanded,
        d = P.renderBookmarkItem,
        p = P.store,
        u = w.useRef(),
        F = function (c) {
          var a = u.current;
          if (a && c.target instanceof HTMLElement && a.contains(c.target))
            switch (c.key) {
              case "ArrowDown":
                (c.preventDefault(),
                  f(function (m, C) {
                    return m.indexOf(C) + 1;
                  }));
                break;
              case "ArrowLeft":
                (c.preventDefault(), b(n.Collapse));
                break;
              case "ArrowRight":
                (c.preventDefault(), b(n.Expand));
                break;
              case "ArrowUp":
                (c.preventDefault,
                  f(function (m, C) {
                    return m.indexOf(C) - 1;
                  }));
                break;
              case "End":
                (c.preventDefault(),
                  f(function (m, C) {
                    return m.length - 1;
                  }));
                break;
              case " ":
              case "Enter":
              case "Space":
                (c.preventDefault(), v());
                break;
              case "Home":
                (c.preventDefault(),
                  f(function (m, C) {
                    return 0;
                  }));
            }
        },
        v = function () {
          var c = document.activeElement
            .closest(".rpv-bookmark__item")
            .querySelector(".rpv-bookmark__title");
          c && c.click();
        },
        f = function (c) {
          var a = u.current,
            m = [].slice.call(a.getElementsByClassName("rpv-bookmark__item"));
          if (m.length !== 0) {
            var C = document.activeElement,
              e = m[Math.min(m.length - 1, Math.max(0, c(m, C)))];
            (C.setAttribute("tabindex", "-1"),
              e.setAttribute("tabindex", "0"),
              e.focus());
          }
        },
        b = function (c) {
          var a = u.current;
          if (
            [].slice.call(a.getElementsByClassName("rpv-bookmark__item"))
              .length !== 0
          ) {
            var m = document.activeElement.closest(".rpv-bookmark__item"),
              C = c === n.Collapse ? "true" : "false";
            if (m && m.parentElement.getAttribute("aria-expanded") === C) {
              var e = m.querySelector(".rpv-bookmark__toggle");
              e && e.click();
            }
          }
        };
      return (
        w.useEffect(function () {
          return (
            document.addEventListener("keydown", F),
            function () {
              document.removeEventListener("keydown", F);
            }
          );
        }, []),
        w.useEffect(function () {
          var c = u.current;
          if (c) {
            var a = [].slice.call(
              c.getElementsByClassName("rpv-bookmark__item"),
            );
            a.length > 0 && (a[0].focus(), a[0].setAttribute("tabindex", "0"));
          }
        }, []),
        w.createElement(
          "div",
          { ref: u },
          w.createElement(X, {
            bookmarks: _,
            depth: 0,
            doc: h,
            isBookmarkExpanded: r,
            isRoot: !0,
            pathFromRoot: "",
            renderBookmarkItem: d,
            store: p,
          }),
        )
      );
    },
    k = function (P) {
      var _ = P.doc,
        h = P.isBookmarkExpanded,
        r = P.renderBookmarkItem,
        d = P.store,
        p = w.useContext(t.LocalizationContext).l10n,
        u =
          w.useContext(t.ThemeContext).direction ===
          t.TextDirection.RightToLeft,
        F = w.useState({ isLoaded: !1, items: [] }),
        v = F[0],
        f = F[1];
      return (
        w.useEffect(
          function () {
            (f({ isLoaded: !1, items: [] }),
              _.getOutline().then(function (b) {
                f({ isLoaded: !0, items: b || [] });
              }));
          },
          [_],
        ),
        v.isLoaded
          ? v.items.length === 0
            ? w.createElement(
                "div",
                {
                  "data-testid": "bookmark__empty",
                  className: t.classNames({
                    "rpv-bookmark__empty": !0,
                    "rpv-bookmark__empty--rtl": u,
                  }),
                },
                p && p.bookmark
                  ? p.bookmark.noBookmark
                  : "There is no bookmark",
              )
            : w.createElement(
                "div",
                {
                  "data-testid": "bookmark__container",
                  className: t.classNames({
                    "rpv-bookmark__container": !0,
                    "rpv-bookmark__container--rtl": u,
                  }),
                },
                w.createElement(W, {
                  bookmarks: v.items,
                  doc: _,
                  isBookmarkExpanded: h,
                  renderBookmarkItem: r,
                  store: d,
                }),
              )
          : w.createElement(
              "div",
              { className: "rpv-bookmark__loader" },
              w.createElement(t.Spinner, null),
            )
      );
    },
    N = function (P) {
      var _ = P.isBookmarkExpanded,
        h = P.renderBookmarkItem,
        r = P.store,
        d = w.useState(r.get("doc")),
        p = d[0],
        u = d[1],
        F = function (v) {
          u(v);
        };
      return (
        w.useEffect(function () {
          return (
            r.subscribe("doc", F),
            function () {
              r.unsubscribe("doc", F);
            }
          );
        }, []),
        p
          ? w.createElement(k, {
              doc: p,
              isBookmarkExpanded: _,
              renderBookmarkItem: h,
              store: r,
            })
          : w.createElement(
              "div",
              { className: "rpv-bookmark__loader" },
              w.createElement(t.Spinner, null),
            )
      );
    };
  return (
    (bookmark_min.DownArrowIcon = i),
    (bookmark_min.RightArrowIcon = H),
    (bookmark_min.bookmarkPlugin = function () {
      var P = w.useMemo(function () {
        return t.createStore({ bookmarkExpandedMap: new Map() });
      }, []);
      return {
        install: function (_) {
          P.update("jumpToDestination", _.jumpToDestination);
        },
        onDocumentLoad: function (_) {
          P.update("doc", _.doc);
        },
        Bookmarks: function (_) {
          return w.createElement(N, {
            isBookmarkExpanded: _ == null ? void 0 : _.isBookmarkExpanded,
            renderBookmarkItem: _ == null ? void 0 : _.renderBookmarkItem,
            store: P,
          });
        },
      };
    }),
    bookmark_min
  );
}
var hasRequiredLib$f;
function requireLib$f() {
  if (hasRequiredLib$f) return lib$e.exports;
  hasRequiredLib$f = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$e.exports = requireBookmark_min()), lib$e.exports);
}
var lib$d = { exports: {} },
  thumbnail_min = {},
  hasRequiredThumbnail_min;
function requireThumbnail_min() {
  return (
    hasRequiredThumbnail_min ||
      ((hasRequiredThumbnail_min = 1),
      (function (t) {
        var A = requireLib$h();
        function n(r) {
          var d = Object.create(null);
          return (
            r &&
              Object.keys(r).forEach(function (p) {
                if (p !== "default") {
                  var u = Object.getOwnPropertyDescriptor(r, p);
                  Object.defineProperty(
                    d,
                    p,
                    u.get
                      ? u
                      : {
                          enumerable: !0,
                          get: function () {
                            return r[p];
                          },
                        },
                  );
                }
              }),
            (d.default = r),
            Object.freeze(d)
          );
        }
        var w,
          S = n(requireReact());
        ((t.ThumbnailDirection = void 0),
          ((w =
            t.ThumbnailDirection || (t.ThumbnailDirection = {})).Horizontal =
            "Horizontal"),
          (w.Vertical = "Vertical"));
        var i = function () {
            return (
              (i =
                Object.assign ||
                function (r) {
                  for (var d, p = 1, u = arguments.length; p < u; p++)
                    for (var F in (d = arguments[p]))
                      Object.prototype.hasOwnProperty.call(d, F) &&
                        (r[F] = d[F]);
                  return r;
                }),
              i.apply(this, arguments)
            );
          },
          H = function (r) {
            var d = r.doc,
              p = r.getPageIndex,
              u = r.renderSpinner,
              F = r.store,
              v = r.width,
              f = d.numPages,
              b = p ? p({ numPages: f }) : 0,
              c = Math.max(0, Math.min(b, f - 1)),
              a = F.get("pagesRotation") || new Map(),
              m = a.has(c) ? a.get(c) : 0,
              C = S.useState(""),
              e = C[0],
              o = C[1],
              y = A.useIsMounted(),
              B = S.useRef(),
              M = S.useState(F.get("rotation") || 0),
              D = M[0],
              x = M[1],
              z = S.useState(m),
              L = z[0],
              V = z[1],
              Y = S.useState(!1),
              T = Y[0],
              s = Y[1],
              g = function (j) {
                var U = j.has(c) ? j.get(c) : 0;
                V(U);
              },
              R = function (j) {
                x(j);
              },
              $ = A.useIntersectionObserver({
                onVisibilityChanged: function (j) {
                  s(j.isVisible);
                },
              });
            return (
              S.useEffect(
                function () {
                  if (T) {
                    var j = $.current;
                    j &&
                      (o(""),
                      A.getPage(d, c).then(function (U) {
                        var Q = U.getViewport({ scale: 1 }),
                          fe = (Q.rotation + D + L) % 360,
                          we = Math.abs(D + L) % 180 == 0,
                          Ee = we ? Q.width : Q.height,
                          Ce = we ? Q.height : Q.width,
                          xe = document.createElement("canvas"),
                          Re = xe.getContext("2d", { alpha: !1 }),
                          ue = j.clientWidth,
                          de = j.clientHeight,
                          I = v ? v / Ee : Math.min(ue / Ee, de / Ce),
                          q = I * Ee,
                          ie = I * Ce;
                        ((xe.height = ie),
                          (xe.width = q),
                          (xe.style.opacity = "0"));
                        var re = U.getViewport({ rotation: fe, scale: I });
                        ((B.current = U.render({
                          canvasContext: Re,
                          viewport: re,
                        })),
                          B.current.promise.then(
                            function () {
                              (y.current && o(xe.toDataURL()),
                                (xe.width = 0),
                                (xe.height = 0));
                            },
                            function () {},
                          ));
                      }));
                  }
                },
                [L, T],
              ),
              S.useEffect(function () {
                return (
                  F.subscribe("pagesRotation", g),
                  F.subscribe("rotation", R),
                  function () {
                    (F.unsubscribe("pagesRotation", g),
                      F.unsubscribe("rotation", R));
                  }
                );
              }, []),
              S.useEffect(function () {
                return function () {
                  var j;
                  (j = B.current) === null || j === void 0 || j.cancel();
                };
              }, []),
              S.createElement(
                "div",
                {
                  ref: $,
                  className: "rpv-thumbnail__cover-inner",
                  "data-testid": "thumbnail__cover-inner",
                },
                e
                  ? S.createElement("img", {
                      className: "rpv-thumbnail__cover-image",
                      "data-testid": "thumbnail__cover-image",
                      src: e,
                    })
                  : S.createElement(
                      "div",
                      {
                        className: "rpv-thumbnail__cover-loader",
                        "data-testid": "thumbnail__cover-loader",
                      },
                      u ? u() : S.createElement(A.Spinner, null),
                    ),
              )
            );
          },
          ee = function (r) {
            var d = r.getPageIndex,
              p = r.renderSpinner,
              u = r.store,
              F = r.width,
              v = S.useState(u.get("doc")),
              f = v[0],
              b = v[1],
              c = function (a) {
                b(a);
              };
            return (
              S.useEffect(function () {
                return (
                  u.subscribe("doc", c),
                  function () {
                    u.unsubscribe("doc", c);
                  }
                );
              }, []),
              S.createElement(
                "div",
                { className: "rpv-thumbnail__cover" },
                f
                  ? S.createElement(H, {
                      doc: f,
                      getPageIndex: d,
                      renderSpinner: p,
                      store: u,
                      width: F,
                    })
                  : S.createElement(
                      "div",
                      { className: "rpv-thumbnail__cover-loader" },
                      p ? p() : S.createElement(A.Spinner, null),
                    ),
              )
            );
          },
          X = function () {
            return S.createElement(A.Spinner, null);
          },
          W = S.createContext({ renderSpinner: X }),
          k = function (r) {
            var d = r.children,
              p = r.doc,
              u = A.useIsMounted(),
              F = S.useState({ loading: !0, labels: [] }),
              v = F[0],
              f = F[1];
            return (
              S.useEffect(
                function () {
                  p.getPageLabels().then(function (b) {
                    u.current && f({ loading: !1, labels: b || [] });
                  });
                },
                [p.loadingTask.docId],
              ),
              v.loading ? S.createElement(S.Fragment, null) : d(v.labels)
            );
          },
          N = function (r) {
            var d = r.page,
              p = r.pageHeight,
              u = r.pageIndex,
              F = r.pageWidth,
              v = r.rotation,
              f = r.thumbnailHeight,
              b = r.thumbnailWidth,
              c = r.onRenderCompleted,
              a = S.useContext(A.LocalizationContext).l10n,
              m = S.useRef(),
              C = S.useState(""),
              e = C[0],
              o = C[1],
              y =
                a && a.thumbnail
                  ? a.thumbnail.thumbnailLabel
                  : "Thumbnail of page {{pageIndex}}";
            return (
              S.useEffect(
                function () {
                  var B = m.current;
                  B && B.cancel();
                  var M = document.createElement("canvas"),
                    D = M.getContext("2d", { alpha: !1 }),
                    x = b,
                    z = x / (F / p),
                    L = x / F;
                  ((M.height = z),
                    (M.width = x),
                    (M.style.height = "".concat(z, "px")),
                    (M.style.width = "".concat(x, "px")));
                  var V = d.getViewport({ rotation: v, scale: L });
                  return (
                    (m.current = d.render({ canvasContext: D, viewport: V })),
                    m.current.promise.then(
                      function () {
                        (o(M.toDataURL()), c(u));
                      },
                      function () {
                        c(u);
                      },
                    ),
                    function () {
                      var Y;
                      (Y = m.current) === null || Y === void 0 || Y.cancel();
                    }
                  );
                },
                [v],
              ),
              e
                ? S.createElement("img", {
                    "aria-label": y.replace("{{pageIndex}}", "".concat(u + 1)),
                    src: e,
                    height: "".concat(f, "px"),
                    width: "".concat(b, "px"),
                  })
                : S.useContext(W).renderSpinner()
            );
          },
          P = function (r) {
            var d = r.doc,
              p = r.pageHeight,
              u = r.pageIndex,
              F = r.pageRotation,
              v = r.pageWidth,
              f = r.rotation,
              b = r.shouldRender,
              c = r.thumbnailWidth,
              a = r.onRenderCompleted,
              m = r.onVisibilityChanged,
              C = A.useIsMounted(),
              e = S.useState({
                height: p,
                page: null,
                viewportRotation: 0,
                width: v,
              }),
              o = e[0],
              y = e[1],
              B = o.page,
              M = o.height,
              D = o.width,
              x = D / M,
              z = Math.abs(f + F) % 180 == 0,
              L = z ? c : c / x,
              V = z ? c / x : c;
            S.useEffect(
              function () {
                b &&
                  A.getPage(d, u).then(function (s) {
                    var g = s.getViewport({ scale: 1 });
                    C.current &&
                      y({
                        height: g.height,
                        page: s,
                        viewportRotation: g.rotation,
                        width: g.width,
                      });
                  });
              },
              [b],
            );
            var Y = (o.viewportRotation + f + F) % 360,
              T = A.useIntersectionObserver({
                onVisibilityChanged: function (s) {
                  m(u, s);
                },
              });
            return S.createElement(
              "div",
              {
                className: "rpv-thumbnail__container",
                "data-testid": "thumbnail__container-".concat(u),
                ref: T,
                style: {
                  height: "".concat(V, "px"),
                  width: "".concat(L, "px"),
                },
              },
              B
                ? S.createElement(N, {
                    page: B,
                    pageHeight: z ? M : D,
                    pageIndex: u,
                    pageWidth: z ? D : M,
                    rotation: Y,
                    thumbnailHeight: V,
                    thumbnailWidth: L,
                    onRenderCompleted: a,
                  })
                : S.useContext(W).renderSpinner(),
            );
          },
          _ = function (r) {
            var d = r.currentPage,
              p = r.doc,
              u = r.labels,
              F = r.pagesRotation,
              v = r.pageHeight,
              f = r.pageWidth,
              b = r.renderCurrentPageLabel,
              c = r.renderThumbnailItem,
              a = r.rotatedPage,
              m = r.rotation,
              C = r.thumbnailDirection,
              e = r.thumbnailWidth,
              o = r.viewMode,
              y = r.onJumpToPage,
              B = r.onRotatePage,
              M = p.numPages,
              D = p.loadingTask.docId,
              x = S.useRef(null),
              z = S.useRef([]),
              L = S.useState(d),
              V = L[0],
              Y = L[1],
              T =
                S.useContext(A.ThemeContext).direction ===
                A.TextDirection.RightToLeft,
              s = S.useState(-1),
              g = s[0],
              R = s[1],
              $ = A.useIsMounted(),
              j = A.usePrevious(o),
              U = S.useRef(!1),
              Q = A.useRenderQueue({ doc: p }),
              fe = S.useMemo(
                function () {
                  return Array(M)
                    .fill(0)
                    .map(function (I, q) {
                      return q;
                    });
                },
                [D],
              ),
              we = S.useMemo(
                function () {
                  switch (o) {
                    case A.ViewMode.DualPage:
                      return A.chunk(fe, 2);
                    case A.ViewMode.DualPageWithCover:
                      return [[fe[0]]].concat(A.chunk(fe.slice(1), 2));
                    case A.ViewMode.SinglePage:
                    default:
                      return A.chunk(fe, 1);
                  }
                },
                [D, o],
              ),
              Ee = function () {
                if (x.current) {
                  var I = z.current,
                    q = V + 1;
                  q < I.length &&
                    (V >= 0 && I[V].setAttribute("tabindex", "-1"), Y(q));
                }
              },
              Ce = function () {
                if (x.current) {
                  var I = z.current,
                    q = V - 1;
                  q >= 0 &&
                    (V >= 0 && I[V].setAttribute("tabindex", "-1"), Y(q));
                }
              },
              xe = function () {
                V >= 0 && V < M && y(V);
              };
            (A.useIsomorphicLayoutEffect(
              function () {
                var I = x.current;
                I &&
                  (z.current = Array.from(
                    I.querySelectorAll(".rpv-thumbnail__item"),
                  ));
              },
              [o],
            ),
              S.useEffect(
                function () {
                  var I = z.current;
                  if (!(I.length === 0 || V < 0 || V > I.length)) {
                    var q = I[V];
                    (q.setAttribute("tabindex", "0"), q.focus());
                  }
                },
                [V],
              ),
              A.useIsomorphicLayoutEffect(
                function () {
                  var I = x.current,
                    q = z.current;
                  if (!(!I || q.length === 0 || d < 0 || d > q.length)) {
                    var ie = q[d].closest(".rpv-thumbnail__items");
                    ie &&
                      (C === t.ThumbnailDirection.Vertical
                        ? (function (re, he) {
                            var Pe =
                                re.getBoundingClientRect().top -
                                he.getBoundingClientRect().top,
                              Me = re.clientHeight,
                              se = he.clientHeight;
                            Pe < 0
                              ? (he.scrollTop += Pe)
                              : Pe + Me <= se || (he.scrollTop += Pe + Me - se);
                          })(ie, I)
                        : (function (re, he) {
                            var Pe =
                                re.getBoundingClientRect().left -
                                he.getBoundingClientRect().left,
                              Me = re.clientWidth,
                              se = he.clientWidth;
                            Pe < 0
                              ? (he.scrollLeft += Pe)
                              : Pe + Me <= se ||
                                (he.scrollLeft += Pe + Me - se);
                          })(ie, I));
                  }
                },
                [d, C],
              ));
            var Re = S.useCallback(
                function (I) {
                  $.current && (Q.markRendered(I), (U.current = !1), de());
                },
                [D],
              ),
              ue = S.useCallback(
                function (I, q) {
                  (q.isVisible
                    ? Q.setVisibility(I, q.ratio)
                    : Q.setOutOfRange(I),
                    de());
                },
                [D],
              ),
              de = S.useCallback(
                function () {
                  if (!U.current) {
                    var I = Q.getHighestPriorityPage();
                    I > -1 && (Q.markRendering(I), (U.current = !0), R(I));
                  }
                },
                [D],
              );
            return (
              S.useEffect(
                function () {
                  a >= 0 && (Q.markRendering(a), (U.current = !0), R(a));
                },
                [D, a],
              ),
              A.useIsomorphicLayoutEffect(
                function () {
                  j !== o && (Q.markNotRendered(), de());
                },
                [o],
              ),
              S.createElement(
                "div",
                {
                  ref: x,
                  "data-testid": "thumbnail__list",
                  className: A.classNames({
                    "rpv-thumbnail__list": !0,
                    "rpv-thumbnail__list--horizontal":
                      C === t.ThumbnailDirection.Horizontal,
                    "rpv-thumbnail__list--rtl": T,
                    "rpv-thumbnail__list--vertical":
                      C === t.ThumbnailDirection.Vertical,
                  }),
                  onKeyDown: function (I) {
                    switch (I.key) {
                      case "ArrowDown":
                        Ee();
                        break;
                      case "ArrowUp":
                        Ce();
                        break;
                      case "Enter":
                        xe();
                    }
                  },
                },
                we.map(function (I, q) {
                  var ie = !1;
                  switch (o) {
                    case A.ViewMode.DualPage:
                      ie = d === 2 * q || d === 2 * q + 1;
                      break;
                    case A.ViewMode.DualPageWithCover:
                      ie =
                        (d === 0 && q === 0) ||
                        (q > 0 && d === 2 * q - 1) ||
                        (q > 0 && d === 2 * q);
                      break;
                    case A.ViewMode.SinglePage:
                    default:
                      ie = d === q;
                  }
                  return S.createElement(
                    "div",
                    {
                      className: A.classNames({
                        "rpv-thumbnail__items": !0,
                        "rpv-thumbnail__items--dual": o === A.ViewMode.DualPage,
                        "rpv-thumbnail__items--dual-cover":
                          o === A.ViewMode.DualPageWithCover,
                        "rpv-thumbnail__items--single":
                          o === A.ViewMode.SinglePage,
                        "rpv-thumbnail__items--selected": ie,
                      }),
                      key: "".concat(q, "___").concat(o),
                    },
                    I.map(function (re) {
                      return (function (he) {
                        var Pe =
                            o === A.ViewMode.DualPageWithCover &&
                            (he === 0 || (M % 2 == 0 && he === M - 1)),
                          Me = "".concat(p.loadingTask.docId, "___").concat(he),
                          se = u.length === M ? u[he] : "".concat(he + 1),
                          je = b
                            ? b({
                                currentPage: d,
                                pageIndex: he,
                                numPages: M,
                                pageLabel: se,
                              })
                            : se,
                          Ie = F.has(he) ? F.get(he) : 0,
                          it = S.createElement(P, {
                            doc: p,
                            pageHeight: v,
                            pageIndex: he,
                            pageRotation: Ie,
                            pageWidth: f,
                            rotation: m,
                            shouldRender: g === he,
                            thumbnailWidth: e,
                            onRenderCompleted: Re,
                            onVisibilityChanged: ue,
                          });
                        return c
                          ? c({
                              currentPage: d,
                              key: Me,
                              numPages: M,
                              pageIndex: he,
                              renderPageLabel: S.createElement(
                                S.Fragment,
                                null,
                                je,
                              ),
                              renderPageThumbnail: it,
                              onJumpToPage: function () {
                                return y(he);
                              },
                              onRotatePage: function (Ke) {
                                return B(he, Ke);
                              },
                            })
                          : S.createElement(
                              "div",
                              { key: Me },
                              S.createElement(
                                "div",
                                {
                                  className: A.classNames({
                                    "rpv-thumbnail__item": !0,
                                    "rpv-thumbnail__item--dual-even":
                                      o === A.ViewMode.DualPage && he % 2 == 0,
                                    "rpv-thumbnail__item--dual-odd":
                                      o === A.ViewMode.DualPage && he % 2 == 1,
                                    "rpv-thumbnail__item--dual-cover": Pe,
                                    "rpv-thumbnail__item--dual-cover-even":
                                      o === A.ViewMode.DualPageWithCover &&
                                      !Pe &&
                                      he % 2 == 0,
                                    "rpv-thumbnail__item--dual-cover-odd":
                                      o === A.ViewMode.DualPageWithCover &&
                                      !Pe &&
                                      he % 2 == 1,
                                    "rpv-thumbnail__item--single":
                                      o === A.ViewMode.SinglePage,
                                    "rpv-thumbnail__item--selected": d === he,
                                  }),
                                  role: "button",
                                  tabIndex: d === he ? 0 : -1,
                                  onClick: function () {
                                    return y(he);
                                  },
                                },
                                it,
                              ),
                              S.createElement(
                                "div",
                                {
                                  "data-testid": "thumbnail__label-".concat(he),
                                  className: "rpv-thumbnail__label",
                                },
                                je,
                              ),
                            );
                      })(re);
                    }),
                  );
                }),
              )
            );
          },
          h = function (r) {
            var d = r.renderCurrentPageLabel,
              p = r.renderThumbnailItem,
              u = r.store,
              F = r.thumbnailDirection,
              v = r.thumbnailWidth,
              f = S.useState(u.get("doc")),
              b = f[0],
              c = f[1],
              a = S.useState(u.get("currentPage") || 0),
              m = a[0],
              C = a[1],
              e = S.useState(u.get("pageHeight") || 0),
              o = e[0],
              y = e[1],
              B = S.useState(u.get("pageWidth") || 0),
              M = B[0],
              D = B[1],
              x = S.useState(u.get("rotation") || 0),
              z = x[0],
              L = x[1],
              V = S.useState(u.get("pagesRotation") || new Map()),
              Y = V[0],
              T = V[1],
              s = S.useState(u.get("rotatedPage") || -1),
              g = s[0],
              R = s[1],
              $ = S.useState(u.get("viewMode")),
              j = $[0],
              U = $[1],
              Q = function (q) {
                C(q);
              },
              fe = function (q) {
                c(q);
              },
              we = function (q) {
                y(q);
              },
              Ee = function (q) {
                D(q);
              },
              Ce = function (q) {
                L(q);
              },
              xe = function (q) {
                T(q);
              },
              Re = function (q) {
                R(q);
              },
              ue = function (q) {
                U(q);
              },
              de = function (q) {
                var ie = u.get("jumpToPage");
                ie && ie(q);
              },
              I = function (q, ie) {
                u.get("rotatePage")(q, ie);
              };
            return (
              S.useEffect(function () {
                return (
                  u.subscribe("doc", fe),
                  u.subscribe("pageHeight", we),
                  u.subscribe("pageWidth", Ee),
                  u.subscribe("rotatedPage", Re),
                  u.subscribe("rotation", Ce),
                  u.subscribe("pagesRotation", xe),
                  u.subscribe("viewMode", ue),
                  function () {
                    (u.unsubscribe("doc", fe),
                      u.unsubscribe("pageHeight", we),
                      u.unsubscribe("pageWidth", Ee),
                      u.unsubscribe("rotatedPage", Re),
                      u.unsubscribe("rotation", Ce),
                      u.unsubscribe("pagesRotation", xe),
                      u.unsubscribe("viewMode", ue));
                  }
                );
              }, []),
              A.useIsomorphicLayoutEffect(function () {
                return (
                  u.subscribe("currentPage", Q),
                  function () {
                    u.unsubscribe("currentPage", Q);
                  }
                );
              }, []),
              b
                ? S.createElement(
                    A.LazyRender,
                    {
                      testId: "thumbnail__list-container",
                      attrs: { className: "rpv-thumbnail__list-container" },
                    },
                    S.createElement(k, { doc: b }, function (q) {
                      return S.createElement(_, {
                        currentPage: m,
                        doc: b,
                        labels: q,
                        pagesRotation: Y,
                        pageHeight: o,
                        pageWidth: M,
                        renderCurrentPageLabel: d,
                        renderThumbnailItem: p,
                        rotatedPage: g,
                        rotation: z,
                        thumbnailDirection: F,
                        thumbnailWidth: v,
                        viewMode: j,
                        onJumpToPage: de,
                        onRotatePage: I,
                      });
                    }),
                  )
                : S.createElement(
                    "div",
                    {
                      "data-testid": "thumbnail-list__loader",
                      className: "rpv-thumbnail__loader",
                    },
                    S.useContext(W).renderSpinner(),
                  )
            );
          };
        t.thumbnailPlugin = function (r) {
          var d = S.useMemo(function () {
              return A.createStore({
                rotatePage: function () {},
                viewMode: A.ViewMode.SinglePage,
              });
            }, []),
            p = S.useState(""),
            u = p[0],
            F = p[1];
          return {
            install: function (v) {
              (d.update("jumpToPage", v.jumpToPage),
                d.update("rotatePage", v.rotatePage));
            },
            onDocumentLoad: function (v) {
              (F(v.doc.loadingTask.docId), d.update("doc", v.doc));
            },
            onViewerStateChange: function (v) {
              return (
                d.update("currentPage", v.pageIndex),
                d.update("pagesRotation", v.pagesRotation),
                d.update("pageHeight", v.pageHeight),
                d.update("pageWidth", v.pageWidth),
                d.update("rotation", v.rotation),
                d.update("rotatedPage", v.rotatedPage),
                d.update("viewMode", v.viewMode),
                v
              );
            },
            Cover: function (v) {
              return S.createElement(
                ee,
                i({}, v, {
                  renderSpinner: r == null ? void 0 : r.renderSpinner,
                  store: d,
                }),
              );
            },
            Thumbnails: S.useCallback(
              function (v) {
                return S.createElement(
                  W.Provider,
                  {
                    value: {
                      renderSpinner:
                        (r == null ? void 0 : r.renderSpinner) || X,
                    },
                  },
                  S.createElement(h, {
                    renderCurrentPageLabel:
                      r == null ? void 0 : r.renderCurrentPageLabel,
                    renderThumbnailItem:
                      v == null ? void 0 : v.renderThumbnailItem,
                    store: d,
                    thumbnailDirection:
                      (v == null ? void 0 : v.thumbnailDirection) ||
                      t.ThumbnailDirection.Vertical,
                    thumbnailWidth:
                      (r == null ? void 0 : r.thumbnailWidth) || 100,
                  }),
                );
              },
              [u],
            ),
          };
        };
      })(thumbnail_min)),
    thumbnail_min
  );
}
var hasRequiredLib$e;
function requireLib$e() {
  if (hasRequiredLib$e) return lib$d.exports;
  hasRequiredLib$e = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$d.exports = requireThumbnail_min()), lib$d.exports);
}
var lib$c = { exports: {} },
  toolbar_min = {},
  lib$b = { exports: {} },
  selectionMode_min = {},
  hasRequiredSelectionMode_min;
function requireSelectionMode_min() {
  return (
    hasRequiredSelectionMode_min ||
      ((hasRequiredSelectionMode_min = 1),
      (function (t) {
        var A = requireLib$h();
        function n(h) {
          var r = Object.create(null);
          return (
            h &&
              Object.keys(h).forEach(function (d) {
                if (d !== "default") {
                  var p = Object.getOwnPropertyDescriptor(h, d);
                  Object.defineProperty(
                    r,
                    d,
                    p.get
                      ? p
                      : {
                          enumerable: !0,
                          get: function () {
                            return h[d];
                          },
                        },
                  );
                }
              }),
            (r.default = h),
            Object.freeze(r)
          );
        }
        var w,
          S = n(requireReact()),
          i = function () {
            return S.createElement(
              A.Icon,
              { size: 16 },
              S.createElement("path", {
                d: `M11.5,5.5v-2C11.5,2.672,12.172,2,13,2s1.5,0.672,1.5,1.5v2 M14.5,11.5v-6C14.5,4.672,15.172,4,16,4
            c0.828,0,1.5,0.672,1.5,1.5v3 M17.5,13V8.5C17.5,7.672,18.172,7,19,7s1.5,0.672,1.5,1.5v10c0,2.761-2.239,5-5,5h-3.335
            c-1.712-0.001-3.305-0.876-4.223-2.321C6.22,18.467,4.083,14,4.083,14c-0.378-0.545-0.242-1.292,0.303-1.67
            c0.446-0.309,1.044-0.281,1.458,0.07L8.5,15.5v-10C8.5,4.672,9.172,4,10,4s1.5,0.672,1.5,1.5v6`,
              }),
            );
          },
          H = function () {
            return (
              (H =
                Object.assign ||
                function (h) {
                  for (var r, d = 1, p = arguments.length; d < p; d++)
                    for (var u in (r = arguments[d]))
                      Object.prototype.hasOwnProperty.call(r, u) &&
                        (h[u] = r[u]);
                  return h;
                }),
              H.apply(this, arguments)
            );
          };
        ((t.SelectionMode = void 0),
          ((w = t.SelectionMode || (t.SelectionMode = {})).Hand = "Hand"),
          (w.Text = "Text"));
        var ee = function () {
            return S.createElement(
              A.Icon,
              { size: 16 },
              S.createElement("path", {
                d: `M13.675,11.671l2.941-2.941c0.195-0.196,0.195-0.512-0.001-0.707C16.563,7.971,16.5,7.931,16.43,7.906
            L4.168,3.527C3.908,3.434,3.622,3.57,3.529,3.83c-0.039,0.109-0.039,0.228,0,0.336l4.379,12.262
            c0.093,0.26,0.379,0.396,0.639,0.303c0.07-0.025,0.133-0.065,0.185-0.117l2.943-2.943l6.146,6.146c0.195,0.195,0.512,0.195,0.707,0
            l1.293-1.293c0.195-0.195,0.195-0.512,0-0.707L13.675,11.671z`,
              }),
            );
          },
          X = function (h) {
            var r = h.children,
              d = h.mode,
              p = h.onClick,
              u = S.useContext(A.LocalizationContext).l10n,
              F = "",
              v = S.createElement(ee, null);
            switch (d) {
              case t.SelectionMode.Hand:
                ((F =
                  u && u.selectionMode
                    ? u.selectionMode.handTool
                    : "Hand tool"),
                  (v = S.createElement(i, null)));
                break;
              case t.SelectionMode.Text:
              default:
                ((F =
                  u && u.selectionMode
                    ? u.selectionMode.textSelectionTool
                    : "Text selection tool"),
                  (v = S.createElement(ee, null)));
            }
            return r({ icon: v, label: F, onClick: p });
          },
          W = { left: 0, top: 8 },
          k = function (h) {
            var r = h.isSelected,
              d = h.mode,
              p = h.onClick,
              u = "";
            switch (d) {
              case t.SelectionMode.Hand:
                u = "selection-mode__hand-button";
                break;
              case t.SelectionMode.Text:
              default:
                u = "selection-mode__text-button";
            }
            return S.createElement(X, { mode: d, onClick: p }, function (F) {
              return S.createElement(A.Tooltip, {
                ariaControlsSuffix: "selection-mode-switch",
                position: A.Position.BottomCenter,
                target: S.createElement(
                  A.MinimalButton,
                  {
                    ariaLabel: F.label,
                    isSelected: r,
                    testId: u,
                    onClick: F.onClick,
                  },
                  F.icon,
                ),
                content: function () {
                  return F.label;
                },
                offset: W,
              });
            });
          },
          N = function (h) {
            var r = h.children,
              d = h.mode,
              p = h.store,
              u = d === p.get("selectionMode");
            return (
              r ||
              function (F) {
                return S.createElement(k, {
                  isSelected: u,
                  mode: F.mode,
                  onClick: F.onClick,
                });
              }
            )({
              isSelected: u,
              mode: d,
              onClick: function () {
                return p.update("selectionMode", d);
              },
            });
          },
          P = function (h) {
            var r = h.isSelected,
              d = h.mode,
              p = h.onClick,
              u = "";
            switch (d) {
              case t.SelectionMode.Hand:
                u = "selection-mode__hand-menu";
                break;
              case t.SelectionMode.Text:
              default:
                u = "selection-mode__text-menu";
            }
            return S.createElement(X, { mode: d, onClick: p }, function (F) {
              return S.createElement(
                A.MenuItem,
                { checked: r, icon: F.icon, testId: u, onClick: F.onClick },
                F.label,
              );
            });
          },
          _ = function (h) {
            var r = h.store,
              d = S.useRef(null),
              p = S.useState(t.SelectionMode.Text),
              u = p[0],
              F = p[1],
              v = S.useRef({ top: 0, left: 0, x: 0, y: 0 }),
              f = function (C) {
                var e = d.current;
                e &&
                  ((e.scrollTop = v.current.top - (C.clientY - v.current.y)),
                  (e.scrollLeft = v.current.left - (C.clientX - v.current.x)));
              },
              b = function () {
                var C = d.current;
                C &&
                  (C.classList.add("rpv-selection-mode__grab"),
                  C.classList.remove("rpv-selection-mode__grabbing"),
                  document.removeEventListener("mousemove", f),
                  document.removeEventListener("mouseup", b));
              },
              c = function (C) {
                var e = d.current;
                e &&
                  u !== t.SelectionMode.Text &&
                  (e.classList.remove("rpv-selection-mode__grab"),
                  e.classList.add("rpv-selection-mode__grabbing"),
                  C.preventDefault(),
                  C.stopPropagation(),
                  (v.current = {
                    left: e.scrollLeft,
                    top: e.scrollTop,
                    x: C.clientX,
                    y: C.clientY,
                  }),
                  document.addEventListener("mousemove", f),
                  document.addEventListener("mouseup", b));
              },
              a = function (C) {
                d.current = C();
              },
              m = function (C) {
                F(C);
              };
            return (
              S.useEffect(
                function () {
                  var C = d.current;
                  if (C)
                    return (
                      u === t.SelectionMode.Hand
                        ? C.classList.add("rpv-selection-mode__grab")
                        : C.classList.remove("rpv-selection-mode__grab"),
                      C.addEventListener("mousedown", c),
                      function () {
                        C.removeEventListener("mousedown", c);
                      }
                    );
                },
                [u],
              ),
              S.useEffect(function () {
                return (
                  r.subscribe("getPagesContainer", a),
                  r.subscribe("selectionMode", m),
                  function () {
                    (r.unsubscribe("getPagesContainer", a),
                      r.unsubscribe("selectionMode", m));
                  }
                );
              }, []),
              S.createElement(S.Fragment, null)
            );
          };
        ((t.HandToolIcon = i),
          (t.TextSelectionIcon = ee),
          (t.selectionModePlugin = function (h) {
            var r = S.useMemo(function () {
                return A.createStore();
              }, []),
              d = function (p) {
                return S.createElement(N, H({}, p, { store: r }));
              };
            return {
              install: function (p) {
                (r.update(
                  "selectionMode",
                  h && h.selectionMode ? h.selectionMode : t.SelectionMode.Text,
                ),
                  r.update("getPagesContainer", p.getPagesContainer));
              },
              renderViewer: function (p) {
                var u = p.slot;
                return (
                  u.subSlot &&
                    u.subSlot.children &&
                    (u.subSlot.children = S.createElement(
                      S.Fragment,
                      null,
                      S.createElement(_, { store: r }),
                      u.subSlot.children,
                    )),
                  u
                );
              },
              SwitchSelectionMode: d,
              SwitchSelectionModeButton: function (p) {
                return S.createElement(d, { mode: p.mode }, function (u) {
                  return S.createElement(k, {
                    isSelected: u.isSelected,
                    mode: u.mode,
                    onClick: function () {
                      u.onClick();
                    },
                  });
                });
              },
              SwitchSelectionModeMenuItem: function (p) {
                return S.createElement(d, { mode: p.mode }, function (u) {
                  return S.createElement(P, {
                    isSelected: u.isSelected,
                    mode: u.mode,
                    onClick: function () {
                      (u.onClick(), p.onClick());
                    },
                  });
                });
              },
            };
          }));
      })(selectionMode_min)),
    selectionMode_min
  );
}
var hasRequiredLib$d;
function requireLib$d() {
  if (hasRequiredLib$d) return lib$b.exports;
  hasRequiredLib$d = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$b.exports = requireSelectionMode_min()), lib$b.exports);
}
var lib$a = { exports: {} },
  fullScreen_min = {},
  hasRequiredFullScreen_min;
function requireFullScreen_min() {
  if (hasRequiredFullScreen_min) return fullScreen_min;
  hasRequiredFullScreen_min = 1;
  var t = requireLib$h();
  function A(p) {
    var u = Object.create(null);
    return (
      p &&
        Object.keys(p).forEach(function (F) {
          if (F !== "default") {
            var v = Object.getOwnPropertyDescriptor(p, F);
            Object.defineProperty(
              u,
              F,
              v.get
                ? v
                : {
                    enumerable: !0,
                    get: function () {
                      return p[F];
                    },
                  },
            );
          }
        }),
      (u.default = p),
      Object.freeze(u)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", { d: "M11.5 23.499L11.5 14.499" }),
        n.createElement("path", { d: "M7.5 18.499L11.5 14.499 15.5 18.499" }),
        n.createElement("path", { d: "M11.5 1.499L11.5 10.499" }),
        n.createElement("path", { d: "M7.5 6.499L11.5 10.499 15.5 6.499" }),
        n.createElement("path", { d: "M20.5 12.499L1.5 12.499" }),
      );
    },
    S = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", { d: "M0.5 12L23.5 12" }),
        n.createElement("path", { d: "M11.5 1L11.5 23" }),
        n.createElement("path", { d: "M8.5 4L11.5 1 14.5 4" }),
        n.createElement("path", { d: "M20.5 9L23.5 12 20.5 15" }),
        n.createElement("path", { d: "M3.5 15L0.5 12 3.5 9" }),
        n.createElement("path", { d: "M14.5 20L11.5 23 8.5 20" }),
      );
    },
    i = function () {
      return (
        (i =
          Object.assign ||
          function (p) {
            for (var u, F = 1, v = arguments.length; F < v; F++)
              for (var f in (u = arguments[F]))
                Object.prototype.hasOwnProperty.call(u, f) && (p[f] = u[f]);
            return p;
          }),
        i.apply(this, arguments)
      );
    },
    H = { left: 0, top: 8 },
    ee = function (p) {
      var u = p.enableShortcuts,
        F = p.onClick,
        v = n.useContext(t.LocalizationContext).l10n,
        f = v && v.fullScreen ? v.fullScreen.enterFullScreen : "Full screen",
        b = u ? (t.isMac() ? "Meta+Ctrl+F" : "F11") : "";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "full-screen-enter",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaKeyShortcuts: b,
            ariaLabel: f,
            isDisabled: !t.isFullScreenEnabled(),
            testId: "full-screen__enter-button",
            onClick: F,
          },
          n.createElement(S, null),
        ),
        content: function () {
          return f;
        },
        offset: H,
      });
    },
    X = { left: 0, top: 8 },
    W = function (p) {
      var u = p.onClick,
        F = n.useContext(t.LocalizationContext).l10n,
        v =
          F && F.fullScreen ? F.fullScreen.exitFullScreen : "Exit full screen";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "full-screen-exit",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaKeyShortcuts: "Esc",
            ariaLabel: v,
            testId: "full-screen__exit-button-with-tooltip",
            onClick: u,
          },
          n.createElement(w, null),
        ),
        content: function () {
          return v;
        },
        offset: X,
      });
    },
    k = function (p, u) {
      var F = n.useState(u.get("fullScreenMode")),
        v = F[0],
        f = F[1],
        b = n.useCallback(function (c) {
          f(c);
        }, []);
      return (
        n.useEffect(function () {
          return (
            u.subscribe("fullScreenMode", b),
            function () {
              u.unsubscribe("fullScreenMode", b);
            }
          );
        }, []),
        {
          enterFullScreen: function () {
            var c = u.get("getPagesContainer");
            if (c) {
              var a = p(c());
              u.get("enterFullScreenMode")(a);
            }
          },
          exitFullScreen: function () {
            u.get("exitFullScreenMode")();
          },
          isFullScreen:
            v === t.FullScreenMode.Entering ||
            v === t.FullScreenMode.EnteredCompletely,
        }
      );
    },
    N = function (p) {
      var u = p.children,
        F = p.enableShortcuts,
        v = p.getFullScreenTarget,
        f = p.store,
        b = k(v, f),
        c = b.enterFullScreen,
        a = b.exitFullScreen,
        m = b.isFullScreen;
      return (
        u ||
        function (C) {
          return m
            ? n.createElement(W, { onClick: C.onClick })
            : n.createElement(ee, { enableShortcuts: F, onClick: C.onClick });
        }
      )({ onClick: m ? a : c });
    },
    P = function (p) {
      var u = p.onClick,
        F = n.useContext(t.LocalizationContext).l10n,
        v = F && F.fullScreen ? F.fullScreen.enterFullScreen : "Full screen";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(S, null),
          isDisabled: !t.isFullScreenEnabled(),
          testId: "full-screen__enter-menu",
          onClick: u,
        },
        v,
      );
    },
    _ = function (p) {
      var u = p.onClick,
        F = n.useContext(t.LocalizationContext).l10n,
        v =
          n.useContext(t.ThemeContext).direction ===
          t.TextDirection.RightToLeft,
        f =
          F && F.fullScreen ? F.fullScreen.exitFullScreen : "Exit full screen";
      return n.createElement(
        "div",
        {
          className: t.classNames({
            "rpv-full-screen__exit-button": !0,
            "rpv-full-screen__exit-button--ltr": !v,
            "rpv-full-screen__exit-button--rtl": v,
          }),
        },
        n.createElement(
          t.MinimalButton,
          { ariaLabel: f, testId: "full-screen__exit-button", onClick: u },
          n.createElement(w, null),
        ),
      );
    },
    h = function (p) {
      var u = p.children,
        F = p.getFullScreenTarget,
        v = p.store,
        f = k(F, v),
        b = f.enterFullScreen,
        c = f.exitFullScreen,
        a = f.isFullScreen;
      return (
        a &&
        (
          u ||
          function (m) {
            return n.createElement(_, { onClick: m.onClick });
          }
        )({ onClick: a ? c : b })
      );
    },
    r = function (p) {
      var u = p.store,
        F = p.onEnterFullScreen,
        v = p.onExitFullScreen,
        f = n.useState(u.get("fullScreenMode")),
        b = f[0],
        c = f[1],
        a = n.useCallback(function (m) {
          c(m);
        }, []);
      return (
        n.useEffect(
          function () {
            switch (b) {
              case t.FullScreenMode.EnteredCompletely:
                F(u.get("zoom"));
                break;
              case t.FullScreenMode.Exited:
                v(u.get("zoom"));
            }
          },
          [b],
        ),
        n.useEffect(function () {
          return (
            u.subscribe("fullScreenMode", a),
            function () {
              u.unsubscribe("fullScreenMode", a);
            }
          );
        }, []),
        (b === t.FullScreenMode.Entering || b === t.FullScreenMode.Entered) &&
          n.createElement(
            "div",
            { className: "rpv-full-screen__overlay" },
            n.createElement(t.Spinner, null),
          )
      );
    },
    d = function (p) {
      var u = p.containerRef,
        F = p.getFullScreenTarget,
        v = p.store,
        f = k(F, v).enterFullScreen,
        b = function (c) {
          if (
            !c.shiftKey &&
            !c.altKey &&
            (t.isMac()
              ? c.metaKey && c.ctrlKey && c.key === "f"
              : c.key === "F11")
          ) {
            var a = u.current;
            a &&
              document.activeElement &&
              a.contains(document.activeElement) &&
              (c.preventDefault(), f());
          }
        };
      return (
        n.useEffect(
          function () {
            if (u.current)
              return (
                document.addEventListener("keydown", b),
                function () {
                  document.removeEventListener("keydown", b);
                }
              );
          },
          [u.current],
        ),
        n.createElement(n.Fragment, null)
      );
    };
  return (
    (fullScreen_min.ExitFullScreenIcon = w),
    (fullScreen_min.FullScreenIcon = S),
    (fullScreen_min.fullScreenPlugin = function (p) {
      var u =
          (p == null ? void 0 : p.getFullScreenTarget) ||
          function (c) {
            return c;
          },
        F = n.useMemo(function () {
          return Object.assign(
            {},
            {
              enableShortcuts: !0,
              onEnterFullScreen: function () {},
              onExitFullScreen: function () {},
            },
            p,
          );
        }, []),
        v = n.useMemo(function () {
          return t.createStore({
            enterFullScreenMode: function () {},
            exitFullScreenMode: function () {},
            fullScreenMode: t.FullScreenMode.Normal,
            zoom: function () {},
          });
        }, []),
        f = function (c) {
          return n.createElement(
            N,
            i({}, c, {
              enableShortcuts: F.enableShortcuts,
              getFullScreenTarget: u,
              store: v,
            }),
          );
        },
        b = function () {
          return n.createElement(
            h,
            { getFullScreenTarget: u, store: v },
            p == null ? void 0 : p.renderExitFullScreenButton,
          );
        };
      return {
        install: function (c) {
          (v.update("enterFullScreenMode", c.enterFullScreenMode),
            v.update("exitFullScreenMode", c.exitFullScreenMode),
            v.update("getPagesContainer", c.getPagesContainer),
            v.update("zoom", c.zoom));
        },
        onViewerStateChange: function (c) {
          return (v.update("fullScreenMode", c.fullScreenMode), c);
        },
        renderViewer: function (c) {
          var a = c.slot;
          return (
            a.subSlot &&
              (a.subSlot.children = n.createElement(
                n.Fragment,
                null,
                F.enableShortcuts &&
                  n.createElement(d, {
                    containerRef: c.containerRef,
                    getFullScreenTarget: u,
                    store: v,
                  }),
                n.createElement(r, {
                  store: v,
                  onEnterFullScreen: F.onEnterFullScreen,
                  onExitFullScreen: F.onExitFullScreen,
                }),
                n.createElement(b, null),
                a.subSlot.children,
              )),
            a
          );
        },
        EnterFullScreen: f,
        EnterFullScreenButton: function () {
          return n.createElement(f, null, function (c) {
            return n.createElement(
              ee,
              i({ enableShortcuts: F.enableShortcuts }, c),
            );
          });
        },
        EnterFullScreenMenuItem: function (c) {
          return n.createElement(f, null, function (a) {
            return n.createElement(P, {
              onClick: function () {
                (a.onClick(), c.onClick());
              },
            });
          });
        },
      };
    }),
    fullScreen_min
  );
}
var hasRequiredLib$c;
function requireLib$c() {
  if (hasRequiredLib$c) return lib$a.exports;
  hasRequiredLib$c = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$a.exports = requireFullScreen_min()), lib$a.exports);
}
var lib$9 = { exports: {} },
  getFile_min = {},
  hasRequiredGetFile_min;
function requireGetFile_min() {
  if (hasRequiredGetFile_min) return getFile_min;
  hasRequiredGetFile_min = 1;
  var t = requireLib$h();
  function A(P) {
    var _ = Object.create(null);
    return (
      P &&
        Object.keys(P).forEach(function (h) {
          if (h !== "default") {
            var r = Object.getOwnPropertyDescriptor(P, h);
            Object.defineProperty(
              _,
              h,
              r.get
                ? r
                : {
                    enumerable: !0,
                    get: function () {
                      return P[h];
                    },
                  },
            );
          }
        }),
      (_.default = P),
      Object.freeze(_)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: "M5.5,11.5c-.275,0-.341.159-.146.354l6.292,6.293a.5.5,0,0,0,.709,0l6.311-6.275c.2-.193.13-.353-.145-.355L15.5,11.5V1.5a1,1,0,0,0-1-1h-5a1,1,0,0,0-1,1V11a.5.5,0,0,1-.5.5Z",
        }),
        n.createElement("path", {
          d: "M23.5,18.5v4a1,1,0,0,1-1,1H1.5a1,1,0,0,1-1-1v-4",
        }),
      );
    },
    S = function () {
      return (
        (S =
          Object.assign ||
          function (P) {
            for (var _, h = 1, r = arguments.length; h < r; h++)
              for (var d in (_ = arguments[h]))
                Object.prototype.hasOwnProperty.call(_, d) && (P[d] = _[d]);
            return P;
          }),
        S.apply(this, arguments)
      );
    },
    i = { left: 0, top: 8 },
    H = function (P) {
      var _ = P.onClick,
        h = n.useContext(t.LocalizationContext).l10n,
        r = h && h.download ? h.download.download : "Download";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "get-file",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          { ariaLabel: r, testId: "get-file__download-button", onClick: _ },
          n.createElement(w, null),
        ),
        content: function () {
          return r;
        },
        offset: i,
      });
    },
    ee = function (P, _) {
      var h = document.createElement("a");
      ((h.style.display = "none"),
        (h.href = P),
        h.setAttribute("download", _),
        document.body.appendChild(h),
        h.click(),
        document.body.removeChild(h));
    },
    X = function (P, _, h) {
      var r = URL.createObjectURL(new Blob([P], { type: h }));
      (ee(r, _), r && URL.revokeObjectURL(r));
    },
    W = function (P, _) {
      P.getData().then(function (h) {
        /iphone|ipod|ipad/i.test(navigator.userAgent) &&
        !/CriOS/i.test(navigator.userAgent)
          ? X(h, _, "application/octet-stream")
          : /iphone|ipod|ipad/i.test(navigator.userAgent) &&
              /CriOS/i.test(navigator.userAgent)
            ? ee(
                "data:application/pdf;base64,".concat(
                  (function (r) {
                    return btoa(
                      Array(r.length)
                        .fill("")
                        .map(function (d, p) {
                          return String.fromCharCode(r[p]);
                        })
                        .join(""),
                    );
                  })(h),
                ),
                _,
              )
            : X(h, _, "application/pdf");
      });
    },
    k = function (P) {
      var _ = P.children,
        h = P.fileNameGenerator,
        r = P.store,
        d = n.useState(r.get("file")),
        p = d[0],
        u = d[1],
        F = n.useState(r.get("doc")),
        v = F[0],
        f = F[1],
        b = function (a) {
          f(a);
        },
        c = function (a) {
          u(a);
        };
      return (
        n.useEffect(function () {
          return (
            r.subscribe("doc", b),
            r.subscribe("file", c),
            function () {
              (r.subscribe("doc", b), r.unsubscribe("file", c));
            }
          );
        }, []),
        (
          _ ||
          function (a) {
            return n.createElement(H, { onClick: a.onClick });
          }
        )({
          onClick: function () {
            v && p && W(v, h(p));
          },
        })
      );
    },
    N = function (P) {
      var _ = P.onClick,
        h = n.useContext(t.LocalizationContext).l10n,
        r = h && h.download ? h.download.download : "Download";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(w, null),
          testId: "get-file__download-menu",
          onClick: _,
        },
        r,
      );
    };
  return (
    (getFile_min.DownloadIcon = w),
    (getFile_min.getFilePlugin = function (P) {
      var _ = n.useMemo(function () {
          return t.createStore({});
        }, []),
        h = function (d) {
          return d.name
            ? ((p = d.name),
              (u = p.split("/").pop()) ? u.split("#")[0].split("?")[0] : p)
            : "document.pdf";
          var p, u;
        },
        r = function (d) {
          return n.createElement(
            k,
            S({}, d, {
              fileNameGenerator: (P && P.fileNameGenerator) || h,
              store: _,
            }),
          );
        };
      return {
        onDocumentLoad: function (d) {
          (_.update("doc", d.doc), _.update("file", d.file));
        },
        Download: r,
        DownloadButton: function () {
          return n.createElement(r, null, function (d) {
            return n.createElement(H, S({}, d));
          });
        },
        DownloadMenuItem: function (d) {
          return n.createElement(r, null, function (p) {
            return n.createElement(N, {
              onClick: function () {
                (p.onClick(), d.onClick());
              },
            });
          });
        },
      };
    }),
    getFile_min
  );
}
var hasRequiredLib$b;
function requireLib$b() {
  if (hasRequiredLib$b) return lib$9.exports;
  hasRequiredLib$b = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$9.exports = requireGetFile_min()), lib$9.exports);
}
var lib$8 = { exports: {} },
  open_min = {},
  hasRequiredOpen_min;
function requireOpen_min() {
  if (hasRequiredOpen_min) return open_min;
  hasRequiredOpen_min = 1;
  var t = requireLib$h();
  function A(N) {
    var P = Object.create(null);
    return (
      N &&
        Object.keys(N).forEach(function (_) {
          if (_ !== "default") {
            var h = Object.getOwnPropertyDescriptor(N, _);
            Object.defineProperty(
              P,
              _,
              h.get
                ? h
                : {
                    enumerable: !0,
                    get: function () {
                      return N[_];
                    },
                  },
            );
          }
        }),
      (P.default = N),
      Object.freeze(P)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: "M18.5,7.5c.275,0,.341-.159.146-.354L12.354.854a.5.5,0,0,0-.708,0L5.354,7.147c-.2.195-.129.354.146.354h3v10a1,1,0,0,0,1,1h5a1,1,0,0,0,1-1V7.5Z",
        }),
        n.createElement("path", {
          d: "M23.5,18.5v4a1,1,0,0,1-1,1H1.5a1,1,0,0,1-1-1v-4",
        }),
      );
    },
    S = function () {
      return (
        (S =
          Object.assign ||
          function (N) {
            for (var P, _ = 1, h = arguments.length; _ < h; _++)
              for (var r in (P = arguments[_]))
                Object.prototype.hasOwnProperty.call(P, r) && (N[r] = P[r]);
            return N;
          }),
        S.apply(this, arguments)
      );
    },
    i = function (N) {
      var P = n.useRef(),
        _ = function () {
          var r = P.current;
          r &&
            (r.click(),
            N.get("triggerOpenFile") && N.update("triggerOpenFile", !1));
        },
        h = function (r) {
          r && _();
        };
      return (
        n.useEffect(function () {
          return (
            N.subscribe("triggerOpenFile", h),
            function () {
              N.unsubscribe("triggerOpenFile", h);
            }
          );
        }, []),
        { inputRef: P, openFile: _ }
      );
    },
    H = { left: 0, top: 8 },
    ee = function (N) {
      var P = N.enableShortcuts,
        _ = N.store,
        h = N.onClick,
        r = n.useContext(t.LocalizationContext).l10n,
        d = r && r.open ? r.open.openFile : "Open file",
        p = i(_),
        u = p.inputRef,
        F = p.openFile,
        v = P ? (t.isMac() ? "Meta+O" : "Ctrl+O") : "";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "open",
        position: t.Position.BottomCenter,
        target: n.createElement(
          "div",
          { className: "rpv-open__input-wrapper" },
          n.createElement("input", {
            accept: ".pdf",
            ref: u,
            className: "rpv-open__input",
            multiple: !1,
            tabIndex: -1,
            title: "",
            type: "file",
            onChange: h,
          }),
          n.createElement(
            t.MinimalButton,
            {
              ariaKeyShortcuts: v,
              ariaLabel: d,
              testId: "open__button",
              onClick: F,
            },
            n.createElement(w, null),
          ),
        ),
        content: function () {
          return d;
        },
        offset: H,
      });
    },
    X = function (N) {
      var P = N.children,
        _ = N.enableShortcuts,
        h = N.store;
      return (
        P ||
        function (r) {
          return n.createElement(ee, {
            enableShortcuts: _,
            store: h,
            onClick: r.onClick,
          });
        }
      )({
        onClick: function (r) {
          var d = r.target.files;
          if (d && d.length) {
            var p = h.get("openFile");
            p && p(d[0]);
          }
        },
      });
    },
    W = function (N) {
      var P = N.store,
        _ = N.onClick,
        h = n.useContext(t.LocalizationContext).l10n,
        r = h && h.open ? h.open.openFile : "Open file",
        d = i(P),
        p = d.inputRef,
        u = d.openFile;
      return n.createElement(
        t.MenuItem,
        { icon: n.createElement(w, null), testId: "open__menu", onClick: u },
        n.createElement(
          "div",
          { className: "rpv-open__input-wrapper" },
          n.createElement("input", {
            accept: ".pdf",
            ref: p,
            className: "rpv-open__input",
            multiple: !1,
            tabIndex: -1,
            title: "",
            type: "file",
            onChange: _,
          }),
          r,
        ),
      );
    },
    k = function (N) {
      var P = N.containerRef,
        _ = N.store,
        h = function (r) {
          if (
            !r.shiftKey &&
            !r.altKey &&
            r.key === "o" &&
            (t.isMac() ? r.metaKey : r.ctrlKey)
          ) {
            var d = P.current;
            d &&
              document.activeElement &&
              d.contains(document.activeElement) &&
              (r.preventDefault(), _.update("triggerOpenFile", !0));
          }
        };
      return (
        n.useEffect(
          function () {
            if (P.current)
              return (
                document.addEventListener("keydown", h),
                function () {
                  document.removeEventListener("keydown", h);
                }
              );
          },
          [P.current],
        ),
        n.createElement(n.Fragment, null)
      );
    };
  return (
    (open_min.OpenFileIcon = w),
    (open_min.openPlugin = function (N) {
      var P = n.useMemo(function () {
          return Object.assign({}, { enableShortcuts: !0 }, N);
        }, []),
        _ = n.useMemo(function () {
          return t.createStore({});
        }, []),
        h = function (r) {
          return n.createElement(
            X,
            S({ enableShortcuts: P.enableShortcuts }, r, { store: _ }),
          );
        };
      return {
        install: function (r) {
          _.update("openFile", r.openFile);
        },
        renderViewer: function (r) {
          var d = r.slot,
            p = {
              children: n.createElement(
                n.Fragment,
                null,
                P.enableShortcuts &&
                  n.createElement(k, {
                    containerRef: r.containerRef,
                    store: _,
                  }),
                d.children,
              ),
            };
          return S(S({}, d), p);
        },
        Open: h,
        OpenButton: function () {
          return n.createElement(h, null);
        },
        OpenMenuItem: function () {
          return n.createElement(h, null, function (r) {
            return n.createElement(W, { store: _, onClick: r.onClick });
          });
        },
      };
    }),
    open_min
  );
}
var hasRequiredLib$a;
function requireLib$a() {
  if (hasRequiredLib$a) return lib$8.exports;
  hasRequiredLib$a = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$8.exports = requireOpen_min()), lib$8.exports);
}
var lib$7 = { exports: {} },
  pageNavigation_min = {},
  hasRequiredPageNavigation_min;
function requirePageNavigation_min() {
  if (hasRequiredPageNavigation_min) return pageNavigation_min;
  hasRequiredPageNavigation_min = 1;
  var t = requireLib$h();
  function A(M) {
    var D = Object.create(null);
    return (
      M &&
        Object.keys(M).forEach(function (x) {
          if (x !== "default") {
            var z = Object.getOwnPropertyDescriptor(M, x);
            Object.defineProperty(
              D,
              x,
              z.get
                ? z
                : {
                    enumerable: !0,
                    get: function () {
                      return M[x];
                    },
                  },
            );
          }
        }),
      (D.default = M),
      Object.freeze(D)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M2.32,2.966h19.452c0.552,0.001,1,0.449,0.999,1.001c0,0.182-0.05,0.36-0.144,0.516L12.9,20.552
            c-0.286,0.472-0.901,0.624-1.373,0.338c-0.138-0.084-0.254-0.2-0.338-0.338L1.465,4.483C1.179,4.01,1.331,3.396,1.804,3.11
            C1.96,3.016,2.138,2.966,2.32,2.966z`,
        }),
      );
    },
    S = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043
            L23.541,5.627`,
        }),
      );
    },
    i = function () {
      return (
        (i =
          Object.assign ||
          function (M) {
            for (var D, x = 1, z = arguments.length; x < z; x++)
              for (var L in (D = arguments[x]))
                Object.prototype.hasOwnProperty.call(D, L) && (M[L] = D[L]);
            return M;
          }),
        i.apply(this, arguments)
      );
    },
    H = function (M) {
      var D = n.useState(M.get("currentPage") || 0),
        x = D[0],
        z = D[1],
        L = function (V) {
          z(V);
        };
      return (
        t.useIsomorphicLayoutEffect(function () {
          return (
            M.subscribe("currentPage", L),
            function () {
              M.unsubscribe("currentPage", L);
            }
          );
        }, []),
        { currentPage: x }
      );
    },
    ee = function (M) {
      var D = n.useState(M.get("numberOfPages") || 0),
        x = D[0],
        z = D[1],
        L = function (V) {
          z(V);
        };
      return (
        n.useEffect(function () {
          return (
            M.subscribe("numberOfPages", L),
            function () {
              M.unsubscribe("numberOfPages", L);
            }
          );
        }, []),
        { numberOfPages: x }
      );
    },
    X = function (M) {
      var D = M.store,
        x = n.useContext(t.LocalizationContext).l10n,
        z = n.useState("1"),
        L = z[0],
        V = z[1],
        Y = H(D).currentPage,
        T = ee(D).numberOfPages;
      n.useEffect(
        function () {
          return V("".concat(Y + 1));
        },
        [Y],
      );
      var s = function (R) {
          var $ = D.get("jumpToPage");
          $ && $(R);
        },
        g =
          x && x.pageNavigation
            ? x.pageNavigation.enterPageNumber
            : "Enter a page number";
      return n.createElement(
        "span",
        { className: "rpv-page-navigation__current-page-input" },
        n.createElement(t.TextBox, {
          ariaLabel: g,
          testId: "page-navigation__current-page-input",
          type: "text",
          value: L,
          onChange: V,
          onKeyDown: function (R) {
            switch (R.key) {
              case "ArrowUp":
                (U = Y - 1) >= 0 && (V("".concat(U + 1)), s(U));
                break;
              case "ArrowDown":
                (j = Y + 1) < T && (V("".concat(j + 1)), s(j));
                break;
              case "Enter":
                (($ = parseInt(L, 10)),
                  L === "" || $ < 1 || $ > T ? V("".concat(Y + 1)) : s($ - 1));
            }
            var $, j, U;
          },
        }),
      );
    },
    W = function (M) {
      var D = M.children,
        x = M.doc,
        z = t.useIsMounted(),
        L = n.useState({ loading: !0, labels: [] }),
        V = L[0],
        Y = L[1];
      return (
        n.useEffect(
          function () {
            x.getPageLabels().then(function (T) {
              z.current && Y({ loading: !1, labels: T || [] });
            });
          },
          [x.loadingTask.docId],
        ),
        V.loading ? n.createElement(n.Fragment, null) : D(V.labels)
      );
    },
    k = function (M) {
      var D = M.children,
        x = M.store,
        z = (function (T) {
          var s = n.useState(T.get("doc")),
            g = s[0],
            R = s[1],
            $ = function (j) {
              R(j);
            };
          return (
            n.useEffect(function () {
              return (
                T.subscribe("doc", $),
                function () {
                  T.unsubscribe("doc", $);
                }
              );
            }, []),
            g
          );
        })(x),
        L = H(x).currentPage,
        V = ee(x).numberOfPages,
        Y =
          D ||
          function (T) {
            return n.createElement(n.Fragment, null, T.currentPage + 1);
          };
      return z
        ? n.createElement(W, { doc: z }, function (T) {
            var s = T.length === V && V > 0 ? T[L] : "";
            return Y({ currentPage: L, numberOfPages: V, pageLabel: s });
          })
        : n.createElement(n.Fragment, null);
    },
    N = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M21.783,21.034H2.332c-0.552,0-1-0.448-1-1c0-0.182,0.05-0.361,0.144-0.517L11.2,3.448
            c0.286-0.472,0.901-0.624,1.373-0.338c0.138,0.084,0.254,0.2,0.338,0.338l9.726,16.069c0.286,0.473,0.134,1.087-0.339,1.373
            C22.143,20.984,21.965,21.034,21.783,21.034z`,
        }),
      );
    },
    P = { left: 0, top: 8 },
    _ = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L =
          z && z.pageNavigation ? z.pageNavigation.goToFirstPage : "First page";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "page-navigation-first",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaLabel: L,
            isDisabled: D,
            testId: "page-navigation__first-button",
            onClick: x,
          },
          n.createElement(N, null),
        ),
        content: function () {
          return L;
        },
        offset: P,
      });
    },
    h = function (M) {
      var D = M.children,
        x = M.store;
      return (
        D ||
        function (z) {
          return n.createElement(_, {
            isDisabled: z.isDisabled,
            onClick: z.onClick,
          });
        }
      )({
        isDisabled: H(x).currentPage === 0,
        onClick: function () {
          var z = x.get("jumpToPage");
          z && z(0);
        },
      });
    },
    r = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L =
          z && z.pageNavigation ? z.pageNavigation.goToFirstPage : "First page";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(N, null),
          isDisabled: D,
          testId: "page-navigation__first-menu",
          onClick: x,
        },
        L,
      );
    },
    d = { left: 0, top: 8 },
    p = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L = z && z.pageNavigation ? z.pageNavigation.goToLastPage : "Last page";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "page-navigation-last",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaLabel: L,
            isDisabled: D,
            testId: "page-navigation__last-button",
            onClick: x,
          },
          n.createElement(w, null),
        ),
        content: function () {
          return L;
        },
        offset: d,
      });
    },
    u = function (M) {
      var D = M.children,
        x = M.store,
        z = H(x).currentPage,
        L = ee(x).numberOfPages;
      return (
        D ||
        function (V) {
          return n.createElement(p, {
            isDisabled: V.isDisabled,
            onClick: V.onClick,
          });
        }
      )({
        isDisabled: z + 1 >= L,
        onClick: function () {
          var V = x.get("jumpToPage");
          V && V(L - 1);
        },
      });
    },
    F = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L = z && z.pageNavigation ? z.pageNavigation.goToLastPage : "Last page";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(w, null),
          isDisabled: D,
          testId: "page-navigation__last-menu",
          onClick: x,
        },
        L,
      );
    },
    v = { left: 0, top: 8 },
    f = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L = z && z.pageNavigation ? z.pageNavigation.goToNextPage : "Next page";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "page-navigation-next",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaLabel: L,
            isDisabled: D,
            testId: "page-navigation__next-button",
            onClick: x,
          },
          n.createElement(S, null),
        ),
        content: function () {
          return L;
        },
        offset: v,
      });
    },
    b = function (M) {
      var D = M.children,
        x = M.store;
      return (
        D ||
        function (z) {
          return n.createElement(f, {
            onClick: z.onClick,
            isDisabled: z.isDisabled,
          });
        }
      )({
        isDisabled: H(x).currentPage + 1 >= ee(x).numberOfPages,
        onClick: function () {
          var z = x.get("jumpToNextPage");
          z && z();
        },
      });
    },
    c = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L = z && z.pageNavigation ? z.pageNavigation.goToNextPage : "Next page";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(S, null),
          isDisabled: D,
          testId: "page-navigation__next-menu",
          onClick: x,
        },
        L,
      );
    },
    a = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8
            L0.535,18.373`,
        }),
      );
    },
    m = { left: 0, top: 8 },
    C = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L =
          z && z.pageNavigation
            ? z.pageNavigation.goToPreviousPage
            : "Previous page";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "page-navigation-previous",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaLabel: L,
            isDisabled: D,
            testId: "page-navigation__previous-button",
            onClick: x,
          },
          n.createElement(a, null),
        ),
        content: function () {
          return L;
        },
        offset: m,
      });
    },
    e = function (M) {
      var D = M.store;
      return (
        M.children ||
        function (x) {
          return n.createElement(C, {
            isDisabled: x.isDisabled,
            onClick: x.onClick,
          });
        }
      )({
        isDisabled: H(D).currentPage <= 0,
        onClick: function () {
          var x = D.get("jumpToPreviousPage");
          x && x();
        },
      });
    },
    o = function (M) {
      var D = M.isDisabled,
        x = M.onClick,
        z = n.useContext(t.LocalizationContext).l10n,
        L =
          z && z.pageNavigation
            ? z.pageNavigation.goToPreviousPage
            : "Previous page";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(a, null),
          isDisabled: D,
          testId: "page-navigation__previous-menu",
          onClick: x,
        },
        L,
      );
    },
    y = function (M) {
      var D = M.children,
        x = M.store,
        z = ee(x).numberOfPages;
      return D ? D({ numberOfPages: z }) : n.createElement(n.Fragment, null, z);
    },
    B = function (M) {
      var D = M.containerRef,
        x = M.numPages,
        z = M.store,
        L = H(z).currentPage,
        V = n.useRef(L);
      V.current = L;
      var Y = n.useRef(!1),
        T = function () {
          Y.current = !0;
        },
        s = function () {
          Y.current = !1;
        },
        g = function (R) {
          var $ = D.current,
            j =
              Y.current ||
              (document.activeElement && $.contains(document.activeElement));
          if ($ && j) {
            var U,
              Q,
              fe =
                (R.altKey && R.key === "ArrowDown") ||
                (!R.shiftKey && !R.altKey && R.key === "PageDown"),
              we =
                (R.altKey && R.key === "ArrowUp") ||
                (!R.shiftKey && !R.altKey && R.key === "PageUp");
            if (fe)
              return (
                R.preventDefault(),
                (U = z.get("jumpToPage")),
                (Q = V.current + 1),
                void (U && Q < x && U(Q))
              );
            if (we)
              return (
                R.preventDefault(),
                void (function () {
                  var Ee = z.get("jumpToPage"),
                    Ce = V.current - 1;
                  Ee && Ce >= 0 && Ee(Ce);
                })()
              );
            if (t.isMac() ? R.metaKey && !R.ctrlKey : R.altKey)
              switch (R.key) {
                case "ArrowLeft":
                  (R.preventDefault(),
                    (function () {
                      var Ee = z.get("jumpToPreviousDestination");
                      Ee && Ee();
                    })());
                  break;
                case "ArrowRight":
                  (R.preventDefault(),
                    (function () {
                      var Ee = z.get("jumpToNextDestination");
                      Ee && Ee();
                    })());
              }
          }
        };
      return (
        n.useEffect(
          function () {
            var R = D.current;
            if (R)
              return (
                document.addEventListener("keydown", g),
                R.addEventListener("mouseenter", T),
                R.addEventListener("mouseleave", s),
                function () {
                  (document.removeEventListener("keydown", g),
                    R.removeEventListener("mouseenter", T),
                    R.removeEventListener("mouseleave", s));
                }
              );
          },
          [D.current],
        ),
        n.createElement(n.Fragment, null)
      );
    };
  return (
    (pageNavigation_min.DownArrowIcon = w),
    (pageNavigation_min.NextIcon = S),
    (pageNavigation_min.PreviousIcon = a),
    (pageNavigation_min.UpArrowIcon = N),
    (pageNavigation_min.pageNavigationPlugin = function (M) {
      var D = n.useMemo(function () {
          return Object.assign({}, { enableShortcuts: !0 }, M);
        }, []),
        x = n.useMemo(function () {
          return t.createStore();
        }, []),
        z = function (T) {
          return n.createElement(h, i({}, T, { store: x }));
        },
        L = function (T) {
          return n.createElement(u, i({}, T, { store: x }));
        },
        V = function (T) {
          return n.createElement(b, i({}, T, { store: x }));
        },
        Y = function (T) {
          return n.createElement(e, i({}, T, { store: x }));
        };
      return {
        install: function (T) {
          (x.update("jumpToDestination", T.jumpToDestination),
            x.update("jumpToNextDestination", T.jumpToNextDestination),
            x.update("jumpToNextPage", T.jumpToNextPage),
            x.update("jumpToPage", T.jumpToPage),
            x.update("jumpToPreviousDestination", T.jumpToPreviousDestination),
            x.update("jumpToPreviousPage", T.jumpToPreviousPage));
        },
        renderViewer: function (T) {
          var s = T.slot;
          if (!D.enableShortcuts) return s;
          var g = {
            children: n.createElement(
              n.Fragment,
              null,
              n.createElement(B, {
                containerRef: T.containerRef,
                numPages: T.doc.numPages,
                store: x,
              }),
              s.children,
            ),
          };
          return i(i({}, s), g);
        },
        onDocumentLoad: function (T) {
          (x.update("doc", T.doc), x.update("numberOfPages", T.doc.numPages));
        },
        onViewerStateChange: function (T) {
          return (x.update("currentPage", T.pageIndex), T);
        },
        jumpToNextPage: function () {
          var T = x.get("jumpToNextPage");
          T && T();
        },
        jumpToPage: function (T) {
          var s = x.get("jumpToPage");
          s && s(T);
        },
        jumpToPreviousPage: function () {
          var T = x.get("jumpToPreviousPage");
          T && T();
        },
        CurrentPageInput: function () {
          return n.createElement(X, { store: x });
        },
        CurrentPageLabel: function (T) {
          return n.createElement(k, i({}, T, { store: x }));
        },
        GoToFirstPage: z,
        GoToFirstPageButton: function () {
          return n.createElement(z, null, function (T) {
            return n.createElement(_, i({}, T));
          });
        },
        GoToFirstPageMenuItem: function (T) {
          return n.createElement(z, null, function (s) {
            return n.createElement(r, {
              isDisabled: s.isDisabled,
              onClick: function () {
                (s.onClick(), T.onClick());
              },
            });
          });
        },
        GoToLastPage: L,
        GoToLastPageButton: function () {
          return n.createElement(L, null, function (T) {
            return n.createElement(p, i({}, T));
          });
        },
        GoToLastPageMenuItem: function (T) {
          return n.createElement(L, null, function (s) {
            return n.createElement(F, {
              isDisabled: s.isDisabled,
              onClick: function () {
                (s.onClick(), T.onClick());
              },
            });
          });
        },
        GoToNextPage: V,
        GoToNextPageButton: function () {
          return n.createElement(V, null, function (T) {
            return n.createElement(f, i({}, T));
          });
        },
        GoToNextPageMenuItem: function (T) {
          return n.createElement(V, null, function (s) {
            return n.createElement(c, {
              isDisabled: s.isDisabled,
              onClick: function () {
                (s.onClick(), T.onClick());
              },
            });
          });
        },
        GoToPreviousPage: Y,
        GoToPreviousPageButton: function () {
          return n.createElement(Y, null, function (T) {
            return n.createElement(C, i({}, T));
          });
        },
        GoToPreviousPageMenuItem: function (T) {
          return n.createElement(Y, null, function (s) {
            return n.createElement(o, {
              isDisabled: s.isDisabled,
              onClick: function () {
                (s.onClick(), T.onClick());
              },
            });
          });
        },
        NumberOfPages: function (T) {
          return n.createElement(y, i({}, T, { store: x }));
        },
      };
    }),
    pageNavigation_min
  );
}
var hasRequiredLib$9;
function requireLib$9() {
  if (hasRequiredLib$9) return lib$7.exports;
  hasRequiredLib$9 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$7.exports = requirePageNavigation_min()), lib$7.exports);
}
var lib$6 = { exports: {} },
  print_min = {},
  hasRequiredPrint_min;
function requirePrint_min() {
  if (hasRequiredPrint_min) return print_min;
  hasRequiredPrint_min = 1;
  var t = {},
    A = requireLib$h(),
    n = requireReact(),
    w = requireReactDom();
  function S(v) {
    var f = Object.create(null);
    return (
      v &&
        Object.keys(v).forEach(function (b) {
          if (b !== "default") {
            var c = Object.getOwnPropertyDescriptor(v, b);
            Object.defineProperty(
              f,
              b,
              c.get
                ? c
                : {
                    enumerable: !0,
                    get: function () {
                      return v[b];
                    },
                  },
            );
          }
        }),
      (f.default = v),
      Object.freeze(f)
    );
  }
  var i,
    H = S(n),
    ee = function () {
      return H.createElement(
        A.Icon,
        { size: 16 },
        H.createElement("path", {
          d: `M7.5,19.499h9 M7.5,16.499h9 M5.5,16.5h-3c-1.103-0.003-1.997-0.897-2-2v-6c0.003-1.103,0.897-1.997,2-2h19
            c1.103,0.003,1.997,0.897,2,2v6c-0.003,1.103-0.897,1.997-2,2h-3
            M5.5,4.5v-4h9.586c0.265,0,0.52,0.105,0.707,0.293l2.414,2.414
            C18.395,3.394,18.5,3.649,18.5,3.914V4.5
            M18.5,22.5c0,0.552-0.448,1-1,1h-11c-0.552,0-1-0.448-1-1v-9h13V22.5z
            M3.5,8.499
            c0.552,0,1,0.448,1,1s-0.448,1-1,1s-1-0.448-1-1S2.948,8.499,3.5,8.499z
            M14.5,0.499v4h4`,
        }),
      );
    },
    X = function () {
      return (
        (X =
          Object.assign ||
          function (v) {
            for (var f, b = 1, c = arguments.length; b < c; b++)
              for (var a in (f = arguments[b]))
                Object.prototype.hasOwnProperty.call(f, a) && (v[a] = f[a]);
            return v;
          }),
        X.apply(this, arguments)
      );
    },
    W = { left: 0, top: 8 },
    k = function (v) {
      var f = v.enableShortcuts,
        b = v.onClick,
        c = H.useContext(A.LocalizationContext).l10n,
        a = c && c.print ? c.print.print : "Print",
        m = f ? (A.isMac() ? "Meta+P" : "Ctrl+P") : "";
      return H.createElement(A.Tooltip, {
        ariaControlsSuffix: "print",
        position: A.Position.BottomCenter,
        target: H.createElement(
          A.MinimalButton,
          {
            ariaKeyShortcuts: m,
            ariaLabel: a,
            testId: "print__button",
            onClick: b,
          },
          H.createElement(ee, null),
        ),
        content: function () {
          return a;
        },
        offset: W,
      });
    };
  (function (v) {
    ((v.CheckingPermission = "CheckingPermission"),
      (v.Inactive = "Inactive"),
      (v.Preparing = "Preparing"),
      (v.Cancelled = "Cancelled"),
      (v.Ready = "Ready"));
  })(i || (i = {}));
  var N = function (v) {
      var f = v.children,
        b = v.enableShortcuts,
        c = v.store;
      return (f || k)({
        enableShortcuts: b,
        onClick: function () {
          c.update("printStatus", i.CheckingPermission);
        },
      });
    },
    P = function (v) {
      var f = v.doc,
        b = v.store,
        c = H.useContext(A.LocalizationContext).l10n,
        a = H.useState(!0),
        m = a[0],
        C = a[1];
      return (
        H.useEffect(function () {
          f.getPermissions().then(function (e) {
            e === null || e.includes(4) || e.includes(2048)
              ? b.update("printStatus", i.Preparing)
              : C(!1);
          });
        }, []),
        m
          ? H.createElement(H.Fragment, null)
          : H.createElement(A.Modal, {
              ariaControlsSuffix: "print-permission",
              closeOnClickOutside: !1,
              closeOnEscape: !1,
              content: function (e) {
                return H.createElement(
                  H.Fragment,
                  null,
                  H.createElement(
                    "div",
                    { className: "rpv-print__permission-body" },
                    c && c.print
                      ? c.print.disallowPrint
                      : "The document does not allow to print",
                  ),
                  H.createElement(
                    "div",
                    { className: "rpv-print__permission-footer" },
                    H.createElement(
                      A.Button,
                      {
                        onClick: function () {
                          (e(), b.update("printStatus", i.Cancelled));
                        },
                      },
                      c && c.print ? c.print.close : "Close",
                    ),
                  ),
                );
              },
              isOpened: !0,
            })
      );
    },
    _ = function (v) {
      var f = v.numLoadedPages,
        b = v.numPages,
        c = v.onCancel,
        a = H.useContext(A.LocalizationContext).l10n,
        m =
          H.useContext(A.ThemeContext).direction ===
          A.TextDirection.RightToLeft,
        C = Math.floor((100 * f) / b);
      return H.createElement(
        "div",
        { className: "rpv-print__progress" },
        H.createElement(
          "div",
          {
            className: A.classNames({
              "rpv-print__progress-body": !0,
              "rpv-print__progress-body--rtl": m,
            }),
          },
          H.createElement(
            "div",
            { className: "rpv-print__progress-message" },
            a && a.print ? a.print.preparingDocument : "Preparing document ...",
          ),
          H.createElement(
            "div",
            { className: "rpv-print__progress-bar" },
            H.createElement(A.ProgressBar, { progress: C }),
          ),
          H.createElement(
            A.Button,
            { onClick: c },
            a && a.print ? a.print.cancel : "Cancel",
          ),
        ),
      );
    },
    h = function (v) {
      var f = v.canvas,
        b = v.page,
        c = v.pageHeight,
        a = v.pageIndex,
        m = v.pageWidth,
        C = v.rotation,
        e = v.onLoad,
        o = A.useIsMounted(),
        y = H.useRef(),
        B = H.useState(""),
        M = B[0],
        D = B[1],
        x = H.useMemo(function () {
          return typeof process < "u" && t.JEST_WORKER_ID !== void 0;
        }, []);
      return (
        H.useEffect(function () {
          var z = y.current;
          z && z.cancel();
          var L = 150 / 72;
          ((f.height = Math.floor(c * L)), (f.width = Math.floor(m * L)));
          var V = f.getContext("2d");
          (V.save(),
            (V.fillStyle = "rgb(255, 255, 255)"),
            V.fillRect(0, 0, f.width, f.height),
            V.restore());
          var Y = b.getViewport({ rotation: C, scale: 1 });
          ((y.current = b.render({
            canvasContext: V,
            intent: "print",
            transform: [L, 0, 0, L, 0, 0],
            viewport: Y,
          })),
            y.current.promise.then(
              function () {
                "toBlob" in f && "createObjectURL" in URL
                  ? f.toBlob(function (T) {
                      (o.current && D(URL.createObjectURL(T)), x && e());
                    })
                  : (o.current && D(f.toDataURL()), x && e());
              },
              function () {},
            ));
        }, []),
        M &&
          H.createElement(
            "div",
            { className: "rpv-print__page" },
            H.createElement("img", {
              "data-testid": "print__thumbnail-".concat(a),
              src: M,
              onLoad: function () {
                x || e();
              },
            }),
          )
      );
    },
    r = function (v) {
      var f = v.canvas,
        b = v.doc,
        c = v.pageIndex,
        a = v.pageRotation,
        m = v.pageSize,
        C = v.rotation,
        e = v.shouldRender,
        o = v.onLoad,
        y = A.useIsMounted(),
        B = H.useState(null),
        M = B[0],
        D = B[1],
        x = Math.abs(C + a) % 180 == 0;
      H.useEffect(
        function () {
          e &&
            A.getPage(b, c).then(function (L) {
              y.current && D(L);
            });
        },
        [e],
      );
      var z = (m.rotation + C + a) % 360;
      return (
        M &&
        H.createElement(h, {
          canvas: f,
          page: M,
          pageHeight: x ? m.pageHeight : m.pageWidth,
          pageIndex: c,
          pageWidth: x ? m.pageWidth : m.pageHeight,
          rotation: z,
          onLoad: o,
        })
      );
    },
    d = function (v) {
      var f = v.doc,
        b = v.numLoadedPages,
        c = v.pagesRotation,
        a = v.pageSizes,
        m = v.printPages,
        C = v.printStatus,
        e = v.rotation,
        o = v.onCancel,
        y = v.onLoad,
        B = H.useMemo(function () {
          return document.createElement("canvas");
        }, []),
        M = H.useMemo(function () {
          var z = document.querySelector(".rpv-print__zone");
          if (z) return z;
          var L = document.createElement("div");
          return (
            L.classList.add("rpv-print__zone"),
            L.setAttribute("data-testid", "print__zone"),
            document.body.appendChild(L),
            L
          );
        }, []);
      H.useEffect(
        function () {
          C === i.Ready &&
            (document.documentElement.classList.add("rpv-print__html-printing"),
            document.body.classList.add("rpv-print__body-printing"),
            window.print());
          var z = function () {
            if (C === i.Ready) {
              (document.documentElement.classList.remove(
                "rpv-print__html-printing",
              ),
                document.body.classList.remove("rpv-print__body-printing"));
              var L = document.querySelectorAll(".rpv-print__zone");
              (L &&
                L.forEach(function (V) {
                  V.parentElement.removeChild(V);
                }),
                (B.height = 0),
                (B.width = 0),
                document.removeEventListener("mousemove", z),
                o());
            }
          };
          return (
            document.addEventListener("mousemove", z),
            function () {
              return document.removeEventListener("mousemove", z);
            }
          );
        },
        [C],
      );
      var D = a[0].pageHeight,
        x = a[0].pageWidth;
      return w.createPortal(
        H.createElement(
          H.Fragment,
          null,
          m.map(function (z, L) {
            return H.createElement(r, {
              key: z,
              canvas: B,
              doc: f,
              pageIndex: z,
              pageRotation: c.has(z) ? c.get(z) : 0,
              pageSize: a[z],
              rotation: e,
              shouldRender: L === b,
              onLoad: y,
            });
          }),
          H.createElement("style", {
            dangerouslySetInnerHTML: {
              __html: "@page { size: ".concat(x, "pt ").concat(D, "pt }"),
            },
          }),
        ),
        M,
      );
    },
    p = function (v) {
      var f = v.doc,
        b = v.pagesRotation,
        c = v.pageSizes,
        a = v.renderProgressBar,
        m = v.rotation,
        C = v.setPages,
        e = v.store,
        o = H.useState(i.Inactive),
        y = o[0],
        B = o[1],
        M = H.useState(0),
        D = M[0],
        x = M[1],
        z = H.useMemo(
          function () {
            var T = f.numPages;
            return C(f).filter(function (s) {
              return s >= 0 && s < T;
            });
          },
          [f, C],
        ),
        L = z.length,
        V = function () {
          (x(0), B(i.Inactive));
        },
        Y = function (T) {
          return B(T);
        };
      return (
        H.useEffect(function () {
          return (
            e.subscribe("printStatus", Y),
            function () {
              e.unsubscribe("printStatus", Y);
            }
          );
        }, []),
        H.createElement(
          H.Fragment,
          null,
          y === i.CheckingPermission &&
            H.createElement(P, { doc: f, store: e }),
          y === i.Preparing &&
            (a
              ? a(D, L, V)
              : H.createElement(_, {
                  numLoadedPages: D,
                  numPages: L,
                  onCancel: V,
                })),
          (y === i.Preparing || y === i.Ready) &&
            D <= L &&
            H.createElement(d, {
              doc: f,
              numLoadedPages: D,
              pagesRotation: b,
              pageSizes: c,
              printPages: z,
              printStatus: y,
              rotation: m,
              onCancel: V,
              onLoad: function () {
                var T = D + 1;
                T <= L && (x(T), T === L && B(i.Ready));
              },
            }),
        )
      );
    },
    u = function (v) {
      var f = v.onClick,
        b = H.useContext(A.LocalizationContext).l10n,
        c = b && b.print ? b.print.print : "Print";
      return H.createElement(
        A.MenuItem,
        { icon: H.createElement(ee, null), testId: "print__menu", onClick: f },
        c,
      );
    },
    F = function (v) {
      var f = v.containerRef,
        b = v.store,
        c = function (a) {
          if (
            !a.shiftKey &&
            !a.altKey &&
            a.key === "p" &&
            (A.isMac() ? a.metaKey : a.ctrlKey)
          ) {
            var m = f.current;
            m &&
              document.activeElement &&
              m.contains(document.activeElement) &&
              (a.preventDefault(), b.update("printStatus", i.Preparing));
          }
        };
      return (
        H.useEffect(
          function () {
            if (f.current)
              return (
                document.addEventListener("keydown", c),
                function () {
                  document.removeEventListener("keydown", c);
                }
              );
          },
          [f.current],
        ),
        H.createElement(H.Fragment, null)
      );
    };
  return (
    (print_min.PrintIcon = ee),
    (print_min.getAllPagesNumbers = function (v) {
      return Array(v.numPages)
        .fill(0)
        .map(function (f, b) {
          return b;
        });
    }),
    (print_min.getCustomPagesNumbers = function (v) {
      return function (f) {
        var b,
          c = [];
        return (
          v
            .replace(/\s+/g, "")
            .split(",")
            .forEach(function (a) {
              var m,
                C,
                e = a
                  .split("-")
                  .map(function (o) {
                    return parseInt(o, 10);
                  })
                  .filter(function (o) {
                    return Number.isInteger(o);
                  });
              e.length === 1
                ? c.push(e[0] - 1)
                : e.length === 2 &&
                  c.push.apply(
                    c,
                    ((m = e[0] - 1),
                    (C = e[1] - 1),
                    Array(C - m + 1)
                      .fill(0)
                      .map(function (o, y) {
                        return m + y;
                      })),
                  );
            }),
          ((b = c),
          b.filter(function (a) {
            return b.indexOf(a) === b.lastIndexOf(a);
          })).filter(function (a) {
            return a >= 0 && a < f.numPages;
          })
        );
      };
    }),
    (print_min.getEvenPagesNumbers = function (v) {
      return Array(v.numPages)
        .fill(0)
        .map(function (f, b) {
          return b;
        })
        .filter(function (f) {
          return (f + 1) % 2 == 0;
        });
    }),
    (print_min.getOddPagesNumbers = function (v) {
      return Array(v.numPages)
        .fill(0)
        .map(function (f, b) {
          return b;
        })
        .filter(function (f) {
          return (f + 1) % 2 == 1;
        });
    }),
    (print_min.printPlugin = function (v) {
      var f = H.useMemo(function () {
          return Object.assign(
            {},
            {
              enableShortcuts: !0,
              setPages: function (a) {
                return Array(a.numPages)
                  .fill(0)
                  .map(function (m, C) {
                    return C;
                  });
              },
            },
            v,
          );
        }, []),
        b = H.useMemo(function () {
          return A.createStore({ printStatus: i.Inactive });
        }, []),
        c = function (a) {
          return H.createElement(
            N,
            X({ enableShortcuts: f.enableShortcuts }, a, { store: b }),
          );
        };
      return {
        print: function () {
          b.update("printStatus", i.CheckingPermission);
        },
        renderViewer: function (a) {
          var m = a.slot,
            C = {
              children: H.createElement(
                H.Fragment,
                null,
                f.enableShortcuts &&
                  H.createElement(F, {
                    containerRef: a.containerRef,
                    store: b,
                  }),
                H.createElement(p, {
                  doc: a.doc,
                  pagesRotation: a.pagesRotation,
                  pageSizes: a.pageSizes,
                  renderProgressBar: v == null ? void 0 : v.renderProgressBar,
                  rotation: a.rotation,
                  setPages: f.setPages,
                  store: b,
                }),
                m.children,
              ),
            };
          return X(X({}, m), C);
        },
        Print: c,
        PrintButton: function () {
          return H.createElement(c, null, function (a) {
            return H.createElement(k, X({}, a));
          });
        },
        PrintMenuItem: function (a) {
          return H.createElement(c, null, function (m) {
            return H.createElement(u, {
              onClick: function () {
                (m.onClick(), a.onClick());
              },
            });
          });
        },
        setPages: function (a) {
          f.setPages = a;
        },
      };
    }),
    print_min
  );
}
var hasRequiredLib$8;
function requireLib$8() {
  if (hasRequiredLib$8) return lib$6.exports;
  hasRequiredLib$8 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$6.exports = requirePrint_min()), lib$6.exports);
}
var lib$5 = { exports: {} },
  properties_min = {},
  hasRequiredProperties_min;
function requireProperties_min() {
  if (hasRequiredProperties_min) return properties_min;
  hasRequiredProperties_min = 1;
  var t = requireLib$h();
  function A(h) {
    var r = Object.create(null);
    return (
      h &&
        Object.keys(h).forEach(function (d) {
          if (d !== "default") {
            var p = Object.getOwnPropertyDescriptor(h, d);
            Object.defineProperty(
              r,
              d,
              p.get
                ? p
                : {
                    enumerable: !0,
                    get: function () {
                      return h[d];
                    },
                  },
            );
          }
        }),
      (r.default = h),
      Object.freeze(r)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M12,1.001c6.075,0,11,4.925,11,11s-4.925,11-11,11s-11-4.925-11-11S5.925,1.001,12,1.001z
            M14.5,17.005H13
            c-0.552,0-1-0.448-1-1v-6.5c0-0.276-0.224-0.5-0.5-0.5H10
            M11.745,6.504L11.745,6.504
            M11.745,6.5c-0.138,0-0.25,0.112-0.25,0.25
            S11.607,7,11.745,7s0.25-0.112,0.25-0.25S11.883,6.5,11.745,6.5`,
        }),
      );
    },
    S = function () {
      return (
        (S =
          Object.assign ||
          function (h) {
            for (var r, d = 1, p = arguments.length; d < p; d++)
              for (var u in (r = arguments[d]))
                Object.prototype.hasOwnProperty.call(r, u) && (h[u] = r[u]);
            return h;
          }),
        S.apply(this, arguments)
      );
    },
    i = function (h) {
      var r = h.doc,
        d = h.render,
        p = n.useState(),
        u = p[0],
        F = p[1];
      return (
        n.useEffect(function () {
          r.getMetadata()
            .then(function (v) {
              return Promise.resolve(v);
            })
            .then(function (v) {
              return r.getDownloadInfo().then(function (f) {
                return Promise.resolve({
                  fileName: v.contentDispositionFilename || "",
                  info: v.info,
                  length: f.length,
                });
              });
            })
            .then(function (v) {
              F(v);
            });
        }, []),
        u
          ? d(u)
          : n.createElement(
              "div",
              { className: "rpv-properties__loader" },
              n.createElement(t.Spinner, null),
            )
      );
    },
    H = function (h) {
      var r = h.label,
        d = h.value,
        p =
          n.useContext(t.ThemeContext).direction ===
          t.TextDirection.RightToLeft;
      return n.createElement(
        "dl",
        {
          className: t.classNames({
            "rpv-properties__item": !0,
            "rpv-properties__item--rtl": p,
          }),
        },
        n.createElement(
          "dt",
          { className: "rpv-properties__item-label" },
          r,
          ":",
        ),
        n.createElement(
          "dd",
          { className: "rpv-properties__item-value" },
          d || "-",
        ),
      );
    },
    ee = new RegExp(
      "^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?",
    ),
    X = function (h, r, d, p) {
      var u = parseInt(h, 10);
      return u >= r && u <= d ? u : p;
    },
    W = function (h) {
      var r = h.doc,
        d = h.fileName,
        p = h.onToggle,
        u = n.useContext(t.LocalizationContext).l10n,
        F = function (v) {
          var f = (function (b) {
            var c = ee.exec(b);
            if (!c) return null;
            var a = parseInt(c[1], 10),
              m = X(c[2], 1, 12, 1) - 1,
              C = X(c[3], 1, 31, 1),
              e = X(c[4], 0, 23, 0),
              o = X(c[5], 0, 59, 0),
              y = X(c[6], 0, 59, 0),
              B = c[7] || "Z",
              M = X(c[8], 0, 23, 0),
              D = X(c[9], 0, 59, 0);
            switch (B) {
              case "-":
                ((e += M), (o += D));
                break;
              case "+":
                ((e -= M), (o -= D));
            }
            return new Date(Date.UTC(a, m, C, e, o, y));
          })(v);
          return f
            ? ""
                .concat(f.toLocaleDateString(), ", ")
                .concat(f.toLocaleTimeString())
            : "";
        };
      return n.createElement(
        "div",
        { className: "rpv-properties__modal" },
        n.createElement(i, {
          doc: r,
          render: function (v) {
            return n.createElement(
              n.Fragment,
              null,
              n.createElement(
                "div",
                { className: "rpv-properties__modal-section" },
                n.createElement(H, {
                  label:
                    u && u.properties ? u.properties.fileName : "File name",
                  value:
                    v.fileName ||
                    ((c = d),
                    (a = c.split("/").pop()),
                    a ? a.split("#")[0].split("?")[0] : c),
                }),
                n.createElement(H, {
                  label:
                    u && u.properties ? u.properties.fileSize : "File size",
                  value:
                    ((f = v.length),
                    (b = Math.floor(Math.log(f) / Math.log(1024))),
                    ""
                      .concat((f / Math.pow(1024, b)).toFixed(2), " ")
                      .concat(["B", "kB", "MB", "GB", "TB"][b])),
                }),
              ),
              n.createElement(t.Separator, null),
              n.createElement(
                "div",
                { className: "rpv-properties__modal-section" },
                n.createElement(H, {
                  label: u && u.properties ? u.properties.title : "Title",
                  value: v.info.Title,
                }),
                n.createElement(H, {
                  label: u && u.properties ? u.properties.author : "Author",
                  value: v.info.Author,
                }),
                n.createElement(H, {
                  label: u && u.properties ? u.properties.subject : "Subject",
                  value: v.info.Subject,
                }),
                n.createElement(H, {
                  label: u && u.properties ? u.properties.keywords : "Keywords",
                  value: v.info.Keywords,
                }),
                n.createElement(H, {
                  label: u && u.properties ? u.properties.creator : "Creator",
                  value: v.info.Creator,
                }),
                n.createElement(H, {
                  label:
                    u && u.properties
                      ? u.properties.creationDate
                      : "Creation date",
                  value: F(v.info.CreationDate),
                }),
                n.createElement(H, {
                  label:
                    u && u.properties
                      ? u.properties.modificationDate
                      : "Modification date",
                  value: F(v.info.ModDate),
                }),
              ),
              n.createElement(t.Separator, null),
              n.createElement(
                "div",
                { className: "rpv-properties__modal-section" },
                n.createElement(H, {
                  label:
                    u && u.properties
                      ? u.properties.pdfProducer
                      : "PDF producer",
                  value: v.info.Producer,
                }),
                n.createElement(H, {
                  label:
                    u && u.properties ? u.properties.pdfVersion : "PDF version",
                  value: v.info.PDFFormatVersion,
                }),
                n.createElement(H, {
                  label:
                    u && u.properties ? u.properties.pageCount : "Page count",
                  value: "".concat(r.numPages),
                }),
              ),
            );
            var f, b, c, a;
          },
        }),
        n.createElement(
          "div",
          { className: "rpv-properties__modal-footer" },
          n.createElement(
            t.Button,
            { onClick: p },
            u && u.properties ? u.properties.close : "Close",
          ),
        ),
      );
    },
    k = { left: 0, top: 8 },
    N = function (h) {
      var r = h.onClick,
        d = n.useContext(t.LocalizationContext).l10n,
        p = d && d.properties ? d.properties.showProperties : "Show properties";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "properties",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          { ariaLabel: p, testId: "properties__button", onClick: r },
          n.createElement(w, null),
        ),
        content: function () {
          return p;
        },
        offset: k,
      });
    },
    P = function (h) {
      var r = h.children,
        d = h.store,
        p = (function (v) {
          var f = n.useState(v.get("doc")),
            b = f[0],
            c = f[1],
            a = function (m) {
              c(m);
            };
          return (
            n.useEffect(function () {
              return (
                v.subscribe("doc", a),
                function () {
                  v.unsubscribe("doc", a);
                }
              );
            }, []),
            { currentDoc: b }
          );
        })(d).currentDoc,
        u = d.get("fileName") || "",
        F =
          r ||
          function (v) {
            return n.createElement(N, S({}, v));
          };
      return p
        ? n.createElement(t.Modal, {
            ariaControlsSuffix: "properties",
            target: function (v) {
              return F({ onClick: v });
            },
            content: function (v) {
              return n.createElement(W, { doc: p, fileName: u, onToggle: v });
            },
            closeOnClickOutside: !0,
            closeOnEscape: !0,
          })
        : n.createElement(n.Fragment, null);
    },
    _ = function (h) {
      var r = h.onClick,
        d = n.useContext(t.LocalizationContext).l10n,
        p = d && d.properties ? d.properties.showProperties : "Show properties";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(w, null),
          testId: "properties__menu",
          onClick: r,
        },
        p,
      );
    };
  return (
    (properties_min.InfoIcon = w),
    (properties_min.propertiesPlugin = function () {
      var h = n.useMemo(function () {
          return t.createStore({ fileName: "" });
        }, []),
        r = function (d) {
          return n.createElement(P, S({}, d, { store: h }));
        };
      return {
        onDocumentLoad: function (d) {
          h.update("doc", d.doc);
        },
        onViewerStateChange: function (d) {
          return (h.update("fileName", d.file.name), d);
        },
        ShowProperties: r,
        ShowPropertiesButton: function () {
          return n.createElement(P, { store: h });
        },
        ShowPropertiesMenuItem: function (d) {
          return n.createElement(r, null, function (p) {
            return n.createElement(_, S({}, p));
          });
        },
      };
    }),
    properties_min
  );
}
var hasRequiredLib$7;
function requireLib$7() {
  if (hasRequiredLib$7) return lib$5.exports;
  hasRequiredLib$7 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$5.exports = requireProperties_min()), lib$5.exports);
}
var lib$4 = { exports: {} },
  rotate_min = {},
  hasRequiredRotate_min;
function requireRotate_min() {
  if (hasRequiredRotate_min) return rotate_min;
  hasRequiredRotate_min = 1;
  var t = requireLib$h();
  function A(N) {
    var P = Object.create(null);
    return (
      N &&
        Object.keys(N).forEach(function (_) {
          if (_ !== "default") {
            var h = Object.getOwnPropertyDescriptor(N, _);
            Object.defineProperty(
              P,
              _,
              h.get
                ? h
                : {
                    enumerable: !0,
                    get: function () {
                      return N[_];
                    },
                  },
            );
          }
        }),
      (P.default = N),
      Object.freeze(P)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { ignoreDirection: !0, size: 16 },
        n.createElement("path", {
          d: `M3.434,10.537c0.141-0.438,0.316-0.864,0.523-1.274
            M3.069,14.425C3.023,14.053,3,13.679,3,13.305 c0-0.291,0.014-0.579,0.041-0.863
            M4.389,18.111c-0.341-0.539-0.623-1.112-0.843-1.711
            M7.163,20.9 c-0.543-0.345-1.048-0.747-1.506-1.2
            M10.98,22.248c-0.65-0.074-1.29-0.218-1.909-0.431
            M10,4.25h2 c4.987,0.015,9.017,4.069,9.003,9.055c-0.013,4.581-3.456,8.426-8.008,8.945
            M13.5,1.75L10,4.25l3.5,2.5`,
        }),
      );
    },
    S = function () {
      return n.createElement(
        t.Icon,
        { ignoreDirection: !0, size: 16 },
        n.createElement("path", {
          d: `M20.566,10.537c-0.141-0.438-0.316-0.864-0.523-1.274
            M20.931,14.425C20.977,14.053,21,13.679,21,13.305 c0-0.291-0.014-0.579-0.041-0.863
            M19.611,18.111c0.341-0.539,0.624-1.114,0.843-1.713
            M16.837,20.9 c0.543-0.345,1.048-0.747,1.506-1.2
            M13.02,22.248c0.65-0.074,1.29-0.218,1.909-0.431
            M14,4.25h-2 c-4.987,0.015-9.017,4.069-9.003,9.055c0.013,4.581,3.456,8.426,8.008,8.945
            M10.5,1.75l3.5,2.5l-3.5,2.5`,
        }),
      );
    },
    i = function () {
      return (
        (i =
          Object.assign ||
          function (N) {
            for (var P, _ = 1, h = arguments.length; _ < h; _++)
              for (var r in (P = arguments[_]))
                Object.prototype.hasOwnProperty.call(P, r) && (N[r] = P[r]);
            return N;
          }),
        i.apply(this, arguments)
      );
    },
    H = { left: 0, top: 8 },
    ee = function (N) {
      var P = N.direction,
        _ = N.onClick,
        h = n.useContext(t.LocalizationContext).l10n,
        r = h && h.rotate ? h.rotate.rotateBackward : "Rotate counterclockwise",
        d = h && h.rotate ? h.rotate.rotateForward : "Rotate clockwise",
        p = P === t.RotateDirection.Backward ? r : d,
        u =
          P === t.RotateDirection.Backward
            ? n.createElement(w, null)
            : n.createElement(S, null);
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "rotate",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaLabel: p,
            testId:
              P === t.RotateDirection.Backward
                ? "rotate__backward-button"
                : "rotate__forward-button",
            onClick: _,
          },
          u,
        ),
        content: function () {
          return p;
        },
        offset: H,
      });
    },
    X = function (N) {
      var P = N.children,
        _ = N.direction,
        h = N.store;
      return (
        P ||
        function (r) {
          return n.createElement(ee, {
            direction: r.direction,
            onClick: r.onClick,
          });
        }
      )({
        direction: _,
        onClick: function () {
          var r = h.get("rotate");
          r && r(_);
        },
      });
    },
    W = function (N) {
      var P = N.direction,
        _ = N.onClick,
        h = n.useContext(t.LocalizationContext).l10n,
        r = h && h.rotate ? h.rotate.rotateBackward : "Rotate counterclockwise",
        d = h && h.rotate ? h.rotate.rotateForward : "Rotate clockwise",
        p = P === t.RotateDirection.Backward ? r : d,
        u =
          P === t.RotateDirection.Backward
            ? n.createElement(w, null)
            : n.createElement(S, null);
      return n.createElement(
        t.MenuItem,
        {
          icon: u,
          testId:
            P === t.RotateDirection.Backward
              ? "rotate__backward-menu"
              : "rotate__forward-menu",
          onClick: _,
        },
        p,
      );
    },
    k = function (N) {
      var P = N.children,
        _ = N.store;
      return P({
        onRotatePage: function (h, r) {
          var d = _.get("rotatePage");
          d && d(h, r);
        },
      });
    };
  return (
    (rotate_min.RotateBackwardIcon = w),
    (rotate_min.RotateForwardIcon = S),
    (rotate_min.rotatePlugin = function () {
      var N = n.useMemo(function () {
          return t.createStore();
        }, []),
        P = function (_) {
          return n.createElement(X, i({}, _, { store: N }));
        };
      return {
        install: function (_) {
          (N.update("rotate", _.rotate), N.update("rotatePage", _.rotatePage));
        },
        Rotate: P,
        RotateBackwardButton: function () {
          return n.createElement(
            P,
            { direction: t.RotateDirection.Backward },
            function (_) {
              return n.createElement(ee, i({}, _));
            },
          );
        },
        RotateBackwardMenuItem: function (_) {
          return n.createElement(
            P,
            { direction: t.RotateDirection.Backward },
            function (h) {
              return n.createElement(W, {
                direction: h.direction,
                onClick: function () {
                  (h.onClick(), _.onClick());
                },
              });
            },
          );
        },
        RotateForwardButton: function () {
          return n.createElement(
            P,
            { direction: t.RotateDirection.Forward },
            function (_) {
              return n.createElement(ee, i({}, _));
            },
          );
        },
        RotateForwardMenuItem: function (_) {
          return n.createElement(
            P,
            { direction: t.RotateDirection.Forward },
            function (h) {
              return n.createElement(W, {
                direction: h.direction,
                onClick: function () {
                  (h.onClick(), _.onClick());
                },
              });
            },
          );
        },
        RotatePage: function (_) {
          return n.createElement(k, i({}, _, { store: N }));
        },
      };
    }),
    rotate_min
  );
}
var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$4.exports;
  hasRequiredLib$6 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$4.exports = requireRotate_min()), lib$4.exports);
}
var lib$3 = { exports: {} },
  scrollMode_min = {},
  hasRequiredScrollMode_min;
function requireScrollMode_min() {
  if (hasRequiredScrollMode_min) return scrollMode_min;
  hasRequiredScrollMode_min = 1;
  var t = requireLib$h();
  function A(a) {
    var m = Object.create(null);
    return (
      a &&
        Object.keys(a).forEach(function (C) {
          if (C !== "default") {
            var e = Object.getOwnPropertyDescriptor(a, C);
            Object.defineProperty(
              m,
              C,
              e.get
                ? e
                : {
                    enumerable: !0,
                    get: function () {
                      return a[C];
                    },
                  },
            );
          }
        }),
      (m.default = a),
      Object.freeze(m)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("rect", {
          x: "0.5",
          y: "0.497",
          width: "22",
          height: "22",
          rx: "1",
          ry: "1",
        }),
        n.createElement("line", {
          x1: "0.5",
          y1: "6.497",
          x2: "22.5",
          y2: "6.497",
        }),
        n.createElement("line", {
          x1: "11.5",
          y1: "6.497",
          x2: "11.5",
          y2: "22.497",
        }),
      );
    },
    S = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("rect", {
          x: "0.5",
          y: "0.497",
          width: "22",
          height: "22",
          rx: "1",
          ry: "1",
        }),
        n.createElement("line", {
          x1: "11.5",
          y1: "0.497",
          x2: "11.5",
          y2: "22.497",
        }),
      );
    },
    i = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M6.5,21.5c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z
            M14.5,21.5c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z
            M22.5,21.5 c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z`,
        }),
      );
    },
    H = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("rect", {
          x: "0.5",
          y: "0.497",
          width: "22",
          height: "22",
          rx: "1",
          ry: "1",
        }),
      );
    },
    ee = function () {
      return (
        (ee =
          Object.assign ||
          function (a) {
            for (var m, C = 1, e = arguments.length; C < e; C++)
              for (var o in (m = arguments[C]))
                Object.prototype.hasOwnProperty.call(m, o) && (a[o] = m[o]);
            return a;
          }),
        ee.apply(this, arguments)
      );
    },
    X = function (a, m) {
      a.get("switchScrollMode")(m);
      var C = a.get("viewMode");
      (m !== t.ScrollMode.Horizontal && m !== t.ScrollMode.Wrapped) ||
        C === t.ViewMode.SinglePage ||
        a.get("switchViewMode")(t.ViewMode.SinglePage);
    },
    W = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M23.5,5.5c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V5.5z
            M23.5,13.5c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V13.5z
            M23.5,21.5 c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V21.5z`,
        }),
      );
    },
    k = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M10.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M23.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M10.5,22.5 c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z
            M23.5,22.5c0,0.552-0.448,1-1,1 h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z`,
        }),
      );
    },
    N = function (a) {
      var m = a.children,
        C = a.mode,
        e = a.onClick,
        o = n.useContext(t.LocalizationContext).l10n,
        y = "",
        B = n.createElement(W, null);
      switch (C) {
        case t.ScrollMode.Horizontal:
          ((y =
            o && o.scrollMode
              ? o.scrollMode.horizontalScrolling
              : "Horizontal scrolling"),
            (B = n.createElement(i, null)));
          break;
        case t.ScrollMode.Page:
          ((y =
            o && o.scrollMode ? o.scrollMode.pageScrolling : "Page scrolling"),
            (B = n.createElement(H, null)));
          break;
        case t.ScrollMode.Wrapped:
          ((y =
            o && o.scrollMode
              ? o.scrollMode.wrappedScrolling
              : "Wrapped scrolling"),
            (B = n.createElement(k, null)));
          break;
        case t.ScrollMode.Vertical:
        default:
          ((y =
            o && o.scrollMode
              ? o.scrollMode.verticalScrolling
              : "Vertical scrolling"),
            (B = n.createElement(W, null)));
      }
      return m({ icon: B, label: y, onClick: e });
    },
    P = { left: 0, top: 8 },
    _ = function (a) {
      var m = a.isDisabled,
        C = a.isSelected,
        e = a.mode,
        o = a.onClick,
        y = "";
      switch (e) {
        case t.ScrollMode.Horizontal:
          y = "scroll-mode__horizontal-button";
          break;
        case t.ScrollMode.Page:
          y = "scroll-mode__page-button";
          break;
        case t.ScrollMode.Wrapped:
          y = "scroll-mode__wrapped-button";
          break;
        case t.ScrollMode.Vertical:
        default:
          y = "scroll-mode__vertical-button";
      }
      return n.createElement(N, { mode: e, onClick: o }, function (B) {
        return n.createElement(t.Tooltip, {
          ariaControlsSuffix: "scroll-mode-switch",
          position: t.Position.BottomCenter,
          target: n.createElement(
            t.MinimalButton,
            {
              ariaLabel: B.label,
              isDisabled: m,
              isSelected: C,
              testId: y,
              onClick: B.onClick,
            },
            B.icon,
          ),
          content: function () {
            return B.label;
          },
          offset: P,
        });
      });
    },
    h = function (a) {
      var m = n.useState(a.get("scrollMode") || t.ScrollMode.Vertical),
        C = m[0],
        e = m[1],
        o = function (y) {
          e(y);
        };
      return (
        n.useEffect(function () {
          return (
            a.subscribe("scrollMode", o),
            function () {
              a.unsubscribe("scrollMode", o);
            }
          );
        }, []),
        { scrollMode: C }
      );
    },
    r = function (a) {
      var m = n.useState(a.get("viewMode") || t.ViewMode.SinglePage),
        C = m[0],
        e = m[1],
        o = function (y) {
          e(y);
        };
      return (
        n.useEffect(function () {
          return (
            a.subscribe("viewMode", o),
            function () {
              a.unsubscribe("viewMode", o);
            }
          );
        }, []),
        { viewMode: C }
      );
    },
    d = function (a) {
      var m = a.children,
        C = a.mode,
        e = a.store,
        o = r(e).viewMode,
        y = h(e).scrollMode === C,
        B =
          (C === t.ScrollMode.Horizontal || C === t.ScrollMode.Wrapped) &&
          o !== t.ViewMode.SinglePage;
      return (
        m ||
        function (M) {
          return n.createElement(_, {
            isDisabled: B,
            isSelected: y,
            mode: M.mode,
            onClick: M.onClick,
          });
        }
      )({
        isDisabled: B,
        isSelected: y,
        mode: C,
        onClick: function () {
          X(e, C);
        },
      });
    },
    p = function (a) {
      var m = a.isDisabled,
        C = a.isSelected,
        e = a.mode,
        o = a.onClick,
        y = "";
      switch (e) {
        case t.ScrollMode.Horizontal:
          y = "scroll-mode__horizontal-menu";
          break;
        case t.ScrollMode.Page:
          y = "scroll-mode__page-menu";
          break;
        case t.ScrollMode.Wrapped:
          y = "scroll-mode__wrapped-menu";
          break;
        case t.ScrollMode.Vertical:
        default:
          y = "scroll-mode__vertical-menu";
      }
      return n.createElement(N, { mode: e, onClick: o }, function (B) {
        return n.createElement(
          t.MenuItem,
          {
            checked: C,
            icon: B.icon,
            isDisabled: m,
            testId: y,
            onClick: B.onClick,
          },
          B.label,
        );
      });
    },
    u = function (a, m) {
      a.get("switchViewMode")(m);
      var C = a.get("scrollMode");
      (C !== t.ScrollMode.Horizontal && C !== t.ScrollMode.Wrapped) ||
        m === t.ViewMode.SinglePage ||
        a.get("switchScrollMode")(t.ScrollMode.Vertical);
    },
    F = function (a) {
      var m = a.children,
        C = a.mode,
        e = a.onClick,
        o = n.useContext(t.LocalizationContext).l10n,
        y = "",
        B = n.createElement(H, null);
      switch (C) {
        case t.ViewMode.DualPage:
          ((y = o && o.scrollMode ? o.scrollMode.dualPage : "Dual page"),
            (B = n.createElement(S, null)));
          break;
        case t.ViewMode.DualPageWithCover:
          ((y =
            o && o.scrollMode
              ? o.scrollMode.dualPageCover
              : "Dual page with cover"),
            (B = n.createElement(w, null)));
          break;
        case t.ViewMode.SinglePage:
        default:
          ((y = o && o.scrollMode ? o.scrollMode.singlePage : "Single page"),
            (B = n.createElement(H, null)));
      }
      return m({ icon: B, label: y, onClick: e });
    },
    v = { left: 0, top: 8 },
    f = function (a) {
      var m = a.isDisabled,
        C = a.isSelected,
        e = a.mode,
        o = a.onClick,
        y = "";
      switch (e) {
        case t.ViewMode.DualPage:
          y = "view-mode__dual-button";
          break;
        case t.ViewMode.DualPageWithCover:
          y = "view-mode__dual-cover-button";
          break;
        case t.ViewMode.SinglePage:
        default:
          y = "view-mode__single-button";
      }
      return n.createElement(F, { mode: e, onClick: o }, function (B) {
        return n.createElement(t.Tooltip, {
          ariaControlsSuffix: "view-mode-switch",
          position: t.Position.BottomCenter,
          target: n.createElement(
            t.MinimalButton,
            {
              ariaLabel: B.label,
              isDisabled: m,
              isSelected: C,
              testId: y,
              onClick: B.onClick,
            },
            B.icon,
          ),
          content: function () {
            return B.label;
          },
          offset: v,
        });
      });
    },
    b = function (a) {
      var m = a.children,
        C = a.mode,
        e = a.store,
        o = r(e).viewMode,
        y = h(e).scrollMode,
        B = o === C,
        M =
          (y === t.ScrollMode.Horizontal || y === t.ScrollMode.Wrapped) &&
          C !== t.ViewMode.SinglePage;
      return (
        m ||
        function (D) {
          return n.createElement(f, {
            isDisabled: M,
            isSelected: B,
            mode: D.mode,
            onClick: D.onClick,
          });
        }
      )({
        isDisabled: M,
        isSelected: B,
        mode: C,
        onClick: function () {
          u(e, C);
        },
      });
    },
    c = function (a) {
      var m = a.isDisabled,
        C = a.isSelected,
        e = a.mode,
        o = a.onClick,
        y = "";
      switch (e) {
        case t.ViewMode.DualPage:
          y = "view-mode__dual-menu";
          break;
        case t.ViewMode.DualPageWithCover:
          y = "view-mode__dual-cover-menu";
          break;
        case t.ViewMode.SinglePage:
        default:
          y = "view-mode__single-menu";
      }
      return n.createElement(F, { mode: e, onClick: o }, function (B) {
        return n.createElement(
          t.MenuItem,
          {
            checked: C,
            icon: B.icon,
            isDisabled: m,
            testId: y,
            onClick: B.onClick,
          },
          B.label,
        );
      });
    };
  return (
    (scrollMode_min.DualPageCoverViewModeIcon = w),
    (scrollMode_min.DualPageViewModeIcon = S),
    (scrollMode_min.HorizontalScrollingIcon = i),
    (scrollMode_min.PageScrollingIcon = H),
    (scrollMode_min.VerticalScrollingIcon = W),
    (scrollMode_min.WrappedScrollingIcon = k),
    (scrollMode_min.scrollModePlugin = function () {
      var a = n.useMemo(function () {
          return t.createStore({
            scrollMode: t.ScrollMode.Vertical,
            viewMode: t.ViewMode.SinglePage,
            switchScrollMode: function () {},
            switchViewMode: function () {},
          });
        }, []),
        m = function (e) {
          return n.createElement(d, ee({}, e, { store: a }));
        },
        C = function (e) {
          return n.createElement(b, ee({}, e, { store: a }));
        };
      return {
        install: function (e) {
          (a.update("switchScrollMode", e.switchScrollMode),
            a.update("switchViewMode", e.switchViewMode));
        },
        onViewerStateChange: function (e) {
          return (
            a.update("scrollMode", e.scrollMode),
            a.update("viewMode", e.viewMode),
            e
          );
        },
        switchScrollMode: function (e) {
          X(a, e);
        },
        switchViewMode: function (e) {
          u(a, e);
        },
        SwitchScrollMode: m,
        SwitchScrollModeButton: function (e) {
          return n.createElement(m, { mode: e.mode }, function (o) {
            return n.createElement(_, {
              isDisabled: o.isDisabled,
              isSelected: o.isSelected,
              mode: o.mode,
              onClick: function () {
                o.onClick();
              },
            });
          });
        },
        SwitchScrollModeMenuItem: function (e) {
          return n.createElement(m, { mode: e.mode }, function (o) {
            return n.createElement(p, {
              isDisabled: o.isDisabled,
              isSelected: o.isSelected,
              mode: o.mode,
              onClick: function () {
                (o.onClick(), e.onClick());
              },
            });
          });
        },
        SwitchViewMode: C,
        SwitchViewModeButton: function (e) {
          return n.createElement(C, { mode: e.mode }, function (o) {
            return n.createElement(f, {
              isDisabled: o.isDisabled,
              isSelected: o.isSelected,
              mode: o.mode,
              onClick: function () {
                o.onClick();
              },
            });
          });
        },
        SwitchViewModeMenuItem: function (e) {
          return n.createElement(C, { mode: e.mode }, function (o) {
            return n.createElement(c, {
              isDisabled: o.isDisabled,
              isSelected: o.isSelected,
              mode: o.mode,
              onClick: function () {
                (o.onClick(), e.onClick());
              },
            });
          });
        },
      };
    }),
    scrollMode_min
  );
}
var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$3.exports;
  hasRequiredLib$5 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$3.exports = requireScrollMode_min()), lib$3.exports);
}
var lib$2 = { exports: {} },
  search_min = {},
  hasRequiredSearch_min;
function requireSearch_min() {
  if (hasRequiredSearch_min) return search_min;
  hasRequiredSearch_min = 1;
  var t = requireLib$h();
  function A(e) {
    var o = Object.create(null);
    return (
      e &&
        Object.keys(e).forEach(function (y) {
          if (y !== "default") {
            var B = Object.getOwnPropertyDescriptor(e, y);
            Object.defineProperty(
              o,
              y,
              B.get
                ? B
                : {
                    enumerable: !0,
                    get: function () {
                      return e[y];
                    },
                  },
            );
          }
        }),
      (o.default = e),
      Object.freeze(o)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043
            L23.541,5.627`,
        }),
      );
    },
    S = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: `M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8
            L0.535,18.373`,
        }),
      );
    },
    i = function () {
      return n.createElement(
        t.Icon,
        { ignoreDirection: !0, size: 16 },
        n.createElement("path", {
          d: `M10.5,0.5c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.5,10.5,0.5z
            M23.5,23.5
            l-5.929-5.929`,
        }),
      );
    },
    H = function () {
      return (
        (H =
          Object.assign ||
          function (e) {
            for (var o, y = 1, B = arguments.length; y < B; y++)
              for (var M in (o = arguments[y]))
                Object.prototype.hasOwnProperty.call(o, M) && (e[M] = o[M]);
            return e;
          }),
        H.apply(this, arguments)
      );
    },
    ee = { keyword: "", regExp: new RegExp(" "), wholeWords: !1 },
    X = function (e) {
      return {
        left: "".concat(e.left, "%"),
        top: "".concat(e.top, "%"),
        height: "".concat(e.height, "%"),
        width: "".concat(e.width, "%"),
      };
    },
    W = function (e) {
      var o = e.index,
        y = e.area,
        B = e.onHighlightKeyword,
        M = n.useRef();
      return (
        t.useIsomorphicLayoutEffect(function () {
          var D = M.current;
          B && D && B({ highlightEle: D, keyword: y.keyword });
        }, []),
        n.createElement("div", {
          className: "rpv-search__highlight",
          "data-index": o,
          ref: M,
          style: X(y),
          title: y.keywordStr.trim(),
        })
      );
    },
    k = function (e) {
      var o = e.parentNode;
      o && o.removeChild(e);
    },
    N = function (e) {
      var o = e.parentNode;
      if (o) {
        var y = document.createRange();
        (y.selectNodeContents(e),
          (function (B, M) {
            k(B);
            var D = M.parentNode;
            (D && D.insertBefore(B, M), k(M));
          })(y.extractContents(), e),
          o.normalize());
      }
    },
    P = function (e, o) {
      return e.top < o.top
        ? -1
        : e.top > o.top
          ? 1
          : e.left < o.left
            ? -1
            : e.left > o.left
              ? 1
              : 0;
    },
    _ = function (e) {
      var o = e.numPages,
        y = e.pageIndex,
        B = e.renderHighlights,
        M = e.store,
        D = e.onHighlightKeyword,
        x = n.useRef(),
        z = n.useCallback(function (re) {
          return n.createElement(
            n.Fragment,
            null,
            re.highlightAreas.map(function (he, Pe) {
              return n.createElement(W, {
                index: Pe,
                key: Pe,
                area: he,
                onHighlightKeyword: D,
              });
            }),
          );
        }, []),
        L = B || z,
        V = n.useState(M.get("matchPosition")),
        Y = V[0],
        T = V[1],
        s = n.useState(M.get("keyword") || [ee]),
        g = s[0],
        R = s[1],
        $ = n.useState({
          pageIndex: y,
          scale: 1,
          status: t.LayerRenderStatus.PreRender,
        }),
        j = $[0],
        U = $[1],
        Q = n.useRef(null),
        fe = n.useRef([]),
        we = n.useState([]),
        Ee = we[0],
        Ce = we[1],
        xe = function () {
          return !0;
        },
        Re = n.useCallback(
          function () {
            return M.get("targetPageFilter") || xe;
          },
          [M.get("targetPageFilter")],
        ),
        ue = function (re) {
          var he = fe.current;
          if (he.length === 0) return [];
          var Pe = [],
            Me = [].slice.call(
              re.querySelectorAll(".rpv-core__text-layer-text"),
            ),
            se = he
              .map(function (je) {
                return je.char;
              })
              .join("");
          return (
            g.forEach(function (je) {
              var Ie = je.keyword;
              if (Ie.trim()) {
                for (
                  var it,
                    Ke =
                      je.regExp.flags.indexOf("g") === -1
                        ? new RegExp(je.regExp, "".concat(je.regExp.flags, "g"))
                        : je.regExp,
                    dt = [];
                  (it = Ke.exec(se)) !== null;

                )
                  dt.push({
                    keyword: Ke,
                    startIndex: it.index,
                    endIndex: Ke.lastIndex,
                  });
                dt.map(function (ze) {
                  return {
                    keyword: ze.keyword,
                    indexes: he.slice(ze.startIndex, ze.endIndex),
                  };
                }).forEach(function (ze) {
                  var Je = ze.indexes.reduce(function (st, kt) {
                    return (
                      (st[kt.spanIndex] = (st[kt.spanIndex] || []).concat([
                        kt,
                      ])),
                      st
                    );
                  }, {});
                  Object.values(Je).forEach(function (st) {
                    if (st.length !== 1 || st[0].char.trim() !== "") {
                      var kt = je.wholeWords ? st.slice(1, -1) : st,
                        Le = (function (pe, me, Xe, Ye, ot) {
                          var Z = document.createRange(),
                            Te = Ye.firstChild;
                          if (!Te || Te.nodeType !== Node.TEXT_NODE)
                            return null;
                          var He = Te.textContent.length,
                            Ze = ot[0].charIndexInSpan,
                            tt =
                              ot.length === 1
                                ? Ze
                                : ot[ot.length - 1].charIndexInSpan;
                          if (Ze > He || tt + 1 > He) return null;
                          (Z.setStart(Te, Ze), Z.setEnd(Te, tt + 1));
                          var Ge = document.createElement("span");
                          Z.surroundContents(Ge);
                          var K = Ge.getBoundingClientRect(),
                            G = Xe.getBoundingClientRect(),
                            ae = G.height,
                            Ae = G.width,
                            ke = (100 * (K.left - G.left)) / Ae,
                            Fe = (100 * (K.top - G.top)) / ae,
                            Ne = (100 * K.height) / ae,
                            Qe = (100 * K.width) / Ae;
                          return (
                            N(Ge),
                            {
                              keyword: me,
                              keywordStr: pe,
                              numPages: o,
                              pageIndex: y,
                              left: ke,
                              top: Fe,
                              height: Ne,
                              width: Qe,
                              pageHeight: ae,
                              pageWidth: Ae,
                            }
                          );
                        })(Ie, ze.keyword, re, Me[kt[0].spanIndex], kt);
                      Le && Pe.push(Le);
                    }
                  });
                });
              }
            }),
            Pe.sort(P)
          );
        },
        de = function (re) {
          re && re.length > 0 && R(re);
        },
        I = function (re) {
          return T(re);
        },
        q = function (re) {
          if (re.has(y)) {
            var he = re.get(y);
            he &&
              U({
                ele: he.ele,
                pageIndex: y,
                scale: he.scale,
                status: he.status,
              });
          }
        },
        ie = function () {
          return (
            g.length === 0 || (g.length === 1 && g[0].keyword.trim() === "")
          );
        };
      return (
        n.useEffect(
          function () {
            if (
              !ie() &&
              j.status === t.LayerRenderStatus.DidRender &&
              !fe.current.length
            ) {
              var re = j.ele,
                he = [].slice
                  .call(re.querySelectorAll(".rpv-core__text-layer-text"))
                  .map(function (Pe) {
                    return Pe.textContent;
                  })
                  .reduce(
                    function (Pe, Me, se) {
                      return Pe.concat(
                        Me.split("").map(function (je, Ie) {
                          return {
                            char: je,
                            charIndexInSpan: Ie,
                            spanIndex: se,
                          };
                        }),
                      );
                    },
                    [{ char: "", charIndexInSpan: 0, spanIndex: 0 }],
                  )
                  .slice(1);
              fe.current = he;
            }
          },
          [g, j.status],
        ),
        n.useEffect(
          function () {
            if (
              !ie() &&
              j.ele &&
              j.status === t.LayerRenderStatus.DidRender &&
              Re()({ pageIndex: y, numPages: o })
            ) {
              var re = j.ele,
                he = ue(re);
              Ce(he);
            }
          },
          [g, Y, j.status, fe.current],
        ),
        n.useEffect(
          function () {
            ie() &&
              j.ele &&
              j.status === t.LayerRenderStatus.DidRender &&
              Ce([]);
          },
          [g, j.status],
        ),
        n.useEffect(
          function () {
            if (Ee.length !== 0) {
              var re = x.current;
              if (
                Y.pageIndex === y &&
                re &&
                j.status === t.LayerRenderStatus.DidRender
              ) {
                var he = re.querySelector(
                  '.rpv-search__highlight[data-index="'.concat(
                    Y.matchIndex,
                    '"]',
                  ),
                );
                if (he) {
                  var Pe = (function (Ie, it) {
                      for (
                        var Ke = Ie.offsetTop,
                          dt = Ie.offsetLeft,
                          ze = Ie.parentElement;
                        ze && ze !== it;

                      )
                        ((Ke += ze.offsetTop),
                          (dt += ze.offsetLeft),
                          (ze = ze.parentElement));
                      return { left: dt, top: Ke };
                    })(he, re),
                    Me = Pe.left,
                    se = Pe.top,
                    je = M.get("jumpToDestination");
                  je &&
                    (je({
                      pageIndex: y,
                      bottomOffset:
                        (re.getBoundingClientRect().height - se) / j.scale,
                      leftOffset: Me / j.scale,
                      scaleTo: j.scale,
                    }),
                    Q.current &&
                      Q.current.classList.remove(
                        "rpv-search__highlight--current",
                      ),
                    (Q.current = he),
                    he.classList.add("rpv-search__highlight--current"));
                }
              }
            }
          },
          [Ee, Y],
        ),
        n.useEffect(function () {
          return (
            M.subscribe("keyword", de),
            M.subscribe("matchPosition", I),
            M.subscribe("renderStatus", q),
            function () {
              (M.unsubscribe("keyword", de),
                M.unsubscribe("matchPosition", I),
                M.unsubscribe("renderStatus", q));
            }
          );
        }, []),
        n.createElement(
          "div",
          {
            className: "rpv-search__highlights",
            "data-testid": "search__highlights-".concat(y),
            ref: x,
          },
          L({ getCssProperties: X, highlightAreas: Ee }),
        )
      );
    },
    h = function (e) {
      var o,
        y = e.wholeWords ? " ".concat(e.keyword, " ") : e.keyword,
        B = e.matchCase ? "g" : "gi";
      return {
        keyword: e.keyword,
        regExp: new RegExp(
          ((o = y), o.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")),
          B,
        ),
        wholeWords: e.wholeWords || !1,
      };
    },
    r = function (e, o, y) {
      return e instanceof RegExp
        ? { keyword: e.source, regExp: e, wholeWords: y || !1 }
        : typeof e == "string"
          ? e === ""
            ? ee
            : h({ keyword: e, matchCase: o || !1, wholeWords: y || !1 })
          : (o !== void 0 && (e.matchCase = o),
            y !== void 0 && (e.wholeWords = y),
            h(e));
    },
    d = function (e) {
      var o,
        y = e.get("initialKeyword"),
        B = n.useMemo(function () {
          if (y && y.length === 1) {
            var I = r(y[0]);
            return {
              matchCase: I.regExp.flags.indexOf("i") === -1,
              wholeWords: I.wholeWords,
            };
          }
          return { matchCase: !1, wholeWords: !1 };
        }, []),
        M = (function (I) {
          var q = n.useRef(I.get("doc")),
            ie = function (re) {
              q.current = re;
            };
          return (
            n.useEffect(function () {
              return (
                I.subscribe("doc", ie),
                function () {
                  I.unsubscribe("doc", ie);
                }
              );
            }, []),
            q
          );
        })(e),
        D = n.useState(y),
        x = D[0],
        z = D[1],
        L = n.useState([]),
        V = L[0],
        Y = L[1],
        T = n.useState(0),
        s = T[0],
        g = T[1],
        R = n.useState(B.matchCase),
        $ = R[0],
        j = R[1],
        U = n.useRef([]),
        Q = n.useState(B.wholeWords),
        fe = Q[0],
        we = Q[1],
        Ee = function () {
          return !0;
        },
        Ce = n.useCallback(
          function () {
            return e.get("targetPageFilter") || Ee;
          },
          [e.get("targetPageFilter")],
        ),
        xe = function (I) {
          var q = V.length;
          if (x.length === 0 || q === 0) return null;
          var ie = I === q + 1 ? 1 : Math.max(1, Math.min(q, I));
          return (g(ie), ue(V[ie - 1]));
        },
        Re = function (I) {
          return z(I === "" ? [] : [I]);
        },
        ue = function (I) {
          var q = e.get("jumpToPage");
          return (
            q && q(I.pageIndex),
            e.update("matchPosition", {
              matchIndex: I.matchIndex,
              pageIndex: I.pageIndex,
            }),
            I
          );
        },
        de = function (I, q, ie) {
          var re = M.current;
          if (!re) return Promise.resolve([]);
          var he = re.numPages,
            Pe = I.map(function (Me) {
              return r(Me, q, ie);
            });
          return (
            e.update("keyword", Pe),
            g(0),
            Y([]),
            new Promise(function (Me, se) {
              var je =
                U.current.length === 0
                  ? (function () {
                      var Ie = M.current;
                      if (!Ie) return Promise.resolve([]);
                      var it = Array(Ie.numPages)
                        .fill(0)
                        .map(function (Ke, dt) {
                          return t
                            .getPage(Ie, dt)
                            .then(function (ze) {
                              return ze.getTextContent();
                            })
                            .then(function (ze) {
                              var Je = ze.items
                                .map(function (st) {
                                  return st.str || "";
                                })
                                .join("");
                              return Promise.resolve({
                                pageContent: Je,
                                pageIndex: dt,
                              });
                            });
                        });
                      return Promise.all(it).then(function (Ke) {
                        return (
                          Ke.sort(function (dt, ze) {
                            return dt.pageIndex - ze.pageIndex;
                          }),
                          Promise.resolve(
                            Ke.map(function (dt) {
                              return dt.pageContent;
                            }),
                          )
                        );
                      });
                    })().then(function (Ie) {
                      return ((U.current = Ie), Promise.resolve(Ie));
                    })
                  : Promise.resolve(U.current);
              je.then(function (Ie) {
                var it = [];
                (Ie.forEach(function (Ke, dt) {
                  Ce()({ pageIndex: dt, numPages: he }) &&
                    Pe.forEach(function (ze) {
                      for (var Je, st = 0; (Je = ze.regExp.exec(Ke)) !== null; )
                        (it.push({
                          keyword: ze.regExp,
                          matchIndex: st,
                          pageIndex: dt,
                          pageText: Ke,
                          startIndex: Je.index,
                          endIndex: ze.regExp.lastIndex,
                        }),
                          st++);
                    });
                }),
                  Y(it),
                  it.length > 0 && (g(1), ue(it[0])),
                  Me(it));
              });
            })
          );
        };
      return (
        n.useEffect(
          function () {
            U.current = [];
          },
          [M.current],
        ),
        {
          clearKeyword: function () {
            (e.update("keyword", [ee]), Re(""), g(0), Y([]), j(!1), we(!1));
          },
          changeMatchCase: function (I) {
            (j(I), x.length > 0 && de(x, I, fe));
          },
          changeWholeWords: function (I) {
            (we(I), x.length > 0 && de(x, $, I));
          },
          currentMatch: s,
          jumpToMatch: xe,
          jumpToNextMatch: function () {
            return xe(s + 1);
          },
          jumpToPreviousMatch: function () {
            return xe(s - 1);
          },
          keywords: x,
          matchCase: $,
          numberOfMatches: V.length,
          wholeWords: fe,
          search: function () {
            return de(x, $, fe);
          },
          searchFor: de,
          setKeywords: z,
          keyword:
            x.length === 0
              ? ""
              : ((o = x[0]),
                o instanceof RegExp
                  ? o.source
                  : typeof o == "string"
                    ? o
                    : o.keyword),
          setKeyword: Re,
          setTargetPages: function (I) {
            e.update("targetPageFilter", I);
          },
        }
      );
    },
    p = function (e) {
      var o = e.children,
        y = e.store,
        B = d(y),
        M = n.useState(!1),
        D = M[0],
        x = M[1],
        z = function (L) {
          return x(!0);
        };
      return (
        n.useEffect(function () {
          return (
            y.subscribe("doc", z),
            function () {
              y.unsubscribe("doc", z);
            }
          );
        }, []),
        o(H(H({}, B), { isDocumentLoaded: D }))
      );
    },
    u = function (e) {
      var o = e.containerRef,
        y = e.store,
        B = n.useRef(!1),
        M = function () {
          B.current = !0;
        },
        D = function () {
          B.current = !1;
        },
        x = function (z) {
          var L = o.current;
          L &&
            (z.shiftKey ||
              z.altKey ||
              z.key !== "f" ||
              ((t.isMac() ? z.metaKey && !z.ctrlKey : z.ctrlKey) &&
                (B.current ||
                  (document.activeElement &&
                    L.contains(document.activeElement))) &&
                (z.preventDefault(), y.update("areShortcutsPressed", !0))));
        };
      return (
        n.useEffect(
          function () {
            var z = o.current;
            if (z)
              return (
                document.addEventListener("keydown", x),
                z.addEventListener("mouseenter", M),
                z.addEventListener("mouseleave", D),
                function () {
                  (document.removeEventListener("keydown", x),
                    z.removeEventListener("mouseenter", M),
                    z.removeEventListener("mouseleave", D));
                }
              );
          },
          [o.current],
        ),
        n.createElement(n.Fragment, null)
      );
    },
    F = { left: 0, top: 8 },
    v = function (e) {
      var o = e.store,
        y = e.onToggle,
        B = n.useContext(t.LocalizationContext).l10n,
        M = n.useContext(t.ThemeContext).direction,
        D = n.useState(!1),
        x = D[0],
        z = D[1],
        L = n.useState(!1),
        V = L[0],
        Y = L[1],
        T = M === t.TextDirection.RightToLeft,
        s = d(o),
        g = s.clearKeyword,
        R = s.changeMatchCase,
        $ = s.changeWholeWords,
        j = s.currentMatch,
        U = s.jumpToNextMatch,
        Q = s.jumpToPreviousMatch,
        fe = s.keyword,
        we = s.matchCase,
        Ee = s.numberOfMatches,
        Ce = s.wholeWords,
        xe = s.search,
        Re = s.setKeyword,
        ue = function (re) {
          (z(!0),
            xe().then(function (he) {
              (z(!1), Y(!0), re && re());
            }));
        };
      n.useEffect(function () {
        var re = o.get("initialKeyword");
        re &&
          re.length === 1 &&
          fe &&
          ue(function () {
            o.update("initialKeyword", []);
          });
      }, []);
      var de = B && B.search ? B.search.enterToSearch : "Enter to search",
        I = B && B.search ? B.search.previousMatch : "Previous match",
        q = B && B.search ? B.search.nextMatch : "Next match",
        ie = B && B.search ? B.search.close : "Close";
      return n.createElement(
        "div",
        { className: "rpv-search__popover" },
        n.createElement(
          "div",
          { className: "rpv-search__popover-input-counter" },
          n.createElement(t.TextBox, {
            ariaLabel: de,
            autoFocus: !0,
            placeholder: de,
            type: "text",
            value: fe,
            onChange: function (re) {
              (Y(!1), Re(re));
            },
            onKeyDown: function (re) {
              re.key === "Enter" && fe && (V ? U() : ue());
            },
          }),
          n.createElement(
            "div",
            {
              className: t.classNames({
                "rpv-search__popover-counter": !0,
                "rpv-search__popover-counter--ltr": !T,
                "rpv-search__popover-counter--rtl": T,
              }),
            },
            x &&
              n.createElement(t.Spinner, {
                testId: "search__popover-searching",
                size: "1rem",
              }),
            !x &&
              n.createElement(
                "span",
                { "data-testid": "search__popover-num-matches" },
                j,
                "/",
                Ee,
              ),
          ),
        ),
        n.createElement(
          "label",
          { className: "rpv-search__popover-label" },
          n.createElement("input", {
            className: "rpv-search__popover-label-checkbox",
            "data-testid": "search__popover-match-case",
            checked: we,
            type: "checkbox",
            onChange: function (re) {
              (Y(!1), R(re.target.checked));
            },
          }),
          " ",
          B && B.search ? B.search.matchCase : "Match case",
        ),
        n.createElement(
          "label",
          { className: "rpv-search__popover-label" },
          n.createElement("input", {
            className: "rpv-search__popover-label-checkbox",
            checked: Ce,
            "data-testid": "search__popover-whole-words",
            type: "checkbox",
            onChange: function (re) {
              (Y(!1), $(re.target.checked));
            },
          }),
          " ",
          B && B.search ? B.search.wholeWords : "Whole words",
        ),
        n.createElement(
          "div",
          { className: "rpv-search__popover-footer" },
          n.createElement(
            "div",
            { className: "rpv-search__popover-footer-item" },
            n.createElement(t.Tooltip, {
              ariaControlsSuffix: "search-previous-match",
              position: T ? t.Position.BottomRight : t.Position.BottomCenter,
              target: n.createElement(
                t.MinimalButton,
                { ariaLabel: I, isDisabled: j <= 1, onClick: Q },
                n.createElement(S, null),
              ),
              content: function () {
                return I;
              },
              offset: F,
            }),
          ),
          n.createElement(
            "div",
            { className: "rpv-search__popover-footer-item" },
            n.createElement(t.Tooltip, {
              ariaControlsSuffix: "search-next-match",
              position: t.Position.BottomCenter,
              target: n.createElement(
                t.MinimalButton,
                { ariaLabel: q, isDisabled: j > Ee - 1, onClick: U },
                n.createElement(w, null),
              ),
              content: function () {
                return q;
              },
              offset: F,
            }),
          ),
          n.createElement(
            "div",
            {
              className: t.classNames({
                "rpv-search__popover-footer-button": !0,
                "rpv-search__popover-footer-button--ltr": !T,
                "rpv-search__popover-footer-button--rtl": T,
              }),
            },
            n.createElement(
              t.Button,
              {
                onClick: function () {
                  (y(), g());
                },
              },
              ie,
            ),
          ),
        ),
      );
    },
    f = function (e) {
      var o = e.children,
        y = e.onClick,
        B = n.useContext(t.LocalizationContext).l10n,
        M = B && B.search ? B.search.search : "Search";
      return o({ icon: n.createElement(i, null), label: M, onClick: y });
    },
    b = { left: 0, top: 8 },
    c = function (e) {
      var o = e.enableShortcuts,
        y = e.store,
        B = e.onClick,
        M = o ? (t.isMac() ? "Meta+F" : "Ctrl+F") : "",
        D = function (x) {
          x && B();
        };
      return (
        n.useEffect(function () {
          return (
            y.subscribe("areShortcutsPressed", D),
            function () {
              y.unsubscribe("areShortcutsPressed", D);
            }
          );
        }, []),
        n.createElement(f, { onClick: B }, function (x) {
          return n.createElement(t.Tooltip, {
            ariaControlsSuffix: "search-popover",
            position: t.Position.BottomCenter,
            target: n.createElement(
              t.MinimalButton,
              {
                ariaKeyShortcuts: M,
                ariaLabel: x.label,
                testId: "search__popover-button",
                onClick: B,
              },
              x.icon,
            ),
            content: function () {
              return x.label;
            },
            offset: b,
          });
        })
      );
    },
    a = { left: 0, top: 8 },
    m = function (e) {
      var o = e.children,
        y = e.enableShortcuts,
        B = e.store,
        M =
          n.useContext(t.ThemeContext).direction === t.TextDirection.RightToLeft
            ? t.Position.BottomRight
            : t.Position.BottomLeft,
        D =
          o ||
          function (x) {
            return n.createElement(c, H({ enableShortcuts: y, store: B }, x));
          };
      return n.createElement(t.Popover, {
        ariaControlsSuffix: "search",
        lockScroll: !1,
        position: M,
        target: function (x) {
          return D({ onClick: x });
        },
        content: function (x) {
          return n.createElement(v, { store: B, onToggle: x });
        },
        offset: a,
        closeOnClickOutside: !1,
        closeOnEscape: !0,
      });
    },
    C = function (e) {
      return Array.isArray(e)
        ? e.map(function (o) {
            return r(o);
          })
        : [r(e)];
    };
  return (
    (search_min.NextIcon = w),
    (search_min.PreviousIcon = S),
    (search_min.SearchIcon = i),
    (search_min.searchPlugin = function (e) {
      var o = n.useMemo(function () {
          return Object.assign(
            {},
            { enableShortcuts: !0, onHighlightKeyword: function () {} },
            e,
          );
        }, []),
        y = n.useMemo(function () {
          return t.createStore({
            initialKeyword:
              e && e.keyword
                ? Array.isArray(e.keyword)
                  ? e.keyword
                  : [e.keyword]
                : [],
            keyword: e && e.keyword ? C(e.keyword) : [ee],
            matchPosition: { matchIndex: -1, pageIndex: -1 },
            renderStatus: new Map(),
          });
        }, []),
        B = d(y),
        M = B.clearKeyword,
        D = B.jumpToMatch,
        x = B.jumpToNextMatch,
        z = B.jumpToPreviousMatch,
        L = B.searchFor,
        V = B.setKeywords,
        Y = B.setTargetPages,
        T = function (s) {
          return n.createElement(
            m,
            H({ enableShortcuts: o.enableShortcuts }, s, { store: y }),
          );
        };
      return {
        install: function (s) {
          var g =
              e && e.keyword
                ? Array.isArray(e.keyword)
                  ? e.keyword
                  : [e.keyword]
                : [],
            R = e && e.keyword ? C(e.keyword) : [ee];
          (y.update("initialKeyword", g),
            y.update("jumpToDestination", s.jumpToDestination),
            y.update("jumpToPage", s.jumpToPage),
            y.update("keyword", R));
        },
        renderPageLayer: function (s) {
          return n.createElement(_, {
            key: s.pageIndex,
            numPages: s.doc.numPages,
            pageIndex: s.pageIndex,
            renderHighlights: e == null ? void 0 : e.renderHighlights,
            store: y,
            onHighlightKeyword: o.onHighlightKeyword,
          });
        },
        renderViewer: function (s) {
          var g = s.slot;
          return (
            g.subSlot &&
              (g.subSlot.children = n.createElement(
                n.Fragment,
                null,
                o.enableShortcuts &&
                  n.createElement(u, {
                    containerRef: s.containerRef,
                    store: y,
                  }),
                g.subSlot.children,
              )),
            g
          );
        },
        uninstall: function (s) {
          var g = y.get("renderStatus");
          g && g.clear();
        },
        onDocumentLoad: function (s) {
          y.update("doc", s.doc);
        },
        onTextLayerRender: function (s) {
          var g = y.get("renderStatus");
          g && ((g = g.set(s.pageIndex, s)), y.update("renderStatus", g));
        },
        Search: function (s) {
          return n.createElement(p, H({}, s, { store: y }));
        },
        ShowSearchPopover: T,
        ShowSearchPopoverButton: function () {
          return n.createElement(T, null, function (s) {
            return n.createElement(
              c,
              H({ enableShortcuts: o.enableShortcuts, store: y }, s),
            );
          });
        },
        clearHighlights: function () {
          M();
        },
        highlight: function (s) {
          var g = Array.isArray(s) ? s : [s];
          return (V(g), L(g));
        },
        jumpToMatch: D,
        jumpToNextMatch: x,
        jumpToPreviousMatch: z,
        setTargetPages: Y,
      };
    }),
    search_min
  );
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$2.exports;
  hasRequiredLib$4 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$2.exports = requireSearch_min()), lib$2.exports);
}
var lib$1 = { exports: {} },
  theme_min = {},
  hasRequiredTheme_min;
function requireTheme_min() {
  if (hasRequiredTheme_min) return theme_min;
  hasRequiredTheme_min = 1;
  var t = requireLib$h();
  function A(k) {
    var N = Object.create(null);
    return (
      k &&
        Object.keys(k).forEach(function (P) {
          if (P !== "default") {
            var _ = Object.getOwnPropertyDescriptor(k, P);
            Object.defineProperty(
              N,
              P,
              _.get
                ? _
                : {
                    enumerable: !0,
                    get: function () {
                      return k[P];
                    },
                  },
            );
          }
        }),
      (N.default = k),
      Object.freeze(N)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: "M19.5,15.106l2.4-2.4a1,1,0,0,0,0-1.414l-2.4-2.4V5.5a1,1,0,0,0-1-1H15.106l-2.4-2.4a1,1,0,0,0-1.414,0l-2.4,2.4H5.5a1,1,0,0,0-1,1V8.894l-2.4,2.4a1,1,0,0,0,0,1.414l2.4,2.4V18.5a1,1,0,0,0,1,1H8.894l2.4,2.4a1,1,0,0,0,1.414,0l2.4-2.4H18.5a1,1,0,0,0,1-1Z",
        }),
        n.createElement("path", {
          d: "M10,6.349a6,6,0,0,1,0,11.3,6,6,0,1,0,0-11.3Z",
        }),
      );
    },
    S = function () {
      return n.createElement(
        t.Icon,
        { size: 16 },
        n.createElement("path", {
          d: "M19.491,15.106l2.4-2.4a1,1,0,0,0,0-1.414l-2.4-2.4V5.5a1,1,0,0,0-1-1H15.1L12.7,2.1a1,1,0,0,0-1.414,0l-2.4,2.4H5.491a1,1,0,0,0-1,1V8.894l-2.4,2.4a1,1,0,0,0,0,1.414l2.4,2.4V18.5a1,1,0,0,0,1,1H8.885l2.4,2.4a1,1,0,0,0,1.414,0l2.4-2.4h3.394a1,1,0,0,0,1-1Z",
        }),
        n.createElement("path", { d: "M11.491,6c4,0,6,2.686,6,6s-2,6-6,6Z" }),
      );
    },
    i = function () {
      return (
        (i =
          Object.assign ||
          function (k) {
            for (var N, P = 1, _ = arguments.length; P < _; P++)
              for (var h in (N = arguments[P]))
                Object.prototype.hasOwnProperty.call(N, h) && (k[h] = N[h]);
            return k;
          }),
        i.apply(this, arguments)
      );
    },
    H = { left: 0, top: 8 },
    ee = function (k) {
      var N = k.onClick,
        P = n.useContext(t.ThemeContext),
        _ = n.useContext(t.LocalizationContext).l10n,
        h = P.currentTheme === "dark",
        r =
          _ && _.theme
            ? h
              ? _.theme.switchLightTheme
              : _.theme.switchDarkTheme
            : h
              ? "Switch to the light theme"
              : "Switch to the dark theme";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "theme-switch",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          { ariaLabel: r, testId: "theme__switch-button", onClick: N },
          h ? n.createElement(S, null) : n.createElement(w, null),
        ),
        content: function () {
          return r;
        },
        offset: H,
      });
    },
    X = function (k) {
      var N = k.children,
        P = n.useContext(t.ThemeContext);
      return (
        N ||
        function (_) {
          return n.createElement(ee, { onClick: _.onClick });
        }
      )({
        onClick: function () {
          return P.setCurrentTheme(
            P.currentTheme === "dark" ? "light" : "dark",
          );
        },
      });
    },
    W = function (k) {
      var N = k.onClick,
        P = n.useContext(t.ThemeContext),
        _ = n.useContext(t.LocalizationContext).l10n,
        h = P.currentTheme === "dark",
        r =
          _ && _.theme
            ? h
              ? _.theme.switchLightTheme
              : _.theme.switchDarkTheme
            : h
              ? "Switch to the light theme"
              : "Switch to the dark theme";
      return n.createElement(
        t.MenuItem,
        {
          icon: h ? n.createElement(S, null) : n.createElement(w, null),
          testId: "theme__switch-menu",
          onClick: N,
        },
        r,
      );
    };
  return (
    (theme_min.DarkIcon = w),
    (theme_min.LightIcon = S),
    (theme_min.themePlugin = function () {
      var k = function (N) {
        return n.createElement(X, i({}, N));
      };
      return {
        SwitchTheme: k,
        SwitchThemeButton: function () {
          return n.createElement(k, null, function (N) {
            return n.createElement(ee, i({}, N));
          });
        },
        SwitchThemeMenuItem: function (N) {
          return n.createElement(k, null, function (P) {
            return n.createElement(W, {
              onClick: function () {
                (P.onClick(), N.onClick());
              },
            });
          });
        },
      };
    }),
    theme_min
  );
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$1.exports;
  hasRequiredLib$3 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$1.exports = requireTheme_min()), lib$1.exports);
}
var lib = { exports: {} },
  zoom_min = {},
  hasRequiredZoom_min;
function requireZoom_min() {
  if (hasRequiredZoom_min) return zoom_min;
  hasRequiredZoom_min = 1;
  var t = requireLib$h();
  function A(e) {
    var o = Object.create(null);
    return (
      e &&
        Object.keys(e).forEach(function (y) {
          if (y !== "default") {
            var B = Object.getOwnPropertyDescriptor(e, y);
            Object.defineProperty(
              o,
              y,
              B.get
                ? B
                : {
                    enumerable: !0,
                    get: function () {
                      return e[y];
                    },
                  },
            );
          }
        }),
      (o.default = e),
      Object.freeze(o)
    );
  }
  var n = A(requireReact()),
    w = function () {
      return n.createElement(
        t.Icon,
        { ignoreDirection: !0, size: 16 },
        n.createElement("path", {
          d: `M10.5,0.499c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.499,10.5,0.499z
            M23.5,23.499
            l-5.929-5.929
            M5.5,10.499h10
            M10.5,5.499v10`,
        }),
      );
    },
    S = function () {
      return n.createElement(
        t.Icon,
        { ignoreDirection: !0, size: 16 },
        n.createElement("path", {
          d: `M10.5,0.499c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.499,10.5,0.499z
            M23.5,23.499
            l-5.929-5.929
            M5.5,10.499h10`,
        }),
      );
    },
    i = function () {
      return (
        (i =
          Object.assign ||
          function (e) {
            for (var o, y = 1, B = arguments.length; y < B; y++)
              for (var M in (o = arguments[y]))
                Object.prototype.hasOwnProperty.call(o, M) && (e[M] = o[M]);
            return e;
          }),
        i.apply(this, arguments)
      );
    },
    H = function (e) {
      var o = n.useState(e.get("scale") || 0),
        y = o[0],
        B = o[1],
        M = function (D) {
          B(D);
        };
      return (
        n.useEffect(function () {
          return (
            e.subscribe("scale", M),
            function () {
              e.unsubscribe("scale", M);
            }
          );
        }, []),
        { scale: y }
      );
    },
    ee = function (e) {
      var o = e.children,
        y = e.store;
      return (
        o ||
        function (B) {
          return n.createElement(
            n.Fragment,
            null,
            "".concat(Math.round(100 * B.scale), "%"),
          );
        }
      )({ scale: H(y).scale });
    },
    X = { passive: !1 },
    W = null,
    k = function (e) {
      var o = e.pagesContainerRef,
        y = e.store,
        B = t.useDebounceCallback(function (D) {
          var x = y.get("zoom");
          x && x(D);
        }, 40),
        M = function (D) {
          if (D.ctrlKey) {
            D.preventDefault();
            var x = D.target.getBoundingClientRect(),
              z = 1 - D.deltaY / 100,
              L = D.clientX - x.left,
              V = D.clientY - x.top,
              Y = y.get("scale"),
              T = (
                W ||
                (W = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "svg",
                ))
              )
                .createSVGMatrix()
                .translate(L, V)
                .scale(z)
                .translate(-L, -V)
                .scale(Y);
            B(T.a);
          }
        };
      return (
        t.useIsomorphicLayoutEffect(function () {
          var D = o.current;
          if (D)
            return (
              D.addEventListener("wheel", M, X),
              function () {
                D.removeEventListener("wheel", M);
              }
            );
        }, []),
        n.createElement(n.Fragment, null)
      );
    },
    N = [
      0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9,
      2.1, 2.4, 2.7, 3, 3.3, 3.7, 4.1, 4.6, 5.1, 5.7, 6.3, 7, 7.7, 8.5, 9.4, 10,
    ],
    P = function (e) {
      return (
        N.find(function (o) {
          return o > e;
        }) || e
      );
    },
    _ = function (e) {
      var o = N.findIndex(function (y) {
        return y >= e;
      });
      return o === -1 || o === 0 ? e : N[o - 1];
    },
    h = function (e) {
      var o = e.containerRef,
        y = e.store,
        B = function (M) {
          if (!M.shiftKey && !M.altKey && (t.isMac() ? M.metaKey : M.ctrlKey)) {
            var D = o.current;
            if (
              D &&
              document.activeElement &&
              D.contains(document.activeElement)
            ) {
              var x = y.get("zoom");
              if (x) {
                var z = y.get("scale") || 1,
                  L = 1;
                switch (M.key) {
                  case "-":
                    L = _(z);
                    break;
                  case "=":
                    L = P(z);
                    break;
                  case "0":
                    L = 1;
                    break;
                  default:
                    L = z;
                }
                L !== z && (M.preventDefault(), x(L));
              }
            }
          }
        };
      return (
        n.useEffect(
          function () {
            if (o.current)
              return (
                document.addEventListener("keydown", B),
                function () {
                  document.removeEventListener("keydown", B);
                }
              );
          },
          [o.current],
        ),
        n.createElement(n.Fragment, null)
      );
    },
    r = [0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4],
    d = { left: 0, top: 8 },
    p = function (e) {
      var o = e.levels,
        y = o === void 0 ? r : o,
        B = e.scale,
        M = e.onZoom,
        D = n.useContext(t.LocalizationContext).l10n,
        x =
          n.useContext(t.ThemeContext).direction ===
          t.TextDirection.RightToLeft,
        z = D && D.zoom ? D.zoom.zoomDocument : "Zoom document";
      return n.createElement(t.Popover, {
        ariaControlsSuffix: "zoom",
        ariaHasPopup: "menu",
        position: t.Position.BottomCenter,
        target: function (L) {
          return n.createElement(
            t.MinimalButton,
            {
              ariaLabel: z,
              testId: "zoom__popover-target",
              onClick: function () {
                L();
              },
            },
            n.createElement(
              "span",
              { className: "rpv-zoom__popover-target" },
              n.createElement(
                "span",
                {
                  "data-testid": "zoom__popover-target-scale",
                  className: t.classNames({
                    "rpv-zoom__popover-target-scale": !0,
                    "rpv-zoom__popover-target-scale--ltr": !x,
                    "rpv-zoom__popover-target-scale--rtl": x,
                  }),
                },
                Math.round(100 * B),
                "%",
              ),
              n.createElement("span", {
                className: "rpv-zoom__popover-target-arrow",
              }),
            ),
          );
        },
        content: function (L) {
          return n.createElement(
            t.Menu,
            null,
            Object.keys(t.SpecialZoomLevel).map(function (V) {
              var Y = V;
              return n.createElement(
                t.MenuItem,
                {
                  key: Y,
                  onClick: function () {
                    (L(), M(Y));
                  },
                },
                (function (T) {
                  switch (T) {
                    case t.SpecialZoomLevel.ActualSize:
                      return D && D.zoom ? D.zoom.actualSize : "Actual size";
                    case t.SpecialZoomLevel.PageFit:
                      return D && D.zoom ? D.zoom.pageFit : "Page fit";
                    case t.SpecialZoomLevel.PageWidth:
                      return D && D.zoom ? D.zoom.pageWidth : "Page width";
                  }
                })(Y),
              );
            }),
            n.createElement(t.MenuDivider, null),
            y.map(function (V) {
              return n.createElement(
                t.MenuItem,
                {
                  key: V,
                  onClick: function () {
                    (L(), M(V));
                  },
                },
                "".concat(Math.round(100 * V), "%"),
              );
            }),
          );
        },
        offset: d,
        closeOnClickOutside: !0,
        closeOnEscape: !0,
      });
    },
    u = function (e) {
      var o = e.children,
        y = e.levels,
        B = e.store;
      return (
        o ||
        function (M) {
          return n.createElement(p, {
            levels: y,
            scale: M.scale,
            onZoom: M.onZoom,
          });
        }
      )({
        scale: H(B).scale,
        onZoom: function (M) {
          var D = B.get("zoom");
          D && D(M);
        },
      });
    },
    F = { left: 0, top: 8 },
    v = function (e) {
      var o = e.enableShortcuts,
        y = e.onClick,
        B = n.useContext(t.LocalizationContext).l10n,
        M = B && B.zoom ? B.zoom.zoomIn : "Zoom in",
        D = o ? (t.isMac() ? "Meta+=" : "Ctrl+=") : "";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "zoom-in",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaKeyShortcuts: D,
            ariaLabel: M,
            testId: "zoom__in-button",
            onClick: y,
          },
          n.createElement(w, null),
        ),
        content: function () {
          return M;
        },
        offset: F,
      });
    },
    f = function (e) {
      var o = e.children,
        y = e.enableShortcuts,
        B = e.store,
        M = H(B).scale;
      return (o || v)({
        enableShortcuts: y,
        onClick: function () {
          var D = B.get("zoom");
          D && D(P(M));
        },
      });
    },
    b = function (e) {
      var o = e.onClick,
        y = n.useContext(t.LocalizationContext).l10n,
        B = y && y.zoom ? y.zoom.zoomIn : "Zoom in";
      return n.createElement(
        t.MenuItem,
        { icon: n.createElement(w, null), testId: "zoom__in-menu", onClick: o },
        B,
      );
    },
    c = { left: 0, top: 8 },
    a = function (e) {
      var o = e.enableShortcuts,
        y = e.onClick,
        B = n.useContext(t.LocalizationContext).l10n,
        M = B && B.zoom ? B.zoom.zoomOut : "Zoom out",
        D = o ? (t.isMac() ? "Meta+-" : "Ctrl+-") : "";
      return n.createElement(t.Tooltip, {
        ariaControlsSuffix: "zoom-out",
        position: t.Position.BottomCenter,
        target: n.createElement(
          t.MinimalButton,
          {
            ariaKeyShortcuts: D,
            ariaLabel: M,
            testId: "zoom__out-button",
            onClick: y,
          },
          n.createElement(S, null),
        ),
        content: function () {
          return M;
        },
        offset: c,
      });
    },
    m = function (e) {
      var o = e.children,
        y = e.enableShortcuts,
        B = e.store,
        M = H(B).scale;
      return (o || a)({
        enableShortcuts: y,
        onClick: function () {
          var D = B.get("zoom");
          D && D(_(M));
        },
      });
    },
    C = function (e) {
      var o = e.onClick,
        y = n.useContext(t.LocalizationContext).l10n,
        B = y && y.zoom ? y.zoom.zoomOut : "Zoom out";
      return n.createElement(
        t.MenuItem,
        {
          icon: n.createElement(S, null),
          testId: "zoom__out-menu",
          onClick: o,
        },
        B,
      );
    };
  return (
    (zoom_min.ZoomInIcon = w),
    (zoom_min.ZoomOutIcon = S),
    (zoom_min.zoomPlugin = function (e) {
      var o = n.useMemo(function () {
          return Object.assign({}, { enableShortcuts: !0 }, e);
        }, []),
        y = n.useMemo(function () {
          return t.createStore({});
        }, []),
        B = function (x) {
          return n.createElement(
            f,
            i({ enableShortcuts: o.enableShortcuts }, x, { store: y }),
          );
        },
        M = function (x) {
          return n.createElement(
            m,
            i({ enableShortcuts: o.enableShortcuts }, x, { store: y }),
          );
        },
        D = function (x) {
          return n.createElement(u, i({}, x, { store: y }));
        };
      return {
        renderViewer: function (x) {
          var z = x.slot;
          if (!o.enableShortcuts) return z;
          var L = {
            children: n.createElement(
              n.Fragment,
              null,
              n.createElement(h, { containerRef: x.containerRef, store: y }),
              n.createElement(k, {
                pagesContainerRef: x.pagesContainerRef,
                store: y,
              }),
              z.children,
            ),
          };
          return i(i({}, z), L);
        },
        install: function (x) {
          y.update("zoom", x.zoom);
        },
        onViewerStateChange: function (x) {
          return (y.update("scale", x.scale), x);
        },
        zoomTo: function (x) {
          var z = y.get("zoom");
          z && z(x);
        },
        CurrentScale: function (x) {
          return n.createElement(ee, i({}, x, { store: y }));
        },
        ZoomIn: B,
        ZoomInButton: function () {
          return n.createElement(B, null, function (x) {
            return n.createElement(v, i({}, x));
          });
        },
        ZoomInMenuItem: function (x) {
          return n.createElement(B, null, function (z) {
            return n.createElement(b, {
              onClick: function () {
                (z.onClick(), x.onClick());
              },
            });
          });
        },
        ZoomOut: M,
        ZoomOutButton: function () {
          return n.createElement(M, null, function (x) {
            return n.createElement(a, i({}, x));
          });
        },
        ZoomOutMenuItem: function (x) {
          return n.createElement(M, null, function (z) {
            return n.createElement(C, {
              onClick: function () {
                (z.onClick(), x.onClick());
              },
            });
          });
        },
        Zoom: D,
        ZoomPopover: function (x) {
          return n.createElement(D, null, function (z) {
            return n.createElement(
              p,
              i({ levels: x == null ? void 0 : x.levels }, z),
            );
          });
        },
      };
    }),
    zoom_min
  );
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib.exports;
  hasRequiredLib$2 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib.exports = requireZoom_min()), lib.exports);
}
var hasRequiredToolbar_min;
function requireToolbar_min() {
  if (hasRequiredToolbar_min) return toolbar_min;
  hasRequiredToolbar_min = 1;
  var t = requireLib$h(),
    A = requireLib$d(),
    n = requireReact(),
    w = requireLib$c(),
    S = requireLib$b(),
    i = requireLib$a(),
    H = requireLib$9(),
    ee = requireLib$8(),
    X = requireLib$7(),
    W = requireLib$6(),
    k = requireLib$5(),
    N = requireLib$4(),
    P = requireLib$3(),
    _ = requireLib$2();
  function h(a) {
    var m = Object.create(null);
    return (
      a &&
        Object.keys(a).forEach(function (C) {
          if (C !== "default") {
            var e = Object.getOwnPropertyDescriptor(a, C);
            Object.defineProperty(
              m,
              C,
              e.get
                ? e
                : {
                    enumerable: !0,
                    get: function () {
                      return a[C];
                    },
                  },
            );
          }
        }),
      (m.default = a),
      Object.freeze(m)
    );
  }
  var r = h(n),
    d = function () {
      return r.createElement(
        t.Icon,
        { size: 16 },
        r.createElement("path", {
          d: `M12,0.5c1.381,0,2.5,1.119,2.5,2.5S13.381,5.5,12,5.5S9.5,4.381,9.5,3S10.619,0.5,12,0.5z
            M12,9.5
            c1.381,0,2.5,1.119,2.5,2.5s-1.119,2.5-2.5,2.5S9.5,13.381,9.5,12S10.619,9.5,12,9.5z
            M12,18.5c1.381,0,2.5,1.119,2.5,2.5
            s-1.119,2.5-2.5,2.5S9.5,22.381,9.5,21S10.619,18.5,12,18.5z`,
        }),
      );
    },
    p = { left: 0, top: 8 },
    u = function (a) {
      var m = a.toolbarSlot,
        C = r.useContext(t.LocalizationContext).l10n,
        e =
          r.useContext(t.ThemeContext).direction === t.TextDirection.RightToLeft
            ? t.Position.BottomLeft
            : t.Position.BottomRight,
        o = m.DownloadMenuItem,
        y = m.EnterFullScreenMenuItem,
        B = m.GoToFirstPageMenuItem,
        M = m.GoToLastPageMenuItem,
        D = m.GoToNextPageMenuItem,
        x = m.GoToPreviousPageMenuItem,
        z = m.OpenMenuItem,
        L = m.PrintMenuItem,
        V = m.RotateBackwardMenuItem,
        Y = m.RotateForwardMenuItem,
        T = m.ShowPropertiesMenuItem,
        s = m.SwitchScrollModeMenuItem,
        g = m.SwitchSelectionModeMenuItem,
        R = m.SwitchViewModeMenuItem,
        $ = m.SwitchThemeMenuItem;
      return r.createElement(t.Popover, {
        ariaControlsSuffix: "toolbar-more-actions",
        ariaHasPopup: "menu",
        position: e,
        target: function (j, U) {
          var Q = C && C.toolbar ? C.toolbar.moreActions : "More actions";
          return r.createElement(t.Tooltip, {
            ariaControlsSuffix: "toolbar-more-actions",
            position: e,
            target: r.createElement(
              t.MinimalButton,
              {
                ariaLabel: Q,
                isSelected: U,
                testId: "toolbar__more-actions-popover-target",
                onClick: j,
              },
              r.createElement(d, null),
            ),
            content: function () {
              return Q;
            },
            offset: p,
          });
        },
        content: function (j) {
          return r.createElement(
            t.Menu,
            null,
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement($, { onClick: j }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement(y, { onClick: j }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement(z, null),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement(L, { onClick: j }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement(o, { onClick: j }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement(t.MenuDivider, null),
            ),
            r.createElement(B, { onClick: j }),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement(x, { onClick: j }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--block rpv-core__display--hidden-medium",
              },
              r.createElement(D, { onClick: j }),
            ),
            r.createElement(M, { onClick: j }),
            r.createElement(t.MenuDivider, null),
            r.createElement(Y, { onClick: j }),
            r.createElement(V, { onClick: j }),
            r.createElement(t.MenuDivider, null),
            r.createElement(g, { mode: A.SelectionMode.Text, onClick: j }),
            r.createElement(g, { mode: A.SelectionMode.Hand, onClick: j }),
            r.createElement(t.MenuDivider, null),
            r.createElement(s, { mode: t.ScrollMode.Page, onClick: j }),
            r.createElement(s, { mode: t.ScrollMode.Vertical, onClick: j }),
            r.createElement(s, { mode: t.ScrollMode.Horizontal, onClick: j }),
            r.createElement(s, { mode: t.ScrollMode.Wrapped, onClick: j }),
            r.createElement(t.MenuDivider, null),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-small",
              },
              r.createElement(R, { mode: t.ViewMode.SinglePage, onClick: j }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-small",
              },
              r.createElement(R, { mode: t.ViewMode.DualPage, onClick: j }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-small",
              },
              r.createElement(R, {
                mode: t.ViewMode.DualPageWithCover,
                onClick: j,
              }),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-small",
              },
              r.createElement(t.MenuDivider, null),
            ),
            r.createElement(T, { onClick: j }),
          );
        },
        offset: p,
        closeOnClickOutside: !0,
        closeOnEscape: !0,
      });
    },
    F = function () {
      return (
        (F =
          Object.assign ||
          function (a) {
            for (var m, C = 1, e = arguments.length; C < e; C++)
              for (var o in (m = arguments[C]))
                Object.prototype.hasOwnProperty.call(m, o) && (a[o] = m[o]);
            return a;
          }),
        F.apply(this, arguments)
      );
    },
    v = function (a) {
      return function (m) {
        var C = r.useMemo(function () {
            return a(m);
          }, []),
          e =
            r.useContext(t.ThemeContext).direction ===
            t.TextDirection.RightToLeft,
          o = C.CurrentPageInput,
          y = C.Download,
          B = C.EnterFullScreen,
          M = C.GoToNextPage,
          D = C.GoToPreviousPage,
          x = C.NumberOfPages,
          z = C.Open,
          L = C.Print,
          V = C.ShowSearchPopover,
          Y = C.SwitchTheme,
          T = C.Zoom,
          s = C.ZoomIn,
          g = C.ZoomOut;
        return r.createElement(
          "div",
          {
            "data-testid": "toolbar",
            className: t.classNames({
              "rpv-toolbar": !0,
              "rpv-toolbar--rtl": e,
            }),
            role: "toolbar",
            "aria-orientation": "horizontal",
          },
          r.createElement(
            "div",
            { className: "rpv-toolbar__left" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(V, null),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-small",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(D, null),
              ),
            ),
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(o, null),
              r.createElement(
                "span",
                { className: "rpv-toolbar__label" },
                r.createElement(x, null),
              ),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-small",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(M, null),
              ),
            ),
          ),
          r.createElement(
            "div",
            { className: "rpv-toolbar__center" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(g, null),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-small",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(T, null),
              ),
            ),
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(s, null),
            ),
          ),
          r.createElement(
            "div",
            { className: "rpv-toolbar__right" },
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-medium",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(Y, null),
              ),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-medium",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(B, null),
              ),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-medium",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(z, null),
              ),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-medium",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(y, null),
              ),
            ),
            r.createElement(
              "div",
              {
                className:
                  "rpv-core__display--hidden rpv-core__display--block-medium",
              },
              r.createElement(
                "div",
                { className: "rpv-toolbar__item" },
                r.createElement(L, null),
              ),
            ),
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(u, { toolbarSlot: C }),
            ),
          ),
        );
      };
    },
    f = function (a) {
      var m = a.NumberOfPages;
      return Object.assign({}, a, {
        NumberOfPages: function () {
          return r.createElement(
            r.Fragment,
            null,
            "/ ",
            r.createElement(m, null),
          );
        },
      });
    },
    b = function (a) {
      return v(f)(a);
    },
    c = function (a) {
      var m = a.children,
        C = a.slot;
      return (m || b)(C);
    };
  return (
    (toolbar_min.MoreActionsPopover = u),
    (toolbar_min.MoreIcon = d),
    (toolbar_min.toolbarPlugin = function (a) {
      var m = w.fullScreenPlugin(a ? a.fullScreenPlugin : {}),
        C = S.getFilePlugin(a ? a.getFilePlugin : {}),
        e = i.openPlugin(a ? a.openPlugin : {}),
        o = H.pageNavigationPlugin(a ? a.pageNavigationPlugin : {}),
        y = ee.printPlugin(a ? a.printPlugin : {}),
        B = X.propertiesPlugin(),
        M = W.rotatePlugin(),
        D = k.scrollModePlugin(),
        x = N.searchPlugin(a ? a.searchPlugin : {}),
        z = A.selectionModePlugin(a ? a.selectionModePlugin : {}),
        L = P.themePlugin(),
        V = _.zoomPlugin(a ? a.zoomPlugin : {}),
        Y = [m, C, e, o, y, B, M, D, x, z, L, V],
        T = r.useCallback(function (s) {
          var g = m.EnterFullScreen,
            R = m.EnterFullScreenMenuItem,
            $ = C.Download,
            j = C.DownloadMenuItem,
            U = e.Open,
            Q = e.OpenMenuItem,
            fe = o.CurrentPageInput,
            we = o.CurrentPageLabel,
            Ee = o.GoToFirstPage,
            Ce = o.GoToFirstPageMenuItem,
            xe = o.GoToLastPage,
            Re = o.GoToLastPageMenuItem,
            ue = o.GoToNextPage,
            de = o.GoToNextPageMenuItem,
            I = o.GoToPreviousPage,
            q = o.GoToPreviousPageMenuItem,
            ie = o.NumberOfPages,
            re = y.Print,
            he = y.PrintMenuItem,
            Pe = B.ShowProperties,
            Me = B.ShowPropertiesMenuItem,
            se = M.Rotate,
            je = M.RotateBackwardMenuItem,
            Ie = M.RotateForwardMenuItem,
            it = D.SwitchScrollMode,
            Ke = D.SwitchScrollModeMenuItem,
            dt = D.SwitchViewMode,
            ze = D.SwitchViewModeMenuItem,
            Je = x.Search,
            st = x.ShowSearchPopover,
            kt = z.SwitchSelectionMode,
            Le = z.SwitchSelectionModeMenuItem,
            pe = L.SwitchTheme,
            me = L.SwitchThemeMenuItem,
            Xe = V.CurrentScale,
            Ye = V.Zoom,
            ot = V.ZoomIn,
            Z = V.ZoomInMenuItem,
            Te = V.ZoomOut,
            He = V.ZoomOutMenuItem;
          return r.createElement(
            c,
            F({}, s, {
              slot: {
                CurrentPageInput: fe,
                CurrentPageLabel: we,
                CurrentScale: Xe,
                Download: $,
                DownloadMenuItem: j,
                EnterFullScreen: g,
                EnterFullScreenMenuItem: R,
                GoToFirstPage: Ee,
                GoToFirstPageMenuItem: Ce,
                GoToLastPage: xe,
                GoToLastPageMenuItem: Re,
                GoToNextPage: ue,
                GoToNextPageMenuItem: de,
                GoToPreviousPage: I,
                GoToPreviousPageMenuItem: q,
                NumberOfPages: ie,
                Open: U,
                OpenMenuItem: Q,
                Print: re,
                PrintMenuItem: he,
                Rotate: se,
                RotateBackwardMenuItem: je,
                RotateForwardMenuItem: Ie,
                Search: Je,
                ShowProperties: Pe,
                ShowPropertiesMenuItem: Me,
                ShowSearchPopover: st,
                SwitchScrollMode: it,
                SwitchScrollModeMenuItem: Ke,
                SwitchSelectionMode: kt,
                SwitchSelectionModeMenuItem: Le,
                SwitchViewMode: dt,
                SwitchViewModeMenuItem: ze,
                SwitchTheme: pe,
                SwitchThemeMenuItem: me,
                Zoom: Ye,
                ZoomIn: ot,
                ZoomInMenuItem: Z,
                ZoomOut: Te,
                ZoomOutMenuItem: He,
              },
            }),
          );
        }, []);
      return {
        fullScreenPluginInstance: m,
        getFilePluginInstance: C,
        openPluginInstance: e,
        pageNavigationPluginInstance: o,
        printPluginInstance: y,
        propertiesPluginInstance: B,
        rotatePluginInstance: M,
        scrollModePluginInstance: D,
        searchPluginInstance: x,
        selectionModePluginInstance: z,
        themePluginInstance: L,
        zoomPluginInstance: V,
        install: function (s) {
          Y.forEach(function (g) {
            g.install && g.install(s);
          });
        },
        renderPageLayer: function (s) {
          return r.createElement(
            r.Fragment,
            null,
            Y.map(function (g, R) {
              return g.renderPageLayer
                ? r.createElement(r.Fragment, { key: R }, g.renderPageLayer(s))
                : r.createElement(r.Fragment, { key: R });
            }),
          );
        },
        renderViewer: function (s) {
          var g = s.slot;
          return (
            Y.forEach(function (R) {
              R.renderViewer && (g = R.renderViewer(F(F({}, s), { slot: g })));
            }),
            g
          );
        },
        uninstall: function (s) {
          Y.forEach(function (g) {
            g.uninstall && g.uninstall(s);
          });
        },
        onDocumentLoad: function (s) {
          Y.forEach(function (g) {
            g.onDocumentLoad && g.onDocumentLoad(s);
          });
        },
        onAnnotationLayerRender: function (s) {
          Y.forEach(function (g) {
            g.onAnnotationLayerRender && g.onAnnotationLayerRender(s);
          });
        },
        onTextLayerRender: function (s) {
          Y.forEach(function (g) {
            g.onTextLayerRender && g.onTextLayerRender(s);
          });
        },
        onViewerStateChange: function (s) {
          var g = s;
          return (
            Y.forEach(function (R) {
              R.onViewerStateChange && (g = R.onViewerStateChange(g));
            }),
            g
          );
        },
        renderDefaultToolbar: v,
        Toolbar: T,
      };
    }),
    toolbar_min
  );
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$c.exports;
  hasRequiredLib$1 = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$c.exports = requireToolbar_min()), lib$c.exports);
}
var hasRequiredDefaultLayout_min;
function requireDefaultLayout_min() {
  if (hasRequiredDefaultLayout_min) return defaultLayout_min;
  hasRequiredDefaultLayout_min = 1;
  var t = requireLib$h(),
    A = requireReact(),
    n = requireLib$g(),
    w = requireLib$f(),
    S = requireLib$e(),
    i = requireLib$1();
  function H(r) {
    var d = Object.create(null);
    return (
      r &&
        Object.keys(r).forEach(function (p) {
          if (p !== "default") {
            var u = Object.getOwnPropertyDescriptor(r, p);
            Object.defineProperty(
              d,
              p,
              u.get
                ? u
                : {
                    enumerable: !0,
                    get: function () {
                      return r[p];
                    },
                  },
            );
          }
        }),
      (d.default = r),
      Object.freeze(d)
    );
  }
  var ee = H(A),
    X = function () {
      return ee.createElement(
        t.Icon,
        { size: 16 },
        ee.createElement("path", {
          d: `M11.5,1.5h11c0.552,0,1,0.448,1,1v20c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h3
            M11.5,10.5c0,0.55-0.3,0.661-0.659,0.248L8,7.5l-2.844,3.246c-0.363,0.414-0.659,0.3-0.659-0.247v-9c0-0.552,0.448-1,1-1h5
            c0.552,0,1,0.448,1,1L11.5,10.5z
            M14.5,6.499h6
            M14.5,10.499h6
            M3.5,14.499h17
            M3.5,18.499h16.497`,
        }),
      );
    },
    W = function () {
      return (
        (W =
          Object.assign ||
          function (r) {
            for (var d, p = 1, u = arguments.length; p < u; p++)
              for (var F in (d = arguments[p]))
                Object.prototype.hasOwnProperty.call(d, F) && (r[F] = d[F]);
            return r;
          }),
        W.apply(this, arguments)
      );
    },
    k = function () {
      return ee.createElement(
        t.Icon,
        { size: 16 },
        ee.createElement("path", {
          d: `M7.618,15.345l8.666-8.666c0.78-0.812,2.071-0.838,2.883-0.058s0.838,2.071,0.058,2.883
            c-0.019,0.02-0.038,0.039-0.058,0.058L7.461,21.305c-1.593,1.593-4.175,1.592-5.767,0s-1.592-4.175,0-5.767c0,0,0,0,0,0
            L13.928,3.305c2.189-2.19,5.739-2.19,7.929-0.001s2.19,5.739,0,7.929l0,0L13.192,19.9`,
        }),
      );
    },
    N = function () {
      return ee.createElement(
        t.Icon,
        { size: 16 },
        ee.createElement("path", {
          d: `M10.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M23.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M10.5,22.5 c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z
            M23.5,22.5c0,0.552-0.448,1-1,1 h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z`,
        }),
      );
    },
    P = { left: 8, top: 0 },
    _ = { left: -8, top: 0 },
    h = function (r) {
      var d = r.attachmentTabContent,
        p = r.bookmarkTabContent,
        u = r.store,
        F = r.thumbnailTabContent,
        v = r.tabs,
        f = ee.useRef(),
        b = ee.useContext(t.LocalizationContext).l10n,
        c = ee.useState(u.get("isCurrentTabOpened") || !1),
        a = c[0],
        m = c[1],
        C = ee.useState(Math.max(u.get("currentTab") || 0, 0)),
        e = C[0],
        o = C[1],
        y =
          ee.useContext(t.ThemeContext).direction ===
          t.TextDirection.RightToLeft,
        B = [
          {
            content: F,
            icon: ee.createElement(N, null),
            title:
              b && b.defaultLayout ? b.defaultLayout.thumbnail : "Thumbnail",
          },
          {
            content: p,
            icon: ee.createElement(X, null),
            title: b && b.defaultLayout ? b.defaultLayout.bookmark : "Bookmark",
          },
          {
            content: d,
            icon: ee.createElement(k, null),
            title:
              b && b.defaultLayout ? b.defaultLayout.attachment : "Attachment",
          },
        ],
        M = v ? v(B) : B,
        D = function (z) {
          z >= 0 &&
            z <= M.length - 1 &&
            (u.update("isCurrentTabOpened", !0), o(z));
        },
        x = function (z) {
          m(z);
        };
      return (
        ee.useEffect(function () {
          return (
            u.subscribe("currentTab", D),
            u.subscribe("isCurrentTabOpened", x),
            function () {
              (u.unsubscribe("currentTab", D),
                u.unsubscribe("isCurrentTabOpened", x));
            }
          );
        }, []),
        M.length === 0
          ? ee.createElement(ee.Fragment, null)
          : ee.createElement(
              ee.Fragment,
              null,
              ee.createElement(
                "div",
                {
                  "data-testid": "default-layout__sidebar",
                  className: t.classNames({
                    "rpv-default-layout__sidebar": !0,
                    "rpv-default-layout__sidebar--opened": a,
                    "rpv-default-layout__sidebar--ltr": !y,
                    "rpv-default-layout__sidebar--rtl": y,
                  }),
                  ref: f,
                },
                ee.createElement(
                  "div",
                  { className: "rpv-default-layout__sidebar-tabs" },
                  ee.createElement(
                    "div",
                    {
                      className: "rpv-default-layout__sidebar-headers",
                      role: "tablist",
                      "aria-orientation": "vertical",
                    },
                    M.map(function (z, L) {
                      return ee.createElement(
                        "div",
                        {
                          "aria-controls":
                            "rpv-default-layout__sidebar-content",
                          "aria-selected": e === L,
                          key: L,
                          className: "rpv-default-layout__sidebar-header",
                          id: "rpv-default-layout__sidebar-tab-".concat(L),
                          role: "tab",
                        },
                        ee.createElement(t.Tooltip, {
                          ariaControlsSuffix:
                            "default-layout-sidebar-tab-".concat(L),
                          position: y
                            ? t.Position.LeftCenter
                            : t.Position.RightCenter,
                          target: ee.createElement(
                            t.MinimalButton,
                            {
                              ariaLabel: z.title,
                              isSelected: e === L,
                              onClick: function () {
                                return (function (V) {
                                  if (e === V) {
                                    u.update(
                                      "isCurrentTabOpened",
                                      !u.get("isCurrentTabOpened"),
                                    );
                                    var Y = f.current;
                                    Y &&
                                      Y.style.width &&
                                      Y.style.removeProperty("width");
                                  } else u.update("currentTab", V);
                                })(L);
                              },
                            },
                            z.icon,
                          ),
                          content: function () {
                            return z.title;
                          },
                          offset: y ? _ : P,
                        }),
                      );
                    }),
                  ),
                  ee.createElement(
                    "div",
                    {
                      "aria-labelledby":
                        "rpv-default-layout__sidebar-tab-".concat(e),
                      id: "rpv-default-layout__sidebar-content",
                      className: t.classNames({
                        "rpv-default-layout__sidebar-content": !0,
                        "rpv-default-layout__sidebar-content--opened": a,
                        "rpv-default-layout__sidebar-content--ltr": !y,
                        "rpv-default-layout__sidebar-content--rtl": y,
                      }),
                      role: "tabpanel",
                      tabIndex: -1,
                    },
                    M[e].content,
                  ),
                ),
              ),
              a &&
                ee.createElement(t.Splitter, {
                  constrain: function (z) {
                    return (
                      z.firstHalfPercentage >= 20 && z.firstHalfPercentage <= 80
                    );
                  },
                }),
            )
      );
    };
  return (
    (defaultLayout_min.BookmarkIcon = X),
    (defaultLayout_min.FileIcon = k),
    (defaultLayout_min.ThumbnailIcon = N),
    (defaultLayout_min.defaultLayoutPlugin = function (r) {
      var d = ee.useMemo(function () {
          return t.createStore({ isCurrentTabOpened: !1, currentTab: 0 });
        }, []),
        p = n.attachmentPlugin(),
        u = w.bookmarkPlugin(),
        F = S.thumbnailPlugin(r ? r.thumbnailPlugin : {}),
        v = i.toolbarPlugin(r ? r.toolbarPlugin : {}),
        f = p.Attachments,
        b = u.Bookmarks,
        c = F.Thumbnails,
        a = v.Toolbar,
        m = r
          ? r.sidebarTabs
          : function (e) {
              return e;
            },
        C = [p, u, F, v];
      return {
        attachmentPluginInstance: p,
        bookmarkPluginInstance: u,
        thumbnailPluginInstance: F,
        toolbarPluginInstance: v,
        activateTab: function (e) {
          d.update("currentTab", e);
        },
        toggleTab: function (e) {
          var o = d.get("currentTab");
          (d.update("isCurrentTabOpened", !d.get("isCurrentTabOpened")),
            o !== e && d.update("currentTab", e));
        },
        install: function (e) {
          C.forEach(function (o) {
            o.install && o.install(e);
          });
        },
        renderPageLayer: function (e) {
          return ee.createElement(
            ee.Fragment,
            null,
            C.map(function (o, y) {
              return o.renderPageLayer
                ? ee.createElement(
                    ee.Fragment,
                    { key: y },
                    o.renderPageLayer(e),
                  )
                : ee.createElement(
                    ee.Fragment,
                    { key: y },
                    ee.createElement(ee.Fragment, null),
                  );
            }),
          );
        },
        renderViewer: function (e) {
          var o = e.slot;
          C.forEach(function (B) {
            B.renderViewer && (o = B.renderViewer(W(W({}, e), { slot: o })));
          });
          var y =
            o.subSlot && o.subSlot.attrs
              ? {
                  className: o.subSlot.attrs.className,
                  "data-testid": o.subSlot.attrs["data-testid"],
                  ref: o.subSlot.attrs.ref,
                  style: o.subSlot.attrs.style,
                }
              : {};
          return (
            (o.children = ee.createElement(
              "div",
              { className: "rpv-default-layout__container" },
              ee.createElement(
                "div",
                {
                  "data-testid": "default-layout__main",
                  className: t.classNames({
                    "rpv-default-layout__main": !0,
                    "rpv-default-layout__main--rtl":
                      e.themeContext.direction === t.TextDirection.RightToLeft,
                  }),
                },
                ee.createElement(h, {
                  attachmentTabContent: ee.createElement(f, null),
                  bookmarkTabContent: ee.createElement(b, null),
                  store: d,
                  thumbnailTabContent: ee.createElement(c, null),
                  tabs: m,
                }),
                ee.createElement(
                  "div",
                  {
                    className: "rpv-default-layout__body",
                    "data-testid": "default-layout__body",
                  },
                  ee.createElement(
                    "div",
                    { className: "rpv-default-layout__toolbar" },
                    r && r.renderToolbar
                      ? r.renderToolbar(a)
                      : ee.createElement(a, null),
                  ),
                  ee.createElement("div", W({}, y), o.subSlot.children),
                ),
              ),
              o.children,
            )),
            (o.subSlot.attrs = {}),
            (o.subSlot.children = ee.createElement(ee.Fragment, null)),
            o
          );
        },
        uninstall: function (e) {
          C.forEach(function (o) {
            o.uninstall && o.uninstall(e);
          });
        },
        onDocumentLoad: function (e) {
          (C.forEach(function (o) {
            o.onDocumentLoad && o.onDocumentLoad(e);
          }),
            r &&
              r.setInitialTab &&
              r.setInitialTab(e.doc).then(function (o) {
                (d.update("currentTab", o), d.update("isCurrentTabOpened", !0));
              }));
        },
        onAnnotationLayerRender: function (e) {
          C.forEach(function (o) {
            o.onAnnotationLayerRender && o.onAnnotationLayerRender(e);
          });
        },
        onTextLayerRender: function (e) {
          C.forEach(function (o) {
            o.onTextLayerRender && o.onTextLayerRender(e);
          });
        },
        onViewerStateChange: function (e) {
          var o = e;
          return (
            C.forEach(function (y) {
              y.onViewerStateChange && (o = y.onViewerStateChange(o));
            }),
            o
          );
        },
      };
    }),
    (defaultLayout_min.setInitialTabFromPageMode = function (r) {
      return new Promise(function (d, p) {
        r.getPageMode().then(function (u) {
          if (u)
            switch (u) {
              case t.PageMode.Attachments:
                d(2);
                break;
              case t.PageMode.Bookmarks:
                d(1);
                break;
              case t.PageMode.Thumbnails:
                d(0);
                break;
              default:
                d(-1);
            }
          else d(-1);
        });
      });
    }),
    defaultLayout_min
  );
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$g.exports;
  hasRequiredLib = 1;
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */ return ((lib$g.exports = requireDefaultLayout_min()), lib$g.exports);
}
var libExports = requireLib();
const PdfViewer = ({ file: t }) => {
  const A = libExports.defaultLayoutPlugin();
  return jsxRuntimeExports.jsx("div", {
    style: { height: "100vh" },
    children: jsxRuntimeExports.jsx(libExports$1.Worker, {
      workerUrl:
        "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js",
      children: jsxRuntimeExports.jsx(libExports$1.Viewer, {
        fileUrl: t,
        plugins: [A],
      }),
    }),
  });
};
export { PdfViewer as P };
